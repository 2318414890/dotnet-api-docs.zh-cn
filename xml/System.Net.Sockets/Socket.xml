<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="51795f05b21ad02430b19a88cef2e202a8914a5b" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36552910" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>实现 Berkeley 套接字接口。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>类为的网络通信提供一组丰富的方法和属性。 <xref:System.Net.Sockets.Socket>类允许你执行同步和异步数据传输使用任何通信协议列入<xref:System.Net.Sockets.ProtocolType>枚举。  
  
 <xref:System.Net.Sockets.Socket>类遵循的异步方法的.NET Framework 命名模式。 例如，同步<xref:System.Net.Sockets.Socket.Receive%2A>方法对应于异步<xref:System.Net.Sockets.Socket.BeginReceive%2A>和<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。  
  
 如果你的应用程序仅在执行过程中需要一个线程，使用以下方法，旨在同步操作模式。  
  
-   如果你使用如 TCP 一个面向连接的协议，你的服务器可以侦听连接使用<xref:System.Net.Sockets.Socket.Listen%2A>方法。 <xref:System.Net.Sockets.Socket.Accept%2A>方法处理任何传入的连接请求，并返回<xref:System.Net.Sockets.Socket>，你可以使用与远程主机通信数据。 使用此返回<xref:System.Net.Sockets.Socket>调用<xref:System.Net.Sockets.Socket.Send%2A>或<xref:System.Net.Sockets.Socket.Receive%2A>方法。 调用<xref:System.Net.Sockets.Socket.Bind%2A>方法之前调用<xref:System.Net.Sockets.Socket.Listen%2A>方法如果你想要指定本地 IP 地址和端口号。 如果你想要为您分配一个可用端口的基础服务提供程序，请使用端口号 0。 如果你想要连接到侦听主机，调用<xref:System.Net.Sockets.Socket.Connect%2A>方法。 若要进行数据通信，调用<xref:System.Net.Sockets.Socket.Send%2A>或<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
-   如果使用如 UDP 无连接协议时，你不需要在所有侦听连接。 调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，以接受任何传入的数据报。 使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法以将数据报发送到远程主机。  
  
 若要处理通信在执行期间使用单独的线程，使用以下方法，适用于异步操作模式。  
  
-   如果你使用如 TCP 一个面向连接的协议，使用<xref:System.Net.Sockets.Socket>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>，和<xref:System.Net.Sockets.Socket.EndConnect%2A>方法来侦听主机的连接。 使用<xref:System.Net.Sockets.Socket.BeginSend%2A>和<xref:System.Net.Sockets.Socket.EndSend%2A>或<xref:System.Net.Sockets.Socket.BeginReceive%2A>和<xref:System.Net.Sockets.Socket.EndReceive%2A>数据之间进行异步通信的方法。 可以使用处理传入的连接请求<xref:System.Net.Sockets.Socket.BeginAccept%2A>和<xref:System.Net.Sockets.Socket.EndAccept%2A>。  
  
-   如果使用如 UDP 无连接协议时，你可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>和<xref:System.Net.Sockets.Socket.EndSendTo%2A>来发送数据报，和<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>和<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>来接收数据报。  
  
 如果执行套接字上的多个异步操作，它们不一定会完成中启动它们的顺序。  
  
 当你完成发送和接收数据，请使用<xref:System.Net.Sockets.Socket.Shutdown%2A>方法来禁用<xref:System.Net.Sockets.Socket>。 在调用<xref:System.Net.Sockets.Socket.Shutdown%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法来释放与关联的所有资源<xref:System.Net.Sockets.Socket>。  
  
 <xref:System.Net.Sockets.Socket>类允许你配置你<xref:System.Net.Sockets.Socket>使用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。 检索使用这些设置<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
> [!NOTE]
>  如果你在编写相对简单的应用程序，并且不需要最高的性能，请考虑使用<xref:System.Net.Sockets.TcpClient>， <xref:System.Net.Sockets.TcpListener>，和<xref:System.Net.Sockets.UdpClient>。 这些类提供的更简单且更加用户友好界面<xref:System.Net.Sockets.Socket>通信。  
  
   
  
## Examples  
 下面的代码示例演示如何<xref:System.Net.Sockets.Socket>类可以用于将数据发送到 HTTP 服务器并接收响应。 此示例阻塞，直到收到整个页面。  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">若要建立一个传出连接或接受传入请求。</permission>
    <threadsafe>此类的实例都是线程安全。</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">
          <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 返回的套接字信息。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 返回的指定的值初始化 <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果调用<xref:System.Net.Sockets.Socket.%23ctor%2A>多次使用相同的字节数组作为每个调用的参数的构造函数，你将创建多个托管<xref:System.Net.Sockets.Socket>具有相同的基础套接字的 s。 强烈建议不要使用这种做法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType">
          <see cref="T:System.Net.Sockets.SocketType" /> 值之一。</param>
        <param name="protocolType">
          <see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</param>
        <summary>使用指定的地址族、套接字类型和协议初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `socketType`参数指定的一种<xref:System.Net.Sockets.Socket>类和`protocolType`参数指定使用的协议<xref:System.Net.Sockets.Socket>。 两个参数不是独立的。 通常<xref:System.Net.Sockets.Socket>类型是在协议中隐式。 如果的组合<xref:System.Net.Sockets.Socket>类型和协议类型无效导致<xref:System.Net.Sockets.Socket>，此构造函数引发<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果此构造函数引发<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketType" /> 和 <paramref name="protocolType" /> 组合将导致套接字无效。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">
          <see cref="T:System.Net.Sockets.AddressFamily" /> 值之一。</param>
        <param name="socketType">
          <see cref="T:System.Net.Sockets.SocketType" /> 值之一。</param>
        <param name="protocolType">
          <see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</param>
        <summary>使用指定的地址族、套接字类型和协议初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addressFamily`参数指定的寻址方案<xref:System.Net.Sockets.Socket>类使用，`socketType`参数指定的一种<xref:System.Net.Sockets.Socket>类，与`protocolType`参数指定使用的协议<xref:System.Net.Sockets.Socket>。 三个参数不是独立的。 某些地址族限制哪些协议可用来与它们，并且通常<xref:System.Net.Sockets.Socket>类型是在协议中隐式。 如果地址族的组合<xref:System.Net.Sockets.Socket>类型和协议类型无效导致<xref:System.Net.Sockets.Socket>，此构造函数引发<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果此构造函数引发<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何创建的实例<xref:System.Net.Sockets.Socket>类。  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="addressFamily" />、<paramref name="socketType" /> 和 <paramref name="protocolType" /> 的组合会导致无效套接字。</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为新建连接创建新的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>新建连接的 <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> 以同步方式从侦听套接字，连接请求队列中提取第一个挂起的连接请求，然后创建并返回一个新<xref:System.Net.Sockets.Socket>。 不能使用此返回<xref:System.Net.Sockets.Socket>接受任何额外连接从连接队列。 但是，你可以调用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>方法的返回<xref:System.Net.Sockets.Socket>来标识远程主机的网络地址和端口号。  
  
 在阻止模式下，<xref:System.Net.Sockets.Socket.Accept%2A>被阻止，直至传入的连接尝试将会排队。 一旦接受连接，则原始<xref:System.Net.Sockets.Socket>继续队列传入连接请求之前关闭它。  
  
 如果调用此方法使用的非阻塞<xref:System.Net.Sockets.Socket>，并且不启用连接请求将排队等待，<xref:System.Net.Sockets.Socket.Accept%2A>引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  之前调用<xref:System.Net.Sockets.Socket.Accept%2A>方法时，你必须首先调用<xref:System.Net.Sockets.Socket.Listen%2A>方法来侦听并对传入的连接请求进行排队。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例接受一个简单<xref:System.Net.Sockets.Socket>连接。  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.Accept" />。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个异步操作来接受一个传入的连接尝试。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用面向连接的协议<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法异步处理传入的连接尝试。 以异步方式接受连接使你能够发送和接收在单独的执行线程中的数据。 之前调用<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法时，必须调用<xref:System.Net.Sockets.Socket.Listen%2A>方法来侦听并对传入的连接请求进行排队。  
  
 若要在完成时得到通知，必须创建实现的回调方法\<SocketAsyncEventArgs > 委托并将挂钩到<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>是必需的对象：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可以选择指定现有<xref:System.Net.Sockets.Socket>要通过指定用于传入连接<xref:System.Net.Sockets.Socket>用于<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>属性。  
  
 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>属性为 null，新<xref:System.Net.Sockets.Socket>构造具有相同<xref:System.Net.Sockets.Socket.AddressFamily%2A>， <xref:System.Net.Sockets.Socket.SocketType%2A>，和<xref:System.Net.Sockets.Socket.ProtocolType%2A>与当前<xref:System.Net.Sockets.Socket>并将设置为<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>属性。  
  
 调用方可能设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>到在调用前要求任何用户状态对象的属性<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法，以便在回叫方法可检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。  
  
 （可选） 可能要接收后套接字上的数据的初始块在其中提供一个缓冲区<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法成功。 在这种情况下，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>属性应设置为包含数据的缓冲区，以接收和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>属性应设置为最大的数据的字节数，以接收缓冲区中。 可以使用设置这些属性<xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType>方法。 传入的缓冲区的一部分将可供内部使用的基础 Winsock AcceptEx 调用。 这意味着返回的数据量始终为的值小于<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>属性<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>提供实例。 在内部使用的缓冲区的量的套接字地址族有所不同。 所需的最小缓冲区大小为 288 个字节。 如果指定较大缓冲区大小，则<xref:System.Net.Sockets.Socket>应除了 Winsock AcceptEx 调用收到的地址数据之外一些额外的数据和将等待，直到收到此额外的数据。 如果发生超时，则连接将重置。 因此如果特定量的预期会有额外的数据，则应缓冲区大小设置为最小缓冲区大小加上此段中。  
  
 完成回调方法应该检查<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>属性来确定如果<xref:System.Net.Sockets.Socket.AcceptAsync%2A>操作成功。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件可发生在某些情况下，在没有连接已被接受时，使<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>属性设置为<xref:System.Net.Sockets.SocketError.ConnectionReset>。 这会导致端口扫描使用半开 SYN 类型扫描 (SYN-> SYN ACK-> RST 序列)。 使用应用程序<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法应准备好处理此情况。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">自变量无效。 如果所提供的缓冲区不够大，将会发生此异常。 缓冲区必须至少为 2 * (sizeof(SOCKADDR_STORAGE + 16) 字节。  如果指定了多个缓冲区，即 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性不为 null，也会发生此异常。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">参数超出范围。 如果 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> 小于 0，将会发生此异常。</exception>
        <exception cref="T:System.InvalidOperationException">请求了无效操作。 如果接收方 <see cref="T:System.Net.Sockets.Socket" /> 未侦听连接或者绑定了接受的套接字，将发生此异常。  <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 和 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 方法必须先于 <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 方法调用。  如果套接字已连接或使用指定的 <paramref name="e" /> 参数的套接字操作已经在进行中，也会发生此异常。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的地址族。</summary>
        <value>
          <see cref="T:System.Net.Sockets.AddressFamily" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.AddressFamily>指定的寻址方案的实例<xref:System.Net.Sockets.Socket>类可以使用。 此属性是只读的并且时会设置<xref:System.Net.Sockets.Socket>创建。  
  
   
  
## Examples  
 下面的代码示例显示<xref:System.Net.Sockets.AddressFamily>， <xref:System.Net.Sockets.SocketType>，和<xref:System.Net.Sockets.ProtocolType>到控制台。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已经从网络接收且可供读取的数据量。</summary>
        <value>从网络接收的、可供读取的数据的字节数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的非阻塞<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Available%2A>是一种好方法，以便确定是否将数据排队以进行读取，然后再调用<xref:System.Net.Sockets.Socket.Receive%2A>。 可用的数据是在读取的网络缓冲区中排队的总数据量。 如果无数据排队网络缓冲区中<xref:System.Net.Sockets.Socket.Available%2A>返回 0。  
  
 如果远程主机关闭或关闭了连接，<xref:System.Net.Sockets.Socket.Available%2A>可以引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例使用 FIONREAD 和可用的属性的调用 IOControl 的结果进行比较。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个异步操作来接受一个传入的连接尝试。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始一个异步操作来接受一个传入的连接尝试。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它引用异步 <see cref="T:System.Net.Sockets.Socket" /> 创建。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用面向连接的协议<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法异步处理传入的连接尝试。 以异步方式接受连接使你能够发送和接收在单独的执行线程中的数据。 之前调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法时，必须调用<xref:System.Net.Sockets.Socket.Listen%2A>方法来侦听并对传入的连接请求进行排队。  
  
 你必须创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 若要这样做，请至少，你必须传递侦听<xref:System.Net.Sockets.Socket>对象传递给<xref:System.Net.Sockets.Socket.BeginAccept%2A>通过`state`参数。 如果你的回调需要详细信息，你可以创建一个小型类来保存<xref:System.Net.Sockets.Socket>和其他必需的信息。 将此类的实例传递<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法通过`state`参数。  
  
 你的回调方法应调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法。 当你的应用程序调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>，系统通常使用单独的线程来执行指定的回调方法，并阻止在<xref:System.Net.Sockets.Socket.EndAccept%2A>直到检索到挂起的连接。 <xref:System.Net.Sockets.Socket.EndAccept%2A> 将返回一个新<xref:System.Net.Sockets.Socket>对象可用于发送和接收与远程主机的数据。 不能使用此返回<xref:System.Net.Sockets.Socket>接受任何额外连接从连接队列。 如果你想要阻止后调用的原始线程<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 在调用 Set 方法<xref:System.Threading.ManualResetEvent>当你想要继续执行原始线程时的回调方法中。  
  
 系统还可能使用调用的线程来调用的回调方法。 在这种情况下，<xref:System.IAsyncResult.CompletedSynchronously%2A>属性对返回<xref:System.IAsyncResult>将设置，则指示<xref:System.Net.Sockets.Socket.BeginAccept%2A>已同步完成的方法。  
  
 有关编写回调方法的更多信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 若要取消挂起调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，关闭<xref:System.Net.Sockets.Socket>。 当<xref:System.Net.Sockets.Socket.Close%2A>方法调用的异步操作正在进行时，回调提供给<xref:System.Net.Sockets.Socket.BeginAccept%2A>调用方法。  后续调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法会引发<xref:System.ObjectDisposedException>以指示已取消该操作。  
  
> [!NOTE]
>  你可以使用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>属性返回的<xref:System.Net.Sockets.Socket>来标识远程主机的网络地址和端口号。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 中有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
   
  
## Examples  
 下面的代码示例将以异步接收的传入连接。  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  - 或 -  已接受的套接字是绑定的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> 小于 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">要从发送方读取的字节数。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始异步操作以接受传入的连接尝试并接收客户端应用程序发送的第一个数据块。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" />，它引用异步 <see cref="T:System.Net.Sockets.Socket" /> 创建。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用面向连接的协议<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法异步处理传入的连接尝试。 以异步方式接受连接可以发送和接收在单独的执行线程中的数据。 此重载允许你指定要接受中的初始传输中的字节数`receiveSize`参数。  
  
 之前调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法时，必须调用<xref:System.Net.Sockets.Socket.Listen%2A>方法来侦听并对传入的连接请求进行排队。  
  
 你必须创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 若要这样做，请至少，你必须传递侦听<xref:System.Net.Sockets.Socket>对象传递给<xref:System.Net.Sockets.Socket.BeginAccept%2A>通过`state`参数。 如果你的回调需要详细信息，你可以创建一个小型类来保存<xref:System.Net.Sockets.Socket>和其他必需的信息。 将此类的实例传递<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法通过`state`参数。  
  
 你的回调方法应调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法。 当你的应用程序调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>，系统通常使用单独的线程来执行指定的回调方法，并阻止在<xref:System.Net.Sockets.Socket.EndAccept%2A>直到检索到挂起的连接。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 返回一个新<xref:System.Net.Sockets.Socket>可用于发送和接收与远程主机的数据。 不能使用此返回<xref:System.Net.Sockets.Socket>接受任何额外连接从连接队列。 如果你想要阻止后调用的原始线程<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 在调用 Set 方法<xref:System.Threading.ManualResetEvent>当你想要继续执行原始线程时的回调方法中。  
  
 系统还可能使用调用的线程来调用的回调方法。 在这种情况下，<xref:System.IAsyncResult.CompletedSynchronously%2A>属性对返回<xref:System.IAsyncResult>将设置，则指示<xref:System.Net.Sockets.Socket.BeginAccept%2A>已同步完成的方法。  
  
 有关编写回调方法的更多信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 若要取消挂起调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，关闭<xref:System.Net.Sockets.Socket>。  当<xref:System.Net.Sockets.Socket.Close%2A>方法调用的异步操作正在进行时，回调提供给<xref:System.Net.Sockets.Socket.BeginAccept%2A>调用方法。  后续调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法会引发<xref:System.ObjectDisposedException>以指示已取消该操作。  
  
> [!NOTE]
>  你可以调用使用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>属性返回的<xref:System.Net.Sockets.Socket>对象来标识远程主机的网络地址和端口号。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
   
  
## Examples  
 下面的代码示例打开一个套接字并接受异步连接。 在此示例中，套接字接受前 10 个字节的数据。 接收的字节数和数据被显示在控制台上的回调委托。 请参阅<xref:System.Net.Sockets.Socket.BeginReceive%2A>有关接收剩余数据的方式的说明。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  - 或 -  已接受的套接字是绑定的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> 小于 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">接受的 <see cref="T:System.Net.Sockets.Socket" /> 对象。 此值可为 <see langword="null" />。</param>
        <param name="receiveSize">要接收的最大字节数。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始异步操作以接受从指定套接字传入的连接尝试并接收客户端应用程序发送的第一个数据块。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它引用异步 <see cref="T:System.Net.Sockets.Socket" /> 对象创建。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用面向连接的协议<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法异步处理传入的连接尝试。 以异步方式接受连接使你能够发送和接收在单独的执行线程中的数据。 此重载允许你指定接受的套接字中`acceptSocket`参数。 如果此参数为`null`，通过创建接受的套接字<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 你可以指定要接受中的初始传输中的字节数`receiveSize`参数。  
  
 之前调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法时，必须调用<xref:System.Net.Sockets.Socket.Listen%2A>方法来侦听并对传入的连接请求进行排队。  
  
 你必须创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 若要这样做，请至少，你必须传递侦听<xref:System.Net.Sockets.Socket>对象传递给<xref:System.Net.Sockets.Socket.BeginAccept%2A>通过`state`参数。 如果你的回调需要详细信息，你可以创建一个小型类来保存<xref:System.Net.Sockets.Socket>和其他必需的信息。 将此类的实例传递<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法通过`state`参数。  
  
 你的回调方法应调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法。 当你的应用程序调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>，系统通常使用单独的线程来执行指定的回调方法，并阻止在<xref:System.Net.Sockets.Socket.EndAccept%2A>直到检索到挂起的连接。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 返回一个新<xref:System.Net.Sockets.Socket>对象可用于发送和接收与远程主机的数据。 不能使用此返回<xref:System.Net.Sockets.Socket>接受任何额外连接从连接队列。 如果你想要阻止后调用的原始线程<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 在调用 Set 方法<xref:System.Threading.ManualResetEvent>当你想要继续执行原始线程时的回调方法中。  
  
 系统还可能使用调用的线程来调用的回调方法。 在这种情况下，<xref:System.IAsyncResult.CompletedSynchronously%2A>属性对返回<xref:System.IAsyncResult>将设置，则指示<xref:System.Net.Sockets.Socket.BeginAccept%2A>已同步完成的方法。  
  
 有关编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 若要取消挂起调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，关闭<xref:System.Net.Sockets.Socket>。 当<xref:System.Net.Sockets.Socket.Close%2A>方法调用的异步操作正在进行时，回调提供给<xref:System.Net.Sockets.Socket.BeginAccept%2A>调用方法。  后续调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法会引发<xref:System.ObjectDisposedException>以指示已取消该操作。  
  
> [!NOTE]
>  你可以使用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>属性返回的<xref:System.Net.Sockets.Socket>对象来标识远程主机的网络地址和端口号。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
   
  
## Examples  
 下面的代码示例打开一个套接字并接受异步连接。 在此示例中，套接字接受前 10 个字节的数据和`acceptSocket`参数是`null`，这将强制<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法来创建接受的套接字。 接收的字节数和数据被显示在控制台上的回调委托。 请参阅<xref:System.Net.Sockets.Socket.BeginReceive%2A>有关接收剩余数据的方式的说明。  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">正在接受的套接字不会侦听连接。 在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  - 或 -  已接受的套接字是绑定的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> 小于 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个对远程主机连接的异步请求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" />
        <Parameter Name="state" Type="System.Object" Index="2" />
      </Parameters>
      <Docs>
        <param name="remoteEP">To be added.</param>
        <param name="end_point">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始一个对远程主机连接的异步请求。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法会启动到的连接的异步请求`remoteEP`参数。 如果你使用的是无连接协议，<xref:System.Net.Sockets.Socket.BeginConnect%2A>建立默认远程主机。 连接或以异步方式设置默认远程主机使你能够发送和接收在单独的执行线程中的数据。  
  
 你可以创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法。 至少，你必须传递<xref:System.Net.Sockets.Socket>到<xref:System.Net.Sockets.Socket.BeginConnect%2A>通过`state`参数。 如果你的回调需要详细信息，你可以创建一个小型类来保存<xref:System.Net.Sockets.Socket>，和其他必需的信息。 将此类的实例传递<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法通过`state`参数。  
  
 你的回调方法应调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 当你的应用程序调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>，系统将使用一个单独的线程执行的指定的回调方法，并阻止<xref:System.Net.Sockets.Socket.EndConnect%2A>直到<xref:System.Net.Sockets.Socket>成功连接或引发异常。 如果你想要阻止后调用的原始线程<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A>。 在调用 Set 方法<xref:System.Threading.ManualResetEvent>当你想要继续执行原始线程时的回调方法中。 有关编写回调方法的更多信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 如果使用如 UDP 无连接协议时，不需要调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>之前发送和接收数据。 你可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>和<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>与远程主机通信。 如果调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>，来自地址而不是指定默认的地址的任何数据报将被放弃。 如果你想要将默认远程主机为广播地址，必须先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>并将广播设置为`true`。 如果你不能<xref:System.Net.Sockets.Socket.BeginConnect%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果你使用的是面向连接的协议，并且不调用<xref:System.Net.Sockets.Socket.Bind%2A>之前调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>，基础服务提供程序将分配的最合适的本地网络地址和端口号。 如果你使用的是无连接协议，直到你调用，则服务提供程序将不分配本地网络地址和端口号<xref:System.Net.Sockets.Socket.BeginSend%2A>或<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 如果你想要更改默认远程主机时，调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>再次使用所需终结点的方法。  
  
 若要取消挂起调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，关闭<xref:System.Net.Sockets.Socket>。 当<xref:System.Net.Sockets.Socket.Close%2A>方法调用的异步操作正在进行时，回调提供给<xref:System.Net.Sockets.Socket.BeginConnect%2A>调用方法。  后续调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法会引发<xref:System.ObjectDisposedException>以指示已取消该操作。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  如果以前已断开此套接字，然后<xref:System.Net.Sockets.Socket.BeginConnect%2A>必须调用该操作完成之前不会退出的线程上。 这是基础提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="address">远程主机的 <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">远程主机的端口号。</param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">一个用户定义对象，其中包含连接操作的相关信息。 操作完成后，此对象会被传递给 <c>requestCallback</c> 委托。</param>
        <summary>开始一个对远程主机连接的异步请求。 主机由 <see cref="T:System.Net.IPAddress" /> 和端口号指定。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作必须通过调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 通常情况下，通过调用该方法`requestCallback`委托。  
  
 此方法不会阻止，直到完成该操作。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Sockets.Socket.Connect%2A>方法重载或<xref:System.Net.Sockets.Socket.EndConnect%2A>。  
  
 若要取消挂起调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，关闭<xref:System.Net.Sockets.Socket>。 当<xref:System.Net.Sockets.Socket.Close%2A>方法调用的异步操作正在进行时，回调提供给<xref:System.Net.Sockets.Socket.BeginConnect%2A>调用方法。  后续调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法会引发<xref:System.ObjectDisposedException>以指示已取消该操作。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  如果以前已断开此套接字，然后<xref:System.Net.Sockets.Socket.BeginConnect%2A>必须调用该操作完成之前不会退出的线程上。 这是基础提供程序的限制。 此外<xref:System.Net.EndPoint>，它是使用必须不同。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Net.Sockets.Socket" /> 不在套接字族中。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="addresses">至少一个用于指定远程主机的 <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">远程主机的端口号。</param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">一个用户定义对象，其中包含连接操作的相关信息。 操作完成后，此对象会被传递给 <c>requestCallback</c> 委托。</param>
        <summary>开始一个对远程主机连接的异步请求。 主机由 <see cref="T:System.Net.IPAddress" /> 数组和端口号指定。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作必须通过调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 通常情况下，通过调用该方法`requestCallback`委托。  
  
 此方法不会阻止，直到完成该操作。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Sockets.Socket.Connect%2A>方法重载。  
  
 若要取消挂起调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，关闭<xref:System.Net.Sockets.Socket>。 当<xref:System.Net.Sockets.Socket.Close%2A>方法调用的异步操作正在进行时，回调提供给<xref:System.Net.Sockets.Socket.BeginConnect%2A>调用方法。  后续调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法会引发<xref:System.ObjectDisposedException>以指示已取消该操作。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  如果以前已断开此套接字，然后<xref:System.Net.Sockets.Socket.BeginConnect%2A>必须调用该操作完成之前不会退出的线程上。 这是基础提供程序的限制。 此外<xref:System.Net.EndPoint>，它是使用必须不同。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对使用 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 的套接字有效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="host">远程主机的名称。</param>
        <param name="port">远程主机的端口号。</param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">一个用户定义对象，其中包含连接操作的相关信息。 操作完成后，此对象会被传递给 <c>requestCallback</c> 委托。</param>
        <summary>开始一个对远程主机连接的异步请求。 主机由主机名和端口号指定。</summary>
        <returns>引用异步连接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作必须通过调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 通常情况下，通过调用该方法`requestCallback`委托。  
  
 此方法不会阻止，直到完成该操作。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Sockets.Socket.Connect%2A>方法重载。  
  
 若要取消挂起调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，关闭<xref:System.Net.Sockets.Socket>。 当<xref:System.Net.Sockets.Socket.Close%2A>方法调用的异步操作正在进行时，回调提供给<xref:System.Net.Sockets.Socket.BeginConnect%2A>调用方法。  后续调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法会引发<xref:System.ObjectDisposedException>以指示已取消该操作。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  如果以前已断开此套接字，然后<xref:System.Net.Sockets.Socket.BeginConnect%2A>必须调用该操作完成之前不会退出的线程上。 这是基础提供程序的限制。 此外<xref:System.Net.EndPoint>，它是使用必须不同。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
   
  
## Examples  
 下面的代码示例启动异步连接尝试。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态，或异步操作已在进行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">如果关闭该连接后可以重用此套接字，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始异步请求从远程终结点断开连接。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它引用异步操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的一个面向连接的协议，则可以调用<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>方法来从远程终结点请求断开连接。 如果`reuseSocket`是`true`，你可以重复使用套接字。  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>方法使用一个单独的线程来调用指定的回调方法。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>方法阻塞，直到挂起的断开连接已完成。 有关编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>异常，请改用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例创建套接字进行异步通信，并将一些数据发送到远程主机。 当数据已发送时，<xref:System.Net.Sockets.Socket.Shutdown%2A>调用以停止发送和接收活动。 然后<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>调用以开始断开连接请求。 完成请求后，<xref:System.Net.Sockets.Socket.Connected%2A>属性将查询以测试是否断开连接的套接字。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">操作系统为 Windows 2000 或更低版本，而此方法需要在 Windows XP 中使用。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作必须通过调用<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 通常情况下，通过调用该方法`callback`委托。  
  
 此方法不会阻止，直到完成该操作。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Sockets.Socket.Receive%2A>方法重载。  
  
 若要取消挂起<xref:System.Net.Sockets.Socket.BeginReceive%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  在线程退出时，由给定线程启动的所有 i/o 操作已取消。 如果在线程退出操作完成前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作必须通过调用<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 通常情况下，通过调用该方法`callback`委托。  
  
 此方法不会阻止，直到完成该操作。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Sockets.Socket.Receive%2A>方法重载。  
  
 若要取消挂起<xref:System.Net.Sockets.Socket.BeginReceive%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  在线程退出时，由给定线程启动的所有 i/o 操作已取消。 如果在线程退出操作完成前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset">
          <c>buffer</c> 参数中存储所接收数据的位置，该位置从零开始计数。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作必须通过调用<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 通常情况下，通过调用该方法`callback`委托。  
  
 此方法不会阻止，直到完成该操作。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Sockets.Socket.Receive%2A>方法重载。  
  
 若要取消挂起<xref:System.Net.Sockets.Socket.BeginReceive%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  在线程退出时，由给定线程启动的所有 i/o 操作已取消。 如果在线程退出操作完成前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
   
  
## Examples  
 下面的代码示例开始以异步方式从连接中接收数据<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset">
          <c>buffer</c> 中存储所接收数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">To be added.</param>
        <param name="flags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <param name="error">To be added.</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义的对象，其中包含接收操作的相关信息。 当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</param>
        <summary>开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作必须通过调用<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 通常情况下，通过调用该方法`callback`委托。  
  
 此方法不会阻止，直到完成该操作。 若要阻止该操作完成之前，请使用之一<xref:System.Net.Sockets.Socket.Receive%2A>方法重载。  
  
 若要取消挂起<xref:System.Net.Sockets.Socket.BeginReceive%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  在线程退出时，由给定线程启动的所有 i/o 操作已取消。 如果在线程退出操作完成前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset">
          <c>buffer</c> 参数中存储数据的位置，该位置从零开始计数。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始从指定网络设备中异步接收数据。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法会启动异步读取远程主机无连接数据报。 调用<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法使你能够接收在单独的执行线程中的数据。  
  
 你可以创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 为此，请至少，你`state`参数必须包含连接或默认<xref:System.Net.Sockets.Socket>用于进行通信。 如果你的回调需要详细信息，你可以创建一个小型类来保存<xref:System.Net.Sockets.Socket>和其他必需的信息。 将此类的实例传递<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法通过`state`参数。  
  
 你的回调方法应调用<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法。 当你的应用程序调用<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，系统将使用一个单独的线程执行指定的回调方法，它将阻塞<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>直到<xref:System.Net.Sockets.Socket>读取数据或引发异常。 如果你想要阻止后调用的原始线程<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 当你想要继续执行原始线程时，请在回调方法调用 Set 方法。 有关编写回调方法的其他信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
> [!NOTE]
>  之前调用<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，必须显式将绑定<xref:System.Net.Sockets.Socket>本地终结点使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，或<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 此方法将数据读入`buffer`参数，而捕获的远程主机从其发送数据的终结点。 有关如何检索此终结点的信息，请参阅<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>。 此方法是最有用，如果你想要以异步方式从未知的主机或多个主机中接收无连接数据报。 在这些情况下，<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>将读取到本地网络缓冲区接收到第一个排队数据报。 如果你收到的数据报大于的大小`buffer`、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法将填充`buffer`尽可能可能，而引发的消息与<xref:System.Net.Sockets.SocketException>。 如果你使用的不可靠的协议，多余的数据将丢失。 如果你使用的是可靠的协议对过量数据将保留由服务提供商，你可以通过调用来检索它<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>使用足够大的缓冲区的方法。  
  
 若要确保始终返回远程主机终结点、 应用程序应显式绑定<xref:System.Net.Sockets.Socket>本地终结点使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，然后调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法替换`optionLevel`参数设置为<xref:System.Net.Sockets.SocketOptionLevel.IP>或<xref:System.Net.Sockets.SocketOptionLevel.IPv6>视情况而定`optionName`参数设置为<xref:System.Net.Sockets.SocketOptionName.PacketInformation>，和`optionValue`参数以启用此选项之前调用<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 否则，它是要发件人已发送的数据报数目之前接收方调用时不会返回的远程主机终结点可能<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。  
  
 尽管<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>适用于无连接协议，你可以使用也是一个面向连接的协议。 如果你选择这样做，你必须首先可以建立远程主机的连接通过调用<xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A>方法或通过调用接受传入的连接请求<xref:System.Net.Sockets.Socket.Accept%2A>或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 如果调用<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法时建立或接受连接之前，你将获取<xref:System.Net.Sockets.SocketException>。 你还可以建立默认远程主机之前调用无连接协议<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法将忽略`remoteEP`参数和仅接收从连接的数据或默认远程主机。  
  
 对于面向连接的套接字，<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>将读取原样可用直到达到指定的字节数多的数据`size`参数。  
  
 若要取消挂起<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
   
  
## Examples  
 下面的代码示例以异步方式从远程主机接收无连接数据报。  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset">
          <c>buffer</c> 参数中存储数据的位置，该位置从零开始计数。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">一个 <see cref="T:System.Net.EndPoint" />，它表示数据的来源。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>开始使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定字节数的数据异步接收到数据缓冲区的指定位置，然后存储终结点和数据包信息。</summary>
        <returns>引用异步读的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异步接收操作必须由调用完成<xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A>方法。 通常情况下，通过调用该方法`asyncCallback`委托。  
  
 此方法不会阻止该操作完成之前。 若要阻止该操作完成之前，请使用<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法。  
  
 若要取消挂起<xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 有关使用异步编程模型的详细信息，请参阅[异步调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 此方法将数据读入`buffer`参数，并捕获的远程主机终结点从其发送数据，以及有关接收的数据包的信息。 有关如何检索此终结点的信息，请参阅<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>。 此方法是最有用，如果你想要以异步方式从未知的主机或多个主机中接收无连接数据报。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">操作系统为 Windows 2000 或更低版本，而此方法需要在 Windows XP 中使用。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法会启动异步发送操作中建立的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果不首先调用将引发异常<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 调用<xref:System.Net.Sockets.Socket.BeginSend%2A>方法使你能够发送单独的执行线程中的数据。  
  
 你可以创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 为此，请至少，你`state`参数必须包含连接或默认<xref:System.Net.Sockets.Socket>用于进行通信。 如果你的回调需要详细信息，可以创建一个小型类或结构，用于保存<xref:System.Net.Sockets.Socket>和其他必需的信息。 将此类的实例传递<xref:System.Net.Sockets.Socket.BeginSend%2A>方法通过`state`参数。  
  
 你的回调方法应调用<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 当你的应用程序调用<xref:System.Net.Sockets.Socket.BeginSend%2A>，系统将使用一个单独的线程执行的指定的回调方法，并阻止<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>发送请求的字节数或引发异常。 如果你想要阻止后调用的原始线程<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 当你想要继续执行原始线程时，请在回调方法调用 Set 方法。 有关编写回调方法的更多信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 适用于面向连接的协议，尽管<xref:System.Net.Sockets.Socket.BeginSend%2A>还应用于无连接协议，前提是你第一次调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法来建立默认远程主机。 如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 你还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.BeginSend%2A>通过另一个调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 使用无连接协议，你还必须确保你的缓冲区的大小不能超过基础服务提供程序的最大的数据包大小。 如果是这样，将不发送数据报和<xref:System.Net.Sockets.Socket.BeginSend%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，发送的无法路由的数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  在线程退出时，由给定线程启动的所有 i/o 操作已取消。 如果在线程退出操作完成前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  成功完成后发送不指示已成功传递数据。 如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法会启动异步发送操作中建立的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果不首先调用将引发异常<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 调用<xref:System.Net.Sockets.Socket.BeginSend%2A>方法使你能够发送单独的执行线程中的数据。  
  
 你可以创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 为此，请至少，你`state`参数必须包含连接或默认<xref:System.Net.Sockets.Socket>用于进行通信。 如果你的回调需要详细信息，可以创建一个小型类或结构，用于保存<xref:System.Net.Sockets.Socket>和其他必需的信息。 将此类的实例传递<xref:System.Net.Sockets.Socket.BeginSend%2A>方法通过`state`参数。  
  
 你的回调方法应调用<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 当你的应用程序调用<xref:System.Net.Sockets.Socket.BeginSend%2A>，系统将使用一个单独的线程执行的指定的回调方法，并阻止<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>发送请求的字节数或引发异常。 如果你想要阻止后调用的原始线程<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 在调用 Set 方法<xref:System.Threading.ManualResetEvent>当你想要继续执行原始线程时的回调方法中。 有关编写回调方法的更多信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 适用于面向连接的协议，尽管<xref:System.Net.Sockets.Socket.BeginSend%2A>还应用于无连接协议，前提是你第一次调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法来建立默认远程主机。 如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 你还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.BeginSend%2A>通过另一个调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 使用无连接协议，你还必须确保你的缓冲区的大小不能超过基础服务提供程序的最大的数据包大小。 如果是这样，将不发送数据报和<xref:System.Net.Sockets.Socket.BeginSend%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，发送的无法路由的数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  在线程退出时，由给定线程启动的所有 i/o 操作已取消。 如果在线程退出操作完成前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  成功完成后发送不指示已成功传递数据。 如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="offset">
          <c>buffer</c> 参数中开始发送数据的位置，该位置从零开始计数。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法会启动异步发送操作中建立的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果不首先调用将引发异常<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 调用<xref:System.Net.Sockets.Socket.BeginSend%2A>方法使你能够发送单独的执行线程中的数据。  
  
 你可以创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 为此，请至少，你`state`参数必须包含连接或默认<xref:System.Net.Sockets.Socket>用于进行通信。 如果你的回调需要详细信息，可以创建一个小型类或结构，用于保存<xref:System.Net.Sockets.Socket>和其他必需的信息。 将此类的实例传递<xref:System.Net.Sockets.Socket.BeginSend%2A>方法通过`state`参数。  
  
 你的回调方法应调用<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 当你的应用程序调用<xref:System.Net.Sockets.Socket.BeginSend%2A>，系统将使用一个单独的线程执行的指定的回调方法，并阻止<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>发送请求的字节数或引发异常。 如果你想要阻止后调用的原始线程<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 当你想要继续执行原始线程时，请在回调方法调用 Set 方法。 有关编写回调方法的更多信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 适用于面向连接的协议，尽管<xref:System.Net.Sockets.Socket.BeginSend%2A>还应用于无连接协议，前提是你第一次调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法来建立默认远程主机。 如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 你还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.BeginSend%2A>通过另一个调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 使用无连接协议，你还必须确保你的缓冲区的大小不能超过基础服务提供程序的最大的数据包大小。 如果是这样，将不发送数据报和<xref:System.Net.Sockets.Socket.BeginSend%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，发送的无法路由的数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  在线程退出时，由给定线程启动的所有 i/o 操作已取消。 如果在线程退出操作完成前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  成功完成后发送不指示已成功传递数据。 如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 小于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="offset">
          <c>buffer</c> 参数中开始发送数据的位置，该位置从零开始计数。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法会启动异步发送操作中建立的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果不首先调用将引发异常<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 调用<xref:System.Net.Sockets.Socket.BeginSend%2A>方法使你能够发送单独的执行线程中的数据。  
  
 你可以创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 为此，请至少，你`state`参数必须包含连接或默认<xref:System.Net.Sockets.Socket>用于进行通信。 如果你的回调需要详细信息，可以创建一个小型类或结构，用于保存<xref:System.Net.Sockets.Socket>和其他必需的信息。 将此类的实例传递<xref:System.Net.Sockets.Socket.BeginSend%2A>方法通过`state`参数。  
  
 你的回调方法应调用<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 当你的应用程序调用<xref:System.Net.Sockets.Socket.BeginSend%2A>，系统将使用一个单独的线程执行的指定的回调方法，并阻止<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>发送请求的字节数或引发异常。 如果你想要阻止后调用的原始线程<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 当你想要继续执行原始线程时，请在回调方法调用 Set 方法。 有关编写回调方法的更多信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 适用于面向连接的协议，尽管<xref:System.Net.Sockets.Socket.BeginSend%2A>还应用于无连接协议，前提是你第一次调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法来建立默认远程主机。 如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 你还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.BeginSend%2A>通过另一个调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 使用无连接协议，你还必须确保你的缓冲区的大小不能超过基础服务提供程序的最大的数据包大小。 如果是这样，将不发送数据报和<xref:System.Net.Sockets.Socket.BeginSend%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，发送的无法路由的数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  在线程退出时，由给定线程启动的所有 i/o 操作已取消。 如果在线程退出操作完成前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  `state` 是用户定义的实例化。  
  
> [!NOTE]
>  成功完成后发送不指示已成功传递数据。 如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
   
  
## Examples  
 下面的代码示例开始以异步方式将数据发送到远程主机。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 小于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将文件异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">一个字符串，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 标志，将文件 <paramref name="fileName" /> 发送到连接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 对象。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它表示异步发送。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载将文件发送`fileName`到连接的套接字。 如果`fileName`是在本地目录中，则可以标识与只是文件的名称; 否则，必须指定完整路径和文件的名称。 通配符 ("...\\\myfile.txt") 和 UNC 共享名 ("\\\\\\\shared 目录\\\myfile.txt") 支持。 如果未找到文件，该异常<xref:System.IO.FileNotFoundException>引发。  
  
 此方法使用`TransmitFile`Windows 套接字 2 API 中找到函数。 有关详细信息`TransmitFile`函数和其标志，请参阅 MSDN 库中的 Windows 套接字文档。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法会启动异步发送操作中建立的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>，<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 引发异常，如果不首先调用<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 调用<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法使你能够发送单独的执行线程中的文件。  
  
 若要完成该操作，你可以创建由调用的回调方法<xref:System.AsyncCallback>委托参数。 为此，请至少，`state`参数必须包含<xref:System.Net.Sockets.Socket>对象用于进行通信。 如果你的回调需要详细信息，可以创建类或结构，用于保存<xref:System.Net.Sockets.Socket>和其他必需的信息。 将为此自定义对象的实例传递<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法通过`state`参数。  
  
 你的回调方法必须调用<xref:System.Net.Sockets.Socket.EndSendFile%2A>方法。 当你的应用程序调用<xref:System.Net.Sockets.Socket.BeginSendFile%2A>，系统将使用一个单独的线程执行指定的回调方法，并阻止在<xref:System.Net.Sockets.Socket.EndSendFile%2A>直到<xref:System.Net.Sockets.Socket>发送完整的文件或引发异常。 有关编写回调方法的更多信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 适用于面向连接的协议，尽管<xref:System.Net.Sockets.Socket.BeginSendFile%2A>还应用于无连接协议，前提是你第一次调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法来建立默认远程主机。 使用无连接协议，则必须确保你的文件的大小不超过基础服务提供程序的最大的数据包大小。 如果是这样，不会发送数据报和<xref:System.Net.Sockets.Socket.BeginSendFile%2A>引发<xref:System.Net.Sockets.SocketException>异常。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>异常，请改用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
   
  
## Examples  
 下面的代码示例创建并连接的套接字进行异步通信。 首先，"text.txt"该文件是以异步方式发送，到远程主机。 回调委托调用<xref:System.Net.Sockets.Socket.EndSendFile%2A>完成传输。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.NotSupportedException">套接字未连接到远程主机。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">一个字符串，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <param name="preBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件前要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="postBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件后要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="flags">
          <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值的按位组合。</param>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，将在此操作完成时调用它。 此参数可以为 <see langword="null" />。</param>
        <param name="state">一个用户定义的对象，它包含此请求的状态信息。 此参数可以为 <see langword="null" />。</param>
        <summary>将文件和数据缓冲区异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <returns>一个 <see cref="T:System.IAsyncResult" /> 对象，它表示异步操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载需要你想要发送的文件和的按位组合的名称<xref:System.Net.Sockets.TransmitFileOptions>值。 `preBuffer`参数包含你想要位于文件之前的任何数据。 `postBuffer` 包含你想要遵照该文件的数据。 如果`fileName`是在本地目录中，则可以标识与只是文件的名称; 否则，必须指定完整路径和文件的名称。 通配符 ("...\\\myfile.txt") 和 UNC 共享名 ("\\\\\\\shared 目录\\\myfile.txt") 支持。 如果未找到文件，该异常<xref:System.IO.FileNotFoundException>引发。  
  
 `flags`参数提供关于文件传输的其他信息的窗口套接字服务提供程序。 有关如何使用此参数的详细信息，请参阅<xref:System.Net.Sockets.TransmitFileOptions>。  
  
 此方法使用`TransmitFile`Windows 套接字 2 API 中找到函数。 有关详细信息`TransmitFile`函数和其标志，请参阅 MSDN 库中的 Windows 套接字文档。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法会启动异步发送操作中建立的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 引发异常，如果不首先调用<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 调用<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法使你能够发送单独的执行线程中的文件。  
  
 若要完成该操作，你可以创建由调用的回调方法<xref:System.AsyncCallback>委托参数。 为此，请至少，`state`参数必须包含<xref:System.Net.Sockets.Socket>对象用于进行通信。 如果你的回调需要详细信息，可以创建类或结构，用于保存<xref:System.Net.Sockets.Socket>和其他必需的信息。 将为此自定义对象的实例传递<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法通过`state`参数。  
  
 你的回调方法必须调用<xref:System.Net.Sockets.Socket.EndSendFile%2A>方法。 当你的应用程序调用<xref:System.Net.Sockets.Socket.BeginSendFile%2A>，系统将使用一个单独的线程执行指定的回调方法，并阻止在<xref:System.Net.Sockets.Socket.EndSendFile%2A>直到<xref:System.Net.Sockets.Socket>发送完整的文件或引发异常。 有关编写回调方法的更多信息，请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 适用于面向连接的协议，尽管<xref:System.Net.Sockets.Socket.BeginSendFile%2A>还应用于无连接协议，前提是你第一次调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法来建立默认远程主机。 使用无连接协议，你还必须确保你的文件的大小不能超过基础服务提供程序的最大的数据包大小。 如果是这样，不会发送数据报和<xref:System.Net.Sockets.Socket.BeginSendFile%2A>引发<xref:System.Net.Sockets.SocketException>异常。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>异常，请改用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
   
  
## Examples  
 下面的代码示例创建和连接进行异步通信套接字并开始文件"text.txt"以异步方式发送到远程主机。 在此示例中，`preBuffer`和`postBuffer`的数据创建要与文件和默认值一起发送<xref:System.Net.Sockets.TransmitFileOptions>使用值。 回调委托调用<xref:System.Net.Sockets.Socket.EndSendFile%2A>完成传输。  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.NotSupportedException">操作系统不是 Windows NT 或更高版本。  \- 或 -  套接字未连接到远程主机。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</param>
        <param name="offset">
          <c>buffer</c> 中开始发送数据的位置，该位置从零开始计数。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">包含此请求的状态信息的对象。</param>
        <summary>以异步方式将数据发送到特定远程主机。</summary>
        <returns>引用异步发送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法会启动异步发送操作中指定远程主机`remoteEP`参数。 调用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法使你能够发送单独的执行线程中的数据。 虽然供无连接协议，但是<xref:System.Net.Sockets.Socket.BeginSendTo%2A>适用于无连接和面向连接的协议。  
  
 你可以创建实现一个回调方法<xref:System.AsyncCallback>委托并将传递到其名称<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法。 为此，请至少，你`state`参数必须包含连接或默认<xref:System.Net.Sockets.Socket>用于进行通信。 如果你的回调需要详细信息，你可以创建一个小型类来保存<xref:System.Net.Sockets.Socket>，和其他必需的信息。 将此类的实例传递<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法通过`state`参数。  
  
 你的回调方法应调用<xref:System.Net.Sockets.Socket.EndSendTo%2A>方法。 当你的应用程序调用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>，系统将使用一个单独的线程执行的指定的回调方法，并阻止<xref:System.Net.Sockets.Socket.EndSendTo%2A>直到<xref:System.Net.Sockets.Socket>发送请求的字节数或引发异常。 如果你想要阻止后调用的原始线程<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法，请使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 当你想要继续执行原始线程时，请在回调方法调用 Set 方法。 有关编写回调方法的其他信息请参阅[委托作为回调方法进行封送](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 如果你使用的一个面向连接的协议，必须先调用<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，或<xref:System.Net.Sockets.Socket.BeginSendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 将忽略`remoteEP`参数并将数据发送到<xref:System.Net.EndPoint>中建立<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。  
  
 如果你使用的是无连接协议，不需要建立默认远程主机使用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>。 只需执行此操作，如果你想要调用<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`只为发送操作，参数将覆盖指定的默认远程主机。 你还无需调用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 在这种情况下，基础服务提供程序将分配的最合适的本地网络地址和端口号。 如果你想要选择可用端口的基础服务提供程序，请使用端口号 0。 如果你需要确定分配的本地网络地址和端口号，则可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性后的<xref:System.Net.Sockets.Socket.EndSendTo%2A>方法已成功完成。  
  
 如果你想要将数据发送到广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法并设置套接字选项设为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 -你还必须确保你的缓冲区的大小不能超过基础服务提供程序的最大的数据包大小。 如果是这样，将不发送数据报和<xref:System.Net.Sockets.Socket.EndSendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，发送的无法路由的数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  执行上下文 （安全上下文，模拟的用户，并调用上下文） 会进行缓存以便异步<xref:System.Net.Sockets.Socket>方法。 在特定上下文首次使用后 (异步特定<xref:System.Net.Sockets.Socket>方法、 特定<xref:System.Net.Sockets.Socket>实例和特定的回调)，以后使用该上下文将提高性能。  
  
   
  
## Examples  
 下面的代码示例以异步方式将数据发送到指定的远程主机。  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">要与 <see cref="T:System.Net.EndPoint" /> 关联的本地 <see cref="T:System.Net.Sockets.Socket" />。</param>
        <summary>使 <see cref="T:System.Net.Sockets.Socket" /> 与一个本地终结点相关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Net.Sockets.Socket.Bind%2A>方法如果你需要使用特定的本地终结点。 必须调用<xref:System.Net.Sockets.Socket.Bind%2A>才能调用<xref:System.Net.Sockets.Socket.Listen%2A>方法。 不需要调用<xref:System.Net.Sockets.Socket.Bind%2A>之前使用<xref:System.Net.Sockets.Socket.Connect%2A>方法除非你需要使用特定的本地终结点。 你可以使用<xref:System.Net.Sockets.Socket.Bind%2A>无连接和面向连接的协议方法。  
  
 之前调用<xref:System.Net.Sockets.Socket.Bind%2A>，你必须首先创建本地<xref:System.Net.IPEndPoint>从想要进行数据通信。 如果你不关心哪些本地地址分配，你可以创建<xref:System.Net.IPEndPoint>使用<xref:System.Net.IPAddress.Any?displayProperty=nameWithType>地址参数，以及基础服务提供程序将分配的最合适的网络地址。 这可能有助于简化你的应用程序，如果你有多个网络接口。 如果你不关心使用哪个本地端口，则可以创建<xref:System.Net.IPEndPoint>使用 0 作为端口号。 在这种情况下，服务提供商将分配 1024年和 5000 之间可用的端口号。  
  
 如果使用上面的方法，你可能会发现已通过调用分配了哪些本地网络地址和端口数量<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>。 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>后所做的调用不会返回之前的本地分配的网络地址<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 如果你使用的是无连接协议，将不具有访问此信息，直到已完成发送或接收。  
  
 如果 UDP 套接字想要接收上接收数据包的接口信息<xref:System.Net.Sockets.Socket.SetSocketOption%2A>应该与套接字选项设置为显式调用方法<xref:System.Net.Sockets.SocketOptionName.PacketInformation>后立即调用<xref:System.Net.Sockets.Socket.Bind%2A>方法。  
  
> [!NOTE]
>  如果你想要接收多播数据报，则必须调用<xref:System.Net.Sockets.Socket.Bind%2A>方法具有多路广播的端口号。  
  
> [!NOTE]
>  必须调用<xref:System.Net.Sockets.Socket.Bind%2A>方法如果你想要接收无连接数据报使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>调用时<xref:System.Net.Sockets.Socket.Bind%2A>方法，请使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例将绑定<xref:System.Net.Sockets.Socket>使用指定的本地终结点。  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自定义的主机的连接<paramref name="localEP" />。 关联的枚举： <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Net.Sockets.Socket" /> 是否处于阻止模式。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 将阻止，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Blocking%2A>属性指示是否<xref:System.Net.Sockets.Socket>处于阻止模式。  
  
 如果你是在阻止模式下，并且进行方法调用这不会立即完成，你的应用程序将请求的操作完成之前阻止执行。 如果你想执行要继续即使请求的操作未完成，更改<xref:System.Net.Sockets.Socket.Blocking%2A>属性`false`。 <xref:System.Net.Sockets.Socket.Blocking%2A>属性不起作用对异步方法。 如果你是发送和异步接收数据，并想要阻止执行，使用<xref:System.Threading.ManualResetEvent>类。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象，该对象用于通过调用 <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> 方法之一，请求与远程主机的连接。</param>
        <summary>取消一个对远程主机连接的异步请求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A>方法取消对远程主机连接的异步请求。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> 参数不能为 null，并且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>关闭 <see cref="T:System.Net.Sockets.Socket" /> 连接并释放所有关联的资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭 <see cref="T:System.Net.Sockets.Socket" /> 连接并释放所有关联的资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>方法关闭远程主机连接并释放所有托管和非托管资源与关联<xref:System.Net.Sockets.Socket>。 结算时，<xref:System.Net.Sockets.Socket.Connected%2A>属性设置为`false`。  
  
 对于面向连接的协议，建议您调用<xref:System.Net.Sockets.Socket.Shutdown%2A>之前调用<xref:System.Net.Sockets.Socket.Close%2A>方法。 这可确保发送和关闭之前连接的套接字上接收到的所有数据。  
  
 如果你需要调用<xref:System.Net.Sockets.Socket.Close%2A>而无需首先调用<xref:System.Net.Sockets.Socket.Shutdown%2A>，你可以确保数据排队等待传出传输将发送通过设置<xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket>选项设为`false`并指定非零的超时间隔。 <xref:System.Net.Sockets.Socket.Close%2A> 然后将阻止状态，直到发送此数据，或直到指定的超时时间已到。 如果你设置<xref:System.Net.Sockets.SocketOptionName.DontLinger>到`false`并指定零的超时间隔、<xref:System.Net.Sockets.Socket.Close%2A>释放连接并自动放弃传出排队的数据。  
  
> [!NOTE]
>  若要设置<xref:System.Net.Sockets.SocketOptionName.DontLinger>套接字选项`false`，创建<xref:System.Net.Sockets.LingerOption>，将启用的属性设置为`true`，并设置<xref:System.Net.Sockets.LingerOption.LingerTime%2A>到所需的超时期间的属性。 使用此<xref:System.Net.Sockets.LingerOption>连同<xref:System.Net.Sockets.SocketOptionName.DontLinger>套接字选项调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例关闭<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">等待最多 <c>timeout</c> 秒后，即可发送任何剩余数据，然后关闭套接字。</param>
        <summary>关闭 <see cref="T:System.Net.Sockets.Socket" /> 连接并释放所有与指定超时关联的资源，以允许要发送的数据排队。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>方法关闭远程主机连接并释放所有托管和非托管资源与关联<xref:System.Net.Sockets.Socket>。 结算时，<xref:System.Net.Sockets.Socket.Connected%2A>属性设置为`false`。  
  
 对于面向连接的协议，建议您调用<xref:System.Net.Sockets.Socket.Shutdown%2A>之前调用<xref:System.Net.Sockets.Socket.Close%2A>。 这可确保发送和关闭之前连接的套接字上接收到的所有数据。  
  
 如果你需要调用<xref:System.Net.Sockets.Socket.Close%2A>而无需首先调用<xref:System.Net.Sockets.Socket.Shutdown%2A>，你可以确保数据排队等待传出传输将发送通过设置<xref:System.Net.Sockets.SocketOptionName.DontLinger>选项设为`false`并指定非零的超时间隔。 <xref:System.Net.Sockets.Socket.Close%2A> 然后将阻止状态，直到发送此数据，或直到指定的超时时间已到。 如果你设置<xref:System.Net.Sockets.SocketOptionName.DontLinger>到`false`并指定零的超时间隔、<xref:System.Net.Sockets.Socket.Close%2A>释放连接并自动放弃传出排队的数据。  
  
> [!NOTE]
>  若要设置<xref:System.Net.Sockets.SocketOptionName.DontLinger>套接字选项`false`，创建<xref:System.Net.Sockets.LingerOption>，将启用的属性设置为`true`，并设置<xref:System.Net.Sockets.LingerOption.LingerTime%2A>到所需的超时期间的属性。 使用此<xref:System.Net.Sockets.LingerOption>连同<xref:System.Net.Sockets.SocketOptionName.DontLinger>套接字选项调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何关闭<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>与远程主机建立连接。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">表示远程设备的 <see cref="T:System.Net.EndPoint" />。</param>
        <summary>与远程主机建立连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的使用面向连接的协议 TCP，例如<xref:System.Net.Sockets.Socket.Connect%2A>方法以同步方式网络之间建立连接<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的远程终结点。 如果你使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机。 调用后<xref:System.Net.Sockets.Socket.Connect%2A>，你可以将数据发送到远程设备与<xref:System.Net.Sockets.Socket.Send%2A>方法，或从远程设备与接收数据<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果使用如 UDP 无连接协议时，不需要调用<xref:System.Net.Sockets.Socket.Connect%2A>之前发送和接收数据。 你可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>能够同步与远程主机通信。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>，来自地址而不是指定默认的地址的任何数据报将被放弃。 如果你想要将默认远程主机为广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法并设置套接字选项设为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>方法将一直阻止，除非专门设置<xref:System.Net.Sockets.Socket.Blocking%2A>属性`false`之前调用<xref:System.Net.Sockets.Socket.Connect%2A>。 如果你使用一个面向连接的协议，如 TCP 和你确实禁用了阻止，<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>因为它需要时间来建立连接。 无连接协议不会引发异常，因为它们只需要建立默认远程主机。 你可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>以获得特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。 如果 WSAEWOULDBLOCK 返回的错误，已由一个面向连接的启动远程主机连接<xref:System.Net.Sockets.Socket>，但未尚未成功完成。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法来确定何时<xref:System.Net.Sockets.Socket>完成连接。  
  
> [!NOTE]
>  如果你使用一个面向连接的协议，并且未调用<xref:System.Net.Sockets.Socket.Bind%2A>之前调用<xref:System.Net.Sockets.Socket.Connect%2A>，基础服务提供程序将分配的本地网络地址和端口号。 如果你使用的是无连接协议，服务提供程序将不会分配本地网络地址和端口号，直到完成发送或接收操作。 如果你想要更改默认远程主机时，调用<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需终结点。  
  
> [!NOTE]
>  如果之前断开连接的套接字，然后无法使用此方法以恢复连接。 使用异步之一<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法重新连接。 这是基础提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并接着验证连接。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
        <permission cref="T:System.Net.SocketPermission">用于连接到远程主机。 关联的枚举： <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">远程主机的 IP 地址。</param>
        <param name="port">远程主机的端口号。</param>
        <summary>与远程主机建立连接。 主机由 IP 地址和端口号指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的使用面向连接的协议 TCP，例如<xref:System.Net.Sockets.Socket.Connect%2A>方法以同步方式网络之间建立连接<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的远程终结点。 如果你使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机。 调用后<xref:System.Net.Sockets.Socket.Connect%2A>你可以将数据发送到远程设备与<xref:System.Net.Sockets.Socket.Send%2A>方法，或从远程设备与接收数据<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果使用如 UDP 无连接协议时，不需要调用<xref:System.Net.Sockets.Socket.Connect%2A>之前发送和接收数据。 你可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>能够同步与远程主机通信。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>来自地址而不是指定默认的地址的任何数据报将被放弃。 如果你想要将默认远程主机为广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法并设置套接字选项设为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法将一直阻止，除非专门设置<xref:System.Net.Sockets.Socket.Blocking%2A>属性`false`之前调用<xref:System.Net.Sockets.Socket.Connect%2A>。 如果你使用一个面向连接的协议，如 TCP 和你确实禁用了阻止，<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>因为它需要时间来建立连接。 无连接协议不会引发异常，因为它们只需要建立默认远程主机。 你可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>以获得特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。 如果 WSAEWOULDBLOCK 返回的错误，已由一个面向连接的启动远程主机连接<xref:System.Net.Sockets.Socket>，但未尚未成功完成。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法来确定何时<xref:System.Net.Sockets.Socket>完成连接。  
  
> [!NOTE]
>  如果你使用一个面向连接的协议，并且未调用<xref:System.Net.Sockets.Socket.Bind%2A>之前调用<xref:System.Net.Sockets.Socket.Connect%2A>，基础服务提供程序将分配的本地网络地址和端口号。 如果你使用的是无连接协议，服务提供程序将不会分配本地网络地址和端口号，直到完成发送或接收操作。 如果你想要更改默认远程主机时，调用<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需终结点。  
  
> [!NOTE]
>  如果之前断开连接的套接字，然后无法使用此方法以恢复连接。 使用异步之一<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法重新连接。 这是基础提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并接着验证连接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">远程主机的 IP 地址。</param>
        <param name="port">远程主机的端口号。</param>
        <summary>与远程主机建立连接。 主机由 IP 地址数组和端口号指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用之后立即通常使用此方法<xref:System.Net.Dns.GetHostAddresses%2A>，这可以针对单个主机返回多个 IP 地址。 如果你使用的使用面向连接的协议 TCP，例如<xref:System.Net.Sockets.Socket.Connect%2A>方法以同步方式网络之间建立连接<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的远程终结点。 如果你使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机。 调用后<xref:System.Net.Sockets.Socket.Connect%2A>你可以将数据发送到远程设备与<xref:System.Net.Sockets.Socket.Send%2A>方法，或从远程设备与接收数据<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果使用如 UDP 无连接协议时，不需要调用<xref:System.Net.Sockets.Socket.Connect%2A>之前发送和接收数据。 你可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>能够同步与远程主机通信。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>来自地址而不是指定默认的地址的任何数据报将被放弃。 如果你想要将默认远程主机为广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法并设置套接字选项设为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法将一直阻止，除非专门设置<xref:System.Net.Sockets.Socket.Blocking%2A>属性`false`之前调用<xref:System.Net.Sockets.Socket.Connect%2A>。 如果你使用一个面向连接的协议，如 TCP 和你确实禁用了阻止，<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>因为它需要时间来建立连接。 无连接协议不会引发异常，因为它们只需要建立默认远程主机。 你可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>以获得特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。 如果 WSAEWOULDBLOCK 返回的错误，已由一个面向连接的启动远程主机连接<xref:System.Net.Sockets.Socket>，但未尚未成功完成。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法来确定何时<xref:System.Net.Sockets.Socket>完成连接。  
  
> [!NOTE]
>  如果你使用一个面向连接的协议，并且未调用<xref:System.Net.Sockets.Socket.Bind%2A>之前调用<xref:System.Net.Sockets.Socket.Connect%2A>，基础服务提供程序将分配的本地网络地址和端口号。 如果你使用的是无连接协议，服务提供程序将不会分配本地网络地址和端口号，直到完成发送或接收操作。 如果你想要更改默认远程主机时，调用<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需终结点。  
  
> [!NOTE]
>  如果之前断开连接的套接字，然后无法使用此方法以恢复连接。 使用异步之一<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法重新连接。 这是基础提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并接着验证连接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> 的长度为零。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">远程主机的名称。</param>
        <param name="port">远程主机的端口号。</param>
        <summary>与远程主机建立连接。 主机由主机名和端口号指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的使用面向连接的协议 TCP，例如<xref:System.Net.Sockets.Socket.Connect%2A>方法以同步方式网络之间建立连接<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的远程主机。 如果你使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机。 调用后<xref:System.Net.Sockets.Socket.Connect%2A>你可以将数据发送到远程设备与<xref:System.Net.Sockets.Socket.Send%2A>方法，或从远程设备与接收数据<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果使用如 UDP 无连接协议时，不需要调用<xref:System.Net.Sockets.Socket.Connect%2A>之前发送和接收数据。 你可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>能够同步与远程主机通信。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>来自地址而不是指定默认的地址的任何数据报将被放弃。 如果你想要将默认远程主机为广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法并设置套接字选项设为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法将一直阻止，除非专门设置<xref:System.Net.Sockets.Socket.Blocking%2A>属性`false`之前调用<xref:System.Net.Sockets.Socket.Connect%2A>。 如果你使用一个面向连接的协议，如 TCP 和你确实禁用了阻止，<xref:System.Net.Sockets.Socket.Connect%2A>将引发<xref:System.Net.Sockets.SocketException>因为它需要时间来建立连接。 无连接协议不会引发异常，因为它们只需要建立默认远程主机。 你可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>以获得特定错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。 如果 WSAEWOULDBLOCK 返回的错误，已由一个面向连接的启动远程主机连接<xref:System.Net.Sockets.Socket>，但未尚未成功完成。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法来确定何时<xref:System.Net.Sockets.Socket>完成连接。  
  
 如果启用了 IPv6 和<xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29>调用方法来连接到的主机，将解析为这两个 IPv6 和 IPv4 地址、 IPv6 地址将与连接尝试之前的 IPv4 地址的第一个。 这可能产生的延迟的时间来建立连接，如果主机未侦听 IPv6 地址的效果。  
  
> [!NOTE]
>  如果你使用一个面向连接的协议，并且未调用<xref:System.Net.Sockets.Socket.Bind%2A>之前调用<xref:System.Net.Sockets.Socket.Connect%2A>，基础服务提供程序将分配的本地网络地址和端口号。 如果你使用的是无连接协议，服务提供程序将不会分配本地网络地址和端口号，直到完成发送或接收操作。 如果你想要更改默认远程主机时，调用<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需终结点。  
  
> [!NOTE]
>  如果之前断开连接的套接字，然后无法使用此方法以恢复连接。 使用异步之一<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法重新连接。 这是基础提供程序的限制。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，并接着验证连接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">端口号无效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</exception>
        <exception cref="T:System.InvalidOperationException">已通过调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始一个对远程主机连接的异步请求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个对远程主机连接的异步请求。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法会启动与远程主机的连接的异步请求。 如果你使用的是无连接协议，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>建立默认远程主机。  
  
 若要在完成时得到通知，必须创建实现的回调方法\<SocketAsyncEventArgs > 委托和附加到回调<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 调用方必须设置<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>属性<xref:System.Net.IPEndPoint>要连接到的远程主机。  
  
 调用方可能设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>到在调用前要求任何用户状态对象的属性<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，以便在回叫方法可检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。  
  
 如果使用如 UDP 无连接协议时，不需要调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>之前发送和接收数据。 你可以使用<xref:System.Net.Sockets.Socket.SendToAsync%2A>和<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>与远程主机通信。 如果调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，来自地址而不是指定默认的地址的任何数据报将被放弃。 如果你想要更改默认远程主机时，调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>再次使用所需终结点的方法。  
  
 如果你想要设置为广播地址的默认远程主机，必须先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>并将广播设置为`true`。 如果不执行此操作，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法会引发<xref:System.Net.Sockets.SocketException>。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>是必需的对象：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 （可选） 缓冲区可能会提供它以原子方式发送后的套接字上<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法成功。 在这种情况下，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>属性应设置为包含数据的缓冲区，以发送和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>属性应设置为数据的字节数，以从该缓冲区发送。 一旦建立的连接，该缓冲区中的数据被发送。  
  
 如果你使用的是面向连接的协议，并且不调用<xref:System.Net.Sockets.Socket.Bind%2A>之前调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，基础服务提供程序将分配的最合适的本地网络地址和端口号。  
  
 如果你使用的是无连接协议，直到你调用，则服务提供程序将不分配本地网络 IP 地址和端口号<xref:System.Net.Sockets.Socket.SendAsync%2A>或<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法抛出异常<xref:System.NotSupportedException>如果的地址族<xref:System.Net.Sockets.Socket>和<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>不是相同的地址族。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>调用此方法时，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">自变量无效。 如果指定了多个缓冲区，即 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性不为 null，将会发生此异常。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> 参数不能为 null，并且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为空。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> 正在侦听或已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。 如果本地终结点和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是相同的地址族，也会发生此异常。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType">
          <see cref="T:System.Net.Sockets.SocketType" /> 值之一。</param>
        <param name="protocolType">
          <see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</param>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个对远程主机连接的异步请求。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的一个面向连接的协议，M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) 方法会启动对的异步请求连接到远程主机。 如果你使用的是无连接协议，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>建立默认远程主机由指定`socketType`和`protocolType`参数。  
  
 若要在完成时得到通知，必须创建实现的回调方法\<SocketAsyncEventArgs > 委托和附加到回调<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 调用方必须设置<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>属性<xref:System.Net.IPEndPoint>要连接到的远程主机。  
  
 调用方可能设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>到在调用前要求任何用户状态对象的属性<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，以便在回叫方法可检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。  
  
 如果使用如 UDP 无连接协议时，不需要调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>之前发送和接收数据。 你可以使用<xref:System.Net.Sockets.Socket.SendToAsync%2A>和<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>与远程主机通信。 如果调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，来自地址而不是指定默认的地址的任何数据报将被放弃。 如果你想要更改默认远程主机时，调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>再次使用所需终结点的方法。  
  
 如果你想要设置为广播地址的默认远程主机，必须先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>并将广播设置为`true`。 如果不执行此操作，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法会引发<xref:System.Net.Sockets.SocketException>。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>是必需的对象：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 （可选） 缓冲区可能会提供它以原子方式发送后的套接字上<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法成功。 在这种情况下，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>属性应设置为包含数据的缓冲区，以发送和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>属性应设置为数据的字节数，以从该缓冲区发送。 一旦建立的连接，该缓冲区中的数据被发送。  
  
 如果你使用的是面向连接的协议，并且不调用<xref:System.Net.Sockets.Socket.Bind%2A>之前调用<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，基础服务提供程序将分配的最合适的本地网络地址和端口号。  
  
 如果你使用的是无连接协议，直到你调用，则服务提供程序将不分配本地网络 IP 地址和端口号<xref:System.Net.Sockets.Socket.SendAsync%2A>或<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法抛出异常<xref:System.NotSupportedException>如果的地址族<xref:System.Net.Sockets.Socket>和<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>不是相同的地址族。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>调用此方法时，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">自变量无效。 如果指定了多个缓冲区，即 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性不为 null，将会发生此异常。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> 参数不能为 null，并且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为空。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> 正在侦听或已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。 如果本地终结点和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是相同的地址族，也会发生此异常。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的较高调用方无权执行所请求的操作。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Net.Sockets.Socket" /> 是在上次 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 还是 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 操作时连接到远程主机。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 在最近操作时连接到远程资源，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Connected`属性获取的连接状态<xref:System.Net.Sockets.Socket>截止到最后一个的 I/O 操作。 如果该属性返回`false`、<xref:System.Net.Sockets.Socket>要么从未连接，或已断开连接。  
  
 值<xref:System.Net.Sockets.Socket.Connected%2A>属性反映截至最近的操作连接的状态。 如果你需要确定连接的当前状态，请调用阻止、 零字节发送。 如果调用成功返回，或者引发 WAEWOULDBLOCK 错误代码 (10035)，则仍会连接套接字;否则，套接字已断开连接。  
  
 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>用户数据报协议 (UDP) 套接字上,<xref:System.Net.Sockets.Socket.Connected%2A>属性始终返回`true`; 但是，此操作不会更改的 UDP 固有无连接的特点。  
  
   
  
## Examples  
 下面的代码示例连接到远程终结点，检查<xref:System.Net.Sockets.Socket.Connected%2A>属性，并检查连接的当前状态。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">如果关闭当前连接后可以重用此套接字，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>关闭套接字连接并允许重用套接字。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的一个面向连接的协议，你可以使用此方法关闭套接字。 此方法将结束的连接和集<xref:System.Net.Sockets.Socket.Connected%2A>属性`false`。 但是，如果`reuseSocket`是`true`，你可以重复使用套接字。  
  
 若要确保所有数据是发送和接收套接字关闭之前，应调用<xref:System.Net.Sockets.Socket.Shutdown%2A>之前调用<xref:System.Net.Sockets.Socket.Disconnect%2A>方法。  
  
 如果你需要调用<xref:System.Net.Sockets.Socket.Disconnect%2A>而无需首先调用<xref:System.Net.Sockets.Socket.Shutdown%2A>，你可以设置<xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket>选项设为`false`和指定非零的超时间隔，以确保排队等待发送传出传输的数据。 <xref:System.Net.Sockets.Socket.Disconnect%2A> 然后阻止，直到发送数据，或直到指定的超时时间已到。 如果你设置<xref:System.Net.Sockets.SocketOptionName.DontLinger>到`false`并指定零的超时间隔、<xref:System.Net.Sockets.Socket.Close%2A>释放连接并自动放弃传出排队的数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例创建进行同步通信套接字，并将一些数据发送到远程主机。 然后，它调用<xref:System.Net.Sockets.Socket.Shutdown%2A>，以停止发送和接收活动，和<xref:System.Net.Sockets.Socket.Disconnect%2A>以关闭套接字连接。  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">此方法需要 Windows 2000 或更低版本，否则将引发异常。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始异步请求从远程终结点断开连接。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当使用面向连接的协议时，调用<xref:System.Net.Sockets.Socket.DisconnectAsync%2A>方法从远程终结点请求断开连接。 如果你设置<xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType>到`true`中`e`参数，可以重用套接字。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> 参数不能为 null。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>释放 <see cref="T:System.Net.Sockets.Socket" /> 类的当前实例所使用的所有资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Net.Sockets.Socket" /> 类的当前实例所使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完成使用 `Dispose` 后，应调用 <xref:System.Net.Sockets.Socket>。 `Dispose` 方法使 <xref:System.Net.Sockets.Socket> 处于不可用状态。 在调用`Dispose`，必须释放对所有引用<xref:System.Net.Sockets.Socket>以便垃圾回收器才能回收的内存，<xref:System.Net.Sockets.Socket>占用。  
  
 有关详细信息，请参阅[清洗向上非托管资源](~/docs/standard/garbage-collection/unmanaged.md)和[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
> [!NOTE]
>  每次释放对 `Dispose` 的最后一个引用前，均应调用 <xref:System.Net.Sockets.Socket>。 否则，在垃圾回收器调用 <xref:System.Net.Sockets.Socket> 对象的 `Finalize` 方法之前，该对象正在使用的资源不会被释放。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">如果释放托管资源和非托管资源，则为 <see langword="true" />；如果仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放由 <see cref="T:System.Net.Sockets.Socket" /> 使用的非托管资源，并可根据需要释放托管资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法称为由公共`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。 `Dispose()` 调用受保护`Dispose(Boolean)`方法替换`disposing`参数设置为`true`。 <xref:System.Object.Finalize%2A> 调用`Dispose`与`disposing`设置为`false`。  
  
 当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.Net.Sockets.Socket> 引用的、由任何托管对象持有的全部资源。 此方法调用每个引用对象的 `Dispose()` 方法。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> 可以多次调用由其他对象。重写 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> 时，请注意不要引用在以前调用 <see langword="Dispose" /> 时已释放的对象。有关如何实现详细信息<see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />，请参阅 [实现释放 Method](~/docs/standard/garbage-collection/implementing-dispose.md)。有关详细信息<see langword="Dispose" />和<see cref="M:System.Object.Finalize" />，请参阅 [清洗向上非托管 Resources](~/docs/standard/garbage-collection/unmanaged.md) 和 [重写 Finalize 方法] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否允许将 Internet 协议 (IP) 数据报分段。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 允许数据报分段，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 其大小超过最大传输单元 (MTU) 的传输介质时，数据报需要碎片。 可以对数据报消息分片通过发送主机 （所有 Internet 协议版本） 或中间的路由器 (Internet 协议版本 4 仅)。 如果必须碎片数据报，和<xref:System.Net.Sockets.Socket.DontFragment%2A>选项设置、 数据报将被丢弃，以及 Internet 控制消息协议 (ICMP) 错误消息发送回数据报的发件人。  
  
 传输控制协议 (TCP) 套接字上设置此属性将产生任何影响。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.DontFragment%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">只有对于在 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 族中的套接字，才可以设置此属性。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否是用于 IPv4 和 IPv6 的双模式套接字。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 是双模式套接字，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">从中创建重复套接字引用的目标进程的 ID。</param>
        <summary>重复目标进程的套接字引用，并关闭此进程的套接字。</summary>
        <returns>要传递到目标进程的套接字引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目标进程应使用<xref:System.Net.Sockets.Socket.%23ctor%2A>创建重复的套接字实例。  
  
 如果调用<xref:System.Net.Sockets.Socket.%23ctor%2A>多次使用相同的字节数组作为每个调用的参数的构造函数，你将创建多个托管<xref:System.Net.Sockets.Socket>具有相同的基础套接字的实例。 强烈建议不要使用这种做法。  
  
 如果进程创建套接字使用异步方法 (<xref:System.Net.Sockets.Socket.BeginReceive%2A>或<xref:System.Net.Sockets.Socket.BeginSend%2A>)，必须首先设置过程<xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A>属性设置为 true; 否则为套接字绑定到完成端口的创建过程中，这可能导致<xref:System.ArgumentNullException>上目标进程引发。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="targetProcessID" /> 不是有效的进程 ID。  - 或 -  套接字引用的复制失败。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否可以发送或接收广播数据包。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 允许广播数据包，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 广播将仅限于特定子网，并且必须使用用户数据报协议 (UDP)。有关 Internet 协议版本 4，您可以通过将数据包发送到 255.255.255.255; 广播本地子网或者，你可以使用定向广播的地址，这是与设置的主机部分中的所有位的 Internet 协议 (IP) 地址的网络部分。 例如，如果你的 IP 地址为 192.168.1.40 （C 类地址，网络掩码为 255.255.255.0-网络部分是前三个八位字节，和的主机部分是最后一个八位字节），则定向广播的地址是 192.168.1.255。  
  
 传输控制协议 (TCP) 套接字上设置此属性将产生任何影响。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.EnableBroadcast%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">此选项仅对数据报套接字有效。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>异步接受传入的连接尝试。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">包含所传输字节的类型 <see cref="T:System.Byte" /> 的数组。</param>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息以及任何用户定义数据。</param>
        <summary>异步接受传入的连接尝试，并创建新的 <see cref="T:System.Net.Sockets.Socket" /> 对象来处理远程主机通信。 此方法返回包含所传输的初始数据的缓冲区。</summary>
        <returns>一个 <see cref="T:System.Net.Sockets.Socket" /> 对象，它处理与远程主机的通信。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成对调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>。 之前调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>，你需要创建一个由调用的回调方法<xref:System.AsyncCallback>委托。 此回调方法在单独的线程中，执行之后, 由系统调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法返回。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法`asyncResult`参数来获取<xref:System.Net.Sockets.Socket>对其进行连接尝试。 获取之后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法才能成功完成连接尝试。 `buffer`的此重载的参数包含对的调用中收到的数据<xref:System.Net.Sockets.Socket.BeginAccept%2A>和`bytesTransferred`参数包含已传输的调用中的字节数。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法阻止，直到连接正在等待传入的连接队列中。 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法接受传入连接，并返回一个新<xref:System.Net.Sockets.Socket>可用来将数据发送到和从远程主机接收数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.Sockets.Socket.BeginAccept%2A>创建和连接套接字并接受前 10 个字节的数据。 回调委托调用<xref:System.Net.Sockets.Socket.EndAccept%2A>来结束异步请求。 在中返回传输的字节数和数据`buffer`和`bytesTransferred`此方法的参数并在控制台上显示。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为空。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的调用创建的。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法以前被调用过。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问 <see cref="T:System.Net.Sockets.Socket" /> 时出错</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>异步接受传入的连接尝试，并创建新的 <see cref="T:System.Net.Sockets.Socket" /> 来处理远程主机通信。</summary>
        <returns>一个 <see cref="T:System.Net.Sockets.Socket" />，它处理与远程主机的通信。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成对调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>。 之前调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 此回调方法在单独的线程中，执行之后, 由系统调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法返回。 它必须接受`asyncResult`参数从返回<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法`asyncResult`参数来获取<xref:System.Net.Sockets.Socket>对其进行连接尝试。 获取之后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法才能成功完成连接尝试。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法阻止，直到连接正在等待传入的连接队列中。 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法接受传入连接，并返回一个新<xref:System.Net.Sockets.Socket>可用来将数据发送到和从远程主机接收数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例结束的异步请求并创建一个新<xref:System.Net.Sockets.Socket>无法接受传入的连接请求。 有关完整示例，演示与套接字的异步通信的说明，请参阅[套接字的代码示例](~/docs/framework/network-programming/socket-code-examples.md)。  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的调用创建的。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 有关详细信息，请参阅备注部分。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法以前被调用过。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">包含所传输字节的类型 <see cref="T:System.Byte" /> 的数组。</param>
        <param name="bytesTransferred">已传输的字节数。</param>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息以及任何用户定义数据。</param>
        <summary>异步接受传入的连接尝试，并创建新的 <see cref="T:System.Net.Sockets.Socket" /> 对象来处理远程主机通信。 此方法返回一个缓冲区，其中包含初始数据和传输的字节数。</summary>
        <returns>一个 <see cref="T:System.Net.Sockets.Socket" /> 对象，它处理与远程主机的通信。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成对调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>。 之前调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>，你需要创建一个由调用的回调方法<xref:System.AsyncCallback>委托。 此回调方法在单独的线程中，执行之后, 由系统调用<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法返回。 它必须接受`asyncResult`参数从返回<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法`asyncResult`参数来获取<xref:System.Net.Sockets.Socket>对其进行连接尝试。 获取之后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法才能成功完成连接尝试。 `buffer`的此重载的参数包含对的调用中收到的数据<xref:System.Net.Sockets.Socket.BeginAccept%2A>和`bytesTransferred`参数包含已传输的调用中的字节数。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法阻止，直到连接正在等待传入的连接队列中。 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法接受传入连接，并返回一个新<xref:System.Net.Sockets.Socket>可用来将数据发送到和从远程主机接收数据。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.Sockets.Socket.BeginAccept%2A>创建和连接套接字并接受前 10 个字节的数据。 回调委托调用<xref:System.Net.Sockets.Socket.EndAccept%2A>来结束异步请求。 在中返回传输的字节数和数据`buffer`和`bytesTransferred`此方法的参数并在控制台上显示。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为空。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的调用创建的。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法以前被调用过。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问 <see cref="T:System.Net.Sockets.Socket" /> 时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>结束挂起的异步连接请求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> 在中启动一个完成异步远程主机连接请求的阻止方法<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法。  
  
 之前调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 此回调方法在一个单独的线程中执行之后, 由系统调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回<xref:System.Net.Sockets.Socket.BeginConnect%2A>作为参数的方法。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>参数来获取<xref:System.Net.Sockets.Socket>对其进行连接尝试。 获取之后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法才能成功完成连接尝试。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例结束异步连接尝试。 有关完整示例，演示与套接字的异步通信的说明，请参阅[套接字的代码示例](~/docs/framework/network-programming/socket-code-examples.md)。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步连接调用过 <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息以及所有用户定义数据。</param>
        <summary>结束挂起的异步断开连接请求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 完成对调用<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>方法阻止，直至断开连接完成。 有关异步操作的信息，请参阅 MSDN 库中的异步编程的概述主题。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例创建套接字进行异步通信，并将一些数据发送到远程主机。 当数据已发送时，<xref:System.Net.Sockets.Socket.Shutdown%2A>调用以停止发送和接收活动。 然后<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>调用以开始断开连接请求。 回调委托调用<xref:System.Net.Sockets.Socket.EndDisconnect%2A>来结束异步请求。 完成请求后，<xref:System.Net.Sockets.Socket.Connected%2A>属性将查询以测试是否断开连接的套接字。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">操作系统为 Windows 2000 或更低版本，而此方法需要在 Windows XP 中使用。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步连接调用过 <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.Net.WebException">断开连接请求已超时。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>结束挂起的异步读取。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>结束挂起的异步读取。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法完成异步读取的操作以启动<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。  
  
 之前调用<xref:System.Net.Sockets.Socket.BeginReceive%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 此回调方法在一个单独的线程中执行之后, 由系统调用<xref:System.Net.Sockets.Socket.BeginReceive%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回<xref:System.Net.Sockets.Socket.BeginReceive%2A>作为参数的方法。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>以获取状态对象传递给<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 提取接收<xref:System.Net.Sockets.Socket>从此状态对象。 获取之后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndReceive%2A>方法已成功完成读取的操作，并返回读取的字节数。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法将一直阻止到的数据是否可用。 如果你使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndReceive%2A>将读取传入的网络缓冲区中可用的第一个排队数据报。 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法将读取多的数据可用最中指定的字节数多`size`参数<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法将立即完成并返回零字节。  
  
 若要获取已接收的数据，请调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>，然后提取生成的状态对象中包含的缓冲区。  
  
 若要取消挂起<xref:System.Net.Sockets.Socket.BeginReceive%2A>，调用<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  在线程退出时，由给定线程启动的所有 i/o 操作已取消。 如果在线程退出操作完成前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例结束挂起的异步读取。 有关完整示例，演示与套接字的异步通信的说明，请参阅[套接字的代码示例](~/docs/framework/network-programming/socket-code-examples.md)。  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>结束挂起的异步读取。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法完成异步读取的操作以启动<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。  
  
 之前调用<xref:System.Net.Sockets.Socket.BeginReceive%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 此回调方法在一个单独的线程中执行之后, 由系统调用<xref:System.Net.Sockets.Socket.BeginReceive%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回<xref:System.Net.Sockets.Socket.BeginReceive%2A>作为参数的方法。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>以获取状态对象传递给<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 提取接收<xref:System.Net.Sockets.Socket>从此状态对象。 获取之后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndReceive%2A>方法已成功完成读取的操作，并返回读取的字节数。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法将一直阻止到的数据是否可用。 如果你使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndReceive%2A>将读取传入的网络缓冲区中可用的第一个排队数据报。 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法将读取多的数据可用最中指定的字节数多`size`参数<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法将立即完成并返回零字节。  
  
 若要获取已接收的数据，请调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>，然后提取生成的状态对象中包含的缓冲区。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  在线程退出时，由给定线程启动的所有 i/o 操作已取消。 如果在线程退出操作完成前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <param name="endPoint">To be added.</param>
        <param name="end_point">To be added.</param>
        <summary>结束挂起的、从特定终结点进行异步读取。</summary>
        <returns>如果成功，则返回已接收的字节数。 如果不成功，则返回 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法完成异步读取的操作以启动<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。  
  
 之前调用<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 此回调方法在一个单独的线程中执行之后, 由系统调用<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>作为参数的方法。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>以获取状态对象传递给<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 提取接收<xref:System.Net.Sockets.Socket>从此状态对象。 获取之后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法已成功完成读取的操作，并返回读取的字节数。  
  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法将一直阻止到的数据是否可用。 如果你使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>将读取传入的网络缓冲区中可用的第一个排队数据报。 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法将读取多的数据可用最中指定的字节数多`size`参数<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法将立即完成并返回零字节。 若要获取已接收的数据，请调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>对象，然后提取生成的状态对象中包含的缓冲区。 若要标识原始主机，提取<xref:System.Net.EndPoint>和将其转换为<xref:System.Net.IPEndPoint>。 使用<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>方法来获取的 IP 地址和<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>方法来获取端口号。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例结束挂起的异步读取从特定<xref:System.Net.EndPoint>。  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</param>
        <param name="socketFlags">所接收数据包的 <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="endPoint">源 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation">所接收数据包的 <see cref="T:System.Net.IPAddress" /> 和接口。</param>
        <summary>结束挂起的、从特定终结点进行异步读取。 此方法还显示有关数据包而不是 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> 的更多信息。</summary>
        <returns>如果成功，则返回已接收的字节数。 如果不成功，则返回 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该操作未完成，此方法阻止，直至它执行。  
  
 若要以同步方式执行此操作，使用<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法。  
  
 检查`ipPacketInformation`如果你需要知道是否使用单播、 多播或广播地址发送数据报。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />  - 或 -   <paramref name="endPoint" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>结束挂起的异步发送。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>结束挂起的异步发送。</summary>
        <returns>如果成功，则将返回向 <see cref="T:System.Net.Sockets.Socket" /> 发送的字节数；否则会返回无效 <see cref="T:System.Net.Sockets.Socket" /> 错误。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 完成异步发送操作以启动<xref:System.Net.Sockets.Socket.BeginSend%2A>。  
  
 之前调用<xref:System.Net.Sockets.Socket.BeginSend%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 此回调方法在一个单独的线程中执行之后, 由系统调用<xref:System.Net.Sockets.Socket.BeginSend%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回<xref:System.Net.Sockets.Socket.BeginSend%2A>作为参数的方法。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>参数来获取发送<xref:System.Net.Sockets.Socket>。 获取之后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndSend%2A>方法已成功完成发送操作并返回发送的字节数。  
  
 如果你使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndSend%2A>将阻止，直到发送数据报。 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.EndSend%2A>将阻止，直到一些缓冲区已发送。 如果返回值从<xref:System.Net.Sockets.Socket.EndSend%2A>指示缓冲区不完全发送，调用<xref:System.Net.Sockets.Socket.BeginSend%2A>方法再次，修改要保存未发送的数据的缓冲区。  
  
 就你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.BeginSend%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  在线程退出时，由给定线程启动的所有 i/o 操作已取消。 如果在线程退出操作完成前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  成功完成后发送不指示已成功传递数据。 如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例结束挂起的异步发送。  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前为异步发送已调用过 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>结束挂起的异步发送。</summary>
        <returns>如果成功，则将返回向 <see cref="T:System.Net.Sockets.Socket" /> 发送的字节数；否则会返回无效 <see cref="T:System.Net.Sockets.Socket" /> 错误。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 完成异步发送操作以启动<xref:System.Net.Sockets.Socket.BeginSend%2A>。  
  
 之前调用<xref:System.Net.Sockets.Socket.BeginSend%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 此回调方法在一个单独的线程中执行之后, 由系统调用<xref:System.Net.Sockets.Socket.BeginSend%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回<xref:System.Net.Sockets.Socket.BeginSend%2A>作为参数的方法。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>参数来获取发送<xref:System.Net.Sockets.Socket>。 获取之后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndSend%2A>方法已成功完成发送操作并返回发送的字节数。  
  
 如果你使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndSend%2A>将阻止，直到发送数据报。 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.EndSend%2A>将阻止，直到一些缓冲区已发送。 如果返回值从<xref:System.Net.Sockets.Socket.EndSend%2A>指示缓冲区不完全发送，调用<xref:System.Net.Sockets.Socket.BeginSend%2A>方法再次，修改要保存未发送的数据的缓冲区。  
  
 就你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.BeginSend%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  在线程退出时，由给定线程启动的所有 i/o 操作已取消。 如果在线程退出操作完成前，挂起的异步操作可能会失败。  
  
> [!NOTE]
>  成功完成后发送不指示已成功传递数据。 如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前为异步发送已调用过 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息。</param>
        <summary>结束文件的挂起异步发送。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 完成异步发送操作以启动<xref:System.Net.Sockets.Socket.BeginSendFile%2A>。  
  
 之前调用<xref:System.Net.Sockets.Socket.BeginSendFile%2A>，你必须创建实现一个回调方法<xref:System.AsyncCallback>委托。 此回调方法在一个单独的线程中执行之后, 由系统调用<xref:System.Net.Sockets.Socket.BeginSendFile%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回对象<xref:System.Net.Sockets.Socket.BeginSendFile%2A>作为参数的方法。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>参数来获取发送<xref:System.Net.Sockets.Socket>。 获取之后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndSendFile%2A>方法才能成功完成发送操作。  
  
 如果你使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndSendFile%2A>一直阻塞，直到发送数据报。 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.EndSendFile%2A>一直阻塞，直到发送整个文件。 就你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例创建和连接进行异步通信套接字并开始文件"text.txt"以异步方式发送到远程主机。 回调委托调用<xref:System.Net.Sockets.Socket.EndSendFile%2A>完成传输。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为空。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前曾为异步 <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> 调用过 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>结束挂起的、向指定位置进行的异步发送。</summary>
        <returns>如果成功，则返回已发送的字节数；否则会返回无效 <see cref="T:System.Net.Sockets.Socket" /> 错误。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 完成异步发送操作以启动<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。  
  
 之前调用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>，你需要创建实现一个回调方法<xref:System.AsyncCallback>委托。 此回调方法在一个单独的线程中执行之后, 由系统调用<xref:System.Net.Sockets.Socket.BeginReceive%2A>返回。 回调方法必须接受<xref:System.IAsyncResult>返回<xref:System.Net.Sockets.Socket.BeginSendTo%2A>作为参数的方法。  
  
 在回调方法中，调用<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>参数来获取发送<xref:System.Net.Sockets.Socket>。 获取之后<xref:System.Net.Sockets.Socket>，可以调用<xref:System.Net.Sockets.Socket.EndSendTo%2A>方法已成功完成发送操作并返回发送的字节数。  
  
 如果你使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndSendTo%2A>将阻止，直到发送数据报。 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.EndSendTo%2A>将阻止，直到发送请求的字节数。 就你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例结束异步发送到特定位置。  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">对 <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 方法的调用未返回 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">先前为异步发送已调用过 <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否仅允许一个进程绑定到端口。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 仅允许一个套接字绑定到特定端口，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值是<see langword="true" />为 Windows Server 2003 和 Windows XP Service Pack 2，和<see langword="false" />对于所有其他版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>是`false`，可以使用多个套接字<xref:System.Net.Sockets.Socket.Bind%2A>方法将绑定到特定端口; 但是只有一个套接字可以执行对发送到端口的网络流量的操作。 如果尝试使用多个套接字<xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29>方法来绑定到特定端口，则具有更具体的 IP 地址将处理发送到该端口的网络流量。  
  
 如果<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>是`true`，第一次使用<xref:System.Net.Sockets.Socket.Bind%2A>方法来尝试将绑定到特定端口，而不考虑 Internet 协议 (IP) 地址，将会成功; 的所有后续使用<xref:System.Net.Sockets.Socket.Bind%2A>方法来尝试将绑定到该端口将之前销毁原始绑定套接字失败。  
  
 此属性必须之前设置<xref:System.Net.Sockets.Socket.Bind%2A>调用; 否则为<xref:System.InvalidOperationException>将引发。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">已为此 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 调用了 <see cref="T:System.Net.Sockets.Socket" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Net.Sockets.Socket" /> 类使用的资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>类终结器调用<xref:System.Net.Sockets.Socket.Close%2A>方法来关闭<xref:System.Net.Sockets.Socket>并释放与关联的资源<xref:System.Net.Sockets.Socket>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Net.Sockets.Socket" /> 选项的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <summary>返回指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项的值，表示为一个对象。</summary>
        <returns>一个对象，表示选项的值。 当将 <paramref name="optionName" /> 参数设置为 <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> 时，返回值为 <see cref="T:System.Net.Sockets.LingerOption" /> 类的一个实例。 当将 <paramref name="optionName" /> 设置为 <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> 或 <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> 时，返回值为 <see cref="T:System.Net.Sockets.MulticastOption" /> 类的一个实例。 当 <paramref name="optionName" /> 为其他任何值时，返回值为整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项将确定当前行为<xref:System.Net.Sockets.Socket>。 此重载用于获取<xref:System.Net.Sockets.SocketOptionName.Linger>， <xref:System.Net.Sockets.SocketOptionName.AddMembership>，和<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>选项。 有关<xref:System.Net.Sockets.SocketOptionName.Linger>选项，请使用<xref:System.Net.Sockets.Socket>为`optionLevel`参数。 有关<xref:System.Net.Sockets.SocketOptionName.AddMembership>和<xref:System.Net.Sockets.SocketOptionName.DropMembership>，使用<xref:System.Net.Sockets.SocketOptionLevel.IP>。 如果你想要设置的任何上面列出的选项的值，则使用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例检索<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>超时值，并向控制台显示它们。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。  - 或 -  <paramref name="optionName" /> 设置为不支持的值 <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">
          <see cref="T:System.Byte" /> 类型的数组，用于接收选项设置。</param>
        <summary>返回指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置，表示为字节数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项将确定当前行为<xref:System.Net.Sockets.Socket>。 在此方法成功完成，通过将指定的数组`optionValue`参数包含指定的值<xref:System.Net.Sockets.Socket>选项。  
  
 时的长度`optionValue`数组小于存储的值指定所需的字节数<xref:System.Net.Sockets.Socket>选项，<xref:System.Net.Sockets.Socket.GetSocketOption%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。 对于由布尔值或整数表示任何套接字使用此重载。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例检索<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>超时值，并向控制台显示它们。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。  \- 或 -  在 .NET Compact Framework 应用程序中，Windows CE 默认缓冲区的空间被设置为 32768 字节。 通过调用 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，可以更改每个套接字缓冲区的空间。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionLength">所需返回值的长度（以字节为单位）。</param>
        <summary>返回数组中指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项的值。</summary>
        <returns>
          <see cref="T:System.Byte" /> 类型的数组，它包含套接字选项的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength`参数设置返回的字节数组的最大大小。 如果选项值要求更少字节数，该数组将包含仅的很多字节。 如果选项值需要更多字节<xref:System.Net.Sockets.Socket.GetSocketOption%2A>将引发<xref:System.Net.Sockets.SocketException>。 对于由布尔值或整数表示任何套接字使用此重载。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例检索<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>超时值，并向控制台显示它们。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。  \- 或 -  在 .NET Compact Framework 应用程序中，Windows CE 默认缓冲区的空间被设置为 32768 字节。 通过调用 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，可以更改每个套接字缓冲区的空间。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的操作系统句柄。</summary>
        <value>一个 <see cref="T:System.IntPtr" />，它表示 <see cref="T:System.Net.Sockets.Socket" /> 的操作系统句柄。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为 <see cref="T:System.Net.Sockets.Socket" /> 设置低级别操作模式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">一个 <see cref="T:System.Int32" /> 值，该值指定要执行的操作的控制代码。</param>
        <param name="optionInValue">一个 <see cref="T:System.Byte" /> 数组，它包含操作需要的输入数据。</param>
        <param name="optionOutValue">一个 <see cref="T:System.Byte" /> 数组，它包含操作返回的输出数据。</param>
        <summary>使用数字控制代码，为 <see cref="T:System.Net.Sockets.Socket" /> 设置低级操作模式。</summary>
        <returns>
          <paramref name="optionOutValue" /> 参数中的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.IOControl%2A>方法提供对操作系统的低级别访问<xref:System.Net.Sockets.Socket>基础的当前实例<xref:System.Net.Sockets.Socket>类。 有关详细信息，请参阅 MSDN 库中的 WSAIoctl 文档。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例将 FIONREAD 和可用的属性的结果进行比较。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">尝试不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 属性更改阻止模式。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要执行非托管的代码。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">一个 <see cref="T:System.Net.Sockets.IOControlCode" /> 值，它指定要执行的操作的控制代码。</param>
        <param name="optionInValue">
          <see cref="T:System.Byte" /> 类型的数组，包含操作要求的输入数据。</param>
        <param name="optionOutValue">
          <see cref="T:System.Byte" /> 类型的数组，包含由操作返回的输出数据。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 枚举指定控制代码，为 <see cref="T:System.Net.Sockets.IOControlCode" /> 设置低级操作模式。</summary>
        <returns>
          <paramref name="optionOutValue" /> 参数中的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法提供对操作系统的低级别访问<xref:System.Net.Sockets.Socket>基础的当前实例<xref:System.Net.Sockets.Socket>类。 有关详细信息，请参阅 MSDN 库中的 WSAIoctl 文档。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例调用的结果进行比较<xref:System.Net.Sockets.Socket.IOControl%2A>与<xref:System.Net.Sockets.IOControlCode.DataToRead>和<xref:System.Net.Sockets.Socket.Available%2A>属性。  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">尝试不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 属性更改阻止模式。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要执行非托管的代码。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Net.Sockets.Socket" /> 是否绑定到特定本地端口。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 绑定到本地端口，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果显式将其绑定通过调用，套接字将被视为绑定到的本地端口<xref:System.Net.Sockets.Socket.Bind%2A>方法，或通过调用成员等隐式绑定<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.SendTo%2A>，或<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，此过程使用临时的本地端口 （免费端口大于1024，选择的操作系统。)服务器使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，以便客户端可能会连接到它们将绑定到的已知端口。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.IsBound%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 在尝试发送所有挂起数据时是否延迟关闭套接字。</summary>
        <value>一个 <see cref="T:System.Net.Sockets.LingerOption" />，它指定关闭套接字时如何逗留。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LingerState%2A>属性用于更改方式<xref:System.Net.Sockets.Socket.Close%2A>方法的行为。 当组修改在其下连接可以重置通过 Winsock 的条件时，此属性。 连接重置仍会发生根据 IP 协议行为。  
  
 此属性控制的面向连接的连接到在调用后将保持打开的时间长度<xref:System.Net.Sockets.Socket.Close%2A>仍然要发送数据时。  
  
 在调用方法来向对等节点发送数据时，此数据将被置于传出的网络缓冲区。 此属性可以用于确保将此数据发送到远程主机之前<xref:System.Net.Sockets.TcpClient.Close%2A>方法删除连接。  
  
 若要启用延迟，创建<xref:System.Net.Sockets.LingerOption>实例包含所需的值，并设置<xref:System.Net.Sockets.Socket.LingerState%2A>指向此实例的属性。  
  
 下表描述的行为<xref:System.Net.Sockets.Socket.Close%2A>输入的可能的值的方法<xref:System.Net.Sockets.LingerOption.Enabled%2A>属性和<xref:System.Net.Sockets.LingerOption.LingerTime%2A>属性存储在<xref:System.Net.Sockets.Socket.LingerState%2A>属性。  
  
|LingerState.Enabled|LingerState.LingerTime|行为|  
|-------------------------|----------------------------|--------------|  
|`false` （禁用），默认值|超时不适用，（默认值）。|尝试发送数据挂起，直到默认 IP 协议超时时间已到。|  
|`true` （已启用）|非零的超时|尝试发送挂起的数据，直到指定的超时时间已到，如果尝试失败，然后 Winsock 重置连接。|  
|`true` （已启用）|零超时。|丢弃所有挂起的数据。 对于面向连接的套接字 (例如 TCP)，Winsock 重置连接。|  
  
 IP 堆栈计算默认 IP 协议超时期限为使用基于连接的往返时间。 在大多数情况下，该堆栈计算的该超时是个应用程序定义更具相关性。 这是一个套接字的默认行为时<xref:System.Net.Sockets.Socket.LingerState%2A>未设置属性。  
  
 当<xref:System.Net.Sockets.LingerOption.LingerTime%2A>属性存储在<xref:System.Net.Sockets.Socket.LingerState%2A>属性设置大于默认 IP 协议超时值，则仍将应用和重写的默认 IP 协议超时时间。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.LingerState%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">挂起连接队列的最大长度。</param>
        <summary>将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> 导致一个面向连接的<xref:System.Net.Sockets.Socket>侦听传入的连接尝试。 `backlog`参数指定可排队等待接受的传入连接数。 若要确定的最大可以指定的连接数，检索<xref:System.Net.Sockets.SocketOptionName.MaxConnections>值。 <xref:System.Net.Sockets.Socket.Listen%2A> 不会阻止。  
  
 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。 使用<xref:System.Net.Sockets.Socket.Accept%2A>或<xref:System.Net.Sockets.Socket.BeginAccept%2A>以接受来自队列的连接。  
  
> [!NOTE]
>  必须调用<xref:System.Net.Sockets.Socket.Bind%2A>方法之前调用<xref:System.Net.Sockets.Socket.Listen%2A>，或<xref:System.Net.Sockets.Socket.Listen%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  积压工作参数仅限于具体取决于操作系统的不同值。 你可以指定更高的值，但积压工作将会受到某些限制的基于操作系统。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.Sockets.Socket>来侦听传入连接。  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取本地终结点。</summary>
        <value>
          <see cref="T:System.Net.EndPoint" /> 当前用以进行通信的 <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性可以获取<xref:System.Net.EndPoint>包含到的本地 IP 地址和端口号你<xref:System.Net.Sockets.Socket>绑定。 您必须将此转换<xref:System.Net.EndPoint>到<xref:System.Net.IPEndPoint>之前检索的任何信息。 然后，你可以调用<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>方法来检索本地<xref:System.Net.IPAddress>，和<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>方法来检索其中的本地端口号。  
  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性通常设置进行的调用之后<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果你允许系统分配套接字的本地 IP 地址和端口号，<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性将设置后第一次的 I/O 操作。 对于面向连接的协议，第一次的 I/O 操作将是调用<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 对于无连接协议，第一次的 I/O 操作是任何发送或接收调用。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例检索并显示本地和远程终结点。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定传出的多路广播数据包是否传递到发送应用程序。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 接收传出的多路广播数据包，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多路广播是用于在 Internet 上的多对多通信的可扩展方法。 进程订阅到多播地址;然后，由订阅进程发送任何数据包接收订阅的多播地址的每个其他进程。  
  
 传输控制协议 (TCP) 套接字上设置此属性将产生任何影响。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.MulticastLoopback%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Boolean" /> 值，该值指定流 <see cref="T:System.Net.Sockets.Socket" /> 是否正在使用 Nagle 算法。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 使用 Nagle 算法，则为 <see langword="false" />；否则为 <see langword="true" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagle 算法旨在导致套接字缓冲小数据包，然后合并并将其发送在某些情况下的一个数据包中，从而减少网络流量。 TCP 数据包包含 40 个字节的标头以及所发送的数据。 当与 TCP 发送的数据的小数据包时，TCP 标头导致开销可能会的网络流量的重要部分。使高负荷在网络上，这种开销导致拥塞可能导致丢失数据报和重新传输数，以及导致阻塞过多的传播时间。 Nagle 算法抑制发送的新 TCP segmentswhen 新传出数据到达从用户中，如果在连接上的任何处数据将保留未确认。  
  
 大多数网络应用程序应使用 Nagle 算法。  
  
 用户数据报协议 (UDP) 套接字上设置此属性将产生任何影响。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.NoDelay%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问 <see cref="T:System.Net.Sockets.Socket" /> 时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示基础操作系统和网络适配器是否支持 Internet 协议第 4 版 (IPv4)。</summary>
        <value>如果操作系统和网络适配器支持 IPv4 协议，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示基础操作系统和网络适配器是否支持 Internet 协议第 6 版 (IPv6)。</summary>
        <value>如果操作系统和网络适配器支持 IPv6 协议，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">等待响应的时间（以微秒为单位）。</param>
        <param name="mode">
          <see cref="T:System.Net.Sockets.SelectMode" /> 值之一。</param>
        <summary>确定 <see cref="T:System.Net.Sockets.Socket" /> 的状态。</summary>
        <returns>基于 <paramref name="mode" /> 参数中传递的轮询模式值的 <see cref="T:System.Net.Sockets.Socket" /> 的状态。  
  
 <list type="table"><listheader><term> 模式  </term><description> 返回值  </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" /> 如果已调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 并且连接正在挂起；  - 或 -  如果数据可供读取，则为 <see langword="true" />；  - 或 -  如果已关闭、重置或终止连接，则为 <see langword="true" />；  否则，返回 <see langword="false" />。  </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description>，如果正在处理 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> 且已成功连接，则为 <see langword="true" />；  - 或 -  如果已发送数据，则为 <see langword="true" />；  否则，返回 <see langword="false" />。  </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description> 如果正在处理未阻止的 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />并且连接已失败，则为 <see langword="true" />；  - 或 -  如果未设置 <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> 并且带外数据可用，则为 <see langword="true" />；  否则，返回 <see langword="false" />。  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Poll%2A>方法将检查的状态<xref:System.Net.Sockets.Socket>。 指定<xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType>为`selectMode`参数，以确定如果<xref:System.Net.Sockets.Socket>是可读。 指定<xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType>以确定是否<xref:System.Net.Sockets.Socket>是可写。 使用<xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType>来检测错误条件。 <xref:System.Net.Sockets.Socket.Poll%2A> 将阻止执行，直到指定的时间段，以测量`microseconds`，间隔。 设置`microSeconds`参数为负的整数，如果你想要无限期地等待响应。 如果你想要检查多个套接字的状态，你可能希望使用<xref:System.Net.Sockets.Socket.Select%2A>方法。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  此方法无法检测到某些类型的连接问题，如网络电缆中断，或远程主机已意外关闭。 你必须尝试发送或接收数据，以检测这些类型的错误。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例创建套接字，连接到服务器，并使用<xref:System.Net.Sockets.Socket.Poll%2A>若要检查的套接字的状态。  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="mode" /> 参数不是一个 <see cref="T:System.Net.Sockets.SelectMode" /> 值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参阅下面的备注。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的协议类型。</summary>
        <value>
          <see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A>时设置属性<xref:System.Net.Sockets.Socket>创建，并指定所使用的协议<xref:System.Net.Sockets.Socket>。  
  
   
  
## Examples  
 下面的代码示例显示<xref:System.Net.Sockets.AddressFamily>， <xref:System.Net.Sockets.SocketType>，和<xref:System.Net.Sockets.ProtocolType>到控制台。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收来自绑定的 <see cref="T:System.Net.Sockets.Socket" /> 的数据。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <summary>从绑定的 <see cref="T:System.Net.Sockets.Socket" /> 套接字接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入的缓冲区参数并返回成功读取的字节数。 你可以调用<xref:System.Net.Sockets.Socket.Receive%2A>从面向连接的和无连接的套接字。  
  
 此重载仅要求你提供接收缓冲区。 缓冲区偏移量的默认值为 0，默认大小为缓冲区参数的长度和<xref:System.Net.Sockets.SocketFlags>值默认为<xref:System.Net.Sockets.SocketFlags.None>。  
  
 如果你使用的一个面向连接的协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或<xref:System.Net.Sockets.Socket.Accept%2A>接受之前调用的传入连接<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将仅读取数据中建立的远程主机从到达<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果你使用的是无连接协议，你还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将阻塞，直到数据不可用，除非通过使用设置超时值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果超出了超时值，<xref:System.Net.Sockets.Socket.Receive%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 你可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定是否可供读取数据。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取多的数据可用，直到达到的缓冲区的大小。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果你使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>将从你在中指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffer`参数，`buffer`被填与消息的第一个部分，多余的数据将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例接收在连接上的数据<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 类型的一个 <see cref="T:System.Byte" /> 列表，包含接收的数据。</param>
        <summary>从绑定的 <see cref="T:System.Net.Sockets.Socket" /> 接收数据，将数据存入接收缓冲区列表中。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将数据读入的缓冲区参数并返回成功读取的字节数。 你可以调用从面向连接的和无连接的套接字。  
  
 此重载都需要你提供一个或多个接收缓冲区。  
  
 如果你使用的一个面向连接的协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或<xref:System.Net.Sockets.Socket.Accept%2A>接受之前调用的传入连接<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将仅读取数据中建立的远程主机连接从到达<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果你使用的是无连接协议，你还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将阻塞，直到数据不可用，除非通过使用设置超时值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果超出了超时值，<xref:System.Net.Sockets.Socket.Receive%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 你可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定是否可供读取数据。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取多的数据可用，直到达到的缓冲区的大小。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果你使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>将从你在中指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffers`参数，`buffers`被填与消息的第一个部分，多余的数据将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
 **请注意**时你的应用程序中启用网络跟踪，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入的缓冲区参数并返回成功读取的字节数。 你可以调用<xref:System.Net.Sockets.Socket.Receive%2A>从面向连接的和无连接的套接字。  
  
 此重载仅要求您提供接收缓冲区和所需<xref:System.Net.Sockets.SocketFlags>。 缓冲区偏移量的默认值为 0，并且大小默认为字节参数的长度。  
  
 如果你使用的一个面向连接的协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或<xref:System.Net.Sockets.Socket.Accept%2A>接受之前调用的传入连接<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将仅读取数据中建立的远程主机从到达<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果你使用的是无连接协议，你还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将一直阻止到的数据是否可用。 如果你是在非阻塞模式下，并且没有在协议堆栈缓冲区中可用的数据<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 你可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定是否可供读取数据。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试你接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取到缓冲区的大小可尽可能数据。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果你使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>将从你在中指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffer`参数，`buffer`被填与消息的第一个部分，多余的数据将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例指定数据缓冲区和<xref:System.Net.Sockets.SocketFlags>用于接收上连接的数据<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 类型的一个 <see cref="T:System.Byte" /> 列表，包含接收的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区列表中。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将数据读入`buffers`参数并返回成功读取的字节数。 你可以调用从面向连接的和无连接的套接字。  
  
 此重载都需要你提供一个或多个接收缓冲区。 <xref:System.Net.Sockets.SocketFlags>值默认为<xref:System.Net.Sockets.SocketFlags.None>。  
  
 如果你使用的一个面向连接的协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或<xref:System.Net.Sockets.Socket.Accept%2A>接受之前调用的传入连接<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将仅读取数据中建立的远程主机连接从到达<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果你使用的是无连接协议，你还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将阻塞，直到数据不可用，除非通过使用设置超时值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果超出了超时值，<xref:System.Net.Sockets.Socket.Receive%2A>调用会引发<xref:System.Net.Sockets.SocketException>。 如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 你可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定是否可供读取数据。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取多的数据可用，直到达到的缓冲区的大小。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果你使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>将从你在中指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffers`参数，`buffers`被填与消息的第一个部分，多余的数据将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何在连接上接收数据<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 为 <see langword="null" />。  - 或 -  <paramref name="buffers" />.Count 是零。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收指定字节数的数据，并将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入`buffer`参数并返回成功读取的字节数。 你可以调用<xref:System.Net.Sockets.Socket.Receive%2A>从面向连接的和无连接的套接字。  
  
 此重载仅要求您提供接收缓冲区、 你想要接收，字节和所需的数量<xref:System.Net.Sockets.SocketFlags>。  
  
 如果你使用的一个面向连接的协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或<xref:System.Net.Sockets.Socket.Accept%2A>接受之前调用的传入连接<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将仅读取数据中建立的远程主机从到达<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果你使用的是无连接协议，你还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将阻塞，直到数据不可用，除非通过使用设置超时值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果超出了超时值，<xref:System.Net.Sockets.Socket.Receive%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 你可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定是否可供读取数据。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试你接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取原样可用，直到达到指定的字节数多的数据`size`参数。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果你使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>将从你在中指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffer`参数，`buffer`被填与消息的第一个部分，多余的数据将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 以下接收到发现的数据`buffer`，并指定<xref:System.Net.Sockets.SocketFlags.None>为<xref:System.Net.Sockets.SocketFlags>。  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> 超出了 <paramref name="buffer" /> 的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 类型的一个 <see cref="T:System.Byte" /> 列表，包含接收的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区列表中。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将数据读入`buffers`参数并返回成功读取的字节数。 你可以调用从面向连接的和无连接的套接字。  
  
 此重载都需要你提供一个或多个接收缓冲区。 <xref:System.Net.Sockets.SocketFlags>值默认为<xref:System.Net.Sockets.SocketFlags.None>。  
  
 如果你使用的一个面向连接的协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或<xref:System.Net.Sockets.Socket.Accept%2A>接受之前调用的传入连接<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将仅读取数据中建立的远程主机连接从到达<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果你使用的是无连接协议，你还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将阻塞，直到数据不可用，除非通过使用设置超时值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果超出了超时值，<xref:System.Net.Sockets.Socket.Receive%2A>调用会引发<xref:System.Net.Sockets.SocketException>。 如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 你可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定是否可供读取数据。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取多的数据可用，直到达到的缓冲区的大小。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果你使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>将从你在中指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffers`参数，`buffers`被填与消息的第一个部分，多余的数据将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 为 <see langword="null" />。  - 或 -  <paramref name="buffers" />.Count 是零。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="offset">
          <c>buffer</c> 中存储所接收数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收指定的字节数，存入接收缓冲区的指定偏移量位置。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入的缓冲区参数并返回成功读取的字节数。 你可以调用<xref:System.Net.Sockets.Socket.Receive%2A>从面向连接的和无连接的套接字。  
  
 如果你使用的一个面向连接的协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或<xref:System.Net.Sockets.Socket.Accept%2A>接受之前调用的传入连接<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将仅读取数据中建立的远程主机从到达<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果你使用的是无连接协议，你还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将阻塞，直到数据不可用，除非通过使用设置超时值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果超出了超时值，<xref:System.Net.Sockets.Socket.Receive%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 尝试访问套接字时出错。 请参阅下面的备注。 你可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定是否可供读取数据。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取原样可用，直到达到指定大小参数的字节数多的数据。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果你使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>将从你在中指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffer`参数，`buffer`被填与消息的第一个部分，多余的数据将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例上连接接收数据之前指定数据缓冲区、 偏移量、 大小和套接字标志<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  - 或 -  访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="offset">
          <c>buffer</c> 参数中用于存储所接收数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法将数据读入的缓冲区参数并返回成功读取的字节数。 你可以调用<xref:System.Net.Sockets.Socket.Receive%2A>从面向连接的和无连接的套接字。  
  
 如果你使用的一个面向连接的协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或<xref:System.Net.Sockets.Socket.Accept%2A>接受之前调用的传入连接<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法将仅读取数据中建立的远程主机从到达<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果你使用的是无连接协议，你还可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将可以接收来自任何主机的数据。  
  
 如果没有数据可供读取，<xref:System.Net.Sockets.Socket.Receive%2A>方法将阻塞，直到数据不可用，除非通过使用设置超时值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果超出了超时值，<xref:System.Net.Sockets.Socket.Receive%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 尝试访问套接字时出错。 请参阅下面的备注。 你可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定是否可供读取数据。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 如果使用的一个面向连接的<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法将读取原样可用，直到达到指定大小参数的字节数多的数据。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.Receive%2A>方法将立即完成并返回零字节。  
  
 如果你使用的是无连接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>将从你在中指定的目标地址中读取第一个排队数据报<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果你收到的数据报大于的大小`buffer`参数，`buffer`被填与消息的第一个部分，多余的数据将丢失和<xref:System.Net.Sockets.SocketException>引发。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  - 或 -  访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始一个异步请求以便从连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象中接收数据。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法使用套接字或绑定无连接的套接字连接，并且用于读取传入数据。 必须知道套接字的本地地址。  
  
 对于绑定无连接的套接字，此函数将限制从其接受接收的消息的地址。 该函数仅返回从连接中指定的远程地址的消息。 从其他地址的消息将以无提示方式被丢弃。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>属性`e`参数提供关于读取请求的其他信息的窗口套接字服务提供程序。 有关如何使用此参数的详细信息，请参阅<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>对象所需成功调用此方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>设置  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>设置  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可能设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>到在调用前要求任何用户状态对象的属性<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法，以便在回叫方法可检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。  
  
 对于字节流样式套接字，传入数据会放入缓冲区中，直到填充了缓冲区，连接将关闭，或用完内部缓冲的数据。  
  
 对于面向消息的套接字，传入消息会放入缓冲区中直到与关联的缓冲区的总大小`e`参数。 如果消息是比的缓冲区大，与消息的第一个部分填充缓冲区。  
  
 对于面向连接的套接字，<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法可以指示中依赖于套接字为字节流还是面向消息的两种方式之一虚拟线路正常终止。 对于字节流，设置已读零字节指示正常结束，并且将不会读取任何多个字节。 对于面向消息的套接字，其中零字节的消息通常是允许的<xref:System.Net.Sockets.SocketException>与<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>设置为本机 Winsock WSAEDISCON 错误代码 (10101) 用于指示正常的闭包。 在任何情况下，<xref:System.Net.Sockets.SocketException>与<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>错误代码 (10054) 设置为本机 Winsock WSAECONNRESET 指示放弃性关闭已发生。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">参数无效。 <paramref name="e" /> 参数的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 或 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性必须引用有效的缓冲区。 可以设置这两个属性中的某一个，但不能同时设置这两个属性。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，它指定 <see cref="T:System.Net.Sockets.Socket" /> 接收缓冲区的大小。</summary>
        <value>
          <see cref="T:System.Int32" />，它包含接收缓冲区的大小（以字节为单位）。 默认值为 8192。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 更大的缓冲区大小可能会减少的空确认 （不包含数据部分的 TCP 数据包），但也可能会延迟连接问题的识别。 请考虑增加缓冲区大小，如果传输大型文件，或者正在使用的高带宽、 高延迟连接 （如卫星宽带提供程序。）  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 0。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收数据报并存储源终结点。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>将数据报接收到数据缓冲区并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将数据读入`buffer`参数中，返回的字节数已成功读取，并捕获从其发送数据的远程主机终结点。 此方法很有用，如果你想要从未知的主机或多个主机接收无连接数据报。  
  
 此重载仅要求您提供一个接收`buffer`，和<xref:System.Net.EndPoint>表示远程主机。 缓冲区偏移量的默认值为 0。 大小默认的长度为`buffer`参数和`socketFlags`值默认为<xref:System.Net.Sockets.SocketFlags.None>。  
  
> [!NOTE]
>  之前调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，必须显式将绑定<xref:System.Net.Sockets.Socket>本地终结点使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果你不希望这样做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 使用无连接协议<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取到本地网络缓冲区接收到第一个排队数据报。 如果你收到的数据报大于的大小`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将填充`buffer`尽可能可能，而引发的消息与<xref:System.Net.Sockets.SocketException>。 如果你使用的不可靠的协议，多余的数据将丢失。 如果你使用的是可靠的协议对过量数据将保留由服务提供商，你可以通过调用来检索它<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>使用足够大的缓冲区的方法。  
  
 如果没有数据可供读取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将一直阻止到的数据是否可用。 如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 你可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定是否可供读取数据。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 尽管<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>适用于无连接协议，你可以使用也是一个面向连接的协议。 如果你选择这样做，你必须首先可以建立远程主机的连接通过调用<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受传入的远程主机连接，通过调用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果未建立或不接受连接，然后调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法时，将获取<xref:System.Net.Sockets.SocketException>。 你还可以建立默认远程主机之前调用无连接协议<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将忽略`remoteEP`参数和仅接收从连接的数据或默认远程主机。  
  
 对于面向连接的套接字，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取多大小的可用尽可能数据`buffer`。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并返回零字节。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>需要匹配<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将数据报接收到数据缓冲区并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将数据读入`buffer`参数中，返回的字节数已成功读取，并捕获从其发送数据的远程主机终结点。 此方法很有用，如果你想要从未知的主机或多个主机接收无连接数据报。  
  
 此重载仅要求你提供接收缓冲区，所需<xref:System.Net.Sockets.SocketFlags>，和<xref:System.Net.EndPoint>表示远程主机。 偏移量默认值为 0 和默认大小为缓冲区参数的长度。  
  
> [!NOTE]
>  之前调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，必须显式将绑定<xref:System.Net.Sockets.Socket>本地终结点使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果你不希望这样做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 使用无连接协议<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取到本地网络缓冲区接收到第一个排队数据报。 如果你收到的数据报大于的大小`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将填充`buffer`尽可能可能，而引发的消息与<xref:System.Net.Sockets.SocketException>。 如果你使用的不可靠的协议，多余的数据将丢失。 如果你使用的是可靠的协议对过量数据将保留由服务提供商，你可以通过调用来检索它<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>使用足够大的缓冲区的方法。  
  
 如果没有数据可供读取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将一直阻止到的数据是否可用。 如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 你可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定是否可供读取数据。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 尽管<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>适用于无连接协议，你可以使用也是一个面向连接的协议。 如果你选择这样做，你必须首先可以建立远程主机的连接通过调用<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受传入的远程主机连接，通过调用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果未建立或不接受连接，然后调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法时，将获取<xref:System.Net.Sockets.SocketException>。 你还可以建立默认远程主机之前调用无连接协议<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将忽略`remoteEP`参数和仅接收从连接的数据或默认远程主机。  
  
 对于面向连接的套接字，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取多大小的可用尽可能数据`buffer`。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并返回零字节。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>需要匹配<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。 <xref:System.Net.Sockets.SocketFlags> 传递给<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定的字节数接收到数据缓冲区并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将数据读入`buffer`参数中，返回的字节数已成功读取，并捕获从其发送数据的远程主机终结点。 此方法很有用，如果你想要从未知的主机或多个主机接收无连接数据报。  
  
 此重载仅要求你提供接收缓冲区，你想要接收，所需的字节数<xref:System.Net.Sockets.SocketFlags>，和<xref:System.Net.EndPoint>表示远程主机。 缓冲区偏移量的默认值为 0。  
  
 使用无连接协议<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取到本地网络缓冲区接收到第一个排队数据报。 如果你收到的数据报大于的大小`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将填充`buffer`尽可能可能，而引发的消息与<xref:System.Net.Sockets.SocketException>。 如果你使用的不可靠的协议，多余的数据将丢失。 如果你使用的是可靠的协议对过量数据将保留由服务提供商，你可以通过调用来检索它<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>使用足够大的缓冲区的方法。  
  
 如果没有数据可供读取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将一直阻止到的数据是否可用。 如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 你可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定是否可供读取数据。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 尽管<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>适用于无连接协议，你可以使用也是一个面向连接的协议。 如果你选择这样做，你必须首先可以建立远程主机的连接通过调用<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受传入的远程主机连接，通过调用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果未建立或不接受连接，然后调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法时，将获取<xref:System.Net.Sockets.SocketException>。 你还可以建立默认远程主机之前调用无连接协议<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将忽略`remoteEP`参数和仅接收从连接的数据或默认远程主机。  
  
 对于面向连接的套接字，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取原样可用直到达到指定的字节数多的数据`size`参数。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并返回零字节。  
  
> [!NOTE]
>  之前调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，必须显式将绑定<xref:System.Net.Sockets.Socket>本地终结点使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果你不希望这样做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>需要匹配<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。 缓冲区大小和<xref:System.Net.Sockets.SocketFlags>传递给<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  - 或 -  访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="offset">
          <c>buffer</c> 参数中用于存储所接收数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定的数据字节数接收到数据缓冲区的指定位置，并存储终结点。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将数据读入`buffer`参数中，返回的字节数已成功读取，并捕获从其发送数据的远程主机终结点。 此方法很有用，如果你想要从未知的主机或多个主机接收无连接数据报。  
  
 使用无连接协议<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取到本地网络缓冲区接收到第一个排队数据报。 如果你收到的数据报大于的大小`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将填充`buffer`尽可能可能，而引发的消息与<xref:System.Net.Sockets.SocketException>。 如果你使用的不可靠的协议，多余的数据将丢失。 如果你使用的是可靠的协议对过量数据将保留由服务提供商，你可以通过调用来检索它<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>使用足够大的缓冲区的方法。  
  
 如果没有数据可供读取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将一直阻止到的数据是否可用。 如果你是在非阻塞模式下，并且没有中可用的数据在协议堆栈缓冲区中<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并引发<xref:System.Net.Sockets.SocketException>。 你可以使用<xref:System.Net.Sockets.Socket.Available%2A>属性来确定是否可供读取数据。 当<xref:System.Net.Sockets.Socket.Available%2A>为非零，重试该接收操作。  
  
 尽管<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>适用于无连接协议，你可以使用也是一个面向连接的协议。 如果你选择这样做，你必须首先可以建立远程主机的连接通过调用<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受传入的远程主机连接，通过调用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果未建立或不接受连接，然后调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法时，将获取<xref:System.Net.Sockets.SocketException>。 你还可以建立默认远程主机之前调用无连接协议<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将忽略`remoteEP`参数和仅接收从连接的数据或默认远程主机。  
  
 对于面向连接的套接字，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将读取到指定的字节量可尽可能数据`size`参数。 如果远程主机关闭<xref:System.Net.Sockets.Socket>与连接<xref:System.Net.Sockets.Socket.Shutdown%2A>收到方法，并且所有可用数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法将立即完成并返回零字节。  
  
> [!NOTE]
>  之前调用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，必须显式将绑定<xref:System.Net.Sockets.Socket>本地终结点使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果你不希望这样做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>需要匹配<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例从远程主机接收无连接的数据报。 偏移量、 缓冲区大小和<xref:System.Net.Sockets.SocketFlags>传递给<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去偏移量参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  - 或 -  尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始从指定网络设备中异步接收数据。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>方法主要用于在无连接的套接字上接收数据。 必须知道套接字的本地地址。  
  
 调用方必须设置<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>属性<xref:System.Net.IPEndPoint>是要接收数据的远程主机。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>属性`e`参数提供关于读取请求的其他信息的窗口套接字服务提供程序。 有关如何使用此参数的详细信息，请参阅<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>对象所需成功调用此方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可能设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>到在调用前要求任何用户状态对象的属性<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>方法，以便在回叫方法可检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。  
  
 对于面向消息的套接字，传入消息会放入缓冲区中，直到达到总大小的缓冲区。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>属性确定在缓冲区中数据的位置和的数据量。  
  
 对于字节流 – 样式套接字，传入数据会放入缓冲区中，直到填充了缓冲区，连接将关闭，或用完内部缓冲的数据。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>属性确定在缓冲区中数据的位置和的数据量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为 null。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</param>
        <param name="offset">
          <c>buffer</c> 参数中用于存储所接收数据的位置。</param>
        <param name="size">要接收的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</param>
        <param name="ipPacketInformation">保存地址和接口信息的 <see cref="T:System.Net.Sockets.IPPacketInformation" />。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定字节数的数据接收到指定的数据缓冲区位置，并存储终结点和数据包信息。</summary>
        <returns>收到的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法将数据读入`buffer`参数中，返回的字节数已成功读取，并捕获从中已发送数据，以及有关接收的数据包的信息的远程主机终结点。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法主要用于接收无连接的套接字上的消息数据。 必须知道套接字的本地地址。 此方法仅可用于数据报和原始套接字。 必须使用套接字类型设置为初始化套接字<xref:System.Net.Sockets.SocketType.Dgram>或<xref:System.Net.Sockets.SocketType.Raw>之前调用此方法。 这可以使用构造套接字时<xref:System.Net.Sockets.Socket.%23ctor%2A>。  
  
 对于面向消息的套接字，传入消息放入`buffer`直到达到总大小中指定的参数`size`参数。 `offset`参数确定中的何处`buffer`放置数据。 实际数据量放入`buffer`返回<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法自动方法设置<xref:System.Net.Sockets.SocketOptionName.PacketInformation>套接字选项`true`首次调用它的给定<xref:System.Net.Sockets.Socket>。 但是，返回<xref:System.Net.Sockets.IPPacketInformation>对象将只能的数据包到达本地计算机的套接字选项已设置后有效。 如果套接字之间发送数据包时它所绑定到的本地终结点 (显式<xref:System.Net.Sockets.Socket.Bind%2A>方法或通过某项的隐式<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.ConnectAsync%2A>， <xref:System.Net.Sockets.Socket.SendTo%2A>，或<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法) 和其第一次调用<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法，调用到<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法将返回无效<xref:System.Net.Sockets.IPPacketInformation>为这些数据包的对象。  
  
 若要确保所有<xref:System.Net.Sockets.IPPacketInformation>对象有效，应用程序应设置<xref:System.Net.Sockets.SocketOptionName.PacketInformation>套接字选项`true`绑定到本地终结点使用之前<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>方法。  
  
 应用程序可以检查`ipPacketInformation`参数是否需要了解是否使用单播、 多播或广播地址发送数据报。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>需要匹配<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>中使用<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  \- 或-  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去偏移量参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。  - 或 -  .NET Framework 运行在 AMD 64 位处理器上。  - 或 -  尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.NotSupportedException">操作系统为 Windows 2000 或更低版本，而此方法需要在 Windows XP 中使用。</exception>
        <permission cref="T:System.Net.SocketPermission">用于接受来自网络的连接。 关联枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>开始使用指定的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> 将指定字节数的数据异步接收到数据缓冲区的指定位置，并存储终结点和数据包信息。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法主要用于接收无连接的套接字上的消息数据。 必须知道套接字的本地地址。 此方法仅可用于数据报和原始套接字。 必须使用套接字类型设置为初始化套接字<xref:System.Net.Sockets.SocketType.Dgram>或<xref:System.Net.Sockets.SocketType.Raw>之前调用此方法。 这可以使用构造套接字时<xref:System.Net.Sockets.Socket.%23ctor%2A>。  
  
 调用方必须设置<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>属性<xref:System.Net.IPEndPoint>是要接收数据的远程主机。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>对象所需成功调用此方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可能设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>到在调用前要求任何用户状态对象的属性<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法，以便在回叫方法可检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。  
  
 对于面向消息的套接字，传入消息会放入缓冲区中，直到达到总大小的缓冲区。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>属性确定在缓冲区中数据的位置和的数据量。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法会自动设置<xref:System.Net.Sockets.SocketOptionName.PacketInformation>套接字选项`true`首次调用它的给定<xref:System.Net.Sockets.Socket>。 但是，<xref:System.Net.Sockets.IPPacketInformation>对象将只能的数据包到达本地计算机的套接字选项已设置后有效。 如果套接字之间发送数据包时该套接字绑定到的本地终结点 (显式<xref:System.Net.Sockets.Socket.Bind%2A>方法或通过某项的隐式<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.ConnectAsync%2A>， <xref:System.Net.Sockets.Socket.SendTo%2A>，或<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法) 和首次调用<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法，调用到<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法将导致无效<xref:System.Net.Sockets.IPPacketInformation>为这些数据包的对象。  
  
 若要确保所有<xref:System.Net.Sockets.IPPacketInformation>对象有效，应用程序应设置<xref:System.Net.Sockets.SocketOptionName.PacketInformation>套接字选项`true`绑定到本地终结点使用之前<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>方法。  
  
 应用程序可以检查生成<xref:System.Net.Sockets.IPPacketInformation>对象它是否需要了解是否使用单播、 多播或广播地址发送数据报。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为 null。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定之后同步 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 调用将超时的时间长度。</summary>
        <value>超时值（以毫秒为单位）。 默认值为 0，指示超时期限无限大。 指定 -1 还会指示超时期限无限大。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此选项适用于同步<xref:System.Net.Sockets.Socket.Receive%2A>仅调用。 如果超出超时期限，<xref:System.Net.Sockets.Socket.Receive%2A>方法会引发<xref:System.Net.Sockets.SocketException>。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 1。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取远程终结点。</summary>
        <value>当前和 <see cref="T:System.Net.EndPoint" /> 通信的 <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>属性可以获取<xref:System.Net.EndPoint>包含到的远程 IP 地址和端口号<xref:System.Net.Sockets.Socket>连接。 如果你使用的是无连接协议，<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>包含默认远程 IP 地址和端口号与其<xref:System.Net.Sockets.Socket>将通信。 您必须将此转换<xref:System.Net.EndPoint>到<xref:System.Net.IPEndPoint>之前检索的任何信息。 然后，你可以调用<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>方法来检索远程<xref:System.Net.IPAddress>，和<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>方法来检索远程端口号。  
  
 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>后调用设置<xref:System.Net.Sockets.Socket.Accept%2A>或<xref:System.Net.Sockets.Socket.Connect%2A>。 如果你尝试访问此属性更早版本，<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例检索并显示本地和远程终结点。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead">用于检查可读性的 <see cref="T:System.Net.Sockets.Socket" /> 实例的 <see cref="T:System.Collections.IList" />。</param>
        <param name="checkWrite">用于检查可写性的 <see cref="T:System.Net.Sockets.Socket" /> 实例的 <see cref="T:System.Collections.IList" />。</param>
        <param name="checkError">用于检查错误的 <see cref="T:System.Net.Sockets.Socket" /> 实例的 <see cref="T:System.Collections.IList" />。</param>
        <param name="microSeconds">超时值（以微秒为单位）。 值 -1 指示无限超时。</param>
        <summary>确定一个或多个套接字的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> 是一个静态方法，确定一个或多个状态<xref:System.Net.Sockets.Socket>实例。 你必须将放置到的一个或多个套接字<xref:System.Collections.IList>然后才能使用<xref:System.Net.Sockets.Socket.Select%2A>方法。 通过调用检查可读性<xref:System.Net.Sockets.Socket.Select%2A>与<xref:System.Collections.IList>作为`checkRead`参数。 若要检查的可写性套接字，使用`checkWrite`参数。 检测错误条件，请使用`checkError`。 在调用<xref:System.Net.Sockets.Socket.Select%2A>、<xref:System.Collections.IList>将填充满足条件这些套接字。  
  
 如果要在侦听状态中，可读意味着调用<xref:System.Net.Sockets.Socket.Accept%2A>而不会阻止将会成功。 如果你已接受连接，则可读意味着数据是可供读取。 在这些情况下，所有的接收操作而不会阻止将会成功。 可读性也可指示是否远程<xref:System.Net.Sockets.Socket>已关闭连接关闭; 在这种情况下调用<xref:System.Net.Sockets.Socket.Receive%2A>会立即返回，返回零字节。  
  
 <xref:System.Net.Sockets.Socket.Select%2A> 返回时至少一个感兴趣的套接字 (中的套接字`checkRead`， `checkWrite`，和`checkError`列出) 满足其指定的条件，或`microSeconds`超过参数，不管先满足。 设置`microSeconds`为-1 指定无限期超时。  
  
 如果进行到非阻止调用<xref:System.Net.Sockets.Socket.Connect%2A>，则可写意味着你已成功连接。 如果你没有建立的连接，则可写意味着所有发送操作而不会阻止将会成功。  
  
 如果你具有对进行了非阻止调用<xref:System.Net.Sockets.Socket.Connect%2A>、`checkerror`参数标识未成功连接的套接字。  
  
> [!NOTE]
>  使用<xref:System.Net.Sockets.Socket.Poll%2A>方法如果你只想要确定的单个状态<xref:System.Net.Sockets.Socket>。  
  
> [!NOTE]
>  此方法无法检测到某些类型的连接问题，如网络电缆中断，或远程主机已意外关闭。 你必须尝试发送或接收数据，以检测这些类型的错误。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.Sockets.Socket.Select%2A>来确定哪些侦听套接字有一个连接请求。  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="checkRead" /> 参数为 <see langword="null" /> 或为空。  - 并且 -  <paramref name="checkWrite" /> 参数为 <see langword="null" /> 或为空  - 并且 -  <paramref name="checkError" /> 参数为 <see langword="null" /> 或为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <summary>将数据发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式将数据发送到中指定的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可以用于面向连接的和无连接协议。  
  
 此重载都需要包含你想要发送的数据的缓冲区。 <xref:System.Net.Sockets.SocketFlags>的默认值为 0，缓冲区偏移量的默认值为 0，并要将默认值发送到的缓冲区大小的字节数。  
  
 如果你使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法，或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你使用的一个面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或者使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，你将必须调用<xref:System.Net.Sockets.Socket.Connect%2A>对每个调用之前<xref:System.Net.Sockets.Socket.Send%2A>。 你可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 你还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>通过另一个调用<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.Send%2A>将阻止，直到缓冲区中的字节的所有发送时，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超出了超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在锁定模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能会成功完成，即使它发送的字节数小于缓冲区中。 它是你的应用程序负责跟踪发送的字节数并重试该操作，直到应用程序发送缓冲区中的字节。 此外，还有你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.Send%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  成功完成后发送不指示已成功传递数据。 如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何在连接上的发送数据<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 类型的 <see cref="T:System.Byte" /> 的列表，它包含要发送的数据。</param>
        <summary>将列表中的一组缓冲区发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 可以用于面向连接的和无连接协议。  
  
 此重载都需要至少一个包含你想要发送的数据的缓冲区。  
  
 如果你使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法，或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你使用的一个面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或者使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，你将必须调用<xref:System.Net.Sockets.Socket.Connect%2A>对每个调用之前<xref:System.Net.Sockets.Socket.Send%2A>。 你可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 你还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>通过另一个调用<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.Send%2A>将阻止，直到缓冲区中的字节的所有发送时，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超出了超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在锁定模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能会成功完成，即使它发送的字节数小于缓冲区中。 它是你的应用程序负责跟踪发送的字节数并重试该操作，直到应用程序发送缓冲区中的字节。 此外，还有你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.Send%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  成功完成后发送不指示已成功传递数据。 如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 请参见下面的备注部分。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" /> 将数据发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式将数据发送到中建立的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A>方法可以用于面向连接的和无连接协议。  
  
 此重载都需要包含你想要发送的数据的缓冲区和的按位组合<xref:System.Net.Sockets.SocketFlags>。 缓冲区偏移量的默认值为 0，并要将默认值发送到的缓冲区大小的字节数。 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数值，则发送的无法路由的数据。  
  
 如果你使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法，或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你使用的一个面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或者使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，你将必须调用<xref:System.Net.Sockets.Socket.Connect%2A>方法对每个调用之前<xref:System.Net.Sockets.Socket.Send%2A>。 你可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 你还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>通过另一个调用<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.Send%2A>将阻止，直到缓冲区中的字节的所有发送时，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超出了超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在锁定模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能会成功完成，即使它发送的字节数小于缓冲区中。 它是你的应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送请求的字节数。 此外，还有你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.Send%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
> [!NOTE]
>  你必须确保你的缓冲区的大小不超过基础服务提供程序的最大的数据包大小。 如果是这样，将不发送数据报和<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  成功完成后发送不指示已成功传递数据。 如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何在连接上的发送数据<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 类型的 <see cref="T:System.Byte" /> 的列表，它包含要发送的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，将列表中的一组缓冲区发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载都需要至少一个包含你想要发送的数据的缓冲区。 <xref:System.Net.Sockets.SocketFlags>值默认为 0。 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketFlags`参数，发送的无法路由的数据。  
  
 如果你使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法，或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你使用的一个面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或者使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，你将必须调用<xref:System.Net.Sockets.Socket.Connect%2A>对每个调用之前<xref:System.Net.Sockets.Socket.Send%2A>。 你可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 你还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>通过另一个调用<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.Send%2A>将阻止，直到缓冲区中的字节的所有发送时，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超出了超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在非阻塞模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能会成功完成，即使它发送的字节数小于缓冲区中。 它是你的应用程序负责跟踪发送的字节数并重试该操作，直到应用程序发送缓冲区中的字节。 此外，还有你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.Send%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  成功完成后发送不指示已成功传递数据。 如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，将指定字节数的数据发送到已连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式将数据发送到中建立的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可以用于面向连接的和无连接协议。  
  
 此重载都需要包含你想要发送，你想要发送的字节数和任何的按位组合的数据的缓冲区<xref:System.Net.Sockets.SocketFlags>。 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，发送的无法路由的数据。  
  
 如果你使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法，或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你使用的一个面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或者使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，你将必须调用<xref:System.Net.Sockets.Socket.Connect%2A>方法对每个调用之前<xref:System.Net.Sockets.Socket.Send%2A>方法。 你可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 你还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>通过另一个调用<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 与面向连接的协议，<xref:System.Net.Sockets.Socket.Send%2A>将阻止，直到发送请求的字节数，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超出了超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在锁定模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能会成功完成，即使它发送的请求的字节数小于。 它是你的应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送请求的字节数。 此外，还有你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.Send%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
> [!NOTE]
>  你必须确保大小不超过基础服务提供程序的最大的数据包大小。 如果是这样，将不发送数据报和<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  成功完成后发送不指示已成功传递数据。 如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例将发送缓冲区中的数据，并指定<xref:System.Net.Sockets.SocketFlags.None>为<xref:System.Net.Sockets.SocketFlags>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> 小于 0 或超过缓冲区的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  访问套接字时发生操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 类型的 <see cref="T:System.Byte" /> 的列表，它包含要发送的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，将列表中的一组缓冲区发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载都需要至少一个包含你想要发送的数据的缓冲区。 <xref:System.Net.Sockets.SocketFlags>值默认为 0。 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketFlags`参数，发送的无法路由的数据。  
  
 如果你使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法，或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你使用的一个面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或者使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，你将必须调用<xref:System.Net.Sockets.Socket.Connect%2A>对每个调用之前<xref:System.Net.Sockets.Socket.Send%2A>。 你可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 你还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>通过另一个调用<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.Send%2A>将阻止，直到缓冲区中的字节的所有发送时，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超出了超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在非阻塞模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能会成功完成，即使它发送的字节数小于缓冲区中。 它是你的应用程序负责跟踪发送的字节数并重试该操作，直到应用程序发送缓冲区中的字节。 此外，还有你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.Send%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  成功完成后发送不指示已成功传递数据。 如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> 为空。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="offset">开始发送数据的缓冲区中的位置。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <summary>从指定偏移量开始，使用指定 <see cref="T:System.Net.Sockets.SocketFlags" />，将指定的数据字节数发送到已连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式将数据发送到中指定的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可以用于面向连接的和无连接协议。  
  
 在此重载中，如果你指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，发送的无法路由的数据。  
  
 如果你使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>在调用此方法之前或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你使用的一个面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或者使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>，你将需要调用<xref:System.Net.Sockets.Socket.Connect%2A>对每个调用之前<xref:System.Net.Sockets.Socket.Send%2A>。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 你还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>通过另一个调用<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 你还必须确保大小不超过基础服务提供程序的最大的数据包大小。 如果是这样，将不发送数据报和<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.Send%2A>将阻止，直到发送请求的字节数，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超出了超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在锁定模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能会成功完成，即使它发送的请求的字节数小于。 它是你的应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送请求的字节数。 此外，还有你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.Send%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  成功完成后发送不指示已成功传递数据。 如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例指定数据缓冲区、 偏移量、 大小和<xref:System.Net.Sockets.SocketFlags>用于将数据发送到连接<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="offset">开始发送数据的缓冲区中的位置。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="errorCode">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</param>
        <summary>从指定的偏移量开始使用指定的 <see cref="T:System.Net.Sockets.Socket" /> 将指定字节数的数据发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式将数据发送到中指定的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法并返回成功发送的字节数。 <xref:System.Net.Sockets.Socket.Send%2A> 可以用于面向连接的和无连接协议。  
  
 在此重载中，如果你指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，发送的无法路由的数据。  
  
 如果你使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>在调用此方法之前或<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。 如果你使用的一个面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或者使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果你使用的无连接协议和计划将数据发送到若干不同的主机，则应使用<xref:System.Net.Sockets.Socket.SendTo%2A>。 如果不使用<xref:System.Net.Sockets.Socket.SendTo%2A>，你将需要调用<xref:System.Net.Sockets.Socket.Connect%2A>对每个调用之前<xref:System.Net.Sockets.Socket.Send%2A>。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>甚至已建立默认远程主机使用后<xref:System.Net.Sockets.Socket.Connect%2A>。 你还可以更改默认远程主机之前调用<xref:System.Net.Sockets.Socket.Send%2A>通过另一个调用<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 你还必须确保大小不超过基础服务提供程序的最大的数据包大小。 如果是这样，将不发送数据报和<xref:System.Net.Sockets.Socket.Send%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.Send%2A>将阻止，直到发送请求的字节数，除非使用设置超时<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果超出了超时值，<xref:System.Net.Sockets.Socket.Send%2A>调用将引发<xref:System.Net.Sockets.SocketException>。 在锁定模式下，<xref:System.Net.Sockets.Socket.Send%2A>可能会成功完成，即使它发送的请求的字节数小于。 它是你的应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送请求的字节数。 此外，还有你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.Send%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  成功完成后发送不指示已成功传递数据。 如果没有缓冲区空间以容纳要传输的数据传输系统中可用，除非套接字置于阻止模式下，将阻止发送。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例指定数据缓冲区、 偏移量、 大小和<xref:System.Net.Sockets.SocketFlags>用于将数据发送到连接<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>方法用于从面向连接的套接字上的一个或多个缓冲区写入传出数据。 此方法也可用，但是，在已连接操作指定远程主机的无连接套接字上。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>方法会启动异步发送操作中建立的远程主机<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>对象所需成功调用此方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>设置  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>设置  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可能设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>到在调用前要求任何用户状态对象的属性<xref:System.Net.Sockets.Socket.SendAsync%2A>方法，以便在回叫方法可检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>方法将引发异常，如果不首先调用<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>。  
  
 调用<xref:System.Net.Sockets.Socket.SendAsync%2A>方法使你能够发送单独的执行线程中的数据。  
  
 对于面向消息的套接字，不超过基础 Windows 套接字服务提供程序的最大消息大小。 如果数据太长，来以原子方式通过基础服务提供商，传输任何数据和<xref:System.Net.Sockets.Socket.SendAsync%2A>方法抛出异常<xref:System.Net.Sockets.SocketException>与<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>设置为本机 Winsock WSAEMSGSIZE 错误代码 (10040)。  
  
 请注意，成功完成<xref:System.Net.Sockets.Socket.SendAsync%2A>方法并不表示已成功传递数据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="e" /> 参数的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 或 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性必须引用有效的缓冲区。 可以设置这两个属性中的某一个，但不能同时设置这两个属性。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <see cref="T:System.Net.Sockets.Socket" /> 尚未连接或者尚未通过 <see cref="M:System.Net.Sockets.Socket.Accept" />、<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 或 <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> 方法获得。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 发送缓冲区的大小。</summary>
        <value>
          <see cref="T:System.Int32" />，它包含发送缓冲区的大小（以字节为单位）。 默认值为 8192。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 更大的缓冲区大小可能会延迟连接问题的识别。 请考虑增加缓冲区大小，如果传输大型文件，或者正在使用的高带宽、 高延迟连接 （如卫星宽带提供程序。）  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.SendBufferSize%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 0。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将文件和可选数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">一个 <see cref="T:System.String" />，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 传输标志，将文件 <paramref name="fileName" /> 发送到连接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载将文件发送`fileName`到连接的套接字。 `flags`参数默认为<xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread>(0)，和`preBuffer`和`postBuffer`参数默认为`null`。 如果`fileName`是在本地目录中，则可以标识与只是文件的名称; 否则，必须指定完整路径和文件的名称。 通配符 ("...\\\myfile.txt") 和 UNC 共享名 ("\\\\\\\shared 目录\\\myfile.txt") 支持。 如果未找到文件，该异常<xref:System.IO.FileNotFoundException>引发。  
  
 此方法使用`TransmitFile`Windows 套接字 2 API 中找到函数。 有关详细信息`TransmitFile`函数和其标志，请参阅 MSDN 库中的 Windows 套接字文档。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 以同步方式将文件发送到中指定的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 <xref:System.Net.Sockets.Socket.SendFile%2A> 可用于同时面向连接的和无连接协议。  
  
 如果你使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法，否则<xref:System.Net.Sockets.Socket.SendFile%2A>引发<xref:System.Net.Sockets.SocketException>异常。 如果你使用的一个面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机连接或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.SendFile%2A>阻止，直到发送文件为止。 在锁定模式下，<xref:System.Net.Sockets.Socket.SendFile%2A>已发送的整个文件之前，可能会成功完成。 就你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.SendFile%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例创建并连接套接字然后将文件发送到远程主机。 文件"test.txt"位于本地计算机的根目录中。  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">套接字未连接到远程主机。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象未处于阻止模式，无法接受此同步调用。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">一个 <see cref="T:System.String" />，它包含要发送的文件的路径和名称。 此参数可以为 <see langword="null" />。</param>
        <param name="preBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件前要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="postBuffer">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件后要发送的数据。 此参数可以为 <see langword="null" />。</param>
        <param name="flags">一个或多个 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值。</param>
        <summary>通过指定的 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值，将文件 <paramref name="fileName" /> 和数据缓冲区发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载需要你想要发送的文件和的按位组合的名称<xref:System.Net.Sockets.TransmitFileOptions>值。 `preBuffer`参数包含你想要位于文件之前的任何数据。 `postBuffer` 包含你想要遵照该文件的数据。 如果`fileName`是在当前工作目录中，则可以标识与只是文件的名称; 否则，必须指定完整路径和文件的名称。 通配符 ("...\\\myfile.txt") 和 UNC 共享名 ("\\\\\\\shared 目录\\\myfile.txt") 支持。  
  
 `flags`参数提供关于文件传输的其他信息的窗口套接字服务提供程序。 有关如何使用此参数的详细信息，请参阅<xref:System.Net.Sockets.TransmitFileOptions>。  
  
 此方法使用`TransmitFile`Windows 套接字 2 API 中找到函数。 有关详细信息`TransmitFile`函数和其标志，请参阅 MSDN 库中的 Windows 套接字文档。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 以同步方式将文件发送到中指定的远程主机<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 <xref:System.Net.Sockets.Socket.SendFile%2A> 可用于同时面向连接的和无连接协议。  
  
 如果你使用的是无连接协议，则必须调用<xref:System.Net.Sockets.Socket.Connect%2A>之前调用此方法; 否则为<xref:System.Net.Sockets.Socket.SendFile%2A>引发<xref:System.Net.Sockets.SocketException>。 如果你使用的一个面向连接的协议，则必须使用<xref:System.Net.Sockets.Socket.Connect%2A>建立远程主机的连接，或者使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受传入连接。  
  
 如果你使用的一种面向连接的协议，<xref:System.Net.Sockets.Socket.SendFile%2A>一直阻塞，直到发送整个文件。 在锁定模式下，<xref:System.Net.Sockets.Socket.SendFile%2A>已发送的整个文件之前，可能会成功完成。 就你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.SendFile%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例创建并连接套接字。 文件"test.txt"位于本地计算机的根目录中。 在此示例中，我们将创建缓冲区和数据后，并使用该文件将它们发送到远程主机。 默认值<xref:System.Net.Sockets.TransmitFileOptions>使用。  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">操作系统不是 Windows NT 或更高版本。  \- 或 -  套接字未连接到远程主机。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象未处于阻止模式，无法接受此同步调用。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>将文件集合或者内存中的数据缓冲区以异步方法发送给连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法用于将集合中的文件或在内存中发送到远程主机的数据缓冲区。 <xref:System.Net.Sockets.Socket>必须已连接到远程主机。  
  
 如果<xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType>的工作目录中的文件的引用，那么可能只是文件的名称以进行标识; 否则，必须指定完整路径和文件的名称。 支持通配符和 UNC 共享名。 如果未找到该文件，<xref:System.IO.FileNotFoundException>引发。  
  
 若要在完成时得到通知，必须创建实现的回调方法\<SocketAsyncEventArgs > 委托和附加到回调<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>属性`e`参数提供关于文件传输的其他信息的窗口套接字服务提供程序。 有关如何使用此参数的详细信息，请参阅<xref:System.Net.Sockets.TransmitFileOptions>。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>对象所需成功调用此方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可能设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>到在调用前要求任何用户状态对象的属性<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法，以便在回叫方法可检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。  
  
 此方法使用在 Windows 套接字 2 API 中找到 TransmitPackets 函数。 有关 TransmitPackets 函数和其标志的详细信息，请参阅 MSDN 库中的 Windows 套接字文档。  
  
 适用于面向连接的协议，尽管<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法也适用于无连接协议，前提是你第一次调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法来建立默认远程主机。 使用无连接协议，你还必须确保你的文件的大小不能超过基础服务提供程序的最大的数据包大小。 如果是这样，不会发送数据报和<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>引发<xref:System.Net.Sockets.SocketException>异常。  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法进行了优化根据在其中使用的操作系统。 在 Windows server 版本上<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>获得高性能优化方法。  
  
 Windows 客户端版本，<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法进行了优化以最小内存和资源利用率。  
  
 利用<xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType>中标记出来<xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>属性`e`参数可以提供显著的性能优势。 如果线程启动<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法调用用于繁重的计算，但可以，虽然不，Apc 可能无法启动。 请注意，内核和用户模式 Apc 之间存在的差异。 在线程处于等待状态时，将启动内核 Apc。 用户模式 Apc 在线程处于可报警等待状态时启动  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">未找到在 <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> 属性中指定的文件。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。 如果 <see cref="T:System.Net.Sockets.Socket" /> 未连接到远程主机，也会发生此异常。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">使用的是无连接 <see cref="T:System.Net.Sockets.Socket" />，并且所发送的文件超过了基础传输的最大数据包大小。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定之后同步 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 调用将超时的时间长度。</summary>
        <value>超时值（以毫秒为单位）。 如果将该属性设置为 1 到 499 之间的值，该值将被更改为 500。 默认值为 0，指示超时期限无限大。 指定 -1 还会指示超时期限无限大。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此选项适用于同步<xref:System.Net.Sockets.Socket.Send%2A>仅调用。 如果超出超时期限，<xref:System.Net.Sockets.Socket.Send%2A>方法会引发<xref:System.Net.Sockets.SocketException>。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.SendTimeout%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于 1。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据发送到特定终结点。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>将数据发送到指定的终结点。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此重载中，缓冲区偏移量的默认值为 0，要将默认值发送到的大小的字节数`buffer`参数，与<xref:System.Net.Sockets.SocketFlags>值默认为 0。  
  
 如果你使用的是无连接协议，不需要建立默认远程主机使用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>。 只需执行此操作，如果你想要调用<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`只为发送操作，参数将覆盖指定的默认远程主机。 你还无需调用<xref:System.Net.Sockets.Socket.Bind%2A>方法，因为基础服务提供程序将分配的最合适的本地网络地址和端口号。 如果你需要确定分配的本地网络地址和端口号，则可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性后的<xref:System.Net.Sockets.Socket.SendTo%2A>方法已成功完成。  
  
 虽然供无连接协议，但是<xref:System.Net.Sockets.Socket.SendTo%2A>也适用于面向连接的协议。 如果使用的一个面向连接的协议，你首先必须通过调用来建立远程主机连接<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受传入的连接请求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果未建立或不接受远程主机的连接，<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。 你还可以建立默认远程主机之前调用无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.SendTo%2A>将忽略`remoteEP`参数并仅将数据发送到已连接或默认远程主机。  
  
 阻止套接字将发送的字节缓冲区中的所有一直阻止。 由于非阻止<xref:System.Net.Sockets.Socket>完成立即，它可能不发送的字节数的所有`buffer`。 它是你的应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送的字节数的所有`buffer`。 此外，还有你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.SendTo%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
 如果在阻止模式下，将无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>将阻止，直到发送数据报。 如果你想要将数据发送到广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法并设置套接字选项设为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 你还必须是确保发送的字节数不超过基础服务提供程序的最大的数据包大小。 如果是这样，将不发送数据报和<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例将无连接的数据报发送到指定的远程主机。  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，将数据发送到特定的终结点。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此重载中，缓冲区偏移量的默认值为 0，并要将默认值发送到的大小的字节数`buffer`。 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，发送的无法路由的数据。  
  
 如果你使用的是无连接协议，不需要建立默认远程主机使用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>。 只需执行此操作，如果你想要调用<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`只为发送操作，参数将覆盖指定的默认远程主机。 你还无需调用<xref:System.Net.Sockets.Socket.Bind%2A>方法，因为基础服务提供程序将分配的最合适的本地网络地址和端口号。 如果你需要确定分配的本地网络地址和端口号，则可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性后的<xref:System.Net.Sockets.Socket.SendTo%2A>方法已成功完成。  
  
 虽然供无连接协议，但是<xref:System.Net.Sockets.Socket.SendTo%2A>也适用于面向连接的协议。 如果使用的一个面向连接的协议，你首先必须通过调用来建立远程主机连接<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受传入的连接请求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果未建立或不接受远程主机的连接，<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。 你还可以建立默认远程主机之前调用无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.SendTo%2A>将忽略`remoteEP`参数并仅将数据发送到已连接或默认远程主机。  
  
 阻止套接字将一直阻止请求中的字节的所有`buffer`发送。 由于非阻止<xref:System.Net.Sockets.Socket>完成立即，它可能不发送的字节数的所有`buffer`。 它是你的应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送的字节数的所有`buffer`。 此外，还有你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.SendTo%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
 如果在阻止模式下，将无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>将阻止，直到发送数据报。 如果你想要将数据发送到广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法并设置套接字选项设为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 你还必须是确保发送的字节数不超过基础服务提供程序的最大的数据包大小。 如果是这样，将不发送数据报和<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例将无连接的数据报发送到指定的远程主机。 <xref:System.Net.Sockets.SocketFlags> 传递给<xref:System.Net.Sockets.Socket.SendTo%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，将指定字节数的数据发送到指定的终结点。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此重载中，缓冲区偏移量的默认值为 0。 如果指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，发送的无法路由的数据。  
  
 如果你使用的是无连接协议，不需要建立默认远程主机使用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>。 只需执行此操作，如果你想要调用<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`只为发送操作，参数将覆盖指定的默认远程主机。 你还无需调用<xref:System.Net.Sockets.Socket.Bind%2A>方法，因为基础服务提供程序将分配的最合适的本地网络地址和端口号。 如果你需要确定分配的本地网络地址和端口号，则可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性后的<xref:System.Net.Sockets.Socket.SendTo%2A>方法已成功完成。  
  
 虽然供无连接协议，但是<xref:System.Net.Sockets.Socket.SendTo%2A>也适用于面向连接的协议。 如果使用的一个面向连接的协议，你首先必须通过调用来建立远程主机连接<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受传入的连接请求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果未建立或不接受远程主机的连接，<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。 你还可以建立默认远程主机之前调用无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.SendTo%2A>将忽略`remoteEP`参数并仅将数据发送到已连接或默认远程主机。  
  
 阻止套接字将阻止，直到发送请求的字节数。 由于非阻止<xref:System.Net.Sockets.Socket>完成立即，它可能未发送的所有单个操作中请求的字节数。 它是你的应用程序负责跟踪发送的字节数并重试操作，直到应用程序发送请求的字节数。 此外，还有你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.SendTo%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
 如果在阻止模式下，将无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>将阻止，直到发送数据报。 如果你想要将数据发送到广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法并设置套接字选项设为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 你还必须是确保发送的字节数不超过基础服务提供程序的最大的数据包大小。 如果是这样，将不发送数据报和<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例将无连接的数据报发送到指定的远程主机。 大小和<xref:System.Net.Sockets.SocketFlags>传递给<xref:System.Net.Sockets.Socket.SendTo%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的 <paramref name="size" /> 超出 <paramref name="buffer" /> 的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</param>
        <param name="offset">开始发送数据的缓冲区中的位置。</param>
        <param name="size">要发送的字节数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，将指定字节数的数据发送到指定终结点（从缓冲区中的指定位置开始）。</summary>
        <returns>已发送的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在此重载中，如果你指定<xref:System.Net.Sockets.SocketFlags.DontRoute>标记为`socketflags`参数，发送的无法路由的数据。  
  
 如果你使用的是无连接协议，不需要建立默认远程主机使用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>。 只需执行此操作，如果你想要调用<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果调用<xref:System.Net.Sockets.Socket.Connect%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`只为发送操作，参数将覆盖指定的默认远程主机。 你还无需调用<xref:System.Net.Sockets.Socket.Bind%2A>方法，因为基础服务提供程序将分配的最合适的本地网络地址和端口号。 如果你需要确定分配的本地网络地址和端口号，则可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性后的<xref:System.Net.Sockets.Socket.SendTo%2A>方法已成功完成。  
  
 虽然供无连接协议，但是<xref:System.Net.Sockets.Socket.SendTo%2A>也适用于面向连接的协议。 如果使用的一个面向连接的协议，你首先必须通过调用来建立远程主机连接<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受传入的连接请求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果未建立或不接受远程主机的连接，<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。 你还可以建立默认远程主机之前调用无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在这些情况下，任一<xref:System.Net.Sockets.Socket.SendTo%2A>将忽略`remoteEP`参数并仅将数据发送到已连接或默认远程主机。  
  
 阻止套接字将阻止，直到发送请求的字节数。 由于非阻塞<xref:System.Net.Sockets.Socket>完成立即，它可能未发送的所有单个操作中请求的字节数。 它是你应用程序负责跟踪发送的字节数并重试该操作，直到应用程序发送请求的字节数。 此外，还有你发送的数据将立即显示在网络不能保证。 若要增加网络效率，基础系统可能会延迟传输，直到收集了大量传出数据。 成功完成后<xref:System.Net.Sockets.Socket.SendTo%2A>方法意味着基础系统有空间来你的数据的网络发送的缓冲区。  
  
 如果在阻止模式下，将无连接协议<xref:System.Net.Sockets.Socket.SendTo%2A>将阻止，直到发送数据报。 如果你想要将数据发送到广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法并设置套接字选项设为<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 你还必须确保大小不超过基础服务提供程序的最大的数据包大小。 如果是这样，将不发送数据报和<xref:System.Net.Sockets.Socket.SendTo%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例将无连接的数据报发送到指定的远程主机。 偏移量、 大小和<xref:System.Net.Sockets.SocketFlags>传递给<xref:System.Net.Sockets.Socket.SendTo%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。  - 或 -  <paramref name="remoteEP" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小于 0。  - 或 -  <paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。  - 或 -  <paramref name="size" /> 小于 0。  - 或 -  <paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值组合。  - 或 -  访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用堆栈中的调用方没有所需的权限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</param>
        <summary>以异步方式将数据发送到特定远程主机。</summary>
        <returns>如果 I/O 操作挂起，将返回 <see langword="true" />。 操作完成时，将引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 操作同步完成，将返回 <see langword="false" />。 在这种情况下，将不会引发 <paramref name="e" /> 参数的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendToAsync%2A>方法会启动异步发送操作中指定远程主机<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>属性`e`参数。 调用<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法使你能够发送单独的执行线程中的数据。 尽管此方法适用于无连接协议，<xref:System.Net.Sockets.Socket.SendToAsync%2A>适用于无连接和面向连接的协议。  
  
 若要在完成时得到通知，必须创建实现的回调方法\<SocketAsyncEventArgs > 委托和附加到回调<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 下列属性和事件上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>对象所需成功调用此方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 调用方可能设置<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>到在调用前要求任何用户状态对象的属性<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法，以便在回叫方法可检索信息。 如果回调需要比单个对象的详细信息，可以创建一个小型类来保存作为成员的其他所需的状态信息。  
  
 如果你使用的一个面向连接的协议，必须先调用<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法。 否则为<xref:System.Net.Sockets.Socket.SendToAsync%2A>将引发<xref:System.Net.Sockets.SocketException>。 当使用面向连接的协议，<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法将忽略<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>属性并将数据发送到<xref:System.Net.EndPoint?displayProperty=nameWithType>中建立<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法。  
  
 如果你使用的是无连接协议，不需要建立默认远程主机使用<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendToAsync%2A>。 只需执行此操作，如果你想要调用<xref:System.Net.Sockets.Socket.BeginSend%2A>或<xref:System.Net.Sockets.Socket.SendAsync%2A>方法。 如果调用<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法之前调用<xref:System.Net.Sockets.Socket.SendToAsync%2A>、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>属性只为发送操作将覆盖指定的默认远程主机。 你还无需调用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 在这种情况下，基础服务提供程序将分配的最合适的本地网络 IP 地址和端口号。 如果你想要选择可用端口的基础服务提供程序，请使用端口号 0。 如果你需要确定分配的本地网络 IP 地址和端口号，则可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>属性后的<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>发出信号事件和调用关联的委托。  
  
 如果你想要将数据发送到广播地址，则必须首先调用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法并设置套接字选项<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>为 true。 你还必须是缓冲区的确保你的大小不超过基础服务提供程序的最大的数据包大小。 如果是这样，将不发送数据报和<xref:System.Net.Sockets.Socket.SendToAsync%2A>将引发<xref:System.Net.Sockets.SocketException>。  
  
 如果指定中的 DontRoute 标志<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>属性、 发送的无法路由的数据。  
  
 对于面向消息的套接字，必须格外小心不能超过基础传输的最大消息大小。 如果缓冲区的大小超过基础服务提供程序的最大的数据包大小，不会发送数据报和<xref:System.Net.Sockets.Socket.SendToAsync%2A>将引发<xref:System.Net.Sockets.SocketException>。 成功完成<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法并不表示已成功传递数据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为 null。</exception>
        <exception cref="T:System.InvalidOperationException">已经在使用 <paramref name="e" /> 参数中指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象执行套接字操作。</exception>
        <exception cref="T:System.NotSupportedException">此方法需要 Windows XP 或更高版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">指定的协议是面向连接的，但 <see cref="T:System.Net.Sockets.Socket" /> 尚未连接。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">要为此套接字设置的 IP 保护级别。</param>
        <summary>设置套接字的 IP 保护级别。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>方法使限制 IPv6 或 IP 套接字以侦听指定的作用域，如具有相同的地址的链接本地或站点本地前缀。 此套接字选项使应用程序可以限制对 IPv6 或 IP 套接字的访问。 通过应用此类限制，可让在专用局域网上运行的应用程序能够通过简单的方式很好地增强自身的安全性，以便防范外部攻击。 此套接字选项还可以用于删除访问权限限制，如果`level`参数设置为<xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>。 此套接字选项可以扩大或缩小侦听套接字的范围，从而使得公共用户和私人用户可以在适当情况下对站点进行无限制的访问，或者可以根据需要对同一站点进行有限制的访问。  
  
 此套接字选项具有 <xref:System.Net.Sockets.IPProtectionLevel> 枚举中指定的已定义保护级别。  
  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>方法用于启用或禁用网络地址遍历 (NAT) 为<xref:System.Net.Sockets.Socket>实例。 可能使用 Teredo、 6to4 或 ISATAP 隧道提供 NAT 遍历。  
  
 当`level`参数设置为<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>，或<xref:System.Net.Sockets.IPProtectionLevel.Restricted>，这会显式禁用 NAT 遍历<xref:System.Net.Sockets.Socket>实例。  
  
 当`level`参数设置为<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>，这可能使 NAT 遍历<xref:System.Net.Sockets.Socket>具体取决于系统上实施防火墙规则。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="level" /> 参数不能为 <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />。 IP 保护级别不能设置为未指定。</exception>
        <exception cref="T:System.NotSupportedException">套接字的 <see cref="T:System.Net.Sockets.AddressFamily" /> 必须为 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />。</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置 <see cref="T:System.Net.Sockets.Socket" /> 选项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">选项的值，表示为 <see cref="T:System.Boolean" />。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定的 <see cref="T:System.Boolean" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项将确定当前行为<xref:System.Net.Sockets.Socket>。 设置`optionValue`到`true`以启用该选项，或`false`以禁用该选项。  
  
 <xref:System.Net.Sockets.Socket> 选项级别协议支持的分组。  
  
 下面列出了各种<xref:System.Net.Sockets.Socket>可以使用此重载设置的选项。 这些选项按相应分组<xref:System.Net.Sockets.SocketOptionLevel>值。 如果你想要设置下列任一选项，请确保使用适当<xref:System.Net.Sockets.SocketOptionLevel>值`optionLevel`参数。 必须指定你选择设置选项`optionName`参数。 如果你想要获取任何所列的选项的当前值，请使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 可以使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 可以使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 可以使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 可以使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 有关这些选项的详细信息，请参阅<xref:System.Net.Sockets.SocketOptionName>枚举。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>异常，请改用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例打开一个套接字并启用`DontLinger`和`OutOfBandInline`套接字选项。  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">
          <see cref="T:System.Byte" /> 类型的数组，表示选项值。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定的值，表示为字节数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项将确定当前行为<xref:System.Net.Sockets.Socket>。 使用此重载来设置那些<xref:System.Net.Sockets.Socket>需要作为一个选项值的字节数组的选项。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>超时值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">该选项的值。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定的整数值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项将确定当前行为<xref:System.Net.Sockets.Socket>。 针对选项<xref:System.Boolean>数据类型，指定要启用该选项，则为非 0 值和零值以禁用该选项。 对于具有整数数据类型选项，指定适当的值。 <xref:System.Net.Sockets.Socket> 选项级别协议支持的分组。  
  
 下面列出了各种<xref:System.Net.Sockets.Socket>可以使用此重载设置的选项。 这些选项按相应分组<xref:System.Net.Sockets.SocketOptionLevel>。 如果你想要设置下列任一选项，请确保使用适当<xref:System.Net.Sockets.SocketOptionLevel>为`optionLevel`参数。 必须指定你选择设置选项`optionName`参数。 如果你想要获取任何所列的选项的当前值，请使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 可以使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 可以使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 可以使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 可以使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> 可以使用此重载设置的选项。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 有关这些选项的详细信息，请参阅<xref:System.Net.Sockets.SocketOptionName>枚举。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>超时值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</param>
        <param name="optionValue">一个 <see cref="T:System.Net.Sockets.LingerOption" /> 或 <see cref="T:System.Net.Sockets.MulticastOption" />，它包含该选项的值。</param>
        <summary>将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定值，表示为对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 选项将确定当前行为<xref:System.Net.Sockets.Socket>。 此重载用于设置<xref:System.Net.Sockets.SocketOptionName.Linger>， <xref:System.Net.Sockets.SocketOptionName.AddMembership>，和<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>选项。 有关<xref:System.Net.Sockets.SocketOptionName.Linger>选项，请使用<xref:System.Net.Sockets.Socket>为`optionLevel`参数。 有关<xref:System.Net.Sockets.SocketOptionName.AddMembership>和<xref:System.Net.Sockets.SocketOptionName.DropMembership>，使用<xref:System.Net.Sockets.SocketOptionLevel.IP>。 如果你想要获取任何上面列出的选项的当前值，请使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>超时值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="optionValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">
          <see cref="T:System.Net.Sockets.SocketShutdown" /> 值之一，它指定不再允许执行的操作。</param>
        <summary>禁用某 <see cref="T:System.Net.Sockets.Socket" /> 上的发送和接收。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当使用面向连接的<xref:System.Net.Sockets.Socket>，始终调用<xref:System.Net.Sockets.Socket.Shutdown%2A>方法在关闭前的<xref:System.Net.Sockets.Socket>。 这可确保发送和关闭之前连接的套接字上接收到的所有数据。  
  
 调用<xref:System.Net.Sockets.Socket.Close%2A>方法释放所有托管和非托管资源与关联<xref:System.Net.Sockets.Socket>。 请不要尝试重用<xref:System.Net.Sockets.Socket>后结束。  
  
 下表显示<xref:System.Net.Sockets.SocketShutdown>对有效的枚举值`how`参数。  
  
|“值”|描述|  
|-----------|-----------------|  
|发送|禁用对此发送<xref:System.Net.Sockets.Socket>。|  
|接收|禁用对此接收<xref:System.Net.Sockets.Socket>。|  
|消息和传送|禁用同时发送和接收此<xref:System.Net.Sockets.Socket>。|  
  
 设置`how`到<xref:System.Net.Sockets.SocketShutdown.Send>指定，后续调用<xref:System.Net.Sockets.Socket.Send%2A>不允许。 如果你使用的是无连接<xref:System.Net.Sockets.Socket>，并指定<xref:System.Net.Sockets.SocketShutdown.Send>将产生任何影响。  
  
 设置`how`到<xref:System.Net.Sockets.SocketShutdown.Receive>指定，后续调用<xref:System.Net.Sockets.Socket.Receive%2A>不允许。 这在较低的协议层上无效。 如果你使用的一个面向连接的协议，如果以下条件之一存在后调用，则连接将终止<xref:System.Net.Sockets.Socket.Shutdown%2A>:  
  
-   数据是等待接收传入的网络缓冲区中。  
  
-   更多的数据已到达。  
  
 如果你使用的是无连接协议，接受并排队数据报。 但是，如果没有缓冲区空间可用于其他传入数据报，它们将被放弃，并且将向发件人返回任何错误。 使用<xref:System.Net.Sockets.Socket.Shutdown%2A>上是无连接<xref:System.Net.Sockets.Socket>不建议。  
  
 设置`how`到<xref:System.Net.Sockets.SocketShutdown.Both>同时禁用发送和接收上文所述。  
  
> [!NOTE]
>  如果你收到<xref:System.Net.Sockets.SocketException>调用时<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，请使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.Sockets.Socket.Shutdown%2A>禁用<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Net.Sockets.Socket" /> 的类型。</summary>
        <value>
          <see cref="T:System.Net.Sockets.SocketType" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> 是只读的和设置时<xref:System.Net.Sockets.Socket>创建。  
  
   
  
## Examples  
 下面的代码示例显示<xref:System.Net.Sockets.AddressFamily>， <xref:System.Net.Sockets.SocketType>，和<xref:System.Net.Sockets.ProtocolType>到控制台。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在当前主机上 IPv4 支持是否可用并且已启用。</summary>
        <value>如果当前主机支持 IPv4 协议，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 Framework 对某些已过时的 <see cref="T:System.Net.Dns" /> 成员是否支持 IPv6。</summary>
        <value>如果 Framework 对某些已过时的 <see cref="T:System.Net.Dns" /> 方法支持 IPv6，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作系统可能支持 IPv4 和 IPv6 协议。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，指定 <see cref="T:System.Net.Sockets.Socket" /> 发送的 Internet 协议 (IP) 数据包的生存时间 (TTL) 值。</summary>
        <value>TTL 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TTL 值指示的路由器数据包可以遍历路由器放弃数据包和 Internet 控制消息协议 (ICMP)"TTL 超出"之前的最大数目的错误消息返回到发件人。  
  
 从 0 到 255，TTL 值可能设置为一个值。 如果未设置此属性，套接字的默认 TTL 值为 32。  
  
 传输控制协议 (TCP) 套接字上设置此属性被忽略由 TCP/IP 堆栈中，如果具有使用套接字已建立成功连接。  
  
 如果你收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>属性来获取特定的错误代码。 获取此代码后，请参阅 Windows 套接字版本 2 API 错误代码文档 MSDN 库中的有关错误的详细说明。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Net.Sockets.Socket.Ttl%2A>属性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">TTL 值不能设置为负数。</exception>
        <exception cref="T:System.NotSupportedException">只有对于在 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 族中的套接字，才可以设置此属性。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尝试访问套接字时出错。 在尝试将 TTL 设置为大于 255 的值时，也将返回此错误。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定套接字是否应仅使用重叠 I/O 模式。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 仅使用重叠 I/O，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此属性设置为`true`为<xref:System.Net.Sockets.Socket>你想要调用<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>。 否则，框架可以将完成端口分配给套接字，它将禁止使用<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">套接字已绑定到完成端口。</exception>
      </Docs>
    </Member>
  </Members>
</Type>