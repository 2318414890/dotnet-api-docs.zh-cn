<Type Name="ArrayList" FullName="System.Collections.ArrayList">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9a105732aa94698f5ea781b6eed29feca20656b5" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30370921" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ArrayList : ICloneable, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ArrayList extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ArrayList" />
  <TypeSignature Language="VB.NET" Value="Public Class ArrayList&#xA;Implements ICloneable, IList" />
  <TypeSignature Language="C++ CLI" Value="public ref class ArrayList : ICloneable, System::Collections::IList" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.ArrayList/ArrayListDebugView))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>使用大小会根据需要动态增加的数组来实现 <see cref="T:System.Collections.IList" /> 接口。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>类旨在保存异类对象的集合。 但是，它不始终提供最佳性能。 相反，我们的建议如下：  
  
-   对于异类对象的集合，使用`List<Object>`（在 C# 中) 或`List(Of Object)`（在 Visual Basic 中) 中，键入。  
  
-   对于同类对象的集合，使用<xref:System.Collections.Generic.List%601>类。  
  
 请参阅中的"性能注意事项"部分<xref:System.Collections.Generic.List%601>这些类的相对性能的讨论的参考主题。  
  
 <xref:System.Collections.ArrayList>不一定进行排序。  您必须对进行排序<xref:System.Collections.ArrayList>通过调用其<xref:System.Collections.ArrayList.Sort%2A>在执行操作之前的方法 (如<xref:System.Collections.ArrayList.BinarySearch%2A>) 需要<xref:System.Collections.ArrayList>来进行排序。 若要维护添加新元素时会自动进行排序的集合，可以使用<xref:System.Collections.Generic.SortedSet%601>类。  
  
 容量<xref:System.Collections.ArrayList>是元素的数目<xref:System.Collections.ArrayList>可以保存。 如元素添加到<xref:System.Collections.ArrayList>，自动增加容量通过重新分配所需的方式。 可以通过调用减少容量<xref:System.Collections.ArrayList.TrimToSize%2A>或通过设置<xref:System.Collections.ArrayList.Capacity%2A>属性显式。  
  
 对于非常大<xref:System.Collections.ArrayList>对象，你可以通过设置增加到 20 亿元素在 64 位系统上的最大容量`enabled`到的配置元素的属性`true`在运行时环境中。  
  
 可以使用整数索引访问此集合中的元素。  在此集合中的索引是从零开始。  
  
 <xref:System.Collections.ArrayList>集合接受`null`作为有效的值。 它还允许重名的元素。  
  
 使用多维数组中的元素作为<xref:System.Collections.ArrayList>不支持的集合。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化<xref:System.Collections.ArrayList>以及如何显示其值。  
  
 [!code-cpp[Classic ArrayList Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>公共静态 (<see langword="Shared" />在 Visual Basic 中) 的此类型的成员都是线程安全。 但不保证所有实例成员都是线程安全的。  
  
 <see cref="T:System.Collections.ArrayList" />同时，可以支持多个读取器，只要不修改该集合。 若要确保的线程安全性<see cref="T:System.Collections.ArrayList" />，所有操作必须通过返回的包装器来都完成<see cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />方法。  
  
 枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Generic.List`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Collections.ArrayList" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ArrayList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArrayList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Collections.ArrayList" /> 类的新实例，该实例为空并且具有默认初始容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 容量<xref:System.Collections.ArrayList>是元素的数目，<xref:System.Collections.ArrayList>可以保存。 如元素添加到<xref:System.Collections.ArrayList>，自动增加容量通过重新分配在内部数组所需的方式。  
  
 如果可以估计集合的大小，指定的初始容量，则无需执行大量的大小将元素添加到时调整操作<xref:System.Collections.ArrayList>。  
  
 此构造函数是 o （1） 操作。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ArrayList (System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArrayList(System::Collections::ICollection ^ c);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="c">其元素已复制到新列表的 <see cref="T:System.Collections.ICollection" />。</param>
        <summary>初始化 <see cref="T:System.Collections.ArrayList" /> 类的新实例，该类包含从指定集合复制的元素，并具有与复制的元素数相同的初始容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 容量<xref:System.Collections.ArrayList>是元素的数目，<xref:System.Collections.ArrayList>可以保存。 如元素添加到<xref:System.Collections.ArrayList>，自动增加容量通过重新分配在内部数组所需的方式。  
  
 如果可以估计集合的大小，指定的初始容量，则无需执行大量的大小将元素添加到时调整操作<xref:System.Collections.ArrayList>。  
  
 将元素复制到<xref:System.Collections.ArrayList>以相同的顺序由读取<xref:System.Collections.IEnumerator>的<xref:System.Collections.ICollection>。  
  
 此构造函数是 O (`n`) 操作，其中`n`是中的元素数`c`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ArrayList (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ArrayList(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">新列表最初可以存储的元素数。</param>
        <summary>初始化 <see cref="T:System.Collections.ArrayList" /> 类的新实例，该实例为空并且具有指定的初始容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 容量<xref:System.Collections.ArrayList>是元素的数目，<xref:System.Collections.ArrayList>可以保存。 如元素添加到<xref:System.Collections.ArrayList>，自动增加容量通过重新分配在内部数组所需的方式。  
  
 如果可以估计集合的大小，指定的初始容量，则无需执行大量的大小将元素添加到时调整操作<xref:System.Collections.ArrayList>。  
  
 此构造函数是 O (`n`) 操作，其中`n`是`capacity`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> 小于零。</exception>
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList Adapter (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList Adapter(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Adapter(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Adapter (list As IList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ Adapter(System::Collections::IList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">要包装的 <see cref="T:System.Collections.IList" />。</param>
        <summary>为特定 <see cref="T:System.Collections.IList" /> 创建 <see cref="T:System.Collections.ArrayList" /> 包装。</summary>
        <returns>
          <see cref="T:System.Collections.IList" /> 的 <see cref="T:System.Collections.ArrayList" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Adapter%2A> 不会复制的内容<xref:System.Collections.IList>。 相反，而只会创建<xref:System.Collections.ArrayList>周围包装<xref:System.Collections.IList>; 因此，更改为<xref:System.Collections.IList>也会影响<xref:System.Collections.ArrayList>。  
  
 <xref:System.Collections.ArrayList>类提供了泛型<xref:System.Collections.ArrayList.Reverse%2A>，<xref:System.Collections.ArrayList.BinarySearch%2A>和<xref:System.Collections.ArrayList.Sort%2A>方法。 此包装可以是一种方法上使用的那些方法<xref:System.Collections.IList>; 但是，执行通过包装这些泛型操作可能比直接在上应用的操作的效率较低<xref:System.Collections.IList>。  
  
 此方法为 o （1） 运算。  
  
## <a name="version-compatibility"></a>版本兼容性  
 .NET framework 版本 1.0 和 1.1 中，调用<xref:System.Collections.ArrayList.GetEnumerator%28System.Int32%2CSystem.Int32%29>上的方法重载<xref:System.Collections.ArrayList>包装返回的枚举数上限，而不是计数处理第二个参数。 在[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]第二个参数正确视为计数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
        <altmember cref="M:System.Collections.ArrayList.Reverse" />
        <altmember cref="M:System.Collections.ArrayList.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual int Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Add(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要添加到 <see cref="T:System.Object" /> 的结尾处的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <summary>将对象添加到 <see cref="T:System.Collections.ArrayList" /> 的结尾处。</summary>
        <returns>
          <see cref="T:System.Collections.ArrayList" /> 索引，已在此处添加了 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> 接受`null`作为有效的值，并允许重复的元素。  
  
 如果<xref:System.Collections.ArrayList.Count%2A>已经等于<xref:System.Collections.ArrayList.Capacity%2A>、 容量的<xref:System.Collections.ArrayList>增加通过自动重新分配在内部数组和现有元素被复制到新数组中，在添加新的元素之前。  
  
 如果<xref:System.Collections.ArrayList.Count%2A>是小于<xref:System.Collections.ArrayList.Capacity%2A>，此方法为 o （1） 运算。 如果容量需要增加以容纳新元素，此方法会成为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何将元素添加到<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.ArrayList" /> 为只读。  
  
 或  
  
 <see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public virtual void AddRange (System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddRange(class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddRange (c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddRange(System::Collections::ICollection ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="c">
          <see cref="T:System.Collections.ICollection" />，其元素应被添加到 <see cref="T:System.Collections.ArrayList" /> 的末尾。 集合本身不能为 <see langword="null" />，但它可以包含为 <see langword="null" /> 的元素。</param>
        <summary>将 <see cref="T:System.Collections.ICollection" /> 的元素添加到 <see cref="T:System.Collections.ArrayList" /> 的末尾。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> 接受`null`作为有效的值，并允许重复的元素。  
  
 中的元素的顺序<xref:System.Collections.ICollection>在过程中保留<xref:System.Collections.ArrayList>。  
  
 如果新<xref:System.Collections.ArrayList.Count%2A>(当前<xref:System.Collections.ArrayList.Count%2A>plus 集合的大小) 将大于<xref:System.Collections.ArrayList.Capacity%2A>、 容量的<xref:System.Collections.ArrayList>增加通过自动重新分配以容纳新元素，在内部数组和在添加新的元素之前，现有元素被复制到新数组。  
  
 如果<xref:System.Collections.ArrayList>可以容纳新元素，而无需增加<xref:System.Collections.ArrayList.Capacity%2A>，此方法为 O (`n`) 操作，其中`n`是要添加的元素数。 如果增加以容纳新元素所需的容量，此方法会成为 O (`n` + `m`) 操作，其中`n`是要添加的元素的数目和`m`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何将元素添加到<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.ArrayList" /> 为只读。  
  
 或  
  
 <see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用对分检索算法在已排序的 <see cref="T:System.Collections.ArrayList" /> 或它的一部分中查找特定元素。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public virtual int BinarySearch (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BinarySearch(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.BinarySearch(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BinarySearch (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int BinarySearch(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 <see cref="T:System.Object" />。 该值可以为 <see langword="null" />。</param>
        <summary>使用默认的比较器在整个已排序的 <see cref="T:System.Collections.ArrayList" /> 中搜索元素，并返回该元素从零开始的索引。</summary>
        <returns>如果找到 <paramref name="value" />，则为排序的 <see cref="T:System.Collections.ArrayList" /> 中从零开始的 <paramref name="value" /> 索引；否则为一个负数，它是大于 <paramref name="value" /> 的下一个元素索引的按位求补，或者，如果没有更大的元素，则为 <see cref="P:System.Collections.ArrayList.Count" /> 的按位求补。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`参数和的每个元素<xref:System.Collections.ArrayList>必须实现<xref:System.IComparable>接口，用于比较。 元素<xref:System.Collections.ArrayList>必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。  
  
 比较`null`允许与任何类型和使用时不会生成异常<xref:System.IComparable>。 在排序时，`null`被视为小于任何其他对象。  
  
 如果<xref:System.Collections.ArrayList>多个元素具有相同的值，该方法返回仅包含一个匹配项，并且可能会返回任何一个匹配项，不一定是第一个。  
  
 如果<xref:System.Collections.ArrayList>不包含指定的值，该方法返回负整数。 你可以应用于此负的整数，以获取大于搜索值的第一个元素的索引的按位求补运算 （~）。 插入到的值时<xref:System.Collections.ArrayList>，此索引应使用的插入点，若要维护的排序顺序。  
  
 此方法为 O (日志`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Collections.ArrayList.BinarySearch%2A>查找中的特定对象<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.BinarySearch1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.BinarySearch1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.BinarySearch1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> 和 <see cref="T:System.Collections.ArrayList" /> 的元素均未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> 和 <see cref="T:System.Collections.ArrayList" /> 的元素不是同一类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public virtual int BinarySearch (object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BinarySearch(object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.BinarySearch(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BinarySearch (value As Object, comparer As IComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int BinarySearch(System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="value">要查找的 <see cref="T:System.Object" />。 该值可以为 <see langword="null" />。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
 或  
  
 如果为 <see langword="null" />，则使用默认比较器，即每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定的比较器在整个已排序的 <see cref="T:System.Collections.ArrayList" /> 中搜索元素，并返回该元素从零开始的索引。</summary>
        <returns>如果找到 <paramref name="value" />，则为排序的 <see cref="T:System.Collections.ArrayList" /> 中从零开始的 <paramref name="value" /> 索引；否则为一个负数，它是大于 <paramref name="value" /> 的下一个元素索引的按位求补，或者，如果没有更大的元素，则为 <see cref="P:System.Collections.ArrayList.Count" /> 的按位求补。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比较器自定义如何比较元素。 例如，你可以使用<xref:System.Collections.CaseInsensitiveComparer>实例作为要执行不区分大小写的字符串搜索的比较器。  
  
 如果`comparer`提供的元素<xref:System.Collections.ArrayList>与使用指定的指定值进行比较<xref:System.Collections.IComparer>实现。 元素<xref:System.Collections.ArrayList>必须已在增加根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。  
  
 如果`comparer`是`null`，完成比较使用<xref:System.IComparable>通过自身的元素或指定的值提供的实现。 元素<xref:System.Collections.ArrayList>必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。  
  
 比较`null`允许与任何类型和使用时不会生成异常<xref:System.IComparable>。 在排序时，`null`被视为小于任何其他对象。  
  
 如果<xref:System.Collections.ArrayList>多个元素具有相同的值，该方法返回仅包含一个匹配项，并且可能会返回任何一个匹配项，不一定是第一个。  
  
 如果<xref:System.Collections.ArrayList>不包含指定的值，该方法返回负整数。 你可以应用于此负的整数，以获取大于搜索值的第一个元素的索引的按位求补运算 （~）。 插入到的值时<xref:System.Collections.ArrayList>，此索引应使用的插入点，若要维护的排序顺序。  
  
 此方法为 O (日志`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Collections.ArrayList>彩色动画。 提供<xref:System.Collections.IComparer>执行二进制搜索的字符串比较。 显示一个迭代搜索和二进制搜索的结果。  
  
 [!code-cpp[Classic ArrayList.BinarySearch1 Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.BinarySearch1 Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.BinarySearch1 Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.BinarySearch1 Example/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 和 <see cref="T:System.Collections.ArrayList" /> 的元素均不实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 和 <see cref="T:System.Collections.ArrayList" /> 的元素不属于同一类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public virtual int BinarySearch (int index, int count, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BinarySearch(int32 index, int32 count, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BinarySearch (index As Integer, count As Integer, value As Object, comparer As IComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int BinarySearch(int index, int count, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="index">要搜索范围的从零开始的起始索引。</param>
        <param name="count">要搜索的范围的长度。</param>
        <param name="value">要查找的 <see cref="T:System.Object" />。 该值可以为 <see langword="null" />。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
 或  
  
 如果为 <see langword="null" />，则使用默认比较器，即每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定的比较器在已排序 <see cref="T:System.Collections.ArrayList" /> 的某个元素范围中搜索元素，并返回该元素从零开始的索引。</summary>
        <returns>如果找到 <paramref name="value" />，则为排序的 <see cref="T:System.Collections.ArrayList" /> 中从零开始的 <paramref name="value" /> 索引；否则为一个负数，它是大于 <paramref name="value" /> 的下一个元素索引的按位求补，或者，如果没有更大的元素，则为 <see cref="P:System.Collections.ArrayList.Count" /> 的按位求补。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 比较器自定义如何比较元素。 例如，你可以使用<xref:System.Collections.CaseInsensitiveComparer>实例作为要执行不区分大小写的字符串搜索的比较器。  
  
 如果`comparer`提供的元素<xref:System.Collections.ArrayList>与使用指定的指定值进行比较<xref:System.Collections.IComparer>实现。 元素<xref:System.Collections.ArrayList>必须已在增加根据定义的排序顺序的值进行排序`comparer`; 否则为结果可能不正确。  
  
 如果`comparer`是`null`，完成比较使用<xref:System.IComparable>通过自身的元素或指定的值提供的实现。 元素<xref:System.Collections.ArrayList>必须已在增加根据定义的排序顺序的值进行排序<xref:System.IComparable>实现; 否则，结果可能不正确。  
  
 比较`null`允许与任何类型和使用时不会生成异常<xref:System.IComparable>。 在排序时，`null`被视为小于任何其他对象。  
  
 如果<xref:System.Collections.ArrayList>多个元素具有相同的值，该方法返回仅包含一个匹配项，并且可能会返回任何一个匹配项，不一定是第一个。  
  
 如果<xref:System.Collections.ArrayList>不包含指定的值，该方法返回负整数。 你可以应用于此负的整数，以获取大于搜索值的第一个元素的索引的按位求补运算 （~）。 插入到的值时<xref:System.Collections.ArrayList>，此索引应使用的插入点，若要维护的排序顺序。  
  
 此方法为 O (日志`n`) 操作，其中`n`是`count`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.ArrayList" /> 中的有效范围。  
  
 或  
  
 <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 和 <see cref="T:System.Collections.ArrayList" /> 的元素均不实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 和 <see cref="T:System.Collections.ArrayList" /> 的元素不属于同一类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零。  
  
 或  
  
 <paramref name="count" /> 小于零。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Collections.ArrayList" /> 可包含的元素数。</summary>
        <value>
          <see cref="T:System.Collections.ArrayList" /> 可包含的元素数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Capacity%2A> 是的元素数的<xref:System.Collections.ArrayList>可以存储。 <xref:System.Collections.ArrayList.Count%2A> 是中的实际的元素数目<xref:System.Collections.ArrayList>。  
  
 <xref:System.Collections.ArrayList.Capacity%2A> 大于或等于始终是<xref:System.Collections.ArrayList.Count%2A>。 如果<xref:System.Collections.ArrayList.Count%2A>超过<xref:System.Collections.ArrayList.Capacity%2A>时添加元素，则自动通过增大容量在复制旧元素和添加新的元素之前重新分配在内部数组。  
  
 可以通过调用减少容量<xref:System.Collections.ArrayList.TrimToSize%2A>或通过设置<xref:System.Collections.ArrayList.Capacity%2A>属性显式。 时的值<xref:System.Collections.ArrayList.Capacity%2A>设置了显式，在内部数组还重新分配以适应指定的容量。  
  
 检索此属性的值的运算 o （1）;将属性设置为 O (`n`) 操作，其中`n`新容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Collections.ArrayList.Capacity" /> 已设置为一个小于 <see cref="P:System.Collections.ArrayList.Count" /> 的值。</exception>
        <exception cref="T:System.OutOfMemoryException">系统上没有足够的可用内存。</exception>
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从 <see cref="T:System.Collections.ArrayList" /> 中移除所有元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Count%2A> 是设置为零，并且集合的元素对其他对象的引用也被释放。  
  
 <xref:System.Collections.ArrayList.Capacity%2A> 保持不变。  若要重置的容量<xref:System.Collections.ArrayList>，调用<xref:System.Collections.ArrayList.TrimToSize%2A>或设置<xref:System.Collections.ArrayList.Capacity%2A>直接属性。 截去空<xref:System.Collections.ArrayList>的容量设置<xref:System.Collections.ArrayList>到默认的容量。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何修整的未使用的部分<xref:System.Collections.ArrayList>以及如何清除的值<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.ArrayList" /> 为只读。  
  
 或  
  
 <see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.TrimToSize" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建 <see cref="T:System.Collections.ArrayList" /> 的浅表副本。</summary>
        <returns>
          <see cref="T:System.Collections.ArrayList" /> 的浅表副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 集合的浅表副本复制仅的元素集合，不论它们是引用类型还是值类型，但它不会复制引用所引用的对象。 新集合中的引用都指向原始集合中的引用指向同一对象。  
  
 与此相反，集合的深层副本复制这些元素，以及由这些元素直接或间接引用的所有内容。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <summary>确定某元素是否在 <see cref="T:System.Collections.ArrayList" /> 中。</summary>
        <returns>
          如果在 <see langword="true" /> 中找到 <paramref name="item" />，则为 <see cref="T:System.Collections.ArrayList" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
 此方法通过调用可确定相等性<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Collections.ArrayList" /> 或它的一部分复制到一维数组。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.CopyTo(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.ArrayList" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <summary>从目标数组的开头开始，将整个 <see cref="T:System.Collections.ArrayList" /> 复制到兼容的一维 <see cref="T:System.Array" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的数组必须具有兼容类型。  
  
 此方法使用<xref:System.Array.Copy%2A?displayProperty=nameWithType>要复制的元素。  
  
 元素被复制到<xref:System.Array>枚举数循环访问的相同顺序<xref:System.Collections.ArrayList>。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何复制<xref:System.Collections.ArrayList>到一维<xref:System.Array?displayProperty=nameWithType>。  
  
 [!code-cpp[Classic ArrayList.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> 是多维的。  
  
 或  
  
 源 <see cref="T:System.Collections.ArrayList" /> 中的元素个数大于目标 <paramref name="array" /> 可以包含的元素个数。</exception>
        <exception cref="T:System.InvalidCastException">无法自动将源 <see cref="T:System.Collections.ArrayList" /> 的类型转换为目标 <paramref name="array" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.ArrayList" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <param name="arrayIndex">
          <c>array</c> 中从零开始的索引，在此处开始复制。</param>
        <summary>从目标数组的指定索引处开始将整个 <see cref="T:System.Collections.ArrayList" /> 复制到兼容的一维 <see cref="T:System.Array" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的数组必须具有兼容类型。  
  
 此方法使用<xref:System.Array.Copy%2A?displayProperty=nameWithType>要复制的元素。  
  
 元素被复制到<xref:System.Array>枚举数循环访问的相同顺序<xref:System.Collections.ArrayList>。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何复制<xref:System.Collections.ArrayList>到一维<xref:System.Array?displayProperty=nameWithType>。  
  
 [!code-cpp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> 是多维的。  
  
 或  
  
 源 <see cref="T:System.Collections.ArrayList" /> 中的元素个数大于从 <paramref name="arrayIndex" /> 到目标 <paramref name="array" /> 末尾之间的可用空间。</exception>
        <exception cref="T:System.InvalidCastException">无法自动将源 <see cref="T:System.Collections.ArrayList" /> 的类型转换为目标 <paramref name="array" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (int index, Array array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(int32 index, class System.Array array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.CopyTo(System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(int index, Array ^ array, int arrayIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">复制即从源 <see cref="T:System.Collections.ArrayList" /> 中从零开始的索引开始。</param>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:System.Collections.ArrayList" /> 复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <param name="arrayIndex">
          <c>array</c> 中从零开始的索引，在此处开始复制。</param>
        <param name="count">要复制的元素数。</param>
        <summary>从目标数组的指定索引处开始，将一定范围的元素从 <see cref="T:System.Collections.ArrayList" /> 复制到兼容的一维 <see cref="T:System.Array" /> 中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的数组必须具有兼容类型。  
  
 此方法使用<xref:System.Array.Copy%2A?displayProperty=nameWithType>要复制的元素。  
  
 元素被复制到<xref:System.Array>枚举数循环访问的相同顺序<xref:System.Collections.ArrayList>。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 下面的代码示例演示如何复制<xref:System.Collections.ArrayList>到一维<xref:System.Array?displayProperty=nameWithType>。  
  
 [!code-cpp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.CopyTo1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.CopyTo1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零。  
  
 或  
  
 <paramref name="arrayIndex" /> 小于零。  
  
 或  
  
 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> 是多维的。  
  
 或  
  
 <paramref name="index" /> 等于或大于源 <see cref="P:System.Collections.ArrayList.Count" /> 的 <see cref="T:System.Collections.ArrayList" />。  
  
 或  
  
 从 <paramref name="index" /> 到源 <see cref="T:System.Collections.ArrayList" /> 的末尾的元素数大于从 <paramref name="arrayIndex" /> 到目标 <paramref name="array" /> 的末尾的可用空间。</exception>
        <exception cref="T:System.InvalidCastException">无法自动将源 <see cref="T:System.Collections.ArrayList" /> 的类型转换为目标 <paramref name="array" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Collections.ArrayList" /> 中实际包含的元素数。</summary>
        <value>
          <see cref="T:System.Collections.ArrayList" /> 中实际包含的元素数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Capacity%2A> 是的元素数的<xref:System.Collections.ArrayList>可以存储。 <xref:System.Collections.ArrayList.Count%2A> 是中的实际的元素数目<xref:System.Collections.ArrayList>。  
  
 <xref:System.Collections.ArrayList.Capacity%2A> 大于或等于始终是<xref:System.Collections.ArrayList.Count%2A>。 如果<xref:System.Collections.ArrayList.Count%2A>超过<xref:System.Collections.ArrayList.Capacity%2A>时添加元素，则自动通过增大容量在复制旧元素和添加新的元素之前重新分配在内部数组。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FixedSize">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回具有固定大小的列表包装，其中的元素允许修改，但不允许添加或移除。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FixedSize">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList FixedSize (System.Collections.ArrayList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList FixedSize(class System.Collections.ArrayList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.FixedSize(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FixedSize (list As ArrayList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ FixedSize(System::Collections::ArrayList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="list">要包装的 <see cref="T:System.Collections.ArrayList" />。</param>
        <summary>返回具有固定大小的 <see cref="T:System.Collections.ArrayList" /> 包装。</summary>
        <returns>具有固定大小的 <see cref="T:System.Collections.ArrayList" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用此包装来防止原始<xref:System.Collections.ArrayList>。 元素仍可以修改或替换。  
  
 具有固定大小的集合是只是一个集合的包装器防止添加和移除元素;因此，如果对基础集合，包括添加或移除元素，进行更改的固定大小的集合将反映这些更改。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何创建的固定大小包装<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FixedSize">
      <MemberSignature Language="C#" Value="public static System.Collections.IList FixedSize (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList FixedSize(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.FixedSize(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FixedSize (list As IList) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ FixedSize(System::Collections::IList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">要包装的 <see cref="T:System.Collections.IList" />。</param>
        <summary>返回具有固定大小的 <see cref="T:System.Collections.IList" /> 包装。</summary>
        <returns>具有固定大小的 <see cref="T:System.Collections.IList" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用此包装来防止原始<xref:System.Collections.IList>。 元素仍可以修改或替换。  
  
 具有固定大小的集合是只是一个集合的包装器防止添加和移除元素;因此，如果对基础集合，包括添加或移除元素，进行更改的固定大小的集合将反映这些更改。  
  
 此方法为 o （1） 运算。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回循环访问 <see cref="T:System.Collections.ArrayList" /> 的枚举数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回整个 <see cref="T:System.Collections.ArrayList" /> 的一个枚举器。</summary>
        <returns>用于整个 <see cref="T:System.Collections.IEnumerator" /> 的 <see cref="T:System.Collections.ArrayList" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C# 语言的 `foreach` 语句（在 Visual Basic 中为 `for each`）隐藏了枚举数的复杂性。  因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 <xref:System.Collections.IEnumerator.Reset%2A> 也会将枚举器放回此位置。  在此位置上，未定义 <xref:System.Collections.IEnumerator.Current%2A>。 因此，在读取 <xref:System.Collections.IEnumerator.MoveNext%2A> 的值之前，必须调用 <xref:System.Collections.IEnumerator.Current%2A> 将枚举器向前移动到集合的第一个元素。  
  
 在调用 <xref:System.Collections.IEnumerator.Current%2A> 或 <xref:System.Collections.IEnumerator.MoveNext%2A> 之前，<xref:System.Collections.IEnumerator.Reset%2A> 返回同一对象。 <xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.IEnumerator.Current%2A> 设置为下一个元素。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过的末尾的集合，枚举数定位在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。 当枚举器位于此位置上，后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。 若要再次将 <xref:System.Collections.IEnumerator.Current%2A> 设置为集合的第一个元素，可以调用 <xref:System.Collections.IEnumerator.Reset%2A> 并接着调用 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合保持不变，枚举数就保持有效。 如果对集合进行更改（如添加、修改或删除元素），则枚举数将失效且不可恢复，而且其行为是不确定的。  
  
 枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的示例获取的枚举数<xref:System.Collections.ArrayList>，和中的元素范围的枚举数<xref:System.Collections.ArrayList>。  
  
 [!code-csharp[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR/collections.arraylist.getenumerator/cs/program.cs#1)]
 [!code-vb[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/collections.arraylist.getenumerator/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.GetEnumerator(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator (index As Integer, count As Integer) As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">枚举器应引用的 <see cref="T:System.Collections.ArrayList" /> 部分从零开始的起始索引。</param>
        <param name="count">枚举器应引用的 <see cref="T:System.Collections.ArrayList" /> 部分中的元素数。</param>
        <summary>返回 <see cref="T:System.Collections.ArrayList" /> 中某个范围内的元素的枚举器。</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> 中指定范围内的元素的 <see cref="T:System.Collections.ArrayList" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` C# 语言的语句 (`for each` Visual c + + 中`For Each`Visual Basic) 隐藏了枚举数的复杂性。  因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 <xref:System.Collections.IEnumerator.Reset%2A> 也会将枚举器放回此位置。  在此位置上，未定义 <xref:System.Collections.IEnumerator.Current%2A>。 因此，在读取 <xref:System.Collections.IEnumerator.MoveNext%2A> 的值之前，必须调用 <xref:System.Collections.IEnumerator.Current%2A> 将枚举器向前移动到集合的第一个元素。  
  
 在调用 <xref:System.Collections.IEnumerator.Current%2A> 或 <xref:System.Collections.IEnumerator.MoveNext%2A> 之前，<xref:System.Collections.IEnumerator.Reset%2A> 返回同一对象。 <xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.IEnumerator.Current%2A> 设置为下一个元素。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过的末尾的集合，枚举数定位在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。 当枚举器位于此位置上，后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。 若要再次将 <xref:System.Collections.IEnumerator.Current%2A> 设置为集合的第一个元素，可以调用 <xref:System.Collections.IEnumerator.Reset%2A> 并接着调用 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合保持不变，枚举数就保持有效。 如果对集合进行更改（如添加、修改或删除元素），则枚举数将失效且不可恢复，而且其行为是不确定的。  
  
 枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 此方法为 o （1） 运算。  
  
## <a name="version-compatibility"></a>版本兼容性  
 中的.NET Framework 版本 1.0 和 1.1 中，枚举数<xref:System.Collections.ArrayList>包装返回<xref:System.Collections.ArrayList.Adapter%2A>方法被视为第二个参数，上限为而不是做一个计数。 在[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]第二个参数正确视为计数。  
  
   
  
## Examples  
 下面的示例获取的枚举数<xref:System.Collections.ArrayList>，和中的元素范围的枚举数<xref:System.Collections.ArrayList>。  
  
 [!code-csharp[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR/collections.arraylist.getenumerator/cs/program.cs#1)]
 [!code-vb[Collections.ArrayList.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/collections.arraylist.getenumerator/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零。  
  
 或  
  
 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.ArrayList" /> 中指定有效范围。</exception>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ArrayList GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ArrayList GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRange (index As Integer, count As Integer) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ArrayList ^ GetRange(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">范围开始处的从零开始的 <see cref="T:System.Collections.ArrayList" /> 索引。</param>
        <param name="count">范围中的元素数。</param>
        <summary>返回 <see cref="T:System.Collections.ArrayList" />，它表示源 <see cref="T:System.Collections.ArrayList" /> 中元素的子集。</summary>
        <returns>
          <see cref="T:System.Collections.ArrayList" />，它表示源 <see cref="T:System.Collections.ArrayList" /> 中元素的子集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不创建的元素的副本。 新<xref:System.Collections.ArrayList>是仅入到源视图窗口<xref:System.Collections.ArrayList>。 但是，对源的所有后续更改<xref:System.Collections.ArrayList>必须通过此视图窗口<xref:System.Collections.ArrayList>。 如果直接对源进行更改<xref:System.Collections.ArrayList>，视图窗口<xref:System.Collections.ArrayList>失效并对它的任何操作将返回<xref:System.InvalidOperationException>。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取的元素范围<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.SetRange Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.SetRange Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.SetRange Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零。  
  
 或  
  
 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.ArrayList" /> 中元素的有效范围。</exception>
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Collections.ArrayList" /> 或它的一部分中某个值的第一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <summary>搜索指定的 <see cref="T:System.Object" />，并返回整个 <see cref="T:System.Collections.ArrayList" /> 中第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到，则为整个 <paramref name="value" /> 中 <see cref="T:System.Collections.ArrayList" /> 第一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>搜索向前从第一个元素开始和结束时间的最后一个元素。  
  
 此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
 此方法通过调用可确定相等性<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。  
  
   
  
## Examples  
 下面的代码示例演示如何确定指定的元素的第一个匹配项的索引。  
  
 [!code-cpp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <param name="startIndex">从零开始的搜索的起始索引。 空列表中 0（零）为有效值。</param>
        <summary>搜索指定的 <see cref="T:System.Object" />，并返回 <see cref="T:System.Collections.ArrayList" /> 中从指定索引到最后一个元素的元素范围内第一个匹配项的从零开始的索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.ArrayList" /> 中从 <paramref name="startIndex" /> 到最后一个元素的元素范围内找到 <paramref name="value" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>处开始向前搜索`startIndex`和结束时间的最后一个元素。  
  
 此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是中的元素数`startIndex`到末尾<xref:System.Collections.ArrayList>。  
  
 此方法通过调用可确定相等性<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。  
  
   
  
## Examples  
 下面的代码示例演示如何确定指定的元素的第一个匹配项的索引。  
  
 [!code-cpp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.ArrayList" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.IndexOf(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <param name="startIndex">从零开始的搜索的起始索引。 空列表中 0（零）为有效值。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的 <see cref="T:System.Object" />，并返回 <see cref="T:System.Collections.ArrayList" /> 中从指定的索引开始并包含指定的元素数的元素范围内第一个匹配项的从零开始的索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.ArrayList" /> 中从 <paramref name="startIndex" /> 开始并包含 <paramref name="count" /> 个元素的元素范围内找到 <paramref name="value" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>处开始向前搜索`startIndex`结束`startIndex`加上`count`减 1，如果`count`大于 0。  
  
 此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是`count`。  
  
 此方法通过调用可确定相等性<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。  
  
   
  
## Examples  
 下面的代码示例演示如何确定指定的元素的第一个匹配项的索引。  
  
 [!code-cpp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.ArrayList" /> 的有效索引范围。  
  
 或  
  
 <paramref name="count" /> 小于零。  
  
 或  
  
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未指定 <see cref="T:System.Collections.ArrayList" /> 中的有效部分。</exception>
        <altmember cref="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public virtual void Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Insert (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">从零开始的索引，应在该位置插入 <c>value</c>。</param>
        <param name="value">要插入的 <see cref="T:System.Object" />。 该值可以为 <see langword="null" />。</param>
        <summary>将元素插入 <see cref="T:System.Collections.ArrayList" /> 的指定索引处。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> 接受`null`作为有效的值，并允许重复的元素。  
  
 如果<xref:System.Collections.ArrayList.Count%2A>已经等于<xref:System.Collections.ArrayList.Capacity%2A>、 容量的<xref:System.Collections.ArrayList>增加通过自动重新分配在内部数组和现有元素被复制到新数组中，在添加新的元素之前。  
  
 如果`index`等同于<xref:System.Collections.ArrayList.Count%2A>，`value`添加到末尾<xref:System.Collections.ArrayList>。  
  
 在由连续的元素组成的集合（如列表）中，插入点下面的元素将下移以容纳新的元素。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶的集合，如哈希表。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何插入元素到<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Insert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Insert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Insert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零。  
  
 或  
  
 <paramref name="index" /> 大于 <see cref="P:System.Collections.ArrayList.Count" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.ArrayList" /> 为只读。  
  
 或  
  
 <see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public virtual void InsertRange (int index, System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertRange(int32 index, class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub InsertRange (index As Integer, c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void InsertRange(int index, System::Collections::ICollection ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="index">应在此处插入新元素的从零开始的索引。</param>
        <param name="c">
          <see cref="T:System.Collections.ICollection" />，应将其元素插入到 <see cref="T:System.Collections.ArrayList" /> 中。 集合本身不能为 <see langword="null" />，但它可以包含为 <see langword="null" /> 的元素。</param>
        <summary>将集合中的元素插入 <see cref="T:System.Collections.ArrayList" /> 的指定索引处。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> 接受`null`作为有效的值，并允许重复的元素。  
  
 如果新<xref:System.Collections.ArrayList.Count%2A>(当前<xref:System.Collections.ArrayList.Count%2A>plus 集合的大小) 将大于<xref:System.Collections.ArrayList.Capacity%2A>、 容量的<xref:System.Collections.ArrayList>增加通过自动重新分配以容纳新元素，在内部数组和在添加新的元素之前，现有元素被复制到新数组。  
  
 如果`index`等同于<xref:System.Collections.ArrayList.Count%2A>，元素添加到末尾<xref:System.Collections.ArrayList>。  
  
 中的元素的顺序<xref:System.Collections.ICollection>在过程中保留<xref:System.Collections.ArrayList>。  
  
 在由连续的元素组成的集合（如列表）中，插入点下面的元素将下移以容纳新的元素。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶的集合，如哈希表。  
  
 此方法为 O (`n` + `m`) 操作，其中`n`是要添加的元素的数目和`m`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何插入元素到<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Insert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Insert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Insert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Insert Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零。  
  
 或  
  
 <paramref name="index" /> 大于 <see cref="P:System.Collections.ArrayList.Count" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.ArrayList" /> 为只读。  
  
 或  
  
 <see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Collections.ArrayList" /> 是否具有固定大小。</summary>
        <value>
          如果 <see langword="true" /> 具有固定大小，则为 <see cref="T:System.Collections.ArrayList" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 具有固定大小的集合在创建之后不能再添加或移除元素，但是允许修改现有元素。  
  
 具有固定大小的集合是只是一个集合的包装器防止添加和移除元素;因此，如果对基础集合，包括添加或移除元素，进行更改的固定大小的集合将反映这些更改。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的代码示例演示如何创建的固定大小包装<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsFixedSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsFixedSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Collections.ArrayList" /> 是否为只读。</summary>
        <value>
          如果 <see langword="true" /> 是只读的，则为 <see cref="T:System.Collections.ArrayList" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在创建只读集合后，该集合不允许添加、移除或修改元素。  
  
 集合是只读的是只是一个集合与防止集合; 进行修改的包装因此，如果对基础集合进行更改，只读集合将反映这些更改。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的代码示例演示如何创建周围的只读包装<xref:System.Collections.ArrayList>以及如何确定如果<xref:System.Collections.ArrayList>是只读的。  
  
 [!code-cpp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否同步对 <see cref="T:System.Collections.ArrayList" /> 的访问（线程安全）。</summary>
        <value>
          如果对 <see langword="true" /> 的访问是同步的（线程安全），则为 <see cref="T:System.Collections.ArrayList" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确保的线程安全性<xref:System.Collections.ArrayList>，所有操作必须通过返回的包装器来都完成<xref:System.Collections.ArrayList.Synchronized%2A>方法。  
  
 枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。  
  
   
  
## Examples  
 下面的代码示例演示如何锁定集合使用<xref:System.Collections.ArrayList.SyncRoot%2A>在整个枚举期间。  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 下面的代码示例演示如何同步<xref:System.Collections.ArrayList>，确定如果<xref:System.Collections.ArrayList>同步以及如何使用同步<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.SyncRoot" />
        <altmember cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要获取或设置的元素的从零开始的索引。</param>
        <summary>获取或设置指定索引处的元素。</summary>
        <value>指定索引处的元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList.Item%2A> 返回 <xref:System.Object>，因此，您可能需要将返回的值强制转换为原始类型以便对其进行操作。 请务必注意，<xref:System.Collections.ArrayList> 不是个强类型集合。 有关强类型替代项，请参见 <xref:System.Collections.Generic.List%601>。  
  
 <xref:System.Collections.ArrayList> 接受`null`作为有效的值，并允许重复的元素。  
  
 可以使用下面的语法通过此属性访问集合中的特定元素：`myCollection[index]`。  
  
 C# 语言使用关键字进行定义而不是实现索引器<xref:System.Collections.ArrayList.Item%2A>属性。 Visual Basic 将 <xref:System.Collections.ArrayList.Item%2A> 实现为默认属性，该属性提供相同的索引功能。  
  
 检索此属性的值的运算 o （1）;设置属性也是 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Collections.ArrayList>并添加多个项。 此示例演示具有访问元素<xref:System.Collections.ArrayList.Item%2A>属性 （索引器在 C# 中），并通过将新值赋给分配更改元素<xref:System.Collections.ArrayList.Item%2A>的指定索引的属性。 该示例还演示<xref:System.Collections.ArrayList.Item%2A>属性不能用于访问或添加外部列表的当前大小的元素。  
  
 [!code-cpp[System.Collections.ArrayList.Item#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/cpp/source.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.Item#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/CS/source.cs#1)]
 [!code-vb[System.Collections.ArrayList.Item#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/VB/source.vb#1)]  
  
 下面的示例使用<xref:System.Collections.ArrayList.Item%2A>属性显式将值分配给列表中的项。 该示例定义继承的类<xref:System.Collections.ArrayList>并添加一个方法进行编码列表项。  
  
 [!code-cpp[System.Collections.ArrayList.Item#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/cpp/source2.cpp#2)]
 [!code-csharp[System.Collections.ArrayList.Item#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/CS/source2.cs#2)]
 [!code-vb[System.Collections.ArrayList.Item#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Item/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零。  
  
 或  
  
 <paramref name="index" /> 等于或大于 <see cref="P:System.Collections.ArrayList.Count" />。</exception>
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see cref="T:System.Collections.ArrayList" /> 或它的一部分中某个值的最后一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.LastIndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <summary>搜索指定的 <see cref="T:System.Object" />，并返回整个 <see cref="T:System.Collections.ArrayList" /> 中最后一个匹配项的从零开始的索引。</summary>
        <returns>如果在整个 <see cref="T:System.Collections.ArrayList" /> 中找到 <paramref name="value" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>向后搜索的最后一个元素开始，在第一个元素结束。  
  
 此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
 从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。  
  
   
  
## Examples  
 下面的代码示例演示如何确定指定的元素的最后一个匹配项的索引。  
  
 [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (value As Object, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <summary>搜索指定的 <see cref="T:System.Object" />，并返回 <see cref="T:System.Collections.ArrayList" /> 中从第一个元素到指定索引的元素范围内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到，则返回在 <see cref="T:System.Collections.ArrayList" /> 中从第一个元素到 <paramref name="startIndex" /> 的元素范围内找到 <paramref name="value" /> 的最后一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>是搜索向后开始`startIndex`和结束的第一个元素。  
  
 此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是从开始处的元素数目<xref:System.Collections.ArrayList>到`startIndex`。  
  
 此方法通过调用可确定相等性<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。  
  
   
  
## Examples  
 下面的代码示例演示如何确定指定的元素的最后一个匹配项的索引。  
  
 [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.ArrayList" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.LastIndexOf(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (value As Object, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 中定位的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的 <see cref="T:System.Object" />，并返回 <see cref="T:System.Collections.ArrayList" /> 中包含指定的元素数并在指定索引处结束的元素范围内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果在 <see cref="T:System.Collections.ArrayList" /> 中到 <paramref name="startIndex" /> 为止包含 <paramref name="count" /> 个元素的这部分元素中找到 <paramref name="value" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList>是搜索向后开始`startIndex`结束`startIndex`减`count`加上 1，如果`count`大于 0。  
  
 此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是`count`。  
  
 此方法通过调用可确定相等性<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 从.NET Framework 2.0 开始，此方法使用集合的对象<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`以确定是否存在项。 在.NET Framework 的早期版本，通过进行此决定<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`参数的集合中的对象。  
  
   
  
## Examples  
 下面的代码示例演示如何确定指定的元素的最后一个匹配项的索引。 请注意，`LastIndexOf`是向后搜索; 因此，`count`必须小于或等于`startIndex`+ 1。  
  
 [!code-cpp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 超出了 <see cref="T:System.Collections.ArrayList" /> 的有效索引范围。  
  
 或  
  
 <paramref name="count" /> 小于零。  
  
 或  
  
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未指定 <see cref="T:System.Collections.ArrayList" /> 中的有效部分。</exception>
        <altmember cref="M:System.Collections.ArrayList.IndexOf(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Contains(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadOnly">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回只读的列表包装。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList ReadOnly (System.Collections.ArrayList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList ReadOnly(class System.Collections.ArrayList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ReadOnly(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadOnly (list As ArrayList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ ReadOnly(System::Collections::ArrayList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="list">要包装的 <see cref="T:System.Collections.ArrayList" />。</param>
        <summary>返回只读的 <see cref="T:System.Collections.ArrayList" /> 包装。</summary>
        <returns>
          <paramref name="list" /> 周围的只读 <see cref="T:System.Collections.ArrayList" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止对`list`，公开`list`只通过此包装器。  
  
 是只读的集合是只需使用的包装器可防止修改集合的集合。 如果对基础集合进行更改，只读集合将反映这些更改。  
  
 此方法为 o （1） 运算。  
  
   
  
## Examples  
 下面的代码示例演示如何创建周围的只读包装<xref:System.Collections.ArrayList>以及如何确定如果<xref:System.Collections.ArrayList>是只读的。  
  
 [!code-cpp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.ReadOnly1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.ReadOnly1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Collections.ArrayList.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public static System.Collections.IList ReadOnly (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList ReadOnly(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadOnly (list As IList) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ ReadOnly(System::Collections::IList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">要包装的 <see cref="T:System.Collections.IList" />。</param>
        <summary>返回只读的 <see cref="T:System.Collections.IList" /> 包装。</summary>
        <returns>
          <paramref name="list" /> 周围的只读 <see cref="T:System.Collections.IList" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止对`list`，公开`list`只通过此包装器。  
  
 是只读的集合是只需使用的包装器可防止修改集合的集合。 如果对基础集合进行更改，只读集合将反映这些更改。  
  
 此方法为 o （1） 运算。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Collections.ArrayList.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要从 <see cref="T:System.Object" /> 移除的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <summary>从 <see cref="T:System.Collections.ArrayList" /> 中移除特定对象的第一个匹配项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Collections.ArrayList>不包含指定的对象，<xref:System.Collections.ArrayList>保持不变。 不引发异常。  
  
 此方法执行的线性搜索;因此，此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
 此方法通过调用可确定相等性<xref:System.Object.Equals%2A?displayProperty=nameWithType>。  
  
 在由连续的元素组成的集合（如列表）中，已移除元素下面的元素将上移以占据空出的位置。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶的集合，如哈希表。  
  
   
  
## Examples  
 下面的代码示例演示如何从中移除元素<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.ArrayList" /> 为只读。  
  
 或  
  
 <see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的元素的从零开始的索引。</param>
        <summary>移除 <see cref="T:System.Collections.ArrayList" /> 的指定索引处的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 移除元素后，调整集合的大小和的值<xref:System.Collections.ArrayList.Count%2A>属性减少 1。  
  
 在由连续的元素组成的集合（如列表）中，已移除元素下面的元素将上移以占据空出的位置。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶的集合，如哈希表。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何从中移除元素<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零。  
  
 或  
  
 <paramref name="index" /> 等于或大于 <see cref="P:System.Collections.ArrayList.Count" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.ArrayList" /> 为只读。  
  
 或  
  
 <see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.Add(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public virtual void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveRange(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的元素范围的从零开始的起始索引。</param>
        <param name="count">要移除的元素数。</param>
        <summary>从 <see cref="T:System.Collections.ArrayList" /> 中移除一定范围的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在由连续的元素组成的集合（如列表）中，已移除元素下面的元素将上移以占据空出的位置。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶的集合，如哈希表。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何从中移除元素<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零。  
  
 或  
  
 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.ArrayList" /> 中元素的有效范围。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.ArrayList" /> 为只读。  
  
 或  
  
 <see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.Remove(System.Object)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
      </Docs>
    </Member>
    <Member MemberName="Repeat">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList Repeat (object value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList Repeat(object value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Repeat(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Repeat (value As Object, count As Integer) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ Repeat(System::Object ^ value, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要在新 <see cref="T:System.Object" /> 中对其进行多次复制的 <see cref="T:System.Collections.ArrayList" />。 该值可以为 <see langword="null" />。</param>
        <param name="count">
          <c>value</c> 应复制的次数。</param>
        <summary>返回 <see cref="T:System.Collections.ArrayList" />，它的元素是指定值的副本。</summary>
        <returns>具有 <paramref name="count" /> 所指定的元素数的 <see cref="T:System.Collections.ArrayList" />，其中的所有元素都是 <paramref name="value" /> 的副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> 接受`null`作为有效的值，并允许重复的元素。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化一个新<xref:System.Collections.ArrayList>具有相同的值。  
  
 [!code-cpp[Classic ArrayList.Repeat Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Repeat Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Repeat Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Repeat Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Repeat Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Repeat Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 小于零。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Collections.ArrayList" /> 或它的一部分中元素的顺序反转。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public virtual void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reverse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将整个 <see cref="T:System.Collections.ArrayList" /> 中元素的顺序反转。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Reverse%2A?displayProperty=nameWithType>若要反转的元素的顺序以便处的元素<xref:System.Collections.ArrayList>[i] 其中 i 表示的范围内的任何索引移动到<xref:System.Collections.ArrayList>[j] 其中 j 等于`index`  +  `index`  +  `count` -i-1。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何反转排序顺序中的值<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.ArrayList" /> 为只读。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public virtual void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reverse(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要反转的范围的从零开始的起始索引。</param>
        <param name="count">要反转的范围内的元素数。</param>
        <summary>将指定范围中元素的顺序反转。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Reverse%2A?displayProperty=nameWithType>若要反转的元素的顺序以便处的元素<xref:System.Collections.ArrayList>[i] 其中 i 表示的范围内的任何索引移动到<xref:System.Collections.ArrayList>[j] 其中 j 等于`index`  +  `index`  +  `count` -i-1。  
  
 此方法为 O (`n`) 操作，其中`n`是`count`。  
  
   
  
## Examples  
 下面的代码示例演示如何反转排序顺序中的一系列元素中的值<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零。  
  
 或  
  
 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="count" /> 不表示 <see cref="T:System.Collections.ArrayList" /> 中元素的有效范围。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.ArrayList" /> 为只读。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetRange">
      <MemberSignature Language="C#" Value="public virtual void SetRange (int index, System.Collections.ICollection c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetRange(int32 index, class System.Collections.ICollection c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.SetRange(System.Int32,System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetRange (index As Integer, c As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetRange(int index, System::Collections::ICollection ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="index">从零开始的 <see cref="T:System.Collections.ArrayList" /> 索引，从此开始复制 <c>c</c> 的元素。</param>
        <param name="c">
          <see cref="T:System.Collections.ICollection" />，要将其元素复制到 <see cref="T:System.Collections.ArrayList" /> 中。 集合本身不能为 <see langword="null" />，但它可以包含为 <see langword="null" /> 的元素。</param>
        <summary>将集合中的元素复制到 <see cref="T:System.Collections.ArrayList" /> 中一定范围的元素上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ArrayList> 接受`null`作为有效的值，并允许重复的元素。  
  
 中的元素的顺序<xref:System.Collections.ICollection>在过程中保留<xref:System.Collections.ArrayList>。  
  
 此方法为 O (`n` + 1) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何设置和获取的元素范围<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.SetRange Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.SetRange Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.SetRange Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.SetRange Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零。  
  
 或  
  
 <paramref name="index" /> 加上 <paramref name="c" /> 中的元素数大于 <see cref="P:System.Collections.ArrayList.Count" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.ArrayList" /> 为只读。</exception>
        <altmember cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.InsertRange(System.Int32,System.Collections.ICollection)" />
        <altmember cref="M:System.Collections.ArrayList.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>对 <see cref="T:System.Collections.ArrayList" /> 或它的一部分中的元素进行排序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public virtual void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Sort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>对整个 <see cref="T:System.Collections.ArrayList" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用<xref:System.Array.Sort%2A?displayProperty=nameWithType>，它使用快速排序算法。 快速排序算法是比较 （也称为不稳定排序），这意味着"小于或等于"的排序比较操作将确定这两个元素应首先出现在最后一个已排序的列表。 但是，如果两个元素相等，则可能不会保留其原始顺序。 与此相反，一个稳定排序保留相等的元素的顺序。 若要执行一个稳定排序，则必须实现一个自定义<xref:System.Collections.IComparer>接口若要使用此方法的其他重载。  
  
 一般情况下，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>; 在最坏情况下它复杂度为 O (`n`^2) 操作。  
  
   
  
## Examples  
 下面的代码示例演示如何进行排序中的值<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Sort Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Sort Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Sort Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Sort Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Sort Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Sort Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.ArrayList" /> 为只读。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public virtual void Sort (System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort(class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Sort(System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Sort (comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Sort(System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
 或  
  
 null 引用（Visual Basic 中为 <see langword="Nothing" />）将使用每个元数的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定的比较器对整个 <see cref="T:System.Collections.ArrayList" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Collections.ArrayList.Sort%2A> 方法通过实现 <xref:System.Collections.IComparer> 接口的自定义比较器对对象的列表进行排序。 如果为 `null` 传递 `comparer`，则此方法将使用每个元素的 <xref:System.IComparable> 实现。 在此情况下，您必须确保列表中包含的对象实现 <xref:System.Collections.IComparer> 接口，否则将发生异常。  
  
 此外，使用 <xref:System.IComparable> 实现意味着此列表将执行比较排序（也称为“不稳定排序”）；也就是说，如果两个元素相等，则可能不会保留其顺序。 与此相反，一个稳定排序保留相等的元素的顺序。 若要执行一个稳定排序，则必须实现一个自定义<xref:System.Collections.IComparer>接口。  
  
 一般情况下，此方法为 O (`n`日志`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>; 在最坏情况下它复杂度为 O (`n`^2) 操作。  
  
   
  
## Examples  
 下面的代码示例演示如何进行排序中的值<xref:System.Collections.ArrayList>使用默认比较器和将反转排序顺序的自定义比较器。  
  
 [!code-cpp[System.Collections.ArrayList.Sort_2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_2/CPP/arraylist_sort2.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.Sort_2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_2/CS/arraylist_sort2.cs#1)]
 [!code-vb[System.Collections.ArrayList.Sort_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_2/VB/arraylist_sort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.ArrayList" /> 为只读。</exception>
        <exception cref="T:System.InvalidOperationException">比较两个元素时出错。</exception>
        <exception cref="T:System.ArgumentException">
          将为 <paramref name="comparer" /> 传递 <see langword="null" />，并且列表中的元素不会实现 <see cref="T:System.IComparable" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public virtual void Sort (int index, int count, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort(int32 index, int32 count, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Sort(System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Sort (index As Integer, count As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Sort(int index, int count, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="index">要排序范围的从零开始的起始索引。</param>
        <param name="count">要排序的范围的长度。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
 或  
  
 null 引用（Visual Basic 中为 <see langword="Nothing" />）将使用每个元数的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定的比较器对 <see cref="T:System.Collections.ArrayList" /> 中某个范围内的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`设置为`null`，此方法将执行比较排序 （也称为不稳定排序）; 即，如果两个元素相等，其顺序可能不会保留。 与此相反，一个稳定排序保留相等的元素的顺序。 若要执行一个稳定排序，则必须实现一个自定义<xref:System.Collections.IComparer>接口。  
  
 一般情况下，此方法为 O (`n`日志`n`) 操作，其中`n`是`count`; 在最坏情况下此操作是 O(n^2) 操作。  
  
   
  
## Examples  
 下面的代码示例演示如何进行排序的元素范围中的值<xref:System.Collections.ArrayList>使用默认比较器和将反转排序顺序的自定义比较器。  
  
 [!code-cpp[System.Collections.ArrayList.Sort_3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_3/CPP/arraylist_sort3.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.Sort_3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_3/CS/arraylist_sort3.cs#1)]
 [!code-vb[System.Collections.ArrayList.Sort_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.Sort_3/VB/arraylist_sort3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零。  
  
 或  
  
 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 和 <paramref name="count" /> 未在 <see cref="T:System.Collections.ArrayList" /> 中指定有效范围。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.ArrayList" /> 为只读。</exception>
        <exception cref="T:System.InvalidOperationException">比较两个元素时出错。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Synchronized">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回同步的（线程安全）列表包装。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.ArrayList Synchronized (System.Collections.ArrayList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ArrayList Synchronized(class System.Collections.ArrayList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Synchronized(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As ArrayList) As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ArrayList ^ Synchronized(System::Collections::ArrayList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="list">要同步的 <see cref="T:System.Collections.ArrayList" />。</param>
        <summary>返回同步的（线程安全）<see cref="T:System.Collections.ArrayList" /> 包装。</summary>
        <returns>同步的（线程安全）<see cref="T:System.Collections.ArrayList" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确保的线程安全性<xref:System.Collections.ArrayList>，必须通过此包装器完成所有操作。  
  
 枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。  
  
   
  
## Examples  
 下面的代码示例演示如何锁定集合使用<xref:System.Collections.ArrayList.SyncRoot%2A>在整个枚举期间。  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 此方法为 o （1） 运算。  
  
 下面的代码示例演示如何同步<xref:System.Collections.ArrayList>，确定如果<xref:System.Collections.ArrayList>同步以及如何使用同步<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Collections.ArrayList.SyncRoot" />
        <altmember cref="P:System.Collections.ArrayList.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.IList Synchronized (System.Collections.IList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList Synchronized(class System.Collections.IList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As IList) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ Synchronized(System::Collections::IList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="list">要同步的 <see cref="T:System.Collections.IList" />。</param>
        <summary>返回同步的（线程安全）<see cref="T:System.Collections.IList" /> 包装。</summary>
        <returns>同步的（线程安全）<see cref="T:System.Collections.IList" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确保的线程安全性<xref:System.Collections.ArrayList>，必须通过此包装器完成所有操作。  
  
 枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。  
  
   
  
## Examples  
 下面的代码示例演示如何锁定集合使用<xref:System.Collections.ArrayList.SyncRoot%2A>在整个枚举期间。  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 此方法为 o （1） 运算。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Collections.ArrayList.SyncRoot" />
        <altmember cref="P:System.Collections.ArrayList.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ArrayList.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可用于同步对 <see cref="T:System.Collections.ArrayList" /> 的访问的对象。</summary>
        <value>可用于同步对 <see cref="T:System.Collections.ArrayList" /> 的访问的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建的同步的版本<xref:System.Collections.ArrayList>，使用<xref:System.Collections.ArrayList.Synchronized%2A>方法。 但是，派生的类可以提供自己的同步的版本<xref:System.Collections.ArrayList>使用<xref:System.Collections.ArrayList.SyncRoot%2A>属性。 同步代码必须在执行操作<xref:System.Collections.ArrayList.SyncRoot%2A>的<xref:System.Collections.ArrayList>，而不是直接在<xref:System.Collections.ArrayList>。 这样可确保对从其他对象派生的集合正确地执行操作。 具体地说，这样可保持正确的同步，与可能同时对修改其他线程<xref:System.Collections.ArrayList>对象。  
  
 枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。  
  
   
  
## Examples  
 下面的代码示例演示如何锁定集合使用<xref:System.Collections.ArrayList.SyncRoot%2A>在整个枚举期间。  
  
 [!code-cpp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic ArrayList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.IsSynchronized Example/VB/source2.vb#2)]  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ArrayList.IsSynchronized" />
        <altmember cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToArray">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Collections.ArrayList" /> 的元素复制到新数组中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual object[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ ToArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将 <see cref="T:System.Collections.ArrayList" /> 的元素复制到新 <see cref="T:System.Object" /> 数组中。</summary>
        <returns>
          <see cref="T:System.Object" /> 数组，它包含 <see cref="T:System.Collections.ArrayList" /> 中元素的副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用复制元素<xref:System.Array.Copy%2A?displayProperty=nameWithType>，这是 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual Array ToArray (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array ToArray(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.ToArray(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ ToArray(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">要创建并向其复制元素的目标数组的元素 <see cref="T:System.Type" />。</param>
        <summary>将 <see cref="T:System.Collections.ArrayList" /> 的元素复制到指定元素类型的新数组中。</summary>
        <returns>指定元素类型的数组，它包含 <see cref="T:System.Collections.ArrayList" /> 中元素的副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的对象的所有<xref:System.Collections.ArrayList>对象强制转换为<xref:System.Type>中指定`type`参数。  
  
 使用复制元素<xref:System.Array.Copy%2A?displayProperty=nameWithType>，这是 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的复制示例演示如何将复制的元素<xref:System.Collections.ArrayList>到字符串数组。  
  
 [!code-cpp[System.Collections.ArrayList.ToArray#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ArrayList.ToArray/CPP/arraylist_toarray.cpp#1)]
 [!code-csharp[System.Collections.ArrayList.ToArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ArrayList.ToArray/CS/arraylist_toarray.cs#1)]
 [!code-vb[System.Collections.ArrayList.ToArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ArrayList.ToArray/VB/arraylist_toarray.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidCastException">源 <see cref="T:System.Collections.ArrayList" /> 的类型不能自动转换为指定类型。</exception>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ArrayList.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void TrimToSize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将容量设置为 <see cref="T:System.Collections.ArrayList" /> 中元素的实际数目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可以用于降低集合的内存开销，如果没有新的元素将添加到集合。  
  
 若要重置<xref:System.Collections.ArrayList>为其初始状态，请在调用<xref:System.Collections.ArrayList.Clear%2A>方法之前调用<xref:System.Collections.ArrayList.TrimToSize%2A>。 截去空<xref:System.Collections.ArrayList>的容量设置<xref:System.Collections.ArrayList>到默认的容量。  
  
 此方法为 O (`n`) 操作，其中`n`是<xref:System.Collections.ArrayList.Count%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何修整的未使用的部分<xref:System.Collections.ArrayList>以及如何清除的值<xref:System.Collections.ArrayList>。  
  
 [!code-cpp[Classic ArrayList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ArrayList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic ArrayList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ArrayList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.ArrayList" /> 为只读。  
  
 或  
  
 <see cref="T:System.Collections.ArrayList" /> 具有固定的大小。</exception>
        <altmember cref="M:System.Collections.ArrayList.Clear" />
        <altmember cref="P:System.Collections.ArrayList.Capacity" />
        <altmember cref="P:System.Collections.ArrayList.Count" />
      </Docs>
    </Member>
  </Members>
</Type>