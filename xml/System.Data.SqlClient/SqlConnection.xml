<Type Name="SqlConnection" FullName="System.Data.SqlClient.SqlConnection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="13a8805b62cac7e4548ac44737cd6c5c1dc3578c" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34452432" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SqlConnection : System.Data.Common.DbConnection, ICloneable, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SqlConnection extends System.Data.Common.DbConnection implements class System.Data.IDbConnection, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.SqlClient.SqlConnection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SqlConnection&#xA;Inherits DbConnection&#xA;Implements ICloneable, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SqlConnection sealed : System::Data::Common::DbConnection, ICloneable, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.SqlClient</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DbConnection</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("InfoMessage")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示到 SQL Server 数据库的连接。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Data.SqlClient.SqlConnection>对象表示到 SQL Server 数据源的唯一的会话。 使用客户端/服务器数据库系统，它相当于网络连接到服务器。 <xref:System.Data.SqlClient.SqlConnection> 使用连同<xref:System.Data.SqlClient.SqlDataAdapter>和<xref:System.Data.SqlClient.SqlCommand>来提高性能时连接到 Microsoft SQL Server 数据库。 对于所有第三方 SQL Server 产品和其他支持 OLE DB 的数据源，使用<xref:System.Data.OleDb.OleDbConnection>。  
  
 当你创建的实例<xref:System.Data.SqlClient.SqlConnection>，所有属性均都设置为其初始值。 有关这些值的列表，请参阅<xref:System.Data.SqlClient.SqlConnection>构造函数。  
  
 请参阅<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>有关连接字符串中的关键字的列表。  
  
 如果<xref:System.Data.SqlClient.SqlConnection>超出范围，则不会关闭。 因此，必须显式关闭连接通过调用`Close`或`Dispose`。 `Close` 和`Dispose`在功能上等效。 如果连接池值`Pooling`设置为`true`或`yes`，则基础连接返回到连接池。 另一方面，如果`Pooling`设置为`false`或`no`，则实际关闭基础连接到服务器。  
  
> [!NOTE]
>  从连接池中提取连接或将连接返回到连接池时，服务器上不会引发登录和注销事件，这是因为在将连接返回到连接池时实际上并没有将其关闭。 有关详细信息，请参阅 [SQL Server 连接池 (ADO.NET)](~/docs/framework/data/adonet/sql-server-connection-pooling.md)。  
  
 若要确保始终关闭连接，打开的内部连接`using`阻止，如下面的代码段中所示。 这样做可确保当代码退出块时自动关闭连接。  
  
```vb  
Using connection As New SqlConnection(connectionString)  
    connection.Open()  
    ' Do work here; connection closed on following line.  
End Using  
  
```  
  
```csharp  
using (SqlConnection connection = new SqlConnection(connectionString))  
    {  
        connection.Open();  
        // Do work here; connection closed on following line.  
    }  
```  
  
> [!NOTE]
>  若要部署高性能应用程序，必须使用连接池。 当你使用适用于 SQL Server 的.NET Framework 数据提供程序时，你无需启用连接池，因为提供程序管理此自动，尽管你可以修改某些设置。 有关详细信息，请参阅 [SQL Server 连接池 (ADO.NET)](~/docs/framework/data/adonet/sql-server-connection-pooling.md)。  
  
 如果<xref:System.Data.SqlClient.SqlException>生成的方法执行<xref:System.Data.SqlClient.SqlCommand>、<xref:System.Data.SqlClient.SqlConnection>保持打开状态时的严重性级别为 19 或以下。 等于或大于 20 的严重性级别时，服务器通常会关闭<xref:System.Data.SqlClient.SqlConnection>。 但是，用户可以重新打开连接并继续操作。  
  
 创建的实例的应用程序<xref:System.Data.SqlClient.SqlConnection>对象可以要求所有直接和间接调用方拥有足够权限的代码通过设置声明性或命令性安全要求。 <xref:System.Data.SqlClient.SqlConnection> 发出安全要求使用<xref:System.Data.SqlClient.SqlClientPermission>对象。 用户可以验证他们的代码通过使用具有足够的权限<xref:System.Data.SqlClient.SqlClientPermissionAttribute>对象。 用户和管理员还可以使用[Caspol.exe （代码访问安全策略工具）](~/docs/framework/tools/caspol-exe-code-access-security-policy-tool.md)可修改计算机、 用户和企业级别的安全策略。 有关详细信息，请参阅[安全性](http://msdn.microsoft.com/library/9a9621d7-8883-4a4f-a874-65e8e09e20a6)。 有关演示如何使用安全要求的示例，请参阅[代码访问安全性和 ADO.NET](~/docs/framework/data/adonet/code-access-security.md)。  
  
 有关处理来自服务器的警告和信息性消息的详细信息，请参阅[连接事件](~/docs/framework/data/adonet/connection-events.md)。 SQL Server 引擎错误和错误消息记录在 SQL Server 联机丛书。  
  
> [!CAUTION]
>  你可以强制 TCP，而不是共享的内存。 你可以通过实现此前缀 tcp： 在连接中的服务器名字符串也可以使用 localhost。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.SqlClient.SqlCommand>和<xref:System.Data.SqlClient.SqlConnection>。 <xref:System.Data.SqlClient.SqlConnection>打开并将其设置为<xref:System.Data.SqlClient.SqlCommand.Connection%2A>为<xref:System.Data.SqlClient.SqlCommand>。 该示例然后调用<xref:System.Data.SqlClient.SqlCommand.ExecuteNonQuery%2A>。 若要实现此目的，<xref:System.Data.SqlClient.SqlCommand.ExecuteNonQuery%2A>传递连接字符串和一个查询字符串[!INCLUDE[tsql](~/includes/tsql-md.md)]INSERT 语句。 在代码退出使用时自动关闭连接块。  
  
 [!code-csharp[Classic WebData SqlCommand.ExecuteNonQuery Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlCommand.ExecuteNonQuery Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlCommand.ExecuteNonQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlCommand.ExecuteNonQuery Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Data.SqlClient.SqlConnection" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlConnection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlConnection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Data.SqlClient.SqlConnection" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新实例时<xref:System.Data.SqlClient.SqlConnection>创建读/写属性设置为以下初始值，除非它们专门设置使用在其关联的关键字<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>属性。  
  
|属性|初始值|  
|----------------|-------------------|  
|<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>|空字符串 ("")|  
|<xref:System.Data.SqlClient.SqlConnection.ConnectionTimeout%2A>|15|  
|<xref:System.Data.SqlClient.SqlConnection.Database%2A>|空字符串 ("")|  
|<xref:System.Data.SqlClient.SqlConnection.DataSource%2A>|空字符串 ("")|  
  
 你可以更改这些属性的值只能通过使用<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>属性。 <xref:System.Data.SqlClient.SqlConnectionStringBuilder>类提供用于创建和管理的连接字符串的内容的功能。  
  
   
  
## Examples  
 下面的示例创建并打开<xref:System.Data.SqlClient.SqlConnection>。  
  
 [!code-csharp[Classic WebData SqlConnection.SqlConnection Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.SqlConnection Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.SqlConnection Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.SqlConnection Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlConnection (string connectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlConnection(System::String ^ connectionString);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">用于打开 SQL Server 数据库的连接。</param>
        <summary>如果给定包含连接字符串的字符串，则初始化 <see cref="T:System.Data.SqlClient.SqlConnection" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新实例时<xref:System.Data.SqlClient.SqlConnection>创建读/写属性设置为以下初始值，除非它们专门设置使用在其关联的关键字<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>属性。  
  
|属性|初始值|  
|----------------|-------------------|  
|<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>|`connectionString`|  
|<xref:System.Data.SqlClient.SqlConnection.ConnectionTimeout%2A>|15|  
|<xref:System.Data.SqlClient.SqlConnection.Database%2A>|空字符串 ("")|  
|<xref:System.Data.SqlClient.SqlConnection.DataSource%2A>|空字符串 ("")|  
  
 你可以更改这些属性的值只能通过使用<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>属性。 <xref:System.Data.SqlClient.SqlConnection>类提供用于创建和管理的连接字符串的内容的功能。  
  
   
  
## Examples  
 下面的示例创建并打开<xref:System.Data.SqlClient.SqlConnection>。  
  
 [!code-csharp[Classic WebData SqlConnection.SqlConnection1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.SqlConnection1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.SqlConnection1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.SqlConnection1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlConnection (string connectionString, System.Data.SqlClient.SqlCredential credential);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString, class System.Data.SqlClient.SqlCredential credential) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.#ctor(System.String,System.Data.SqlClient.SqlCredential)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;xamarinandroid-7.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String, credential As SqlCredential)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlConnection(System::String ^ connectionString, System::Data::SqlClient::SqlCredential ^ credential);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public SqlConnection (string connectionString, System.Data.SqlClient.SqlCredential cred);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString, class System.Data.SqlClient.SqlCredential cred) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String, cred As SqlCredential)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlConnection(System::String ^ connectionString, System::Data::SqlClient::SqlCredential ^ cred);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" Index="0" />
        <Parameter Name="credential" Type="System.Data.SqlClient.SqlCredential" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="cred" Type="System.Data.SqlClient.SqlCredential" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="connectionString">不使用以下任何连接字符串关键字的连接字符串：<see langword="Integrated Security = true" />、 <see langword="UserId" />，或 <see langword="Password" />；或不使用 <see langword="ContextConnection = true" />。</param>
        <param name="credential">To be added.</param>
        <param name="cred">To be added.</param>
        <summary>初始化给定连接字符串的 <see cref="T:System.Data.SqlClient.SqlConnection" /> 类的新实例，而不使用包含用户识别号和密码的 <see langword="Integrated Security = true" /> 和 <see cref="T:System.Data.SqlClient.SqlCredential" /> 对象。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessToken">
      <MemberSignature Language="C#" Value="public string AccessToken { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessToken" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.AccessToken" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessToken As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessToken { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于连接的访问令牌。</summary>
        <value>用于连接的访问令牌。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginDbTransaction">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbTransaction BeginDbTransaction (System.Data.IsolationLevel isolationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Data.Common.DbTransaction BeginDbTransaction(valuetype System.Data.IsolationLevel isolationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.BeginDbTransaction(System.Data.IsolationLevel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Data::Common::DbTransaction ^ BeginDbTransaction(System::Data::IsolationLevel isolationLevel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isolationLevel" Type="System.Data.IsolationLevel" />
      </Parameters>
      <Docs>
        <param name="isolationLevel">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginTransaction">
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始数据库事务。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlTransaction BeginTransaction ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlTransaction BeginTransaction() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.BeginTransaction" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTransaction () As SqlTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlTransaction ^ BeginTransaction();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlTransaction</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始数据库事务。</summary>
        <returns>表示新事务的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令将映射到 BEGIN TRANSACTION 的 SQL Server 实现。  
  
 你必须显式提交或回滚事务使用<xref:System.Data.SqlClient.SqlTransaction.Commit%2A>或<xref:System.Data.SqlClient.SqlTransaction.Rollback%2A>方法。 若要确保 SQL Server 事务管理模型.NET Framework 数据提供程序正常运行，请避免使用其他事务管理模型，例如 SQL Server 提供的那一个。  
  
> [!NOTE]
>  如果不指定隔离级别，使用的默认隔离级别。 若要指定隔离级别与<xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>方法，请使用采用的重载`iso`参数 (<xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>)。 设置事务的隔离级别仍然保持事务完成后，直到关闭或断开连接。 隔离将级别设置为**快照**不启用快照隔离级别时的数据库中不会引发异常。 事务将在完成使用的默认隔离级别。  
  
> [!CAUTION]
>  如果启动事务，级别 16 或更高版本的错误发生在服务器上，事务将不会回滚直到<xref:System.Data.SqlClient.SqlDataReader.Read%2A>调用方法。 不引发任何异常**ExecuteReader**。  
  
> [!CAUTION]
>  当你的查询返回大量的数据和调用`BeginTransaction`、<xref:System.Data.SqlClient.SqlException>因为 SQL Server 不允许并行事务使用 MARS 时引发。 若要避免此问题，始终将关联事务与命令和 / 或连接之前任何读取器处于打开状态。  
  
 对 SQL Server 中的事务的详细信息，请参阅"显式事务"和 SQL Server 联机丛书中的"编码高效事务"。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.SqlClient.SqlConnection>和<xref:System.Data.SqlClient.SqlTransaction>。 它还演示如何使用<xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>、 <xref:System.Data.SqlClient.SqlTransaction.Commit%2A>，和<xref:System.Data.SqlClient.SqlTransaction.Rollback%2A>方法。  
  
 [!code-csharp[Classic WebData SqlConnection.BeginTransaction Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.BeginTransaction Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.SqlClient.SqlException">使用多个活动结果集 (MARS) 时，不允许并行事务。</exception>
        <exception cref="T:System.InvalidOperationException">不支持并行事务。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlTransaction BeginTransaction (System.Data.IsolationLevel iso);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlTransaction BeginTransaction(valuetype System.Data.IsolationLevel iso) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.BeginTransaction(System.Data.IsolationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTransaction (iso As IsolationLevel) As SqlTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlTransaction ^ BeginTransaction(System::Data::IsolationLevel iso);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iso" Type="System.Data.IsolationLevel" />
      </Parameters>
      <Docs>
        <param name="iso">事务应在其下运行的隔离级别。</param>
        <summary>以指定的隔离级别启动数据库事务。</summary>
        <returns>表示新事务的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令将映射到 BEGIN TRANSACTION 的 SQL Server 实现。  
  
 你必须显式提交或回滚事务使用<xref:System.Data.SqlClient.SqlTransaction.Commit%2A>或<xref:System.Data.SqlClient.SqlTransaction.Rollback%2A>方法。 若要确保 SQL Server 事务管理模型.NET Framework 数据提供程序正常运行，请避免使用其他事务管理模型，例如 SQL Server 提供的那一个。  
  
> [!NOTE]
>  提交或回滚事务后，事务的隔离级别仍然存在的所有后续命令处于自动提交模式 （SQL Server 默认值）。 这可能会产生意外的结果，如保持和锁定在行外的其他用户 REPEATABLE READ 隔离级别。 若要重置为默认值 (READ COMMITTED) 的隔离级别，请执行[!INCLUDE[tsql](~/includes/tsql-md.md)]设置事务隔离级别 READ COMMITTED 语句或调用<xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A?displayProperty=nameWithType>后跟来<xref:System.Data.SqlClient.SqlTransaction.Commit%2A?displayProperty=nameWithType>。 有关 SQL Server 隔离级别的详细信息，请参阅"隔离级别中数据库引擎"在 SQL Server 联机丛书。  
  
 对 SQL Server 中的事务的详细信息，请参阅"显式事务"和 SQL Server 联机丛书中的"编码高效事务"。  
  
> [!CAUTION]
>  当你的查询返回大量的数据和调用`BeginTransaction`、<xref:System.Data.SqlClient.SqlException>因为 SQL Server 不允许并行事务使用 MARS 时引发。 若要避免此问题，始终将关联事务与命令和 / 或连接之前任何读取器处于打开状态。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.SqlClient.SqlConnection>和<xref:System.Data.SqlClient.SqlTransaction>。 它还演示如何使用<xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>、 <xref:System.Data.SqlClient.SqlTransaction.Commit%2A>，和<xref:System.Data.SqlClient.SqlTransaction.Rollback%2A>方法。  
  
 [!code-csharp[Classic WebData SqlConnection.BeginTransaction1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.BeginTransaction1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.SqlClient.SqlException">使用多个活动结果集 (MARS) 时，不允许并行事务。</exception>
        <exception cref="T:System.InvalidOperationException">不支持并行事务。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlTransaction BeginTransaction (string transactionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlTransaction BeginTransaction(string transactionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.BeginTransaction(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTransaction (transactionName As String) As SqlTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlTransaction ^ BeginTransaction(System::String ^ transactionName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="transactionName">事务名称。</param>
        <summary>以指定的事务名称启动数据库事务。</summary>
        <returns>表示新事务的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令将映射到 BEGIN TRANSACTION 的 SQL Server 实现。  
  
 长度`transactionName`参数不能超过 32 个字符; 否则将引发异常。  
  
 中的值`transactionName`参数可在更高版本调用<xref:System.Data.SqlClient.SqlTransaction.Rollback%2A>并在`savePoint`参数<xref:System.Data.SqlClient.SqlTransaction.Save%2A>方法。  
  
 你必须显式提交或回滚事务使用<xref:System.Data.SqlClient.SqlTransaction.Commit%2A>或<xref:System.Data.SqlClient.SqlTransaction.Rollback%2A>方法。 若要确保[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]数据提供程序的 SQL Server 事务管理模型是否正常运行，请避免使用其他事务管理模型，例如 SQL Server 提供的。  
  
 对 SQL Server 中的事务的详细信息，请参阅"显式事务"和 SQL Server 联机丛书中的"编码高效事务"。  
  
> [!CAUTION]
>  当你的查询返回大量的数据和调用`BeginTransaction`、<xref:System.Data.SqlClient.SqlException>因为 SQL Server 不允许并行事务使用 MARS 时引发。 若要避免此问题，始终将关联事务与命令和 / 或连接之前任何读取器处于打开状态。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.SqlClient.SqlConnection>和<xref:System.Data.SqlClient.SqlTransaction>。 它还演示如何使用<xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>、 <xref:System.Data.SqlClient.SqlTransaction.Commit%2A>，和<xref:System.Data.SqlClient.SqlTransaction.Rollback%2A>方法。  
  
 [!code-csharp[Classic WebData SqlConnection.BeginTransaction2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.BeginTransaction2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.SqlClient.SqlException">使用多个活动结果集 (MARS) 时，不允许并行事务。</exception>
        <exception cref="T:System.InvalidOperationException">不支持并行事务。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlTransaction BeginTransaction (System.Data.IsolationLevel iso, string transactionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlTransaction BeginTransaction(valuetype System.Data.IsolationLevel iso, string transactionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.BeginTransaction(System.Data.IsolationLevel,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTransaction (iso As IsolationLevel, transactionName As String) As SqlTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlTransaction ^ BeginTransaction(System::Data::IsolationLevel iso, System::String ^ transactionName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iso" Type="System.Data.IsolationLevel" />
        <Parameter Name="transactionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="iso">事务应在其下运行的隔离级别。</param>
        <param name="transactionName">事务名称。</param>
        <summary>以指定的隔离级别和事务名称启动数据库事务。</summary>
        <returns>表示新事务的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此命令将映射到 BEGIN TRANSACTION 的 SQL Server 实现。  
  
 中的值`transactionName`参数可在更高版本调用<xref:System.Data.SqlClient.SqlTransaction.Rollback%2A>并在`savePoint`参数<xref:System.Data.SqlClient.SqlTransaction.Save%2A>方法。  
  
 你必须显式提交或回滚事务使用<xref:System.Data.SqlClient.SqlTransaction.Commit%2A>或<xref:System.Data.SqlClient.SqlTransaction.Rollback%2A>方法。 若要确保 SQL Server 事务管理模型正常运行，请避免使用其他事务管理模型，例如 SQL Server 提供的那一个。  
  
> [!NOTE]
>  提交或回滚事务后，事务的隔离级别仍然存在的所有后续命令处于自动提交模式 （SQL Server 默认值）。 这可能会产生意外的结果，如保持和锁定在行外的其他用户 REPEATABLE READ 隔离级别。 若要重置为默认值 (READ COMMITTED) 的隔离级别，请执行[!INCLUDE[tsql](~/includes/tsql-md.md)]设置事务隔离级别 READ COMMITTED 语句或调用<xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A?displayProperty=nameWithType>后跟来<xref:System.Data.SqlClient.SqlTransaction.Commit%2A?displayProperty=nameWithType>。 有关 SQL Server 隔离级别的详细信息，请参阅"隔离级别中数据库引擎"在 SQL Server 联机丛书。  
  
 对 SQL Server 中的事务的详细信息，请参阅"显式事务"和 SQL Server 联机丛书中的"编码高效事务"。  
  
> [!CAUTION]
>  当你的查询返回大量的数据和调用`BeginTransaction`、<xref:System.Data.SqlClient.SqlException>因为 SQL Server 不允许并行事务使用 MARS 时引发。 若要避免此问题，始终将关联事务与命令和 / 或连接之前任何读取器处于打开状态。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.SqlClient.SqlConnection>和<xref:System.Data.SqlClient.SqlTransaction>。 它还演示如何使用<xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>、 <xref:System.Data.SqlClient.SqlTransaction.Commit%2A>，和<xref:System.Data.SqlClient.SqlTransaction.Rollback%2A>方法。  
  
 [!code-csharp[Classic WebData SqlConnection.BeginTransaction3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.BeginTransaction3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.SqlClient.SqlException">使用多个活动结果集 (MARS) 时，不允许并行事务。</exception>
        <exception cref="T:System.InvalidOperationException">不支持并行事务。</exception>
      </Docs>
    </Member>
    <Member MemberName="ChangeDatabase">
      <MemberSignature Language="C#" Value="public override void ChangeDatabase (string database);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ChangeDatabase(string database) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ChangeDatabase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ChangeDatabase (database As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ChangeDatabase(System::String ^ database);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDbConnection.ChangeDatabase(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="database" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="database">要代替当前数据库加以使用的数据库的名称。</param>
        <summary>更改已打开的 <see cref="T:System.Data.SqlClient.SqlConnection" /> 的当前数据库。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中提供的值`database`参数必须是有效的数据库名称。 `database`参数不能包含 null 值、 空字符串或仅有空白字符的字符串。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.SqlClient.SqlConnection>并显示部分只读属性。  
  
 [!code-csharp[Classic WebData SqlConnection.Database Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Database Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.Database Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Database Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">数据库名称无效。</exception>
        <exception cref="T:System.InvalidOperationException">连接未打开。</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">不能更改数据库。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChangePassword">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>更改 SQL Server 密码。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChangePassword">
      <MemberSignature Language="C#" Value="public static void ChangePassword (string connectionString, string newPassword);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChangePassword(string connectionString, string newPassword) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ChangePassword (connectionString As String, newPassword As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChangePassword(System::String ^ connectionString, System::String ^ newPassword);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="newPassword" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">包含连接至所需服务器的足够信息的连接字符串。 连接字符串必须包含用户 ID 和当前密码。</param>
        <param name="newPassword">要设置的新密码。 此密码必须符合服务器上设置的任何密码安全策略，包括最小长度、特定字符要求等等。</param>
        <summary>将连接字符串中指示的用户的 SQL Server 密码更改为提供的新密码。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你在 Windows Server 上使用 SQL Server 时，开发人员可以利用使客户端应用程序提供当前和新密码才能更改现有密码的功能。 应用程序可以实现功能，如在初始登录期间提示用户输入新密码，如果旧已过期，并且可以完成此操作，而无需管理员干预。  
  
 <xref:System.Data.SqlClient.SqlConnection.ChangePassword%2A>方法更改为用户提供所示的 SQL Server 密码`connectionString`参数中提供的值`newPassword`参数。 如果连接字符串将包括集成安全性的选项 (即"集成的安全性 = True"或同等身份)，将引发异常。  
  
 若要确定的密码已过期，这将调用<xref:System.Data.SqlClient.SqlConnection.Open%2A>方法引发<xref:System.Data.SqlClient.SqlException>。 若要指示，则必须重置连接字符串中包含的密码，<xref:System.Data.SqlClient.SqlException.Number%2A>异常的属性包含状态值 18487 或 18488。 第一个值 (18487) 指示的密码已过期，而第二个 (18488) 指示在登录之前，必须重置密码。  
  
 此方法打开其自己的连接到服务器，请求密码更改，并已完成后立即关闭连接。 此连接不检索从，也不返回到 SQL Server 连接池。  
  
   
  
## Examples  
 下面是更改密码的简单示例：  
  
```  
class Program {  
   static void Main(string[] args) {  
      System.Data.SqlClient.SqlConnection.ChangePassword(  
        "Data Source=a_server;Initial Catalog=a_database;UID=user;PWD=old_password",   
       "new_password");  
   }  
}  
  
```  
  
```  
Module Module1  
    Sub Main()  
System.Data.SqlClient.SqlConnection.ChangePassword(  
        "Data Source=a_server;Initial Catalog=a_database;UID=user;PWD=old_password",   
       "new_password")  
    End Sub  
End Module  
  
```  
  
 以下控制台应用程序演示涉及中更改用户的密码，因为当前的密码已过期的问题。  
  
 [!code-csharp[DataWorks SqlConnection.ChangePassword#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlConnection.ChangePassword/CS/source.cs#1)]
 [!code-vb[DataWorks SqlConnection.ChangePassword#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlConnection.ChangePassword/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">连接字符串包括将使用集成安全性的选项。  或  <paramref name="newPassword" /> 超过了 128 个字符。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connectionString" /> 或 <paramref name="newPassword" /> 参数为 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="ChangePassword">
      <MemberSignature Language="C#" Value="public static void ChangePassword (string connectionString, System.Data.SqlClient.SqlCredential credential, System.Security.SecureString newSecurePassword);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChangePassword(string connectionString, class System.Data.SqlClient.SqlCredential credential, class System.Security.SecureString newSecurePassword) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.Data.SqlClient.SqlCredential,System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ChangePassword (connectionString As String, credential As SqlCredential, newSecurePassword As SecureString)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChangePassword(System::String ^ connectionString, System::Data::SqlClient::SqlCredential ^ credential, System::Security::SecureString ^ newSecurePassword);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="credential" Type="System.Data.SqlClient.SqlCredential" />
        <Parameter Name="newSecurePassword" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="connectionString">包含连接至服务器的足够信息的连接字符串。 不应使用以下任何连接字符串关键字的连接字符串：<see langword="Integrated Security = true" />、 <see langword="UserId" />，或 <see langword="Password" />；或者 <see langword="ContextConnection = true" />。</param>
        <param name="credential">
          <see cref="T:System.Data.SqlClient.SqlCredential" /> 对象。</param>
        <param name="newSecurePassword">新密码。 <c>newSecurePassword</c> 必须为只读。 该密码也必须符合服务器上设置的任何密码安全策略（例如：最小长度、特定字符要求）。</param>
        <summary>更改 <see cref="T:System.Data.SqlClient.SqlCredential" /> 对象中指示的用户的 SQL Server 密码。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">1.连接字符串包含 <see langword="UserId" />、 <see langword="Password" /> 或 <see langword="Integrated Security=true" /> 的任意组合。  2.  连接字符串包含 <see langword="Context Connection=true" />。  3.  <paramref name="newSecurePassword" /> 的长度超过 128 个字符。  4.  <paramref name="newSecurePassword" /> 不是只读的。  5.  <paramref name="newSecurePassword" /> 是一个空字符串。</exception>
        <exception cref="T:System.ArgumentNullException">其中一个参数（<paramref name="connectionString" />、<paramref name="credential" /> 或 <paramref name="newSecurePassword" />）为 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="ClearAllPools">
      <MemberSignature Language="C#" Value="public static void ClearAllPools ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearAllPools() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ClearAllPools" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearAllPools ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearAllPools();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清空连接池。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection.ClearAllPools%2A> 重置 （或清空） 的连接池。 如果在调用时使用的连接，它们进行相应的标记并且将被放弃 （而不返回到池） 时<xref:System.Data.SqlClient.SqlConnection.Close%2A>对其调用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearPool">
      <MemberSignature Language="C#" Value="public static void ClearPool (System.Data.SqlClient.SqlConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearPool(class System.Data.SqlClient.SqlConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ClearPool(System.Data.SqlClient.SqlConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearPool (connection As SqlConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearPool(System::Data::SqlClient::SqlConnection ^ connection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.SqlClient.SqlConnection" />
      </Parameters>
      <Docs>
        <param name="connection">要从池中清除的 <see cref="T:System.Data.SqlClient.SqlConnection" />。</param>
        <summary>清空与指定连接关联的连接池。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection.ClearPool%2A> 清除与关联的连接池`connection`。 如果其他连接与关联`connection`是在使用中时调用的它们进行相应的标记，将被丢弃 （而不返回到池） 时<xref:System.Data.SqlClient.SqlConnection.Close%2A>对其调用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientConnectionId">
      <MemberSignature Language="C#" Value="public Guid ClientConnectionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ClientConnectionId" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ClientConnectionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientConnectionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ClientConnectionId { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最近连接尝试连接的 ID，无论该尝试是成功还是失败。</summary>
        <value>最近连接尝试的连接 ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection.ClientConnectionId%2A> 无论哪个版本的服务器的工作原理你连接到，但扩展的事件日志和上连接环形缓冲区错误项将不会显示在[!INCLUDE[sskatmai_r2](~/includes/sskatmai-r2-md.md)]及更早版本。  
  
 你可以扩展的事件日志，以查看是否在服务器上已失败是否启用日志记录连接 ID 的扩展的事件中找到的连接 ID。 你还可以连接环形缓冲区中找到的连接 ID ([连接中使用连接环形缓冲区的 SQL Server 2008 的故障排除](http://go.microsoft.com/fwlink/?LinkId=207752)) 对于某些连接错误。 如果连接 ID 不是连接环形缓冲区中，你可以假定网络错误。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDbConnection.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭与数据库之间的连接。 此方法是关闭任何打开连接的首选方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection.Close%2A>方法回滚任何挂起的事务。 然后，它将释放到连接池，连接或关闭的连接，如果禁用连接池。  
  
> [!NOTE]
>  挂起的事务开始使用[!INCLUDE[tsql](~/includes/tsql-md.md)]或<xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>连接重置时，如果启用了连接池时将自动回滚。 如果连接池处于关闭状态，则事务将回滚之后`SqlConnection.Close`调用。 通过启动事务<xref:System.Transactions>通过控制`System.Transactions`基础结构，而不受`SqlConnection.Close`。  
  
 应用程序可以调用<xref:System.Data.SqlClient.SqlConnection.Close%2A>不止一次。 不会生成异常。  
  
 如果<xref:System.Data.SqlClient.SqlConnection>超出范围，则不会关闭。 因此，必须显式关闭连接通过调用`Close`或`Dispose`。 `Close` 和`Dispose`在功能上等效。 如果连接池值`Pooling`设置为`true`或`yes`，则基础连接返回到连接池。 另一方面，如果`Pooling`设置为`false`或`no`，则基础到服务器的连接已关闭。  
  
> [!NOTE]
>  从连接池中提取连接或将连接返回到连接池时，服务器上不会引发登录和注销事件，这是因为在将连接返回到连接池时实际上并没有将其关闭。 有关详细信息，请参阅 [SQL Server 连接池 (ADO.NET)](~/docs/framework/data/adonet/sql-server-connection-pooling.md)。  
  
> [!CAUTION]
>  不要调用`Close`或`Dispose`连接、 DataReader 或在任何其他托管的对象上`Finalize`你类的方法。 在终结器中，你应仅释放类直接拥有的非托管的资源。 如果类不拥有任何非托管资源，则不要在类定义中包含 `Finalize` 方法。 有关详细信息，请参阅[垃圾回收](~/docs/standard/garbage-collection/index.md)。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.SqlClient.SqlConnection>、 将其打开、 显示它的一些属性。 连接会自动关闭的末尾`using`块。  
  
 [!code-csharp[Classic WebData SqlConnection.Open Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Open Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.Open Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Open Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.SqlClient.SqlException">打开连接时出现的连接级别的错误。</exception>
      </Docs>
    </Member>
    <Member MemberName="ColumnEncryptionKeyCacheTtl">
      <MemberSignature Language="C#" Value="public static TimeSpan ColumnEncryptionKeyCacheTtl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.TimeSpan ColumnEncryptionKeyCacheTtl" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ColumnEncryptionKeyCacheTtl" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ColumnEncryptionKeyCacheTtl As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property TimeSpan ColumnEncryptionKeyCacheTtl { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在用于 [Always Encrypted](/sql/relational-databases/security/encryption/always-encrypted-database-engine) 功能的列加密密钥缓存中，获取或设置列加密密钥项的生存时间。 默认值为 2 小时。 0 表示无缓存。</summary>
        <value>时间间隔。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnEncryptionQueryMetadataCacheEnabled">
      <MemberSignature Language="C#" Value="public static bool ColumnEncryptionQueryMetadataCacheEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool ColumnEncryptionQueryMetadataCacheEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ColumnEncryptionQueryMetadataCacheEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ColumnEncryptionQueryMetadataCacheEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool ColumnEncryptionQueryMetadataCacheEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示对参数化查询（针对已启用 [Always Encrypted](/sql/relational-databases/security/encryption/always-encrypted-database-engine) 的数据库运行）已启用 (True) 还是未启用 (False) 查询元数据缓存。 默认值为 true。</summary>
        <value>如果启用查询元数据缓存，则返回 True；否则返回 False。 默认为 True。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于参数化查询，SqlClient 往返将向发出 SQL Server 的参数元数据，以查看它需要加密的参数以及如何 （应使用哪个密钥和算法）。 如果应用程序调用相同的查询多个时间，一个额外往返生成指向服务器的每个时，这会降低应用程序性能。  
  
 与**ColumnEncryptionQueryMetadataCacheEnabled**设置为 true，如果多次调用了相同的查询，到服务器往返将进行一次。 缓存中有一个非可配置的最大大小参数，设置为 2000年查询。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnEncryptionTrustedMasterKeyPaths">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,System.Collections.Generic.IList&lt;string&gt;&gt; ColumnEncryptionTrustedMasterKeyPaths { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Generic.IDictionary`2&lt;string, class System.Collections.Generic.IList`1&lt;string&gt;&gt; ColumnEncryptionTrustedMasterKeyPaths" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ColumnEncryptionTrustedMasterKeyPaths" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ColumnEncryptionTrustedMasterKeyPaths As IDictionary(Of String, IList(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Generic::IDictionary&lt;System::String ^, System::Collections::Generic::IList&lt;System::String ^&gt; ^&gt; ^ ColumnEncryptionTrustedMasterKeyPaths { System::Collections::Generic::IDictionary&lt;System::String ^, System::Collections::Generic::IList&lt;System::String ^&gt; ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Collections.Generic.IList&lt;System.String&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>允许你设置数据库服务器的受信任密钥路径列表。 如果在处理应用程序查询时驱动程序接收到不位于列表中的密钥路径，则查询会失败。 此属性针对安全攻击提供附加保护，这些安全攻击涉及提供伪造密钥路径的受威胁的 SQL Server，可能导致密钥存储凭据泄露。</summary>
        <value>适用于列加密的受信任主密钥路径的列表。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectionString">
      <MemberSignature Language="C#" Value="public override string ConnectionString { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionString" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ConnectionString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionString { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbConnection.ConnectionString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.SQL.Design.SqlConnectionStringEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于打开 SQL Server 数据库的字符串。</summary>
        <value>连接字符串，其中包含源数据库名称和建立初始连接所需的其他参数。 默认值为一个空字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>类似于一个 OLE DB 连接字符串，但并不完全相同。 与 OLE DB 或 ADO，不同的连接字符串，则返回等同于用户设置<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>，安全信息如果 Persist Security Info 值设置为减`false`（默认值）。 SQL Server.NET Framework 数据提供程序不会保留或返回一个连接字符串中的密码，除非 Persist Security Info 设置为`true`。  
  
 你可以使用<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>属性，以连接到数据库。 下面的示例演示一个典型的连接字符串。  
  
```  
"Persist Security Info=False;Integrated Security=true;Initial Catalog=Northwind;server=(local)"  
```  
  
 使用新<xref:System.Data.SqlClient.SqlConnectionStringBuilder>可以在运行时构造有效的连接字符串。 有关详细信息，请参阅[连接字符串生成器](~/docs/framework/data/adonet/connection-string-builders.md)。  
  
 <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>关闭连接时，才可以设置属性。 连接字符串值的许多具有相应的只读属性。 当设置连接字符串时，将更新这些属性，除非当检测到错误。 在这种情况下，不会更新任何属性。 <xref:System.Data.SqlClient.SqlConnection> 属性返回中包含的那些设置<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>。  
  
 若要连接到本地计算机，指定"(local)"的服务器。 如果未指定服务器名称，将尝试连接到本地计算机上的默认实例。  
  
 重置<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>关闭的连接将重置所有连接字符串值 （和相关的属性） 包括密码。 例如，如果你设置的连接字符串，包括"数据库 = AdventureWorks"，然后重置的连接字符串"数据源 = myserver; 集成的安全性 = true"，则<xref:System.Data.SqlClient.SqlConnection.Database%2A>属性不能再设置为"AdventureWorks"。  
  
 在设置之后立即分析连接字符串。 如果在分析时，运行时异常，如发现语法中的错误<xref:System.ArgumentException>，生成。 仅当尝试打开连接时，可以找到其他错误。  
  
 连接字符串的基本格式包含一系列的用分号分隔的关键字/值对。 每个关键字和它的值之间用等号 (=) 连接。 若要包含的值包含分号、 单引号字符或双引号字符，则该值必须括在双引号内。 如果值包含分号和双引号字符，则该值可以括在单引号中。 单引号也是有用的值以双引号字符开头。 相反，如果值以单引号开头，则可以使用双引号。 如果值包含单引号和双引号字符，每次它的值中发生时，用于将值括起来的引号字符必须采用双重方括号。  
  
 若要包含前导或尾随空格的字符串值，则该值必须括在单引号或双引号中。 忽略任何前导空格或尾随空格围绕整数、 布尔值或枚举的值，即使用引号引起来。 但是，将保留在字符串文字关键字或值中的空间。 而不使用分隔符，可能在连接字符串中使用单引号或双引号引号 (例如，数据源 = my'Server 或数据源 = 我的"服务器)，除非引号字符的值中的第一个或最后一个字符。  
  
 关键字不区分大小写。  
  
 下表列出了中的关键字值的有效名称<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>。  
  
  以下列表包含的连接池内的值的有效名称<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>。 有关详细信息，请参阅 [SQL Server 连接池 (ADO.NET)](~/docs/framework/data/adonet/sql-server-connection-pooling.md)。  
  
-   Connection Lifetime （或 Load Balance Timeout）  
  
-   Enlist  
  
-   Max Pool Size  
  
-   Min Pool Size  
  
-   Pooling  
  
 在设置关键字或连接池需要一个布尔值的值时，你可以是使用而不是 'true'，和否而不是 'false'。 整数值表示为字符串。  
  
> [!NOTE]
>  SQL Server.NET Framework 数据提供程序使用其自己的协议与 SQL Server 进行通信。 因此，它不支持使用 ODBC 数据源名称 (DSN) 时连接到 SQL Server，因为它不会添加一个 ODBC 层。  
  
> [!NOTE]
>  通用数据链接 (UDL) 文件不支持.NET Framework 数据提供程序为 SQL Server。  
  
> [!CAUTION]
>  在此版本中，应用程序时应小心构造根据用户输入 （例如，从一个对话框，并将其追加到连接字符串中检索用户 ID 和密码信息时） 的连接字符串。 应用程序应确保用户不能嵌入在这些值中的其他连接字符串参数 (例如，输入一个密码作为"validpassword; 数据库 = somedb"尝试附加到不同数据库中)。 如果你需要构造基于用户输入的连接字符串，使用新<xref:System.Data.SqlClient.SqlConnectionStringBuilder>，它验证的连接字符串，并有助于避免此问题。 请参阅[连接字符串生成器](~/docs/framework/data/adonet/connection-string-builders.md)有关详细信息。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.SqlClient.SqlConnection>和设置<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>之前打开连接的属性。  
  
 [!code-csharp[Classic WebData SqlConnection.ConnectionString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.ConnectionString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.ConnectionString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.ConnectionString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">提供了一个无效的连接字符串参数，或者未提供所需的连接字符串参数。</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionTimeout">
      <MemberSignature Language="C#" Value="public override int ConnectionTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ConnectionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ConnectionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ConnectionTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ConnectionTimeout { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbConnection.ConnectionTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取终止尝试并生成错误之前在尝试建立连接时所等待的时间。</summary>
        <value>等待连接打开所需的时间（以秒为单位）。 默认值为 15 秒。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以通过使用连接等待的时间量设置为超时`Connect Timeout`或`Connection Timeout`连接字符串中的关键字。 值为 0 表示没有限制，，应当避免在<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>由于尝试连接将无限期等待。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.SqlClient.SqlConnection>和设置`Connection Timeout`到连接字符串中的 30 秒。 该代码打开连接，并显示<xref:System.Data.SqlClient.SqlConnection.ConnectionTimeout%2A>在控制台窗口中的属性。  
  
 [!code-csharp[Classic WebData SqlConnection.ConnectionTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.ConnectionTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.ConnectionTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.ConnectionTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">设置的值小于 0。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCommand">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCommand CreateCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlCommand CreateCommand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.CreateCommand" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCommand () As SqlCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlCommand ^ CreateCommand();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCommand</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建并返回与 <see cref="T:System.Data.SqlClient.SqlConnection" /> 关联的 <see cref="T:System.Data.SqlClient.SqlCommand" /> 对象。</summary>
        <returns>
          <see cref="T:System.Data.SqlClient.SqlCommand" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[SqlConnection_CreateCommand#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/sqlconnection_createcommand/cs/source.cs#1)]
 [!code-vb[SqlConnection_CreateCommand#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/sqlconnection_createcommand/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDbCommand">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbCommand CreateDbCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Data.Common.DbCommand CreateDbCommand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.CreateDbCommand" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateDbCommand () As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Data::Common::DbCommand ^ CreateDbCommand();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Credential">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCredential Credential { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.SqlClient.SqlCredential Credential" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.Credential" />
      <MemberSignature Language="VB.NET" Value="Public Property Credential As SqlCredential" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SqlClient::SqlCredential ^ Credential { System::Data::SqlClient::SqlCredential ^ get(); void set(System::Data::SqlClient::SqlCredential ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCredential</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此连接的 <see cref="T:System.Data.SqlClient.SqlCredential" /> 对象。</summary>
        <value>此连接的 <see cref="T:System.Data.SqlClient.SqlCredential" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Persist Security Info = true` 获取的值所需<xref:System.Data.SqlClient.SqlCredential>对象<xref:System.Data.SqlClient.SqlConnection.Credential%2A>。  
  
 默认值<xref:System.Data.SqlClient.SqlConnection.Credential%2A>为 null。  
  
 <xref:System.InvalidOperationException>将引发异常：  
  
-   如果<xref:System.Data.SqlClient.SqlConnection.Credential%2A>对打开的连接设置。  
  
-   如果<xref:System.Data.SqlClient.SqlConnection.Credential%2A>时会设置`Context Connection=true`。  
  
-   如果<xref:System.Data.SqlClient.SqlConnection.Credential%2A>时会设置`Integrated Security = true`。  
  
-   如果<xref:System.Data.SqlClient.SqlConnection.Credential%2A>时使用的连接字符串设置`Password`。  
  
-   如果<xref:System.Data.SqlClient.SqlConnection.Credential%2A>时使用的连接字符串设置`UserID`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCredential Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.SqlClient.SqlCredential Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Property Credentials As SqlCredential" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SqlClient::SqlCredential ^ Credentials { System::Data::SqlClient::SqlCredential ^ get(); void set(System::Data::SqlClient::SqlCredential ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCredential</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Database">
      <MemberSignature Language="C#" Value="public override string Database { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Database" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.Database" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Database As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Database { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbConnection.Database</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前数据库的名称或打开连接后要使用的数据库的名称。</summary>
        <value>当前数据库的名称或打开连接后要使用的数据库的名称。 默认值为一个空字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection.Database%2A>属性会动态更新。 如果你更改当前的数据库使用[!INCLUDE[tsql](~/includes/tsql-md.md)]语句或<xref:System.Data.SqlClient.SqlConnection.ChangeDatabase%2A>方法，发送一条信息性消息，并自动更新的属性。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.SqlClient.SqlConnection>并显示部分只读属性。  
  
 [!code-csharp[Classic WebData SqlConnection.Database Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Database Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.Database Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Database Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSource">
      <MemberSignature Language="C#" Value="public override string DataSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSource" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.DataSource" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DataSource As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DataSource { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取要连接的 SQL Server 的实例的名称。</summary>
        <value>要连接到的 SQL Server 实例的名称。 默认值为一个空字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Data.SqlClient.SqlConnection.DataSource%2A>属性返回`null`如果该连接字符串，为<xref:System.Data.SqlClient.SqlConnection>是"上下文连接 = true"。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.SqlClient.SqlConnection>并显示部分只读属性。  
  
 [!code-csharp[Classic WebData SqlConnection.DataSource Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.DataSource Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.DataSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.DataSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DbProviderFactory">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbProviderFactory DbProviderFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbProviderFactory DbProviderFactory" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.DbProviderFactory" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DbProviderFactory As DbProviderFactory" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Data::Common::DbProviderFactory ^ DbProviderFactory { System::Data::Common::DbProviderFactory ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbProviderFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnlistDistributedTransaction">
      <MemberSignature Language="C#" Value="public void EnlistDistributedTransaction (System.EnterpriseServices.ITransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnlistDistributedTransaction(class System.EnterpriseServices.ITransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.EnlistDistributedTransaction(System.EnterpriseServices.ITransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnlistDistributedTransaction (transaction As ITransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnlistDistributedTransaction(System::EnterpriseServices::ITransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.EnterpriseServices.ITransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">对用于登记的现有 <see cref="T:System.EnterpriseServices.ITransaction" /> 的引用。</param>
        <summary>在指定的事务中登记为分布式事务。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用<xref:System.Data.SqlClient.SqlConnection.EnlistTransaction%2A>方法在分布式事务中登记。 因为它登记中的连接<xref:System.Transactions.Transaction>实例， **EnlistTransaction**中可用的功能利用<xref:System.Transactions>命名空间用于管理分布式事务，使其优于**EnlistDistributedTransaction**为此目的。 有关详细信息，请参阅[分布式事务](~/docs/framework/data/adonet/distributed-transactions.md)。  
  
 你可以继续在现有使用分布式的事务中登记**EnlistDistributedTransaction**方法如果禁用了自动登记。 在现有分布式事务中登记可以确保，如果事务是提交还是回滚，数据源的代码所做的修改也提交或回滚。  
  
 `EnlistDistributedTransaction` 如果返回异常<xref:System.Data.SqlClient.SqlConnection>已经启动了事务使用<xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>。 但是，如果事务是在数据源上开始的本地事务 (例如，通过显式执行 BEGIN TRANSACTION 语句使用<xref:System.Data.SqlClient.SqlCommand>对象)， **EnlistDistributedTransaction**回滚本地事务并根据请求在现有分布式事务中登记。 你不会收到通知，该本地事务已回滚，并且会负责管理任何本地事务没有启动使用<xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnlistTransaction">
      <MemberSignature Language="C#" Value="public override void EnlistTransaction (System.Transactions.Transaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EnlistTransaction(class System.Transactions.Transaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.EnlistTransaction(System.Transactions.Transaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EnlistTransaction(System::Transactions::Transaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Transactions.Transaction" />
      </Parameters>
      <Docs>
        <param name="transaction">对用于登记的现有 <see cref="T:System.Transactions.Transaction" /> 的引用。</param>
        <summary>在指定的事务中登记为分布式事务。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用<xref:System.Data.SqlClient.SqlConnection.EnlistTransaction%2A>方法在分布式事务中登记。 因为它登记中的连接<xref:System.Transactions.Transaction>实例， **EnlistTransaction**中可用的功能利用<xref:System.Transactions>命名空间用于管理分布式事务，使其优于**EnlistDistributedTransaction**，它使用**System.EnterpriseServices.ITransaction**对象。 它还具有略有不同的语义： 后在事务中显式登记连接，不能取消登记或第一个事务完成之前在另一个事务中登记。 有关分布式事务的详细信息，请参阅[分布式事务](~/docs/framework/data/adonet/distributed-transactions.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FireInfoMessageEventOnUserErrors">
      <MemberSignature Language="C#" Value="public bool FireInfoMessageEventOnUserErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FireInfoMessageEventOnUserErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property FireInfoMessageEventOnUserErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool FireInfoMessageEventOnUserErrors { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="P:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" /> 属性。</summary>
        <value>如果已设置了 <see cref="P:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" /> 属性，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你将设置<xref:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors%2A>到`true`，则以前视为作为现在处理异常的错误<xref:System.Data.SqlClient.SqlConnection.InfoMessage>事件。 立即激发和事件处理程序处理的所有事件。 如果是<xref:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors%2A>设置为`false`，然后<xref:System.Data.SqlClient.SqlConnection.InfoMessage>事件处理过程的结尾处。  
  
> [!NOTE]
>  导致服务器停止处理命令的错误严重级别为 17 或更高版本需要作为异常进行处理。 在这种情况下，无论如何在 <xref:System.Data.SqlClient.SqlConnection.InfoMessage> 事件中处理该错误，都会引发异常。  
  
 有关处理事件的详细信息，请参阅[连接事件](~/docs/framework/data/adonet/connection-events.md)。 有关由 SQL Server 引擎生成的错误的详细信息，请参阅 SQL Server 联机丛书。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回此 <see cref="T:System.Data.SqlClient.SqlConnection" /> 的数据源的架构信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你尝试检索多个版本控制的存储过程的架构信息时，最新的项目的架构仅返回。 有关版本控制的存储过程的详细信息，请参阅 SQL Server 联机丛书。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchema () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchema();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.Data.SqlClient.SqlConnection" /> 的数据源的架构信息。 有关架构的详细信息，请参阅 [SQL Server 架构集合](http://msdn.microsoft.com/library/ms254969.aspx)。</summary>
        <returns>包含架构信息的 <see cref="T:System.Data.DataTable" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchema (string collectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchema(string collectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.GetSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchema (collectionName As String) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchema(System::String ^ collectionName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="collectionName">指定要返回的架构的名称。</param>
        <summary>使用表示架构名称的指定字符串返回此 <see cref="T:System.Data.SqlClient.SqlConnection" /> 的数据源的架构信息。</summary>
        <returns>包含架构信息的 <see cref="T:System.Data.DataTable" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可能需要数据库、 表或列的架构的信息。 此示例中：  
  
-   使用 GetSchema 获取架构信息。  
  
-   使用架构限制来获取指定的信息。  
  
-   获取架构信息的数据库、 表和某些列。  
  
 运行示例之前，你需要创建示例数据库中，使用以下[!INCLUDE[tsql](~/includes/tsql-md.md)]:  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 [如何从数据库获取架构信息](https://code.msdn.microsoft.com/How-to-Get-Schema-b66d62e2)Visual Studio 项目中都有此代码示例的 C# 和 Visual Basic 版本。  
  
```  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
      using (SqlConnection conn = new SqlConnection("Data Source=(local);Initial Catalog=MySchool;Integrated Security=True;Asynchronous Processing=true;")) {  
         conn.Open();  
  
         // Get the Meta Data for Supported Schema Collections  
         DataTable metaDataTable = conn.GetSchema("MetaDataCollections");  
  
         Console.WriteLine("Meta Data for Supported Schema Collections:");  
         ShowDataTable(metaDataTable, 25);  
         Console.WriteLine();  
  
         // Get the schema information of Databases in your instance  
         DataTable databasesSchemaTable = conn.GetSchema("Databases");  
  
         Console.WriteLine("Schema Information of Databases:");  
         ShowDataTable(databasesSchemaTable, 25);  
         Console.WriteLine();  
  
         // First, get schema information of all the tables in current database;  
         DataTable allTablesSchemaTable = conn.GetSchema("Tables");  
  
         Console.WriteLine("Schema Information of All Tables:");  
         ShowDataTable(allTablesSchemaTable, 20);  
         Console.WriteLine();  
  
         // You can specify the Catalog, Schema, Table Name, Table Type to get   
         // the specified table(s).  
         // You can use four restrictions for Table, so you should create a 4 members array.  
         String[] tableRestrictions = new String[4];  
  
         // For the array, 0-member represents Catalog; 1-member represents Schema;   
         // 2-member represents Table Name; 3-member represents Table Type.   
         // Now we specify the Table Name of the table what we want to get schema information.  
         tableRestrictions[2] = "Course";  
  
         DataTable courseTableSchemaTable = conn.GetSchema("Tables", tableRestrictions);  
  
         Console.WriteLine("Schema Information of Course Tables:");  
         ShowDataTable(courseTableSchemaTable, 20);  
         Console.WriteLine();  
  
         // First, get schema information of all the columns in current database.  
         DataTable allColumnsSchemaTable = conn.GetSchema("Columns");  
  
         Console.WriteLine("Schema Information of All Columns:");  
         ShowColumns(allColumnsSchemaTable);  
         Console.WriteLine();  
  
         // You can specify the Catalog, Schema, Table Name, Column Name to get the specified column(s).  
         // You can use four restrictions for Column, so you should create a 4 members array.  
         String[] columnRestrictions = new String[4];  
  
         // For the array, 0-member represents Catalog; 1-member represents Schema;   
         // 2-member represents Table Name; 3-member represents Column Name.   
         // Now we specify the Table_Name and Column_Name of the columns what we want to get schema information.  
         columnRestrictions[2] = "Course";  
         columnRestrictions[3] = "DepartmentID";  
  
         DataTable departmentIDSchemaTable = conn.GetSchema("Columns", columnRestrictions);  
  
         Console.WriteLine("Schema Information of DepartmentID Column in Course Table:");  
         ShowColumns(departmentIDSchemaTable);  
         Console.WriteLine();  
  
         // First, get schema information of all the IndexColumns in current database  
         DataTable allIndexColumnsSchemaTable = conn.GetSchema("IndexColumns");  
  
         Console.WriteLine("Schema Information of All IndexColumns:");  
         ShowIndexColumns(allIndexColumnsSchemaTable);  
         Console.WriteLine();  
  
         // You can specify the Catalog, Schema, Table Name, Constraint Name, Column Name to   
         // get the specified column(s).  
         // You can use five restrictions for Column, so you should create a 5 members array.  
         String[] indexColumnsRestrictions = new String[5];  
  
         // For the array, 0-member represents Catalog; 1-member represents Schema;   
         // 2-member represents Table Name; 3-member represents Constraint Name;4-member represents Column Name.   
         // Now we specify the Table_Name and Column_Name of the columns what we want to get schema information.  
         indexColumnsRestrictions[2] = "Course";  
         indexColumnsRestrictions[4] = "CourseID";  
  
         DataTable courseIdIndexSchemaTable = conn.GetSchema("IndexColumns", indexColumnsRestrictions);  
  
         Console.WriteLine("Index Schema Information of CourseID Column in Course Table:");  
         ShowIndexColumns(courseIdIndexSchemaTable);  
         Console.WriteLine();  
      }  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   private static void ShowDataTable(DataTable table, Int32 length) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-" + length + "}", col.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         foreach (DataColumn col in table.Columns) {  
            if (col.DataType.Equals(typeof(DateTime)))  
               Console.Write("{0,-" + length + ":d}", row[col]);  
            else if (col.DataType.Equals(typeof(Decimal)))  
               Console.Write("{0,-" + length + ":C}", row[col]);  
            else  
               Console.Write("{0,-" + length + "}", row[col]);  
         }  
         Console.WriteLine();  
      }  
   }  
  
   private static void ShowDataTable(DataTable table) {  
      ShowDataTable(table, 14);  
   }  
  
   private static void ShowColumns(DataTable columnsTable) {  
      var selectedRows = from info in columnsTable.AsEnumerable()  
                         select new {  
                            TableCatalog = info["TABLE_CATALOG"],  
                            TableSchema = info["TABLE_SCHEMA"],  
                            TableName = info["TABLE_NAME"],  
                            ColumnName = info["COLUMN_NAME"],  
                            DataType = info["DATA_TYPE"]  
                         };  
  
      Console.WriteLine("{0,-15}{1,-15}{2,-15}{3,-15}{4,-15}", "TableCatalog", "TABLE_SCHEMA",  
          "TABLE_NAME", "COLUMN_NAME", "DATA_TYPE");  
      foreach (var row in selectedRows) {  
         Console.WriteLine("{0,-15}{1,-15}{2,-15}{3,-15}{4,-15}", row.TableCatalog,  
             row.TableSchema, row.TableName, row.ColumnName, row.DataType);  
      }  
   }  
  
   private static void ShowIndexColumns(DataTable indexColumnsTable) {  
      var selectedRows = from info in indexColumnsTable.AsEnumerable()  
                         select new {  
                            TableSchema = info["table_schema"],  
                            TableName = info["table_name"],  
                            ColumnName = info["column_name"],  
                            ConstraintSchema = info["constraint_schema"],  
                            ConstraintName = info["constraint_name"],  
                            KeyType = info["KeyType"]  
                         };  
  
      Console.WriteLine("{0,-14}{1,-11}{2,-14}{3,-18}{4,-16}{5,-8}", "table_schema", "table_name", "column_name", "constraint_schema", "constraint_name", "KeyType");  
      foreach (var row in selectedRows) {  
         Console.WriteLine("{0,-14}{1,-11}{2,-14}{3,-18}{4,-16}{5,-8}", row.TableSchema,  
             row.TableName, row.ColumnName, row.ConstraintSchema, row.ConstraintName, row.KeyType);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="collectionName" /> 被指定为空。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchema (string collectionName, string[] restrictionValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchema(string collectionName, string[] restrictionValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.GetSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchema (collectionName As String, restrictionValues As String()) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchema(System::String ^ collectionName, cli::array &lt;System::String ^&gt; ^ restrictionValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionName" Type="System.String" />
        <Parameter Name="restrictionValues" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="collectionName">指定要返回的架构的名称。</param>
        <param name="restrictionValues">请求的架构的一组限制值。</param>
        <summary>使用表示架构名称的指定字符串以及表示限制值的指定字符串数组返回此 <see cref="T:System.Data.SqlClient.SqlConnection" /> 的数据源的架构信息。</summary>
        <returns>包含架构信息的 <see cref="T:System.Data.DataTable" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `restrictionValues`参数可以提供*n*深度的值，指定特定集合的限制集合。 若要对给定的限制，设置值，并且未设置其他限制的值，你需要将前面的限制条件设置为`null`然后将为你想要为指定值的限制中的相应值。  
  
 此示例为"表"集合。 如果"表"集合具有三个限制-数据库、 所有者、 表名称--并且想要取回仅与"Carl"的所有者关联的表，请将传递以下值： null，"Carl"。 如果未传入限制值，默认值用于该限制。 这是相同的映射与传入`null`，即不同于传入的参数值为空字符串。 在这种情况下，空字符串 ("") 被视为可为指定的参数的值。  
  
 有关代码示例演示<xref:System.Data.SqlClient.SqlConnection.GetSchema%2A>，请参阅<xref:System.Data.SqlClient.SqlConnection.GetSchema%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="collectionName" /> 被指定为空。</exception>
        <altmember cref="M:System.Data.SqlClient.SqlConnection.GetSchema" />
      </Docs>
    </Member>
    <Member MemberName="InfoMessage">
      <MemberSignature Language="C#" Value="public event System.Data.SqlClient.SqlInfoMessageEventHandler InfoMessage;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.SqlClient.SqlInfoMessageEventHandler InfoMessage" />
      <MemberSignature Language="DocId" Value="E:System.Data.SqlClient.SqlConnection.InfoMessage" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InfoMessage As SqlInfoMessageEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::SqlClient::SqlInfoMessageEventHandler ^ InfoMessage;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlInfoMessageEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 SQL Server 返回一个警告或信息性消息时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要处理警告或信息性消息由服务器发送客户端应创建<xref:System.Data.SqlClient.SqlInfoMessageEventHandler>委托来侦听此事件。  
  
 <xref:System.Data.SqlClient.SqlConnection.InfoMessage>事件发生时的严重级别为 10 的消息或 SQL Server 返回更少。 11 到 20 之间的严重性的消息将引发错误和消息严重性相比，20 原因要关闭的连接。 有关 SQL Server 错误级别的详细信息，请参阅 SQL Server 联机丛书中的"数据库的引擎错误严重性"。  
  
 有关详细信息及示例，请参阅[连接事件](~/docs/framework/data/adonet/connection-events.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public override void Open ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Open() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.Open" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Open ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Open();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDbConnection.Open</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用由 <see cref="P:System.Data.SqlClient.SqlConnection.ConnectionString" /> 指定的属性设置打开一个数据库连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection>从连接池中绘制的开放连接，如果有的话。 否则，它在建立新连接到 SQL Server 的实例。  
  
> [!NOTE]
>  如果<xref:System.Data.SqlClient.SqlConnection>超出范围，它没有闭合是。 因此，必须显式关闭连接通过调用<xref:System.Data.SqlClient.SqlConnection.Close%2A>。  
  
> [!NOTE]
>  如果你指定时要连接到 SQL Server 和使用 TCP/IP，以外的其他协议的一个实例的 1433年以外的端口号<xref:System.Data.SqlClient.SqlConnection.Open%2A>方法失败。 若要指定除 1433年以外的端口号，包括"server = machinename，端口号"中的连接字符串和使用 TCP/IP 协议。  
  
> [!NOTE]
>  SQL Server.NET Framework 数据提供程序需要使用"允许对非托管程序集调用"启用安全权限 (<xref:System.Security.Permissions.SecurityPermission>与<xref:System.Security.Permissions.SecurityPermissionFlag>设置为`UnmanagedCode`) 以打开<xref:System.Data.SqlClient.SqlConnection>启用 SQL 调试。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.SqlClient.SqlConnection>，打开它，并显示它的一些属性。 连接会自动关闭的末尾`using`块。  
  
 [!code-csharp[Classic WebData SqlConnection.Open Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Open Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.Open Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Open Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">如果不指定数据源或服务器，则无法打开连接。  或-  连接已打开。</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">打开连接时出现的连接级别错误。 如果 <see cref="P:System.Data.SqlClient.SqlException.Number" /> 属性包含值 18487 或 18488，这表明指定的密码已过期或必须重置。 有关更多信息，请参阅 <see cref="M:System.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.String)" /> 方法。  App.config 文件中的 <see langword="&lt;system.data.localdb&gt;" /> 标记具有无效或未知元素。</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <see langword="&lt;localdbinstances&gt;" /> 部分中有两个具有相同名称的条目。</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task OpenAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task OpenAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ OpenAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">取消指令。</param>
        <summary>
          <see cref="M:System.Data.SqlClient.SqlConnection.Open" /> 的异步版本，打开 <see cref="P:System.Data.SqlClient.SqlConnection.ConnectionString" /> 指定的属性设置的数据库连接。 取消标记可用于请求在连接超时超过前放弃操作。  异常将通过返回的任务传播。 如果在未成功连接的情况下连接超时时间已过，则返回的任务将被标记为“附带异常出错”。 实现返回一个不带有用于共用和非共用连接的锁定调用线程的“任务”。</summary>
        <returns>表示异步操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用<xref:System.Data.SqlClient.SqlConnection.OpenAsync%2A>，<xref:System.Data.SqlClient.SqlConnection.State%2A>必须返回<xref:System.Data.ConnectionState.Connecting>直到返回<xref:System.Threading.Tasks.Task>完成。 然后，如果连接成功，<xref:System.Data.SqlClient.SqlConnection.State%2A>必须返回<xref:System.Data.ConnectionState.Open>。 如果连接失败，<xref:System.Data.SqlClient.SqlConnection.State%2A>必须返回<xref:System.Data.ConnectionState.Closed>。  
  
 调用<xref:System.Data.SqlClient.SqlConnection.Close%2A>将尝试取消或关闭相应<xref:System.Data.SqlClient.SqlConnection.OpenAsync%2A>调用。  
  
 有关 SQL Server 的.NET Framework 数据提供程序中的异步编程的详细信息，请参阅[异步编程](~/docs/framework/data/adonet/asynchronous-programming.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在完成任务前，为同一个实例多次调用 <see cref="M:System.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" />。  
  
 在连接字符串中指定 <see langword="Context Connection=true" />。  在经过连接超时时间之前从连接池中的连接不可用。</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">打开连接时出现的任何由 SQL Server 返回的错误。</exception>
      </Docs>
    </Member>
    <Member MemberName="PacketSize">
      <MemberSignature Language="C#" Value="public int PacketSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PacketSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.PacketSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PacketSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PacketSize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于与 SQL Server 的实例进行通信的网络数据包的大小（以字节为单位）。</summary>
        <value>网络数据包的大小（以字节为单位）。 默认值为 8000。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果应用程序执行大容量复制操作，或发送或接收大量文本或图像数据，数据包大小大于默认值可能会提高效率，因为它会导致更少的网络读取和写入操作。 如果应用程序发送和接收的信息的信息量很小，你可以将数据包大小设置为 512 个字节 (使用中的数据包大小值<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>)，这对于大多数数据传输操作已经足够。 对于大多数应用程序，默认数据包大小为最佳数值。  
  
 <xref:System.Data.SqlClient.SqlConnection.PacketSize%2A> 可能的 512 和 32767 之间的字节范围中的值。 如果值超出了此范围，则会生成异常。  
  
 将默认值设置为一个数字大于 8000 将导致数据包，而不是要高效得多的 SinglePage 分配器，减少 SQL Server 的整体可伸缩性的 SQL Server 实例上使用多页的分配器。 SQL Server 如何使用内存的详细信息，请参阅[内存体系结构](http://go.microsoft.com/fwlink/?LinkId=143705)SQL Server 联机丛书中。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.SqlClient.SqlConnection>，其中包括设置`Packet Size`为 512 连接字符串中。 它显示<xref:System.Data.SqlClient.SqlConnection.PacketSize%2A>和<xref:System.Data.SqlClient.SqlConnection.ServerVersion%2A>在控制台窗口中的属性。  
  
 [!code-csharp[Classic WebData SqlConnection.PacketSize Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.PacketSize Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.PacketSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.PacketSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterColumnEncryptionKeyStoreProviders">
      <MemberSignature Language="C#" Value="public static void RegisterColumnEncryptionKeyStoreProviders (System.Collections.Generic.IDictionary&lt;string,System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider&gt; customProviders);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterColumnEncryptionKeyStoreProviders(class System.Collections.Generic.IDictionary`2&lt;string, class System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider&gt; customProviders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProviders(System.Collections.Generic.IDictionary{System.String,System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterColumnEncryptionKeyStoreProviders (customProviders As IDictionary(Of String, SqlColumnEncryptionKeyStoreProvider))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterColumnEncryptionKeyStoreProviders(System::Collections::Generic::IDictionary&lt;System::String ^, System::Data::SqlClient::SqlColumnEncryptionKeyStoreProvider ^&gt; ^ customProviders);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customProviders" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider&gt;" />
      </Parameters>
      <Docs>
        <param name="customProviders">自定义提供程序</param>
        <summary>注册列加密密钥存储提供程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetStatistics">
      <MemberSignature Language="C#" Value="public void ResetStatistics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetStatistics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ResetStatistics" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetStatistics ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetStatistics();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果启用了统计信息收集，所有值都将重置为零。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果未启用统计信息收集，并且在调用此方法，不会引发错误。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RetrieveStatistics">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary RetrieveStatistics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IDictionary RetrieveStatistics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.RetrieveStatistics" />
      <MemberSignature Language="VB.NET" Value="Public Function RetrieveStatistics () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IDictionary ^ RetrieveStatistics();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>调用此方法时，将返回统计信息的名称值对集合。</summary>
        <returns>返回 <see cref="T:System.Collections.DictionaryEntry" /> 项的 <see cref="T:System.Collections.IDictionary" /> 类型的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用此方法时，检索到的值是当前点处的时间。 如果你继续使用该连接，则值是不正确。 你需要重新执行该方法来获取最新的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServerVersion">
      <MemberSignature Language="C#" Value="public override string ServerVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServerVersion" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ServerVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ServerVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ServerVersion { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个字符串，其中包含客户端所连接到的 SQL Server 的实例的版本。</summary>
        <value>SQL server 实例的版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 版本的形式 *# #。 # #。 # # #*，其中前两个数字是否为主要版本，接下来的两位数字是次要版本，，最后四位数是发布版本。 字符串的形式*major.minor.build*，其中主要和次要是恰好两位，生成是四位数字。  
  
 当返回的任务未完成，且在调用 <xref:System.Data.SqlClient.SqlConnection.OpenAsync%2A> 后未打开连接时，调用了 <xref:System.Data.SqlClient.SqlConnection.ServerVersion%2A>。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.SqlClient.SqlConnection>并显示<xref:System.Data.SqlClient.SqlConnection.ServerVersion%2A>属性。  
  
 [!code-csharp[Classic WebData ISqlConnection.ServerVersion Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData ISqlConnection.ServerVersion Example/CS/source.cs#1)]
 [!code-vb[Classic WebData ISqlConnection.ServerVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData ISqlConnection.ServerVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">连接已关闭。  
  
 当返回的任务未完成，且在调用 <see cref="M:System.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" /> 后未打开连接时，调用了 <see cref="P:System.Data.SqlClient.SqlConnection.ServerVersion" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="State">
      <MemberSignature Language="C#" Value="public override System.Data.ConnectionState State { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.ConnectionState State" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.State" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property State As ConnectionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::ConnectionState State { System::Data::ConnectionState get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbConnection.State</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConnectionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最近在连接上执行网络操作时表示 <see cref="T:System.Data.SqlClient.SqlConnection" /> 的状态。</summary>
        <value>一个 <see cref="T:System.Data.ConnectionState" /> 枚举。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回<xref:System.Data.ConnectionState>指示的状态枚举<xref:System.Data.SqlClient.SqlConnection>。 关闭并重新打开连接将刷新的值<xref:System.Data.SqlClient.SqlConnection.State%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StatisticsEnabled">
      <MemberSignature Language="C#" Value="public bool StatisticsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool StatisticsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.StatisticsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property StatisticsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool StatisticsEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果设置为 <see langword="true" />，则对当前连接启用统计信息收集。</summary>
        <value>如果启用了统计信息收集，则返回 <see langword="true" />；否则返回 <see langword="false" />。 默认为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 启用统计信息收集小但却显著提高对性能有影响，因此应启用需要时。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ICloneable.Clone">
      <MemberSignature Language="C#" Value="object ICloneable.Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ICloneable.Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.System#ICloneable#Clone" />
      <MemberSignature Language="VB.NET" Value="Function Clone () As Object Implements ICloneable.Clone" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ICloneable.Clone() = ICloneable::Clone;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建作为当前实例副本的新对象。</summary>
        <returns>作为此实例副本的新对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Data.SqlClient.SqlConnection> 实例强制转换为 <xref:System.ICloneable> 接口时使用。  
  
 此成员仅受.NET Compact Framework。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkstationId">
      <MemberSignature Language="C#" Value="public string WorkstationId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WorkstationId" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.WorkstationId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkstationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WorkstationId { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个标识数据库客户端的字符串。</summary>
        <value>一个标识数据库客户端的字符串。 如果未指定，则为客户端计算机的名称。 如果两个都没有指定，则值为空字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字符串通常包含客户端的网络名称。 <xref:System.Data.SqlClient.SqlConnection.WorkstationId%2A>属性对应于`Workstation ID`连接字符串属性。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.SqlClient.SqlConnection>并显示<xref:System.Data.SqlClient.SqlConnection.WorkstationId%2A>属性。  
  
 [!code-csharp[Classic WebData SqlConnection.WorkstationId Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.WorkstationId Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.WorkstationId Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.WorkstationId Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>