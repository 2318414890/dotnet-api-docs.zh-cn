<Type Name="RegistryKey" FullName="Microsoft.Win32.RegistryKey">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bf38aadbe15e4bb0f47ab0540d4be6a651933b15" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32695226" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RegistryKey : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed RegistryKey extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.RegistryKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistryKey&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistryKey sealed : MarshalByRefObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示 Windows 注册表中的项级节点。 此类是注册表封装。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
 注册表充当一台计算机上的操作系统和应用程序信息的中央存储库。 以分层形式，基于存储在它的元素的逻辑顺序组织注册表 (请参阅<xref:Microsoft.Win32.Registry>为此层次结构中的基本级别项)。 当将信息存储在注册表中，选择相应的位置根据所存储信息的类型。 请务必避免破坏创建其他应用程序，因为这可能导致出现意外的行为，这些应用程序，也可以有自己的应用程序产生不利影响的信息。  
  
> [!IMPORTANT]
>  此类型实现<xref:System.IDisposable>接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，调用其<xref:System.IDisposable.Dispose%2A>中的方法`try` / `catch`块。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅中的"使用实现 IDisposable 的对象"部分<xref:System.IDisposable>接口主题。  
  
 注册表项是在注册表中，组织的基本单元，并可以比较到文件资源管理器中的文件夹。 特定键可以有子项，就像一个文件夹可以有子文件夹。 只要用户具有适当的权限进行管理，并且项不是基本密钥或直接在基的密钥级别，可以删除每个键。 每个键还可以与其相关联 （值可以比较到文件），用于存储的信息的多个值-例如，在计算机上安装的应用程序有关的信息。 包含一个特定的信息，可以检索或更新时所需的每个值。 例如，你可以创建<xref:Microsoft.Win32.RegistryKey>贵公司，在密钥 HKEY_LOCAL_MACHINE\Software，然后设置一个用于你的公司创建每个应用程序的子项。 每个子项包含的信息特定于该应用程序，如颜色设置屏幕位置和大小，或可识别的文件扩展名。  
  
 请注意，存储在注册表中的信息可供其他应用程序和用户，因此应不用于存储安全数据或关键应用程序信息。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式的对象。 例如，不允许调用方输入任意键或值。  
  
 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，注册表项的长度不再限制为 255 个字符。  
  
   
  
## Examples  
 下面的代码示例演示如何创建 HKEY_CURRENT_USER 下的注册表子项、 操作其内容，并删除子项。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.Registry" />
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭该项，如果其内容已修改，则将其刷新到磁盘。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在系统项上调用此方法不会产生不起作用，因为永远不会关闭系统密钥。  
  
 如果实例上调用的此方法不执行任何操作`RegistryKey`已关闭的。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.Win32.RegistryKey.Flush" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建一个新子项或打开一个现有子项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">要创建或打开的子项的名称或路径。 此字符串不区分大小写。</param>
        <summary>创建一个新子项或打开一个现有子项以进行写访问。</summary>
        <returns>新创建的子项，如果操作失败，则为 <see langword="null" />。 如果为 <paramref name="subkey" /> 指定了长度为零的字符串，则返回当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要执行此操作，用户必须具有注册表层次结构中的权限在此级别和更低版本。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式的对象。 例如，不允许调用方输入任意键或值。  
  
   
  
## Examples  
 下面的代码示例演示如何创建 HKEY_CURRENT_USER 下的注册表子项、 操作其内容，并删除子项。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或打开注册表项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">调用此方法时所针对的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">无法写入 <see cref="T:Microsoft.Win32.RegistryKey" />；例如，它不是作为可写入项打开的，或者用户没有必需的访问权限。</exception>
        <exception cref="T:System.IO.IOException">嵌套级别超过 510。  
  
 或  
  
 出现系统错误，如删除注册表项，或尝试在 <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> 根中创建注册表项。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">能够修改指定的注册表项，如果存在，或能够创建注册表键如果它尚不存在。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />， <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
      </Parameters>
      <Docs>
        <param name="subkey">要创建或打开的子项的名称或路径。 此字符串不区分大小写。</param>
        <param name="permissionCheck">用于指定打开该项是进行读取还是读取/写入访问的枚举值之一。</param>
        <summary>使用指定的权限检查选项创建一个新子项或打开一个现有子项以进行写访问。</summary>
        <returns>新创建的子项，如果操作失败，则为 <see langword="null" />。 如果为 <paramref name="subkey" /> 指定了长度为零的字符串，则返回当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要执行此操作，用户必须具有注册表层次结构中的权限在此级别和更低版本。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式的对象。 例如，不允许调用方输入任意键或值。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>类。 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或打开注册表项所需的权限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> 包含无效值。</exception>
        <exception cref="T:System.ObjectDisposedException">调用此方法时所针对的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">无法写入 <see cref="T:Microsoft.Win32.RegistryKey" />；例如，它不是作为可写入项打开的，或者用户没有必需的访问权限。</exception>
        <exception cref="T:System.IO.IOException">嵌套级别超过 510。  
  
 或  
  
 出现系统错误，如删除注册表项，或尝试在 <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> 根中创建注册表项。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">能够修改指定的注册表项，如果存在，或能够创建注册表键如果它尚不存在。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />， <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, writable As Boolean) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, bool writable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">要创建或打开的子项的名称或路径。 此字符串不区分大小写。</param>
        <param name="writable">
          如果新子项可写入，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>创建一个新子项或打开具有指定访问权限的现有子项。  
  
 可以开始于 [!INCLUDE[net_v46](~/includes/net-v46-md.md)]</summary>
        <returns>新创建的子项，如果操作失败，则为 <see langword="null" />。 如果为 <paramref name="subkey" /> 指定了长度为零的字符串，则返回当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要执行此操作，用户必须具有注册表层次结构中的权限在此级别和更低版本。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式的对象。 例如，不允许调用方输入任意键或值。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>类。 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或打开注册表项所需的权限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">无法写入当前 <see cref="T:Microsoft.Win32.RegistryKey" />；例如，它未作为可写入项打开，或用户没有必要的访问权限。</exception>
        <exception cref="T:System.IO.IOException">嵌套级别超过 510。  
  
 或  
  
 出现系统错误，如删除注册表项，或尝试在 <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> 根中创建注册表项。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" />
      </Parameters>
      <Docs>
        <param name="subkey">要创建或打开的子项的名称或路径。 此字符串不区分大小写。</param>
        <param name="permissionCheck">用于指定打开该项是进行读取还是读取/写入访问的枚举值之一。</param>
        <param name="registrySecurity">新项的访问控制安全性。</param>
        <summary>使用指定的权限检查选项和注册表安全性创建一个新子项或打开一个现有子项以进行写访问。</summary>
        <returns>新创建的子项，如果操作失败，则为 <see langword="null" />。 如果为 <paramref name="subkey" /> 指定了长度为零的字符串，则返回当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A>方法创建一个具有指定的访问控制的注册表项`registrySecurity`参数。 <xref:Microsoft.Win32.RegistryKey>返回对象表示的注册表项，但该对象不受中指定的访问控制`registrySecurity`参数。  
  
 如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>，则打开该项进行读/写访问。 如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType>，打开该项是进行读取访问。  
  
 用于读取和写入如果打开该项是为了向后兼容，`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>和父项也有<xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>。 如果父项具有任何其他设置，由父项的设置控制读/写状态。  
  
 若要执行此操作，用户必须注册表层次结构中具有此级别和更低的权限。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式的对象。 例如，不允许调用方输入任意键或值。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>类。 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或打开注册表项所需的权限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> 包含无效值。</exception>
        <exception cref="T:System.ObjectDisposedException">调用此方法时所针对的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">无法写入当前 <see cref="T:Microsoft.Win32.RegistryKey" />；例如，它未作为可写入项打开，或用户没有必要的访问权限。</exception>
        <exception cref="T:System.IO.IOException">嵌套级别超过 510。  
  
 或  
  
 出现系统错误，如删除注册表项，或尝试在 <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> 根中创建注册表项。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">能够修改指定的注册表项，如果存在，或能够创建注册表键如果它尚不存在。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />， <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable, Microsoft.Win32.RegistryOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable, valuetype Microsoft.Win32.RegistryOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean,Microsoft.Win32.RegistryOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, writable As Boolean, options As RegistryOptions) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, bool writable, Microsoft::Win32::RegistryOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryOptions" />
      </Parameters>
      <Docs>
        <param name="subkey">要创建或打开的子项的名称或路径。 此字符串不区分大小写。</param>
        <param name="writable">
          如果新子项可写入，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="options">要使用的注册表选项。</param>
        <summary>创建一个新子项或打开具有指定访问权限的现有子项。  
  
 可以开始于 [!INCLUDE[net_v46](~/includes/net-v46-md.md)]</summary>
        <returns>新创建的子项，如果操作失败，则为 <see langword="null" />。 如果为 <paramref name="subkey" /> 指定了长度为零的字符串，则返回当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要执行此操作，用户必须具有注册表层次结构中的权限在此级别和更低版本。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式的对象。 例如，不允许调用方输入任意键或值。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>类。 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 未指定有效的选项</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或打开注册表项所需的权限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">无法写入当前 <see cref="T:Microsoft.Win32.RegistryKey" />；例如，它未作为可写入项打开，或用户没有必要的访问权限。</exception>
        <exception cref="T:System.IO.IOException">嵌套级别超过 510。  
  
 或  
  
 出现系统错误，如删除注册表项，或尝试在 <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> 根中创建注册表项。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions options);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions options) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions registryOptions) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions options);" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck, options As RegistryOptions) As RegistryKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0" />
        <Parameter Name="registryOptions" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="netcore-2.0" />
      </Parameters>
      <Docs>
        <param name="subkey">要创建或打开的子项的名称或路径。</param>
        <param name="permissionCheck">用于指定打开该项是进行读取还是读取/写入访问的枚举值之一。</param>
        <param name="options">要使用的注册表选项；例如，用于创建可变键的注册表选项。</param>
        <param name="registryOptions">To be added.</param>
        <summary>使用指定的权限检查和注册表选项，创建或打开一个用于写访问的子项。</summary>
        <returns>新创建的子项，如果操作失败，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取当前<xref:Microsoft.Win32.RegistryKey>对象，请指定一个空字符串 ("") 为`subkey`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">当前的 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">无法写入当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象；例如，它未作为可写入项打开，或用户不具有所需的访问权限。</exception>
        <exception cref="T:System.IO.IOException">嵌套级别超过 510。  
  
 或  
  
 发生系统错误，例如，删除了项，或者尝试在 <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> 根中创建项。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或打开注册表项所需的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions, System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions registryOptions, class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions,System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions registryOptions, System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
        <Parameter Name="registryOptions" Type="Microsoft.Win32.RegistryOptions" />
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" />
      </Parameters>
      <Docs>
        <param name="subkey">要创建或打开的子项的名称或路径。</param>
        <param name="permissionCheck">用于指定打开该项是进行读取还是读取/写入访问的枚举值之一。</param>
        <param name="registryOptions">要使用的注册表选项。</param>
        <param name="registrySecurity">新子项的访问控制安全性。</param>
        <summary>使用指定的权限检查选项、注册表选项和注册表安全性，创建或打开一个用于写访问的子项。</summary>
        <returns>新创建的子项，如果操作失败，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取当前<xref:Microsoft.Win32.RegistryKey>对象，请指定一个空字符串 ("") 为`subkey`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">当前的 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象被关闭。 无法访问已关闭的项。</exception>
        <exception cref="T:System.UnauthorizedAccessException">无法写入当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象；例如，它未作为可写入项打开，或用户不具有所需的访问权限。</exception>
        <exception cref="T:System.IO.IOException">嵌套级别超过 510。  
  
 或  
  
 发生系统错误，例如，删除了项，或者尝试在 <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> 根中创建项。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或打开注册表项所需的权限。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>删除指定子项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteSubKey">
      <MemberSignature Language="C#" Value="public void DeleteSubKey (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKey(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKey (subkey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKey(System::String ^ subkey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">要删除的子项的名称。 此字符串不区分大小写。</param>
        <summary>删除指定子项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要删除子子项，请使用<xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>。  
  
 正在删除注册表项时要格外小心。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A>。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source2.cpp#5)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source2.cs#5)]
 [!code-vb[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="subkey" /> 有子级子项</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="subkey" /> 参数未指定有效的注册表项</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" /></exception>
        <exception cref="T:System.Security.SecurityException">用户没有删除该项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">修改指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSubKey">
      <MemberSignature Language="C#" Value="public void DeleteSubKey (string subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKey(string subkey, bool throwOnMissingSubKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKey (subkey As String, throwOnMissingSubKey As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKey(System::String ^ subkey, bool throwOnMissingSubKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="throwOnMissingSubKey" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">要删除的子项的名称。 此字符串不区分大小写。</param>
        <param name="throwOnMissingSubKey">指示在找不到指定子项的情况下是否引发异常。 如果该参数为 <see langword="true" />，并且指定的子项不存在，则引发异常。 如果该参数为 <see langword="false" />，并且指定的子项不存在，则不执行任何操作。</param>
        <summary>删除指定的子项，并指定在找不到该子项时是否引发异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要删除子子项，请使用<xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>。  
  
 正在删除注册表项时要格外小心。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="subkey" /> 有子级子项。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="subkey" /> 未指定有效的注册表项，并且 <paramref name="throwOnMissingSubKey" /> 为 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有删除该项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">修改指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteSubKeyTree">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用可选的异常处理方以递归方式删除一个子项以及任何子级子项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteSubKeyTree">
      <MemberSignature Language="C#" Value="public void DeleteSubKeyTree (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKeyTree(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKeyTree (subkey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKeyTree(System::String ^ subkey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">要删除的子项。 此字符串不区分大小写。</param>
        <summary>递归删除子项和任何子级子项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你必须具有适当权限才能删除该子项和其树。  
  
> [!CAUTION]
>  删除特定密钥将在树中删除该项下的所有条目。 将不提供任何警告。 如果你想要仅当不有任何子级子项，使用时删除子项<xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A>方法。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">尝试删除根配置单元。  
  
 或  
  
 <paramref name="subkey" /> 未指定有效的注册表子项。</exception>
        <exception cref="T:System.IO.IOException">发生了 I/O 错误。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有删除该项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">修改指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSubKeyTree">
      <MemberSignature Language="C#" Value="public void DeleteSubKeyTree (string subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKeyTree (subkey As String, throwOnMissingSubKey As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKeyTree(System::String ^ subkey, bool throwOnMissingSubKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="throwOnMissingSubKey" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">要删除的子项的名称。 此字符串不区分大小写。</param>
        <param name="throwOnMissingSubKey">指示在找不到指定子项的情况下是否引发异常。 如果该参数为 <see langword="true" />，并且指定的子项不存在，则引发异常。 如果该参数为 <see langword="false" />，并且指定的子项不存在，则不执行任何操作。</param>
        <summary>以递归方式删除指定的子项和任何子级子项，并指定在找不到子项时是否引发异常。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">尝试删除树的根配置单元。  
  
 或  
  
 <paramref name="subkey" /> 未指定有效的注册表子项，并且 <paramref name="throwOnMissingSubKey" /> 为 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有删除该项所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">修改指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从此项中删除指定的值，并在找不到该值时引发异常。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteValue">
      <MemberSignature Language="C#" Value="public void DeleteValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteValue (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteValue(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要删除的值的名称。</param>
        <summary>从此项中删除指定值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Windows 95、 Windows 98、 Windows 98 Second Edition 和 Windows Millennium Edition 上，指定为空字符串`name`参数不会删除默认值。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#3)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#3)]
 [!code-vb[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 不是对值的有效引用。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有删除该值所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">正在处理的 <see cref="T:Microsoft.Win32.RegistryKey" /> 为只读。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">删除指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="DeleteValue">
      <MemberSignature Language="C#" Value="public void DeleteValue (string name, bool throwOnMissingValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteValue(string name, bool throwOnMissingValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteValue (name As String, throwOnMissingValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteValue(System::String ^ name, bool throwOnMissingValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnMissingValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">要删除的值的名称。</param>
        <param name="throwOnMissingValue">指示在找不到指定值的情况下是否引发异常。 如果该参数为 <see langword="true" />，并且指定的值不存在，则引发异常。 如果该参数为 <see langword="false" />，并且指定的值不存在，则不执行任何操作。</param>
        <summary>从此项中删除指定的值，并指定在找不到该值时是否引发异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`throwOnMissingValue`是`false`，没有方法来告诉删除是否成功，而无需随后尝试访问刚删除的值。 因此，从这种方式注册表中删除值时要谨慎。  
  
 在 Windows 95、 Windows 98、 Windows 98 Second Edition 和 Windows Millennium Edition 上，指定为空字符串`name`参数不会删除默认值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 不是对值的有效引用，并且 <paramref name="throwOnMissingValue" /> 为 <see langword="true" />。  
  
 或  
  
 <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有删除该值所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">正在处理的 <see cref="T:Microsoft.Win32.RegistryKey" /> 为只读。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">删除指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:Microsoft.Win32.RegistryKey" /> 类的当前实例所使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完成使用 `Dispose` 后，应调用 <xref:Microsoft.Win32.RegistryKey>。 `Dispose` 方法使 <xref:Microsoft.Win32.RegistryKey> 处于不可用状态。 在调用`Dispose`，必须释放对所有引用<xref:Microsoft.Win32.RegistryKey>以便垃圾回收器才能回收的内存，<xref:Microsoft.Win32.RegistryKey>占用。  
  
 有关详细信息，请参阅[清洗向上非托管资源](~/docs/standard/garbage-collection/unmanaged.md)和[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
> [!NOTE]
>  每次释放对 `Dispose` 的最后一个引用前，均应调用 <xref:Microsoft.Win32.RegistryKey>。 否则，在垃圾回收器调用 <xref:Microsoft.Win32.RegistryKey> 对象的 `Finalize` 方法之前，该对象正在使用的资源不会被释放。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将指定的打开注册表项的全部特性写到注册表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不需要调用`Flush`写出对项的更改。 注册表更改刷新到磁盘时注册表使用其惰性刷新器。 系统指定的时间间隔后，惰性刷新则会自动地定期。 注册表更改也会刷新到磁盘上的系统关闭。  
  
 与不同<xref:Microsoft.Win32.RegistryKey.Close%2A>、`Flush`函数将返回仅当所有数据已都写入到注册表。  
  
 `Flush`函数还可能写出的部分或所有其他键。 过度调用此函数可以产生负面影响对应用程序的性能。  
  
 应用程序应只调用`Flush`如果它必须是绝对某些注册表更改记录到磁盘。 一般情况下，`Flush`极少数情况下，需要使用如果曾经。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.Win32.RegistryKey.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FromHandle">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>根据指定的句柄创建注册表项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey FromHandle(class Microsoft.Win32.SafeHandles.SafeRegistryHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As SafeRegistryHandle) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ FromHandle(Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeRegistryHandle" />
      </Parameters>
      <Docs>
        <param name="handle">注册表项的句柄。</param>
        <summary>根据指定的句柄创建注册表项。</summary>
        <returns>注册表项。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有执行此操作所需的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey FromHandle(class Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As SafeRegistryHandle, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ FromHandle(Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ handle, Microsoft::Win32::RegistryView view);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeRegistryHandle" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" />
      </Parameters>
      <Docs>
        <param name="handle">注册表项的句柄。</param>
        <param name="view">要使用的注册表视图。</param>
        <summary>利用指定的句柄和注册表视图设置创建注册表项。</summary>
        <returns>注册表项。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `view`在后续操作，例如，打开子项中使用此方法的参数。  
  
 如果`view`是<xref:Microsoft.Win32.RegistryView.Registry64>但计算机运行 32 位操作系统上，则返回的键将使用<xref:Microsoft.Win32.RegistryView.Registry32>视图。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="view" /> 无效。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有执行此操作所需的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回当前注册表项的访问控制安全性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistrySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.RegistrySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As RegistrySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::RegistrySecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistrySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前注册表项的访问控制安全性。</summary>
        <returns>一个对象，该对象描述针对由当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 表示的注册表项的访问控制权限。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重载是等效于调用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%28System.Security.AccessControl.AccessControlSections%29>带有以下标志的按位组合的方法重载： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>， <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>，和<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>。 该重载可用于搜索其他权限。  
  
 用户必须具有<xref:System.Security.AccessControl.RegistryRights.ReadPermissions?displayProperty=nameWithType>权限才能调用此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">用户没有必要的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.InvalidOperationException">当前项已被删除。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistrySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.RegistrySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As RegistrySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::RegistrySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistrySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">枚举值的按位组合，它指定要获取的安全信息类型。</param>
        <summary>返回当前注册表项的访问控制安全性的指定部分。</summary>
        <returns>一个对象，该对象描述针对由当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 表示的注册表项的访问控制权限。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要请求当前授予用户的访问权限，指定以下标志的按位组合： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>， <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>，和<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>。 或者，可以使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl>方法重载，它指定确切的值的组合。  
  
 用户必须具有<xref:System.Security.AccessControl.RegistryRights.ReadPermissions?displayProperty=nameWithType>权限才能调用此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">用户没有必要的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.InvalidOperationException">当前项已被删除。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSubKeyNames">
      <MemberSignature Language="C#" Value="public string[] GetSubKeyNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetSubKeyNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSubKeyNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetSubKeyNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索包含所有子项名称的字符串数组。</summary>
        <returns>包含当前项的子项名称的字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行不是以递归方式查找名称。 它调用它的基级上返回的名称。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">用户没有读取该项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.IO.IOException">发生系统错误，例如，当前项已被删除。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">从注册表中读取的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检索与指定名称关联的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要检索的值的名称。 此字符串不区分大小写。</param>
        <summary>检索与指定名称关联的值。 如果注册表中不存在名称/值对，则返回 <see langword="null" />。</summary>
        <returns>与 <paramref name="name" /> 关联的值；如果未找到 <paramref name="name" />，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  注册表项可以具有不与任何名称关联的一个值。 在注册表编辑器中显示了此未命名的值，而不是名称将显示字符串"（默认值）"。 若要检索此未命名的值，指定`null`或为空字符串 ("") 为`name`。  
  
 当<xref:Microsoft.Win32.RegistryKey.GetValue%2A>方法检索可扩展字符串值 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，它就会展开环境字符串使用本地环境中的数据。 若要从远程计算机上的注册表中检索可扩展字符串值，使用<xref:Microsoft.Win32.RegistryKey.GetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueOptions%29>方法重载来指定不希望展开环境字符串。  
  
> [!NOTE]
>  如果包含对环境变量的可展开引用的值已存储为 string (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>)，而不是可扩展字符串 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，<xref:Microsoft.Win32.RegistryKey.GetValue%2A>不展开它。 已检索到它通过调用后，你可以展开此类字符串<xref:System.Environment.ExpandEnvironmentVariables%2A>方法。  
  
> [!NOTE]
>  要从中检索数据的建议的方法<xref:Microsoft.Win32.Registry.PerformanceData>密钥是使用<xref:System.Diagnostics.PerformanceCounter>类而不是<xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType>方法。  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 不支持类型 REG_NONE 或 REG_LINK 读取的值。  在这两种情况下，默认值 (`null`) 返回而不是实际值。  
  
   
  
## Examples  
 下面的代码示例创建一个测试项，并将不同数据类型的值添加到该密钥。 该示例然后读取的名称/值对，并将它们显示在控制台中，使用<xref:Microsoft.Win32.RegistryKey.GetValueKind%2A>方法来检索相应的注册表数据类型。  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">该用户没有读取注册表项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.IO.IOException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已标记为删除。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要从注册表中读取。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">若要读取的类型 REG_EXPAND_SZ 注册表项。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name, System::Object ^ defaultValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">要检索的值的名称。 此字符串不区分大小写。</param>
        <param name="defaultValue">当 <c>name</c> 不存在时要返回的值。</param>
        <summary>检索与指定名称关联的值。 如果未找到名称，则返回你提供的默认值。</summary>
        <returns>与 <paramref name="name" /> 关联的值，不展开嵌入的任何环境变量；如果未找到 <paramref name="defaultValue" />，则为 <paramref name="name" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请使用此重载<xref:Microsoft.Win32.RegistryKey.GetValue%2A>以处理其中尚不存在名称的情况-例如，首次运行你的应用程序。 每当调用此重载时，使用`defaultValue`参数来指定要返回如果的值`name`不存在。  
  
> [!NOTE]
>  注册表项可以具有不与任何名称关联的一个值。 在注册表编辑器中显示了此未命名的值，而不是名称将显示字符串"（默认值）"。 若要检索此未命名的值，指定`null`或为空字符串 ("") 为`name`。  
  
 当<xref:Microsoft.Win32.RegistryKey.GetValue%2A>方法检索可扩展字符串值 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，它就会展开环境字符串使用本地环境中的数据。 若要从远程计算机上的注册表中检索可扩展字符串值，使用<xref:Microsoft.Win32.RegistryKey.GetValue%2A>重载来指定不希望展开环境字符串。  
  
> [!NOTE]
>  如果包含对环境变量的可展开引用的值已存储为 string (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>)，而不是可扩展字符串 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，则<xref:Microsoft.Win32.RegistryKey.GetValue%2A>方法不会展开。 已检索到它通过调用后，你可以展开此类字符串<xref:System.Environment.ExpandEnvironmentVariables%2A>方法。  
  
> [!NOTE]
>  要从中检索数据的建议的方法<xref:Microsoft.Win32.Registry.PerformanceData>密钥是使用<xref:System.Diagnostics.PerformanceCounter>类而不是<xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType>方法。  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 不支持类型 REG_NONE 或 REG_LINK 读取的值。  在这两种情况下，默认值 (`null`) 返回而不是实际值。  
  
   
  
## Examples  
 下面的代码示例将创建一个测试项具有值，并检索该值。 然后，此示例尝试从密钥; 中检索不存在的值在这种情况下<xref:Microsoft.Win32.RegistryKey.GetValue%2A>方法返回指定的默认值。  
  
 [!code-cpp[Classic RegistryKey.GetValue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RegistryKey.GetValue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/CS/source.cs#1)]
 [!code-vb[Classic RegistryKey.GetValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">该用户没有读取注册表项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.IO.IOException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已标记为删除。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要从注册表中读取。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">若要读取的类型 REG_EXPAND_SZ 注册表项。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name, object defaultValue, Microsoft.Win32.RegistryValueOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name, object defaultValue, valuetype Microsoft.Win32.RegistryValueOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object,Microsoft.Win32.RegistryValueOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String, defaultValue As Object, options As RegistryValueOptions) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name, System::Object ^ defaultValue, Microsoft::Win32::RegistryValueOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryValueOptions" />
      </Parameters>
      <Docs>
        <param name="name">要检索的值的名称。 此字符串不区分大小写。</param>
        <param name="defaultValue">当 <c>name</c> 不存在时要返回的值。</param>
        <param name="options">枚举值之一，它指定对所检索值的可选处理方式。</param>
        <summary>检索与指定的名称和检索选项关联的值。 如果未找到名称，则返回你提供的默认值。</summary>
        <returns>与 <paramref name="name" /> 关联的值，按指定的 <paramref name="options" /> 对其进行处理；如果未找到 <paramref name="defaultValue" />，则为 <paramref name="name" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载用于指定的检索到的值的特殊处理。 例如，可以指定<xref:Microsoft.Win32.RegistryValueOptions.DoNotExpandEnvironmentNames?displayProperty=nameWithType>检索类型的注册表值时<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>来检索字符串而不扩展嵌入的环境变量。  
  
 使用`defaultValue`参数来指定要返回如果的值`name`不存在。  
  
> [!NOTE]
>  注册表项可以具有不与任何名称关联的一个值。 在注册表编辑器中显示了此未命名的值，而不是名称将显示字符串"（默认值）"。 若要检索此未命名的值，指定`null`或为空字符串 ("") 为`name`。  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 不支持类型 REG_NONE 或 REG_LINK 读取的值。  在这两种情况下，默认值 (`null`) 返回而不是实际值。  
  
   
  
## Examples  
 下面的代码示例创建一个测试项，将添加一个值与嵌入的环境变量，并检索扩展和非扩展的窗体中的值。  
  
 [!code-cpp[RegistryValueOptions#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryValueOptions/CPP/RegistryValueOptions.cpp#1)]
 [!code-csharp[RegistryValueOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryValueOptions/CS/source.cs#1)]
 [!code-vb[RegistryValueOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryValueOptions/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">该用户没有读取注册表项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.IO.IOException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已标记为删除。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> 不是有效的 <see cref="T:Microsoft.Win32.RegistryValueOptions" /> 值；例如，无效值将强制转换为 <see cref="T:Microsoft.Win32.RegistryValueOptions" />。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要从注册表中读取。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">若要读取的类型 REG_EXPAND_SZ 注册表项。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.Win32.RegistryValueOptions" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValueKind">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryValueKind GetValueKind (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.Win32.RegistryValueKind GetValueKind(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValueKind (name As String) As RegistryValueKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryValueKind GetValueKind(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryValueKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要检索其注册表数据类型的值的名称。 此字符串不区分大小写。</param>
        <summary>检索与指定名称关联的值的注册表数据类型。</summary>
        <returns>与 <paramref name="name" /> 关联的值的注册表数据类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  注册表项可以具有不与任何名称关联的一个值。 在注册表编辑器中显示了此未命名的值，而不是名称将显示字符串"（默认值）"。 若要检索此未命名的值的注册表数据类型，指定`null`或为空字符串 ("") 为`name`。  
  
 有关受支持的注册表数据类型的说明，请参阅<xref:Microsoft.Win32.RegistryValueKind>枚举。  
  
   
  
## Examples  
 下面的代码示例创建一个测试项，并将不同数据类型的值添加到该密钥。 该示例然后读取的名称/值对，并将它们显示在控制台中，使用<xref:Microsoft.Win32.RegistryKey.GetValueKind%2A>方法来检索相应的注册表数据类型。  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">该用户没有读取注册表项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.IO.IOException">包含指定值的子项不存在。  
  
 或  
  
 由 <paramref name="name" /> 指定的名称/值对不存在。  
  
 在 Windows 95、Windows 98 或 Windows Millennium Edition 中不引发此异常。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要从注册表中读取。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)" />
        <altmember cref="T:Microsoft.Win32.RegistryValueKind" />
      </Docs>
    </Member>
    <Member MemberName="GetValueNames">
      <MemberSignature Language="C#" Value="public string[] GetValueNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetValueNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValueNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValueNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetValueNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索包含与此项关联的所有值名称的字符串数组。</summary>
        <returns>包含当前项的值名称的字符串数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果找到项没有值名称，则返回一个空数组。  
  
 注册表项可以具有默认值-即，在其中名称为空字符串的名称/值对 ("")。 如果已经为注册表项设置了默认值，返回的数组<xref:Microsoft.Win32.RegistryKey.GetValueNames%2A>方法包含空字符串。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">该用户没有读取注册表项所需的权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.IO.IOException">发生系统错误；例如，当前项已被删除。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">从注册表中读取的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeRegistryHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeRegistryHandle Handle" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeRegistryHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeRegistryHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:Microsoft.Win32.SafeHandles.SafeRegistryHandle" /> 对象，该对象表示当前 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象封装的注册表项。</summary>
        <value>注册表项的句柄。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">注册表项已关闭。 无法访问已关闭的项。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.IO.IOException">发生系统错误，例如，删除了当前项。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有读取注册表项所需的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索项的名称。</summary>
        <value>项的绝对（限定）名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 键的名称在注册表中，始终从开始是基项，例如，在 HKEY_LOCAL_MACHINE 包括此项的绝对路径。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <altmember cref="M:Microsoft.Win32.RegistryKey.ToString" />
      </Docs>
    </Member>
    <Member MemberName="OpenBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenBaseKey (Microsoft.Win32.RegistryHive hKey, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenBaseKey(Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenBaseKey (hKey As RegistryHive, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenBaseKey(Microsoft::Win32::RegistryHive hKey, Microsoft::Win32::RegistryView view);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" />
      </Parameters>
      <Docs>
        <param name="hKey">要打开的 HKEY。</param>
        <param name="view">要使用的注册表视图。</param>
        <summary>打开一个新的 <see cref="T:Microsoft.Win32.RegistryKey" />，它使用指定的视图在本地计算机上表示请求的项。</summary>
        <returns>请求的注册表项。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hKey" /> 或 <paramref name="view" /> 无效。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有执行此操作所需的权限。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenRemoteBaseKey">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>打开一个新的 T:Microsoft.Win32.RegistryKey，它使用指定的注册表视图选项在远程计算机上表示请求的项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenRemoteBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenRemoteBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRemoteBaseKey (hKey As RegistryHive, machineName As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenRemoteBaseKey(Microsoft::Win32::RegistryHive hKey, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hKey">要从 <see cref="T:Microsoft.Win32.RegistryHive" /> 枚举中打开的 HKEY。</param>
        <param name="machineName">远程计算机。</param>
        <summary>打开一个新的 <see cref="T:Microsoft.Win32.RegistryKey" />，它表示远程计算机上的请求的项。</summary>
        <returns>请求的注册表项。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果打开本地计算机注册表`machineName`是<xref:System.String.Empty?displayProperty=nameWithType>。 请求的项必须是远程计算机上的根项，并由相应标识<xref:Microsoft.Win32.RegistryHive>值。  
  
 为了使远程打开的密钥，服务器和客户端计算机必须是运行远程注册表服务，而且必须启用远程管理。  
  
   
  
## Examples  
 下面的代码示例演示如何打开远程计算机上的注册表项和枚举的键的值。 远程计算机必须运行远程注册表服务。 调用该程序时，远程计算机的名称指定为命令行参数。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hKey" /> 无效。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="machineName" /> 未找到。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">用户不具有执行该操作的适当权限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:Microsoft.Win32.RegistryHive" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="OpenRemoteBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenRemoteBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, string machineName, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRemoteBaseKey (hKey As RegistryHive, machineName As String, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenRemoteBaseKey(Microsoft::Win32::RegistryHive hKey, System::String ^ machineName, Microsoft::Win32::RegistryView view);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" />
      </Parameters>
      <Docs>
        <param name="hKey">要从 <see cref="T:Microsoft.Win32.RegistryHive" /> 枚举中打开的 HKEY。</param>
        <param name="machineName">远程计算机。</param>
        <param name="view">要使用的注册表视图。</param>
        <summary>打开一个新的注册表项，它使用指定的视图在远程计算机上表示请求的项。</summary>
        <returns>请求的注册表项。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果打开本地计算机注册表`machineName`是<xref:System.String.Empty?displayProperty=nameWithType>。 请求的项必须是远程计算机上的根项，并由相应标识<xref:Microsoft.Win32.RegistryHive>值。  
  
 为了使远程打开的密钥，服务器和客户端计算机必须是运行远程注册表服务，而且必须启用远程管理。  
  
 在 64 位版本的 Windows 中，对于 32 位和 64 位应用程序可以单独存储注册表的不同部分。 有了 32 位应用程序的 32 位视图和 64 位应用程序的 64 位视图。 如果`view`是<xref:Microsoft.Win32.RegistryView.Registry64>但远程计算机正在运行 32 位操作系统，则返回的键将使用<xref:Microsoft.Win32.RegistryView.Registry32>视图。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hKey" /> 或 <paramref name="view" /> 无效。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="machineName" /> 未找到。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.Security.SecurityException">用户不具有执行该操作所需的权限。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检索指定的子项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要以只读方式打开的子项的名称或路径。</param>
        <summary>以只读方式检索子项。</summary>
        <returns>请求的子项；如果操作失败，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须先与其他方法和属性而对其进行操作来打开密钥。 若要修改键，必须打开的重载与它<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，您可以指定写访问权限，如<xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CMicrosoft.Win32.RegistryKeyPermissionCheck%29>重载或<xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CSystem.Boolean%29>重载。  
  
 如果没有找到指定的子项，然后`null`返回。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>。 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
   
  
## Examples  
 下面的代码示例创建一个测试项，并使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法将其打开，并演示了方法的两个重载。  
  
 [!code-cpp[RegistryKey.OpenSubKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CPP/opensubkey.cpp#1)]
 [!code-csharp[RegistryKey.OpenSubKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CS/opensubkey.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey/VB/opensubkey.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" /></exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有读取注册表项所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">读取指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, permissionCheck As RegistryKeyPermissionCheck) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
      </Parameters>
      <Docs>
        <param name="name">要创建或打开的子项的名称或路径。</param>
        <param name="permissionCheck">用于指定打开该项是进行读取还是读取/写入访问的枚举值之一。</param>
        <summary>检索指定的子项以进行读取或读/写访问。</summary>
        <returns>请求的子项；如果操作失败，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 而不是引发异常，此方法返回`null`如果请求的项不存在。  
  
 如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>，则打开该项进行读取和写入; 如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType>或<xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>，用于读取除非父项的已打开方式打开该项是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>类。 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
   
  
## Examples  
 下面的代码示例创建一个包含 100 的键/值对的子项，并将其关闭。 该示例打开与子项<xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default>，记录它所需读取所有值，然后关闭子项的时间。 该示例打开与子项<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree>并记录读取所有值所用的时间。 最后，该示例计算并显示提高百分比。  
  
 [!code-csharp[RegistryKey.OpenSubKey_PermCheck#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey_PermCheck/cs/source.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey_PermCheck#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey_PermCheck/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> 包含无效值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有读取注册表项所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">读取指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, writable As Boolean) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, bool writable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">要打开的子项的名称或路径。</param>
        <param name="writable">如果需要项的写访问权限，则设置为 <see langword="true" />。</param>
        <summary>检索指定的子项，并指定是否将写访问权限应用于该项。</summary>
        <returns>请求的子项；如果操作失败，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果请求的项不存在，此方法返回`null`而不是引发异常。  
  
 如果`writable`是`true`的项将打开用于读取和写入，否则，将以只读方式打开的注册表项。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>方法。 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
   
  
## Examples  
 下面的代码示例创建一个测试项，并使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法将其打开，并演示了方法的两个重载。  
  
 [!code-cpp[RegistryKey.OpenSubKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CPP/opensubkey.cpp#1)]
 [!code-csharp[RegistryKey.OpenSubKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CS/opensubkey.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey/VB/opensubkey.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有在指定模式下访问注册表项所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">读取指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, System.Security.AccessControl.RegistryRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype System.Security.AccessControl.RegistryRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Security.AccessControl.RegistryRights)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, rights As RegistryRights) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, System::Security::AccessControl::RegistryRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.RegistryRights" />
      </Parameters>
      <Docs>
        <param name="name">要创建或打开的子项的名称或路径。</param>
        <param name="rights">注册表项的权限。</param>
        <summary>检索具有指定名称的子项。  
  
 从 .NET Framework 4.6 开始可用</summary>
        <returns>请求的子项；如果操作失败，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须先与其他方法和属性而对其进行操作来打开密钥。 若要修改键，必须打开的重载与它<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>允许你指定写入访问权限的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有在指定模式下访问注册表项所需的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistryRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype System.Security.AccessControl.RegistryRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistryRights)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, permissionCheck As RegistryKeyPermissionCheck, rights As RegistryRights) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistryRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
        <Parameter Name="rights" Type="System.Security.AccessControl.RegistryRights" />
      </Parameters>
      <Docs>
        <param name="name">要创建或打开的子项的名称或路径。</param>
        <param name="permissionCheck">用于指定打开该项是进行读取还是读取/写入访问的枚举值之一。</param>
        <param name="rights">枚举值的按位组合，它指定所需的安全访问。</param>
        <summary>检索指定的子项以进行读取或读/写访问，请求指定的访问权限。</summary>
        <returns>请求的子项；如果操作失败，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 而不是引发异常，此方法返回`null`如果请求的项不存在。  
  
 如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>，则打开该项进行读取和写入; 如果`permissionCheck`是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType>或<xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>，用于读取除非父项的已打开方式打开该项是<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>。  
  
 为指定的访问权限`permissionCheck`优先于为指定的访问权限`rights`。 例如，如果你指定<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType>为`permissionCheck`和<xref:System.Security.AccessControl.RegistryRights.WriteKey?displayProperty=nameWithType>为`rights`，尝试写入到子项引发异常。  
  
 若要使用<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>方法，您必须拥有的实例<xref:Microsoft.Win32.RegistryKey>类。 若要获取其实例<xref:Microsoft.Win32.RegistryKey>，使用的静态成员之一<xref:Microsoft.Win32.Registry>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> 包含无效值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问已关闭的项）。</exception>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="rights" /> 包含无效的注册表权限值。  
  
 或  
  
 用户没有所要求的权限。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">读取指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetAccessControl(System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" />
      </Parameters>
      <Docs>
        <param name="registrySecurity">要应用于当前子项的访问控制安全性。</param>
        <summary>向现有注册表项应用 Windows 访问控制安全性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要修改的注册表项的权限，请使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A>方法来获取<xref:System.Security.AccessControl.RegistrySecurity>表示现有的 Windows 访问控制安全性的对象，修改该<xref:System.Security.AccessControl.RegistrySecurity>对象，，然后使用<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A>方法来更新的安全性键。  
  
> [!CAUTION]
>  <xref:System.Security.AccessControl.RegistrySecurity>对象指定的用于`registrySecurity`替换注册表项的现有安全性。 若要添加的新用户的权限，请使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A>方法来获取现有的访问控制安全性，，然后修改它。  
  
   
  
## Examples  
 下面的代码示例创建一个测试项。 允许当前用户<xref:System.Security.AccessControl.RegistryRights.ReadKey>和<xref:System.Security.AccessControl.RegistryRights.Delete>但拒绝权限<xref:System.Security.AccessControl.RegistryRights.ChangePermissions>和<xref:System.Security.AccessControl.RegistryRights.WriteKey>权限。 后续尝试操作密钥成功还是失败取决于这些权限。  
  
 删除密钥之前，代码就会暂停。 你可以切换到注册表编辑器，并验证密钥访问使用注册表编辑器时，将应用的相同访问权限。 (这最适用如果你使用**RunAs**从命令行无管理员权限的本地用户运行注册表编辑器和示例代码。 注册表编辑器始终允许管理员才能更改权限，即使特定管理员已被拒绝这些权限。 如果已定义名为 TestUser，该命令的本地用户`runas /user:TestUser cmd`打开一个命令窗口，你可以从中运行注册表编辑器，然后选择示例代码。)  
  
 [!code-cpp[RegistrySecurity101#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistrySecurity101/cpp/source.cpp#1)]
 [!code-csharp[RegistrySecurity101#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistrySecurity101/CS/source.cs#1)]
 [!code-vb[RegistrySecurity101#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistrySecurity101/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">当前的 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象表示一个具有访问控制安全性的项，并且调用方没有 <see cref="F:System.Security.AccessControl.RegistryRights.ChangePermissions" /> 权限。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="registrySecurity" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置注册表项中的名称/值对的值。 从所存储数据的类型或指定的 <see cref="T:Microsoft.Win32.RegistryValueKind" /> 确定注册表数据类型，具体取决于重载。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (string name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(string name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (name As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::String ^ name, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">要存储的值的名称。</param>
        <param name="value">要存储的数据。</param>
        <summary>设置指定的名称/值对。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于多个值可以存储在注册表中的每个项，你必须使用`name`参数来指定你想要设置的特定值。  
  
> [!NOTE]
>  注册表项可以具有不与任何名称关联的一个值。 在注册表编辑器中显示了此未命名的值，而不是名称将显示字符串"（默认值）"。 若要设置此未命名的值，指定`null`或为空字符串 ("") 为`name`。  
  
 若要在密钥中设置值，必须具有写访问权限来打开密钥。 具有写访问权限打开一个键后，你可以更改任何该注册表项中的名称/值对。  
  
 如果指定`name`不存在的项中创建和关联的值设置为`value`。  
  
 此重载<xref:Microsoft.Win32.RegistryKey.SetValue%2A>将 64 位整数存储为字符串 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>)。 若要将作为 64 位数字存储<xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>值，请使用<xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>重载指定<xref:Microsoft.Win32.RegistryValueKind>。  
  
 此重载<xref:Microsoft.Win32.RegistryKey.SetValue%2A>存储所有的字符串值作为<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>，即使它们包含对环境变量的可展开引用。 若要保存为可展开的字符串的字符串值 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)，使用<xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>重载指定<xref:Microsoft.Win32.RegistryValueKind>。  
  
 通过此方法重载以字符串形式存储以外 32 位整数的数值类型。 枚举元素存储为包含的元素名称的字符串。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式的对象。 例如，不允许调用方输入任意键或值。  
  
> [!NOTE]
>  在 Windows 98 和 Windows Millennium Edition 上注册表不是 Unicode，而不是所有 Unicode 字符都是有效的所有代码页。 对于当前的代码页无效的 Unicode 字符都替换为最佳的匹配项。 不引发异常。  
  
   
  
## Examples  
 下面的代码示例演示如何<xref:Microsoft.Win32.RegistryKey.SetValue%2A>方法确定的注册表数据类型，它将设置值时。 该示例创建一个测试项，并将不同数据类型的值添加到该密钥。 该示例然后读取的名称/值对，并将它们显示在控制台中，使用<xref:Microsoft.Win32.RegistryKey.GetValueKind%2A>方法以显示相应的注册表数据类型。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> 不是受支持的数据类型。</exception>
        <exception cref="T:System.ObjectDisposedException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 只读，因此无法写入；例如，项不是用写访问权限打开的。  
  
 或  
  
 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象表示根级别节点，操作系统为 Windows Millennium Edition 或 Windows 98。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或修改注册表项所需的权限。</exception>
        <exception cref="T:System.IO.IOException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 对象表示根级别节点，操作系统为 Windows 2000、Windows XP 或 Windows Server 2003。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要修改指定的注册表项，如果存在，或创建注册表项，如果不存在。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />， <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (string name, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(string name, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (name As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::String ^ name, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" />
      </Parameters>
      <Docs>
        <param name="name">要存储的值的名称。</param>
        <param name="value">要存储的数据。</param>
        <param name="valueKind">在存储数据时要使用的注册表数据类型。</param>
        <summary>使用指定的注册表数据类型设置注册表项中的名称/值对的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于多个值可以存储在注册表中的每个项，你必须使用`name`参数来指定你想要设置的特定值。  
  
> [!NOTE]
>  注册表项可以具有不与任何名称关联的一个值。 在注册表编辑器中显示了此未命名的值，而不是名称将显示字符串"（默认值）"。 若要设置此未命名的值，指定`null`或为空字符串 ("") 为`name`。  
  
 若要在密钥中设置值，必须具有写访问权限来打开密钥。 具有写访问权限打开一个键后，你可以更改任何该注册表项中的名称/值对。  
  
 如果指定`name`不存在的项，它创建，并且相关联的值设置为`value`。  
  
> [!NOTE]
>  指定的注册表数据类型<xref:Microsoft.Win32.RegistryValueKind.Unknown>等同于使用<xref:Microsoft.Win32.RegistryKey.SetValue%2A>重载。  
  
 如果指定的类型`value`不匹配指定`valueKind`，和数据不能转换，<xref:System.ArgumentException>引发。 例如，你可以存储<xref:System.Int64?displayProperty=nameWithType>作为<xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>，但仅当其值为的最大值小于<xref:System.Int32?displayProperty=nameWithType>。 无法将值存储在单个字符串作为<xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>。  
  
> [!NOTE]
>  如果已装箱的值传递<xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>或<xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>，完成转换后使用固定区域性。  
  
> [!CAUTION]
>  不会公开<xref:Microsoft.Win32.RegistryKey>，恶意程序无法创建数千个无意义的子项或键/值对的方式的对象。 例如，不允许调用方输入任意键或值。  
  
> [!NOTE]
>  在 Windows 98 和 Windows Millennium Edition 上注册表不是 Unicode，而不是所有 Unicode 字符都是有效的所有代码页。 对于当前的代码页无效的 Unicode 字符都替换为最佳的匹配项。 不引发异常。  
  
   
  
## Examples  
 下面的代码示例创建一个测试项，并使用<xref:Microsoft.Win32.RegistryKey.SetValue%2A>方法以存储多个值，指定每个值的注册表数据类型。 该示例然后读取的名称/值对，并将它们显示在控制台中，使用<xref:Microsoft.Win32.RegistryKey.GetValueKind%2A>方法以显示相应的注册表数据类型。  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> 的类型与 <paramref name="valueKind" /> 指定的注册表数据类型不匹配，因此，未能正确转换该数据。</exception>
        <exception cref="T:System.ObjectDisposedException">包含指定值的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 只读，因此无法写入；例如，项不是用写访问权限打开的。  
  
 或  
  
 <see cref="T:Microsoft.Win32.RegistryKey" /> 对象表示根级别节点，操作系统为 Windows Millennium Edition 或 Windows 98。</exception>
        <exception cref="T:System.Security.SecurityException">用户没有创建或修改注册表项所需的权限。</exception>
        <exception cref="T:System.IO.IOException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> 对象表示根级别节点，操作系统为 Windows 2000、Windows XP 或 Windows Server 2003。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">若要修改指定的注册表项，如果存在，或创建注册表项，如果不存在。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />， <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="T:Microsoft.Win32.RegistryValueKind" />
      </Docs>
    </Member>
    <Member MemberName="SubKeyCount">
      <MemberSignature Language="C#" Value="public int SubKeyCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubKeyCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SubKeyCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubKeyCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索当前项的子项计数。</summary>
        <value>当前项的子项的数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性执行不是以递归方式计数名称。 它只返回调用它的基级上的名称的计数。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">用户没有该项的读取权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.IO.IOException">发生系统错误，例如，当前项已被删除。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">读取指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索此项的字符串表示形式。</summary>
        <returns>表示此项的字符串。 如果指定的项无效（找不到），则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的值包含指定的键和键的十六进制值的注册表路径。 注册表路径包含指定键的绝对根，始终从 1 开始的基键的注册表中，例如，HKEY_LOCAL_MACHINE。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">访问的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <altmember cref="P:Microsoft.Win32.RegistryKey.Name" />
      </Docs>
    </Member>
    <Member MemberName="ValueCount">
      <MemberSignature Language="C#" Value="public int ValueCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ValueCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.ValueCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ValueCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索项中值的计数。</summary>
        <value>项中的名称/值对的数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个注册表项具有不与任何名称相关联的默认值。 此未命名的值可以通过使用设置<xref:Microsoft.Win32.RegistryKey.SetValue%2A>方法并指定`null`或为空字符串 ("") 为`name`。 如果具有永远不会设置默认值，它不影响到返回的总计数<xref:Microsoft.Win32.RegistryKey.ValueCount%2A>属性; 一旦设置，但是，它始终算。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:Microsoft.Win32.RegistryKey>类。  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">用户没有该项的读取权限。</exception>
        <exception cref="T:System.ObjectDisposedException">要操作的 <see cref="T:Microsoft.Win32.RegistryKey" /> 已关闭（无法访问关闭的项）。</exception>
        <exception cref="T:System.UnauthorizedAccessException">用户没有必需的注册表权限。</exception>
        <exception cref="T:System.IO.IOException">发生系统错误，例如，当前项已被删除。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">读取指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="View">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryView View { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Win32.RegistryView View" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.View" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property View As RegistryView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::RegistryView View { Microsoft::Win32::RegistryView get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建注册表项的视图。</summary>
        <value>用于创建注册表项的视图。  
  
 或  
  
 如果未使用视图，则为 <see cref="F:Microsoft.Win32.RegistryView.Default" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 64 位版本的 Windows 中，对于 32 位和 64 位应用程序可以单独存储注册表的不同部分。 有了 32 位应用程序的 32 位视图和 64 位应用程序的 64 位视图。  
  
 不会假定视图始终对应的实际视图<xref:Microsoft.Win32.RegistryKey>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>