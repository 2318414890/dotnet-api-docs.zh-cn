<Type Name="SystemEvents" FullName="Microsoft.Win32.SystemEvents">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6d99d25be1d24abd932081d3e03fd39286f0da69" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32037636" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SystemEvents" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SystemEvents extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.SystemEvents" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SystemEvents" />
  <TypeSignature Language="C++ CLI" Value="public ref class SystemEvents sealed" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供对系统事件通知的访问。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.Win32.SystemEvents>类提供了响应特定类型的系统事件的能力。  
  
 引发系统事件时，任何连接到的事件的委托将调用线程，用于监视用于系统事件。 因此，你应从你事件处理程序线程安全的任何调用。 如果你需要调用未公开作为此类的成员的系统事件，则可以使用<xref:Microsoft.Win32.SystemEvents.InvokeOnEventsThread%2A>方法。  
  
> [!CAUTION]
>  不要将引发一个系统事件处理程序，因为它可能会阻止其他应用程序的工作的线程上执行耗时的处理。  
  
> [!NOTE]
>  某些系统事件可能不会引发上[!INCLUDE[windowsver](~/includes/windowsver-md.md)]。 请务必验证你的应用程序上按预期[!INCLUDE[windowsver](~/includes/windowsver-md.md)]。  
  
   
  
## Examples  
 本部分包含两个示例。 第一个示例演示如何使用普通的应用程序中的系统事件和第二个示例演示如何使用 Windows 服务中的系统事件。  
  
 **示例 1**  
  
 下面的代码示例注册感兴趣的某些系统事件，然后等待任何这些事件发生。 如果用户更改显示分辨率，则会发生显示的输出。  
  
 [!code-cpp[SystemEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#1)]
 [!code-csharp[SystemEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#1)]
 [!code-vb[SystemEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#1)]  
  
 **示例 2**  
  
 下面的代码示例演示处理程序的非常简单的 Windows 服务<xref:Microsoft.Win32.SystemEvents.TimeChanged>和<xref:Microsoft.Win32.SystemEvents.UserPreferenceChanged>事件。 该示例包含一个名为服务`SimpleService`，名为窗体`HiddenForm`，和一个安装程序。 该窗体提供所需的系统事件的消息循环。  
  
> [!NOTE]
>  服务没有消息循环，除非它们可以与桌面交互。 如果隐藏的表单不提供消息循环，如下所示此示例中，必须在本地系统帐户下运行服务，需要手动干预以便与桌面交互。 也就是说，管理员必须手动检查**允许服务与桌面交互**上的复选框**Log On**服务属性对话框中的选项卡。 在这种情况下，自动提供的消息循环。 仅当在本地系统帐户下运行服务时，此选项才可用。 不能以编程方式启用与桌面交互。  
  
 此示例中的服务启动一个运行的实例的线程`HiddenForm`。 挂钩和在窗体中处理事件。 必须在窗体，以确保窗体是完全加载第一次; 的负载事件挂接事件否则不会引发事件。  
  
> [!NOTE]
>  该示例提供所有必要的代码，包括通常由 Visual Studio 设计器生成的窗体初始化代码。 如果你正在开发 Visual Studio 中的服务，你可以忽略第二个分部类并使用**属性**窗口设置高度和宽度为零，该边框样式，隐藏的表单<xref:System.Windows.Forms.FormBorderStyle.None?displayProperty=nameWithType>，和到的窗口状态<xref:System.Windows.Forms.FormWindowState.Minimized?displayProperty=nameWithType>.  
  
 若要运行示例：  
  
1.  编译命令行中的代码。 用于源文件的名称并不重要。  
  
2.  从命令行使用安装服务[Installutil.exe （安装程序工具）](~/docs/framework/tools/installutil-exe-installer-tool.md)实用程序。 例如，`InstallUtil example.exe`源文件名是否`example.cs`或`example.vb`。 您必须是管理员才能安装服务。  
  
3.  使用服务控制台来启动服务。  
  
4.  更改系统时间，或者更改用户首选项，例如鼠标属性。  
  
5.  查看中的消息**应用程序**的事件查看器的类别。  
  
6.  使用服务控制台停止服务。  
  
7.  通过从命令行卸载服务`/u`选项。 例如 `InstallUtil /u example.exe`。  
  
 [!code-csharp[ManagedWindowsService#1](~/samples/snippets/csharp/VS_Snippets_CLR/ManagedWindowsService/cs/source.cs#1)]
 [!code-vb[ManagedWindowsService#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ManagedWindowsService/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">对系统资源的完全访问权限。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。 关联的状态：</permission>
    <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
    <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
  </Docs>
  <Members>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static IntPtr CreateTimer (int interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateTimer(int32 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.CreateTimer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTimer (interval As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateTimer(int interval);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="interval">指定计时器通知之间的间隔（以毫秒为单位）。</param>
        <summary>创建一个与系统事件窗口相关联的新窗口计时器。</summary>
        <returns>新计时器的 ID。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">间隔小于或等于零。</exception>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功，或创建计时器的尝试未成功。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户更改显示设置时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
   
  
## Examples  
 下面的代码示例演示如何监视<xref:Microsoft.Win32.SystemEvents.DisplaySettingsChanged>事件。 此代码示例摘自更大的示例为提供<xref:Microsoft.Win32.SystemEvents>类。  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功。</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanging">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanging As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>更改显示设置时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功。</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      </Docs>
    </Member>
    <Member MemberName="EventsThreadShutdown">
      <MemberSignature Language="C#" Value="public static event EventHandler EventsThreadShutdown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EventsThreadShutdown" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.EventsThreadShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EventsThreadShutdown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EventsThreadShutdown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在侦听系统事件的线程终止前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 侦听的系统事件的线程原样即将终止，则将引发此事件。 使用侦听的系统事件的线程调用系统事件委托。  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功。</exception>
      </Docs>
    </Member>
    <Member MemberName="InstalledFontsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler InstalledFontsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InstalledFontsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.InstalledFontsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event InstalledFontsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ InstalledFontsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户在系统中添加或移除字体时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功。</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeOnEventsThread">
      <MemberSignature Language="C#" Value="public static void InvokeOnEventsThread (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InvokeOnEventsThread(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.InvokeOnEventsThread(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InvokeOnEventsThread (method As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InvokeOnEventsThread(Delegate ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">要使用侦听系统事件的线程调用的委托。</param>
        <summary>使用侦听系统事件的线程调用指定的委托。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用此方法需要以处理系统事件通过否则不公开任何时间<xref:Microsoft.Win32.SystemEvents>类。  
  
 在调用此方法时，将由你的应用程序使用来处理系统事件的线程调用指定的委托。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功。</exception>
      </Docs>
    </Member>
    <Member MemberName="KillTimer">
      <MemberSignature Language="C#" Value="public static void KillTimer (IntPtr timerId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KillTimer(native int timerId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.KillTimer(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KillTimer (timerId As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KillTimer(IntPtr timerId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timerId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="timerId">要终止的计时器的 ID。</param>
        <summary>终止由给定 ID 指定的计时器。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功，或终止计时器的尝试未成功。</exception>
      </Docs>
    </Member>
    <Member MemberName="LowMemory">
      <MemberSignature Language="C#" Value="public static event EventHandler LowMemory;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LowMemory" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.LowMemory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LowMemory As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LowMemory;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当系统用完可用 RAM 时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件包装 WM_COMPACTING 消息。 当系统检测到多个 12.5%的系统时间段 30 到 60 秒间隔内花费了压缩内存时，此消息是发送到所有顶级窗口。 这表明系统内存不足。  
  
> [!NOTE]
>  如果运行消息泵，仅将引发此事件。 在 Windows 服务中，除非使用隐藏的表单或消息泵具有手动启动此事件不会引发。 有关演示如何通过在 Windows 服务中使用隐藏的表单处理系统事件的代码示例，请参阅<xref:Microsoft.Win32.SystemEvents>类。  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功。</exception>
        <block subset="none" type="usage">
          <para>仅为使用 16 位基于 Windows 的应用程序的兼容性提供此消息。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PaletteChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler PaletteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaletteChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PaletteChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PaletteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ PaletteChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户切换到使用其他调色板的应用程序时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果运行消息泵，仅将引发此事件。 在 Windows 服务中，除非使用隐藏的表单或消息泵具有手动启动此事件不会引发。 有关演示如何通过在 Windows 服务中使用隐藏的表单处理系统事件的代码示例，请参阅<xref:Microsoft.Win32.SystemEvents>类。  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
   
  
## Examples  
 下面的代码示例演示如何监视<xref:Microsoft.Win32.SystemEvents.PaletteChanged>事件。 此代码示例摘自更大的示例为提供<xref:Microsoft.Win32.SystemEvents>类。  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功。</exception>
      </Docs>
    </Member>
    <Member MemberName="PowerModeChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PowerModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PowerModeChanged As PowerModeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::PowerModeChangedEventHandler ^ PowerModeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.PowerModeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户挂起或继续系统时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果运行消息泵，仅将引发此事件。 在 Windows 服务中，除非使用隐藏的表单或消息泵具有手动启动此事件不会引发。 有关演示如何通过在 Windows 服务中使用隐藏的表单处理系统事件的代码示例，请参阅<xref:Microsoft.Win32.SystemEvents>类。  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功。</exception>
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.PowerModes" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnded">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndedEventHandler SessionEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndedEventHandler SessionEnded" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnded" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnded As SessionEndedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndedEventHandler ^ SessionEnded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户注销或关闭系统时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果运行消息泵，仅将引发此事件。 在 Windows 服务中，除非使用隐藏的表单或消息泵具有手动启动此事件不会引发。 有关演示如何通过在 Windows 服务中使用隐藏的表单处理系统事件的代码示例，请参阅<xref:Microsoft.Win32.SystemEvents>类。  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功。</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndedEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndingEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndingEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnding As SessionEndingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndingEventHandler ^ SessionEnding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户尝试注销或关闭系统时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是可取消的事件。 设置<xref:Microsoft.Win32.SessionEndingEventArgs.Cancel%2A>属性`true`将请求会话仍将继续运行。 它提供了没有保证的会话不会结束。  
  
 如果你使用<xref:Microsoft.Win32.SystemEvents.SessionEnding>在 Windows 窗体来检测系统注销或重新启动，没有任何确定性的方法来决定是否<xref:System.Windows.Forms.Form.Closing>事件将激发此事件之前。  
  
 如果你想要执行一些特殊的任务，然后<xref:System.Windows.Forms.Form.Closing>是激发，需要确保<xref:Microsoft.Win32.SystemEvents.SessionEnding>之前激发<xref:System.Windows.Forms.Form.Closing>。 若要执行此操作，你需要捕获`WM_QUERYENDSESSION`在窗体中重写`WndProc`函数。  此示例演示如何执行此操作。  
  
```vb  
Private Shared WM_QUERYENDSESSION As Integer = &H11  
 Private Shared systemShutdown As Boolean = False  
 Protected Overrides Sub WndProc(ByRef m As System.Windows.Forms.Message)  
     If m.Msg = WM_QUERYENDSESSION Then  
         MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot")  
         systemShutdown = True  
     End If  
     ' If this is WM_QUERYENDSESSION, the closing event should be raised in the base WndProc.  
     MyBase.WndProc(m)  
 End Sub 'WndProc   
 Private Sub Form1_Closing(ByVal sender As System.Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing  
     If (systemShutdown) Then  
     ' Reset the variable because the user might cancel the shutdown.  
         systemShutdown = False  
         If (System.Windows.Forms.DialogResult.Yes = _  
                 MessageBox.Show("My application", "Do you want to save your work before logging off?", MessageBoxButtons.YesNo)) Then  
                 e.Cancel = True  
         Else  
                 e.Cancel = False  
         End If  
     End If  
 End Sub  
  
```  
  
```csharp  
private static int WM_QUERYENDSESSION = 0x11;  
private static bool systemShutdown = false;  
protected override void WndProc(ref System.Windows.Forms.Message m)  
{  
    if (m.Msg==WM_QUERYENDSESSION)  
    {  
        MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot");  
        systemShutdown = true;  
    }  
  
    // If this is WM_QUERYENDSESSION, the closing event should be  
    // raised in the base WndProc.  
    base.WndProc(ref m);  
  
} //WndProc   
  
private void Form1_Closing(  
    System.Object sender,   
    System.ComponentModel.CancelEventArgs e)  
{  
    if (systemShutdown)  
        // Reset the variable because the user might cancel the   
        // shutdown.  
    {  
        systemShutdown = false;  
        if (DialogResult.Yes==MessageBox.Show("My application",   
            "Do you want to save your work before logging off?",   
            MessageBoxButtons.YesNo))  
        {  
            e.Cancel = true;  
        }  
        else  
        {  
            e.Cancel = false;  
        }  
    }  
}  
```  
  
> [!IMPORTANT]
>  控制台应用程序不会引发<xref:Microsoft.Win32.SystemEvents.SessionEnding>事件。  
  
> [!NOTE]
>  如果运行消息泵，仅将引发此事件。 在 Windows 服务中，除非使用隐藏的表单或消息泵具有手动启动此事件不会引发。 有关演示如何通过在 Windows 服务中使用隐藏的表单处理系统事件的代码示例，请参阅<xref:Microsoft.Win32.SystemEvents>类。  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功。</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndingEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionSwitch">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionSwitchEventHandler SessionSwitch;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionSwitchEventHandler SessionSwitch" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionSwitch" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionSwitch As SessionSwitchEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionSwitchEventHandler ^ SessionSwitch;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionSwitchEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>更改当前登录的用户时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果运行消息泵，仅将引发此事件。 在 Windows 服务中，除非使用隐藏的表单或消息泵具有手动启动此事件不会引发。 有关演示如何通过在 Windows 服务中使用隐藏的表单处理系统事件的代码示例，请参阅<xref:Microsoft.Win32.SystemEvents>类。  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功。</exception>
        <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="TimeChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler TimeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TimeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ TimeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户更改系统时钟上的时间时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果运行消息泵，仅将引发此事件。 在 Windows 服务中，除非使用隐藏的表单或消息泵具有手动启动此事件不会引发。 有关演示如何通过在 Windows 服务中使用隐藏的表单处理系统事件的代码示例，请参阅<xref:Microsoft.Win32.SystemEvents>类。  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功。</exception>
        <altmember cref="P:System.DateTime.Now" />
      </Docs>
    </Member>
    <Member MemberName="TimerElapsed">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.TimerElapsedEventHandler TimerElapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.TimerElapsedEventHandler TimerElapsed" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimerElapsed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimerElapsed As TimerElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::TimerElapsedEventHandler ^ TimerElapsed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.TimerElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在窗口计时器间隔过期时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果运行消息泵，仅将引发此事件。 在 Windows 服务中，除非使用隐藏的表单或消息泵具有手动启动此事件不会引发。 有关演示如何通过在 Windows 服务中使用隐藏的表单处理系统事件的代码示例，请参阅<xref:Microsoft.Win32.SystemEvents>类。  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功。</exception>
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventArgs" />
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanged As UserPreferenceChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangedEventHandler ^ UserPreferenceChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在用户首选项更改后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果运行消息泵，仅将引发此事件。 在 Windows 服务中，除非使用隐藏的表单或消息泵具有手动启动此事件不会引发。 有关演示如何通过在 Windows 服务中使用隐藏的表单处理系统事件的代码示例，请参阅<xref:Microsoft.Win32.SystemEvents>类。  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功。</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanging">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanging As UserPreferenceChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangingEventHandler ^ UserPreferenceChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户首选项更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果运行消息泵，仅将引发此事件。 在 Windows 服务中，除非使用隐藏的表单或消息泵具有手动启动此事件不会引发。 有关演示如何通过在 Windows 服务中使用隐藏的表单处理系统事件的代码示例，请参阅<xref:Microsoft.Win32.SystemEvents>类。  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
   
  
## Examples  
 下面的代码示例演示如何监视<xref:Microsoft.Win32.SystemEvents.UserPreferenceChanging>事件。 此代码示例摘自更大的示例为提供<xref:Microsoft.Win32.SystemEvents>类。  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前上下文不支持系统事件通知。 例如，服务器进程可能不支持全局系统事件通知。</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">创建系统事件窗口线程的尝试未成功。</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
  </Members>
</Type>