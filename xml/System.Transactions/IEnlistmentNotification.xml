<Type Name="IEnlistmentNotification" FullName="System.Transactions.IEnlistmentNotification">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ce7c186bfa7974506e6f23870b923c6bfab1a333" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36406442" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IEnlistmentNotification" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IEnlistmentNotification" />
  <TypeSignature Language="DocId" Value="T:System.Transactions.IEnlistmentNotification" />
  <TypeSignature Language="VB.NET" Value="Public Interface IEnlistmentNotification" />
  <TypeSignature Language="C++ CLI" Value="public interface class IEnlistmentNotification" />
  <TypeSignature Language="F#" Value="type IEnlistmentNotification = interface" />
  <AssemblyInfo>
    <AssemblyName>System.Transactions</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Transactions.Local</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>描述一个接口，资源管理器应实现该接口以在登记参与时为事务管理器提供两阶段提交通知回调。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了让资源管理器来参与事务，它必须通过事务管理器的事务中登记。 <xref:System.Transactions.Transaction> 类定义了一组提供此功能的方法，这些方法的名称以 `Enlist` 开头。 不同`Enlist`方法对应于不同类型的资源管理器可能具有的登记。  
  
 此类描述资源管理器应实现以在登记参与时的事务管理器提供两阶段提交通知回调的接口。 用于每个资源管理器的实现的<xref:System.Transactions.IEnlistmentNotification>接口，你应登记使用<xref:System.Transactions.Transaction.EnlistVolatile%2A>方法或<xref:System.Transactions.Transaction.EnlistDurable%2A>方法<xref:System.Transactions.Transaction>类，具体取决于所需的资源是否是可变或持久性。 登记和 2PC 的详细信息，请参阅[作为参与者在事务中登记资源](~/docs/framework/data/transactions/enlisting-resources-as-participants-in-a-transaction.md)和[提交单阶段和多个阶段中的事务](~/docs/framework/data/transactions/committing-a-transaction-in-single-phase-and-multi-phase.md)分别。  
  
 事务管理器在两阶段提交协议的不同阶段登记的对象通知通过以下方法。  
  
|方法|描述|  
|------------|-----------------|  
|<xref:System.Transactions.IEnlistmentNotification.Prepare%2A>|当事务管理器要求参与者它们是否能够提交事务时，登记对象的此方法由事务管理器的事务的第一个阶段中用作回调。|  
|<xref:System.Transactions.IEnlistmentNotification.Commit%2A>|如果该事务被提交，登记对象的此方法由事务管理器在事务的第二个阶段中用作回调。|  
|<xref:System.Transactions.IEnlistmentNotification.Rollback%2A>|如果 （即，回滚），则中止此事务，登记对象的此方法由事务管理器在事务的第二个阶段中用作回调。|  
|<xref:System.Transactions.IEnlistmentNotification.InDoubt%2A>|如果事务的状态不明，登记对象的此方法由事务管理器在事务的第二个阶段中用作回调。|  
  
> [!NOTE]
>  你应注意通知可能不会在按顺序，或按特定顺序发送。  
  
   
  
## Examples  
 下面的示例演示如何实现此接口，以及该对象登记在事务中使用参与者作为<xref:System.Transactions.Transaction.EnlistVolatile%2A>方法。  
  
 [!code-csharp[Tx_Enlist#1](~/samples/snippets/csharp/VS_Snippets_CFX/tx_enlist/cs/enlist.cs#1)]
 [!code-vb[Tx_Enlist#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/tx_enlist/vb/enlist.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Transactions.ISinglePhaseNotification" />
  </Docs>
  <Members>
    <Member MemberName="Commit">
      <MemberSignature Language="C#" Value="public void Commit (System.Transactions.Enlistment enlistment);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Commit(class System.Transactions.Enlistment enlistment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Transactions.IEnlistmentNotification.Commit(System.Transactions.Enlistment)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Commit(System::Transactions::Enlistment ^ enlistment);" />
      <MemberSignature Language="F#" Value="abstract member Commit : System.Transactions.Enlistment -&gt; unit" Usage="iEnlistmentNotification.Commit enlistment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Transactions</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Transactions.Local</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enlistment" Type="System.Transactions.Enlistment" />
      </Parameters>
      <Docs>
        <param name="enlistment">用于将响应发送到事务管理器的 <see cref="T:System.Transactions.Enlistment" /> 对象。</param>
        <summary>通知登记的对象事务正在提交。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它指示所有参与者提交事务时，事务管理器做出的承诺，在第二个阶段调用登记对象的此方法。  
  
 资源管理器应执行任何工作需要完成事务，随后又通知它完成通过调用 TM<xref:System.Transactions.Enlistment.Done%2A>方法`enlistment`参数。  
  
 如果资源管理器已持久登记，但未通过调用响应<xref:System.Transactions.Enlistment.Done%2A>方法，事务管理器不确定的资源管理器已收到<xref:System.Transactions.IEnlistmentNotification.Commit%2A>调用。 在这种情况下，事务管理器将继续等待响应，并且保留信息与此事务。  如果<xref:System.Transactions.Enlistment.Done%2A>是永远不会调用，这段信息是围绕无限期保留在内存中或在系统级资源。 这会导致无法回收资源。 对于分布式事务，这可能最终填满 MSDTC 日志将停止 MSDTC 过程。 在由事务的情况下<xref:System.Transactions>，这会导致资源管理器的进程的内存消耗的逐步地持续增长。 因此，很重要，则调用<xref:System.Transactions.Enlistment.Done%2A>方法后资源管理器，可使用你准备工作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InDoubt">
      <MemberSignature Language="C#" Value="public void InDoubt (System.Transactions.Enlistment enlistment);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InDoubt(class System.Transactions.Enlistment enlistment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Transactions.IEnlistmentNotification.InDoubt(System.Transactions.Enlistment)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InDoubt(System::Transactions::Enlistment ^ enlistment);" />
      <MemberSignature Language="F#" Value="abstract member InDoubt : System.Transactions.Enlistment -&gt; unit" Usage="iEnlistmentNotification.InDoubt enlistment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Transactions</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Transactions.Local</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enlistment" Type="System.Transactions.Enlistment" />
      </Parameters>
      <Docs>
        <param name="enlistment">用于将响应发送到事务管理器的 <see cref="T:System.Transactions.Enlistment" /> 对象。</param>
        <summary>通知登记的对象事务的状态不确定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事务管理器在已调用单阶段提交操作单个持久资源，然后到持久的资源的连接已丢失之前得到事务结果时，将针对易失性资源调用此方法。 此时，无法安全地确定事务结果。  
  
 作为<xref:System.Transactions.IEnlistmentNotification.InDoubt%2A>是视为事务的最终状态，你不应调用<xref:System.Transactions.IEnlistmentNotification.Commit%2A>或<xref:System.Transactions.IEnlistmentNotification.Rollback%2A>之后调用<xref:System.Transactions.IEnlistmentNotification.InDoubt%2A>。  
  
> [!NOTE]
>  此方法对于易失性资源的实现应对受影响的数据执行它了解任何恢复或包含操作。  它还必须调用<xref:System.Transactions.Enlistment.Done%2A>方法上`enlistment`参数时它已完成其工作。  
  
 如果资源管理器已持久登记，但未通过调用响应<xref:System.Transactions.Enlistment.Done%2A>方法，事务管理器不确定的资源管理器已收到<xref:System.Transactions.IEnlistmentNotification.InDoubt%2A>调用。 在这种情况下，事务管理器将继续等待响应，并且保留信息与此事务。  如果<xref:System.Transactions.Enlistment.Done%2A>是永远不会调用，这段信息是围绕无限期保留在内存中或在系统级资源。 这会导致无法回收资源。 对于分布式事务，这可能最终填满 MSDTC 日志将停止 MSDTC 过程。 在由事务的情况下<xref:System.Transactions>，这会导致资源管理器的进程的内存消耗的逐步地持续增长。 因此，很重要，则调用<xref:System.Transactions.Enlistment.Done%2A>方法后资源管理器，可使用你准备工作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prepare">
      <MemberSignature Language="C#" Value="public void Prepare (System.Transactions.PreparingEnlistment preparingEnlistment);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Prepare(class System.Transactions.PreparingEnlistment preparingEnlistment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Transactions.IEnlistmentNotification.Prepare(System.Transactions.PreparingEnlistment)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Prepare(System::Transactions::PreparingEnlistment ^ preparingEnlistment);" />
      <MemberSignature Language="F#" Value="abstract member Prepare : System.Transactions.PreparingEnlistment -&gt; unit" Usage="iEnlistmentNotification.Prepare preparingEnlistment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Transactions</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Transactions.Local</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="preparingEnlistment" Type="System.Transactions.PreparingEnlistment" />
      </Parameters>
      <Docs>
        <param name="preparingEnlistment">用于将响应发送到事务管理器的 <see cref="T:System.Transactions.PreparingEnlistment" /> 对象。</param>
        <summary>通知登记的对象事务正在为提交做准备。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事务管理器时调用此方法的登记资源管理器的阶段 1 做出的承诺，它将询问参与者它们是否能够提交事务。  
  
 在实现持久的资源管理器时，你应记录你准备在此阶段的记录。 记录应包含所有必需的信息来执行恢复。 这包括<xref:System.Transactions.PreparingEnlistment.RecoveryInformation%2A>属性，传递给事务管理器中的<xref:System.Transactions.TransactionManager.Reenlist%2A>在恢复过程的方法。 有关恢复的详细信息，请参阅[执行恢复](http://msdn.microsoft.com/library/d342c5c7-da64-4a4c-8e63-b52f4fbf2691)。  
  
 资源管理器应完成的所有工作都必须先完成，然后再调<xref:System.Transactions.PreparingEnlistment.Prepared%2A>方法`preparingEnlistment`参数以指示承诺其投票。 你应确保这在提交、 回滚或置疑接收任何第 2 阶段通知此类之前完成。 这是因为第 2 阶段通知时才会在同一线程调用的内联<xref:System.Transactions.PreparingEnlistment.Prepared%2A>第 1 阶段中的方法。 因此，在调用 <xref:System.Transactions.PreparingEnlistment.Prepared%2A> 后，您不应执行任何预计在收到第 2 阶段通知前就可完成的操作（如释放锁定）。  
  
 你还可以调用的方法`preparingEnlistment`参数以指示回滚一票。  
  
 如果你想要只是观察并响应的事务，进度的对象没有参与它，此方法的实现应调用<xref:System.Transactions.Enlistment.Done%2A>方法`preparingEnlistment`参数时它已完成其工作。 这样，资源管理器将不会收到任何第 2 阶段通知。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rollback">
      <MemberSignature Language="C#" Value="public void Rollback (System.Transactions.Enlistment enlistment);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Rollback(class System.Transactions.Enlistment enlistment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Transactions.IEnlistmentNotification.Rollback(System.Transactions.Enlistment)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Rollback(System::Transactions::Enlistment ^ enlistment);" />
      <MemberSignature Language="F#" Value="abstract member Rollback : System.Transactions.Enlistment -&gt; unit" Usage="iEnlistmentNotification.Rollback enlistment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Transactions</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Transactions.Local</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enlistment" Type="System.Transactions.Enlistment" />
      </Parameters>
      <Docs>
        <param name="enlistment">用于将响应发送到事务管理器的 <see cref="T:System.Transactions.Enlistment" /> 对象。</param>
        <summary>通知登记的对象事务正在回滚（中止）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当事务正在回滚 （中止） 由于一个或多个事务参与者无法提交事务时，事务管理器将调用此方法的登记的对象。  
  
 资源管理器应执行任何工作需要完成事务，随后又通知它完成通过调用 TM<xref:System.Transactions.Enlistment.Done%2A>方法`enlistment`参数。  
  
 如果资源管理器已持久登记，但未通过调用响应<xref:System.Transactions.Enlistment.Done%2A>方法，事务管理器不确定的资源管理器已收到<xref:System.Transactions.IEnlistmentNotification.Rollback%2A>调用。 在这种情况下，事务管理器将继续等待响应，并且保留信息与此事务。  如果<xref:System.Transactions.Enlistment.Done%2A>是永远不会调用，这段信息是围绕无限期保留在内存中或在系统级资源。 这会导致无法回收资源。 对于分布式事务，这可能最终填满 MSDTC 日志将停止 MSDTC 过程。 在由事务的情况下<xref:System.Transactions>，这会导致资源管理器的进程的内存消耗的逐步地持续增长。 因此，很重要，则调用<xref:System.Transactions.Enlistment.Done%2A>方法后资源管理器，可使用你准备工作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>