<Type Name="Dispatcher" FullName="System.Windows.Threading.Dispatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="241fd0ba7a347cff7d7803a0904f74473d27fbc8" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36464415" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Dispatcher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Dispatcher extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Threading.Dispatcher" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Dispatcher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Dispatcher sealed" />
  <TypeSignature Language="F#" Value="type Dispatcher = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides services for managing the queue of work items for a thread.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher>维护特定线程的工作项按优先级排列的队列。  
  
 当<xref:System.Windows.Threading.Dispatcher>创建在一个线程，它将变为唯一<xref:System.Windows.Threading.Dispatcher>，可能与线程，即使<xref:System.Windows.Threading.Dispatcher>关闭的情况下。  
  
 如果你尝试获取<xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>当前线程和<xref:System.Windows.Threading.Dispatcher>所关联的线程，<xref:System.Windows.Threading.Dispatcher>将创建。 A<xref:System.Windows.Threading.Dispatcher>创建时还创建<xref:System.Windows.Threading.DispatcherObject>。 如果你创建<xref:System.Windows.Threading.Dispatcher>后台线程，请务必在退出线程之前关闭调度程序。  
  
 如果<xref:System.Windows.Threading.Dispatcher>关闭的情况下，它无法重新启动。  
  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]、<xref:System.Windows.Threading.DispatcherObject>只能由访问<xref:System.Windows.Threading.Dispatcher>与之关联。  例如，后台线程不能更新的内容<xref:System.Windows.Controls.Button>关联<xref:System.Windows.Threading.Dispatcher>上[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]线程。  为了使后台线程访问<xref:System.Windows.Controls.ContentControl.Content%2A>属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与关联[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]线程。  这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。  该操作将添加到的队列<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>上调用<xref:System.Windows.Threading.Dispatcher>，已关闭，返回的 status 属性<xref:System.Windows.Threading.DispatcherOperation>设置为<xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>。  
  
 上的方法的所有<xref:System.Windows.Threading.Dispatcher>，除<xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>，为自由线程对象。  
  
 从派生的对象<xref:System.Windows.Threading.DispatcherObject>具有线程关联。  
  
 从派生的对象<xref:System.Windows.Freezable>是自由线程时它们已冻结。  有关详细信息，请参阅 [Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。  
  
   
  
## Examples  
 下面的示例演示如何放置操作<xref:System.Windows.Threading.Dispatcher>。  此示例的完整源代码，请参阅[单线程应用程序与长时间运行计算示例](http://go.microsoft.com/fwlink/?LinkID=160038)。  
  
 首先，创建委托时，不接受任何参数。  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 接下来，<xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29>调用。  此调用<xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29>采用两个参数： 的优先级设置为<xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>，和回调，在传递委托的一个实例`NextPrimeDelegate`。  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Executes a delegate asynchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。  这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。  该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 是异步的;因此，控制权会立即返回到调用的对象后调用。  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 返回<xref:System.Windows.Threading.DispatcherOperation>可以用于委托时在事件队列的委托交互的对象。  
  
 <xref:System.Windows.Threading.DispatcherOperation>返回对象<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可通过多种方式与指定的委托，如交互：  
  
-   更改<xref:System.Windows.Threading.DispatcherPriority>的委托因为它正在等待执行的事件队列。  
  
-   从事件队列中删除委托。  
  
-   等待要返回的委托。  
  
-   获取在委托返回其后的值执行。  
  
 如果选择多个<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>调用在同一个<xref:System.Windows.Threading.DispatcherPriority>，它们将在调用所做的顺序执行。  
  
 如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>上调用<xref:System.Windows.Threading.Dispatcher>，已关闭，返回的 status 属性<xref:System.Windows.Threading.DispatcherOperation>设置为<xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">The delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate asynchronously with the specified arguments on the thread that the <see cref="T:System.Windows.Threading.Dispatcher" /> was created on.</summary>
        <returns>An object, which is returned immediately after <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.DispatcherOperation>返回对象<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可通过多种方式与指定的委托，如交互：  
  
-   更改<xref:System.Windows.Threading.DispatcherPriority>的委托因为它正在等待执行的事件队列。  
  
-   从事件队列中删除委托。  
  
-   等待要返回的委托。  
  
-   获取在委托返回其后的值执行。  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 是异步的;因此，控制权会立即返回到调用的对象后调用。  
  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。 例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。 为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。 这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。 该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>上调用<xref:System.Windows.Threading.Dispatcher>，已关闭，返回的 status 属性<xref:System.Windows.Threading.DispatcherOperation>设置为<xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">The delegate to a method that takes no arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <summary>Executes the specified delegate asynchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果选择多个<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>调用在同一个<xref:System.Windows.Threading.DispatcherPriority>，它们将在调用所做的顺序执行。  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 返回<xref:System.Windows.Threading.DispatcherOperation>可以用于委托时在事件队列的委托交互的对象。  
  
 <xref:System.Windows.Threading.DispatcherOperation>返回对象<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可通过多种方式与指定的委托，如交互：  
  
-   更改<xref:System.Windows.Threading.DispatcherPriority>的委托因为它正在等待执行的事件队列。  
  
-   从事件队列中删除委托。  
  
-   等待要返回的委托。  
  
-   获取在委托返回其后的值执行。  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 是异步的;因此，控制权会立即返回到调用的对象后调用。  
  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。  这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。  该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>上调用<xref:System.Windows.Threading.Dispatcher>，已关闭，返回的 status 属性<xref:System.Windows.Threading.DispatcherOperation>设置为<xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>。  
  
   
  
## Examples  
 下面的示例演示如何放置操作<xref:System.Windows.Threading.Dispatcher>。  此示例的完整源代码，请参阅[单线程应用程序与长时间运行计算示例](http://go.microsoft.com/fwlink/?LinkID=160038)。  
  
 首先，创建委托时，不接受任何参数。  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 接下来，<xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29>调用。  因为每个<xref:System.Windows.Threading.DispatcherObject>具有一个属性，返回<xref:System.Windows.Threading.Dispatcher>是与所需<xref:System.Windows.Threading.Dispatcher>通过查询获取<xref:System.Windows.Threading.DispatcherObject>，在这种情况下<xref:System.Windows.Controls.Button>名为`startStopButton`。   调用<xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29>采用两个参数： 的优先级设置为<xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>，和回调，在传递委托的一个实例`NextPrimeDelegate`。  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">The delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate asynchronously with the specified arguments, at the specified priority, on the thread that the <see cref="T:System.Windows.Threading.Dispatcher" /> was created on.</summary>
        <returns>An object, which is returned immediately after <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.DispatcherOperation>返回对象<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可通过多种方式与指定的委托，如交互：  
  
-   更改<xref:System.Windows.Threading.DispatcherPriority>的委托因为它正在等待执行的事件队列。  
  
-   从事件队列中删除委托。  
  
-   等待要返回的委托。  
  
-   获取在委托返回其后的值执行。  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 是异步的;因此，控制权会立即返回到调用的对象后调用。  
  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。 例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。 为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。 这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。 该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>上调用<xref:System.Windows.Threading.Dispatcher>，已关闭，返回的 status 属性<xref:System.Windows.Threading.DispatcherOperation>设置为<xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">A delegate to a method that takes one argument, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">The object to pass as an argument to the specified method.</param>
        <summary>Executes the specified delegate asynchronously at the specified priority and with the specified argument on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` 可以是`null`如果不需要参数。  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 返回<xref:System.Windows.Threading.DispatcherOperation>可以用于委托时在事件队列的委托交互的对象。  
  
 <xref:System.Windows.Threading.DispatcherOperation>返回对象<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可通过多种方式与指定的委托，如交互：  
  
-   更改<xref:System.Windows.Threading.DispatcherPriority>的委托因为它正在等待执行的事件队列。  
  
-   从事件队列中删除委托。  
  
-   等待要返回的委托。  
  
-   获取在委托返回其后的值执行。  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 是异步的;因此，控制权会立即返回到调用的对象后调用。  
  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。  这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。  该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 如果选择多个<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>调用在同一个<xref:System.Windows.Threading.DispatcherPriority>，它们将在调用所做的顺序执行。  
  
 如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>上调用<xref:System.Windows.Threading.Dispatcher>，已关闭，返回的 status 属性<xref:System.Windows.Threading.DispatcherOperation>设置为<xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>。  
  
   
  
## Examples  
 下面的示例演示如何放置操作<xref:System.Windows.Threading.Dispatcher>。  
  
 首先，创建委托时，接受一个参数，在此示例中为字符串。  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdelegates)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdelegates)]  
  
 接下来，<xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29>调用。  因为每个<xref:System.Windows.Threading.DispatcherObject>具有一个属性，返回<xref:System.Windows.Threading.Dispatcher>是与所需<xref:System.Windows.Threading.Dispatcher>通过查询获取<xref:System.Windows.Threading.DispatcherObject>，在这种情况下<xref:System.Windows.Controls.Grid>名为`tomorrowsWeather`。 调用<xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29>采用三个参数： 的优先级设置为<xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>; 传递委托的一个实例中的回调`OneArgDelegate`; 和名为一个字符串`weather`，即回调的自变量。  
  
 [!code-csharp[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdispatcheronearge)]
 [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdispatcheronearge)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">A delegate to a method that takes multiple arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">The object to pass as an argument to the specified method.</param>
        <param name="args">An array of objects to pass as arguments to the specified method.</param>
        <summary>Executes the specified delegate asynchronously at the specified priority and with the specified array of arguments on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> is called, that can be used to interact with the delegate as it is pending execution in the <see cref="T:System.Windows.Threading.Dispatcher" /> queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `arg`参数可以为`null`如果不需要参数。  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 返回<xref:System.Windows.Threading.DispatcherOperation>可以用于委托时在事件队列的委托交互的对象。  
  
 <xref:System.Windows.Threading.DispatcherOperation>返回对象<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可通过多种方式与指定的委托，如交互：  
  
-   更改<xref:System.Windows.Threading.DispatcherPriority>的委托因为它正在等待执行的事件队列。  
  
-   从事件队列中删除委托。  
  
-   等待要返回的委托。  
  
-   获取在委托返回其后的值执行。  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 是异步的;因此，控制权会立即返回到调用的对象后调用。  
  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。  这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。  该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 如果选择多个<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>调用在同一个<xref:System.Windows.Threading.DispatcherPriority>，它们将在调用所做的顺序执行。  
  
 如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>上调用<xref:System.Windows.Threading.Dispatcher>，已关闭，返回的 status 属性<xref:System.Windows.Threading.DispatcherOperation>设置为<xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <see cref="T:System.Windows.Threading.DispatcherPriority" /> is not a valid priority.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInvokeShutdown">
      <MemberSignature Language="C#" Value="public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginInvokeShutdown(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInvokeShutdown (priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginInvokeShutdown(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.BeginInvokeShutdown : System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.BeginInvokeShutdown priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">The priority at which to begin shutting down the dispatcher.</param>
        <summary>Initiates shutdown of the <see cref="T:System.Windows.Threading.Dispatcher" /> asynchronously.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.BeginInvokeShutdown%2A> 需求不受限制的 UI 权限。  
  
 当<xref:System.Windows.Threading.Dispatcher>开始关闭的情况下，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>设置为`true`。  
  
 <xref:System.Windows.Threading.Dispatcher>不会关闭完全展开事件队列之前。  
  
 调度程序完成的情况下，关闭时<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>属性设置为`true`。  
  
 关闭流程开始之后，所有挂起的工作将中止队列中的项。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">有关关闭调度程序。  关联的枚举：  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public bool CheckAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckAccess () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckAccess();" />
      <MemberSignature Language="F#" Value="member this.CheckAccess : unit -&gt; bool" Usage="dispatcher.CheckAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determines whether the calling thread is the thread associated with this <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>
          <see langword="true" /> if the calling thread is the thread associated with this <see cref="T:System.Windows.Threading.Dispatcher" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅<xref:System.Windows.Threading.Dispatcher>，<xref:System.Windows.Threading.DispatcherObject>创建在可能访问的对象。  使用<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>用于从另一个线程访问的对象。  
  
 <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> 可以从任何线程调用。  
  
 之间的差异<xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>和<xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>是<xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>返回一个布尔值，该值指示调用线程是否有权访问<xref:System.Windows.Threading.Dispatcher>和<xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>引发异常。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>以确定线程是否有权访问<xref:System.Windows.Controls.Button>。  <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>方法<xref:System.Windows.Threading.Dispatcher>与关联<xref:System.Windows.Controls.Button>调用以验证是否可以访问该线程。  如果调用线程可以访问<xref:System.Windows.Threading.Dispatcher>、<xref:System.Windows.Controls.Button>更新通过访问的成员<xref:System.Windows.Controls.Button>; 否则为一个委托，它接受<xref:System.Windows.Controls.Button>作为自变量，置于<xref:System.Windows.Threading.Dispatcher>。  <xref:System.Windows.Threading.Dispatcher>会将委托的更新的工作<xref:System.Windows.Controls.Button>。  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccesscheckaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccesscheckaccess)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDispatcher">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Threading.Dispatcher CurrentDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDispatcher As Dispatcher" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Threading::Dispatcher ^ CurrentDispatcher { System::Windows::Threading::Dispatcher ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDispatcher : System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Windows.Threading.Dispatcher" /> for the thread currently executing and creates a new <see cref="T:System.Windows.Threading.Dispatcher" /> if one is not already associated with the thread.</summary>
        <value>调度程序与当前线程关联。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Windows.Threading.Dispatcher>所关联的当前线程，新<xref:System.Windows.Threading.Dispatcher>将创建。  这不同于使用 <xref:System.Windows.Threading.Dispatcher.FromThread%2A> 方法的情况。  <xref:System.Windows.Threading.Dispatcher.FromThread%2A> 将返回`null`是否不存在与指定的线程调度程序。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableProcessing">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.DisableProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Function DisableProcessing () As DispatcherProcessingDisabled" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherProcessingDisabled DisableProcessing();" />
      <MemberSignature Language="F#" Value="member this.DisableProcessing : unit -&gt; System.Windows.Threading.DispatcherProcessingDisabled" Usage="dispatcher.DisableProcessing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherProcessingDisabled</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disables processing of the <see cref="T:System.Windows.Threading.Dispatcher" /> queue.</summary>
        <returns>A structure used to re-enable dispatcher processing.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 禁用调度程序处理属于高级的方法，旨在消除不相关的重新进入的可能性。  
  
 禁用处理的作用如下所示：  
  
-   CLR 锁不将内部发送消息。  
  
-   <xref:System.Windows.Threading.DispatcherFrame> 不允许对象推送。  
  
-   不允许消息处理。  
  
 <xref:System.Windows.Threading.DispatcherProcessingDisabled>结构的<xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>返回被调用时可用来重新启用处理的调度程序。  调用<xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A>上<xref:System.Windows.Threading.DispatcherProcessingDisabled>结构将重新启用处理。  
  
 <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> 只能在线程上调用<xref:System.Windows.Threading.Dispatcher>与相关联。  
  
   
  
## Examples  
 下面的示例演示如何禁用调度程序处理并重新启用处理的调度程序。  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> 在中调用**使用**语句。  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> 返回<xref:System.Windows.Threading.DispatcherProcessingDisabled>用作对象，以被释放的结构**使用**块结束。  当<xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A>上调用<xref:System.Windows.Threading.DispatcherProcessingDisabled>结构，处理的调度程序重新启用。  
  
 [!code-csharp[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdisableprocessing)]
 [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdisableprocessing)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExitAllFrames">
      <MemberSignature Language="C#" Value="public static void ExitAllFrames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitAllFrames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitAllFrames ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitAllFrames();" />
      <MemberSignature Language="F#" Value="static member ExitAllFrames : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ExitAllFrames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Requests that all frames exit, including nested frames.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">用于调用此方法。 关联的枚举：  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
        <altmember cref="T:System.Windows.Threading.DispatcherFrame" />
      </Docs>
    </Member>
    <Member MemberName="FromThread">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Threading.Dispatcher FromThread(class System.Threading.Thread thread) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::Dispatcher ^ FromThread(System::Threading::Thread ^ thread);" />
      <MemberSignature Language="F#" Value="static member FromThread : System.Threading.Thread -&gt; System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.FromThread thread" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="System.Threading.Thread" />
      </Parameters>
      <Docs>
        <param name="thread">The thread to obtain the <see cref="T:System.Windows.Threading.Dispatcher" /> from.</param>
        <summary>Gets the <see cref="T:System.Windows.Threading.Dispatcher" /> for the specified thread.</summary>
        <returns>The dispatcher for <paramref name="thread" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果没有可用于指定线程的调度程序`null`将返回。  
  
 <xref:System.Windows.Threading.Dispatcher.FromThread%2A> 不会创建<xref:System.Windows.Threading.Dispatcher>上不具有线程<xref:System.Windows.Threading.Dispatcher>。   一个新<xref:System.Windows.Threading.Dispatcher>尚不包含的线程上创建<xref:System.Windows.Threading.Dispatcher>时尝试获取<xref:System.Windows.Threading.Dispatcher>使用<xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownFinished">
      <MemberSignature Language="C#" Value="public bool HasShutdownFinished { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownFinished" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownFinished As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownFinished { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownFinished : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the <see cref="T:System.Windows.Threading.Dispatcher" /> has finished shutting down.</summary>
        <value>
          <see langword="true" /> 如果调度程序已完成关闭;否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Windows.Threading.Dispatcher>开始关闭的情况下，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>设置为`true`。  
  
 <xref:System.Windows.Threading.Dispatcher>事件队列展开之前完全没有关闭。  
  
 调度程序完成的情况下，关闭时<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>属性设置为`true`。  
  
 关闭流程开始之后，所有挂起的工作将中止队列中的项。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the <see cref="T:System.Windows.Threading.Dispatcher" /> is shutting down.</summary>
        <value>
          <see langword="true" /> 如果<see cref="T:System.Windows.Threading.Dispatcher" />已开始关闭; 否则为为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Windows.Threading.Dispatcher>开始关闭的情况下，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>设置为`true`。  
  
 <xref:System.Windows.Threading.Dispatcher>不会关闭完全展开事件队列之前。  
  
 调度程序完成的情况下，关闭时<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>属性设置为`true`。  
  
 关闭流程开始之后，所有挂起的工作将中止队列中的项。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hooks">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherHooks Hooks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Threading.DispatcherHooks Hooks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Hooks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Hooks As DispatcherHooks" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Threading::DispatcherHooks ^ Hooks { System::Windows::Threading::DispatcherHooks ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Hooks : System.Windows.Threading.DispatcherHooks" Usage="System.Windows.Threading.Dispatcher.Hooks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherHooks</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of hooks that provide additional event information about the <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <value>与此关联的挂钩<see cref="T:System.Windows.Threading.Dispatcher" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.DispatcherHooks>类提供了有关的其他事件信息<xref:System.Windows.Threading.Dispatcher>，例如，当<xref:System.Windows.Threading.Dispatcher>处于非活动状态或完成操作时。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">用于获取此属性。  关联的枚举：  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Executes the specified delegate synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。  这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。  该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。  
  
   
  
## Examples  
 下面的示例将放置到委托<xref:System.Windows.Threading.Dispatcher>在<xref:System.Windows.Threading.DispatcherPriority.Normal>使用<xref:System.Windows.Threading.Dispatcher.Invoke%2A>。  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action -&gt; unit" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action, priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">A delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。 例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。 为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。 这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。 该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">A delegate to a method that takes no arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <summary>Executes the specified delegate synchronously at the specified priority on the thread on which the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。  这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。  该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。  
  
   
  
## Examples  
 下面的示例将放置到委托<xref:System.Windows.Threading.Dispatcher>在<xref:System.Windows.Threading.DispatcherPriority.Normal>使用<xref:System.Windows.Threading.Dispatcher.Invoke%2A>。  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> is equal to <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid priority.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the action.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">A delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="timeout">The maximum amount of time to wait for the operation to complete.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate within the designated time span at the specified priority with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。 例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。 为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。 这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。 该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">A delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate at the specified priority with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。 例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。 为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。 这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。 该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">A delegate to a method that takes one argument, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">An object to pass as an argument to the given method.</param>
        <summary>Executes the specified delegate at the specified priority with the specified argument synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` 可以是`null`如果不需要自变量  
  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。  这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。  该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> is equal to <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid priority.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="timeout">The maximum time to wait for the operation to finish.</param>
        <param name="method">The delegate to a method that takes no arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <summary>Executes the specified delegate synchronously at the specified priority and with the specified time-out value on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> was created.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。  这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。  该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the action.</param>
        <param name="timeout">The minimum amount of time to wait for the operation to start.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">A delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="timeout">The maximum amount of time to wait for the operation to complete.</param>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate within the designated time span at the specified priority with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。 例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。 为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。 这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。 该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">A delegate to a method that takes multiple arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">An object to pass as an argument to the given method.</param>
        <param name="args">An array of objects to pass as arguments to the given method.</param>
        <summary>Executes the specified delegate at the specified priority with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` 可以是`null`如果不需要自变量  
  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。  这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。  该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> is equal to <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid priority.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="timeout">The maximum time to wait for the operation to finish.</param>
        <param name="method">A delegate to a method that takes multiple arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">An object to pass as an argument to the given method. This can be <see langword="null" /> if no arguments are needed.</param>
        <summary>Executes the specified delegate at the specified priority with the specified argument synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` 可以是`null`如果不需要自变量  
  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。  这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。  该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> is equal to <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid priority.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="timeout">The maximum time to wait for the operation to finish.</param>
        <param name="method">A delegate to a method that takes multiple arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">An object to pass as an argument to the specified method.</param>
        <param name="args">An array of objects to pass as arguments to the specified method.</param>
        <summary>Executes the specified delegate at the specified priority with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` 可以是`null`如果不需要自变量。  
  
 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，仅在创建线程<xref:System.Windows.Threading.DispatcherObject>才能访问该对象。  例如，从主 UI 线程运行的后台线程不能更新的内容<xref:System.Windows.Controls.Button>UI 线程上创建。  为了使后台线程访问的内容属性<xref:System.Windows.Controls.Button>，后台线程必须将工作委托给<xref:System.Windows.Threading.Dispatcher>与 UI 线程关联。  这通过使用实现<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的。  该操作将添加到事件队列的<xref:System.Windows.Threading.Dispatcher>位于指定<xref:System.Windows.Threading.DispatcherPriority>。  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步操作;因此，控件将不返回到之前调用的对象后在回调返回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> is equal to <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; -&gt; 'Result" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">指定的委托的返回值类型。</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的值`callback`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">指定的委托的返回值类型。</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的值`callback`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">指定的委托的返回值类型。</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the operation.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的值`callback`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">指定的委托的返回值类型。</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the operation.</param>
        <param name="timeout">The minimum amount of time to wait for the operation to start.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的值`callback`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeAsync">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Executes the specified delegate asynchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> asynchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action, priority As DispatcherPriority) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> asynchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the action.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> asynchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult)) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">指定的委托的返回值类型。</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> asynchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">指定的委托的返回值类型。</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> asynchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">指定的委托的返回值类型。</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the operation.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeShutdown">
      <MemberSignature Language="C#" Value="public void InvokeShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeShutdown();" />
      <MemberSignature Language="F#" Value="member this.InvokeShutdown : unit -&gt; unit" Usage="dispatcher.InvokeShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiates the shutdown process of the <see cref="T:System.Windows.Threading.Dispatcher" /> synchronously.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.InvokeShutdown%2A> 需求不受限制的 UI 权限。  
  
 当<xref:System.Windows.Threading.Dispatcher>开始关闭的情况下，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>设置为`true`。  
  
 <xref:System.Windows.Threading.Dispatcher>不会关闭完全展开事件队列之前。  
  
 调度程序完成的情况下，关闭时<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>属性设置为`true`。  
  
 关闭流程开始之后，所有挂起的工作将中止队列中的项。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">有关关闭调度程序。  关联的枚举：  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PushFrame">
      <MemberSignature Language="C#" Value="public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PushFrame(class System.Windows.Threading.DispatcherFrame frame) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PushFrame (frame As DispatcherFrame)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PushFrame(System::Windows::Threading::DispatcherFrame ^ frame);" />
      <MemberSignature Language="F#" Value="static member PushFrame : System.Windows.Threading.DispatcherFrame -&gt; unit" Usage="System.Windows.Threading.Dispatcher.PushFrame frame" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frame" Type="System.Windows.Threading.DispatcherFrame" />
      </Parameters>
      <Docs>
        <param name="frame">The frame for the dispatcher to process.</param>
        <summary>Enters an execute loop.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Threading.DispatcherFrame>表示处理挂起的工作项的循环。  
  
 调度程序处理在循环中的工作项队列。  循环称为框架。  初始循环通常通过调用来启动应用程序<xref:System.Windows.Threading.Dispatcher.Run%2A>。  
  
 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> 进入该参数表示循环`frame`。  每次迭代循环，<xref:System.Windows.Threading.Dispatcher>将检查<xref:System.Windows.Threading.DispatcherFrame.Continue%2A>属性<xref:System.Windows.Threading.DispatcherFrame>类以确定是否应继续循环或如果它应停止。  
  
 <xref:System.Windows.Threading.DispatcherFrame> 允许<xref:System.Windows.Threading.DispatcherFrame.Continue%2A>属性显式设置，并且它遵循<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>属性<xref:System.Windows.Threading.Dispatcher>。  这意味着当<xref:System.Windows.Threading.Dispatcher>开始关闭的情况下，使用默认的帧<xref:System.Windows.Threading.DispatcherFrame>实现将退出，从而使所有嵌套的帧退出。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Windows.Threading.DispatcherFrame>达到类似结果作为[!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)]<xref:System.Windows.Forms.Application.DoEvents%2A>方法。  
  
 [!code-csharp[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdispatcherframedoevents)]
 [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdispatcherframedoevents)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="frame" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" /> is <see langword="true" />  -or-  <paramref name="frame" /> is running on a different <see cref="T:System.Windows.Threading.Dispatcher" />.  -or-  Dispatcher processing has been disabled.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">用于推送执行帧。  关联的枚举：  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pushes the main execution frame on the event queue of the <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher>处理在循环中的事件队列。  循环称为框架。  初始循环通常通过调用来启动应用程序<xref:System.Windows.Threading.Dispatcher.Run%2A>。  
  
 主执行帧将继续进行，直到<xref:System.Windows.Threading.Dispatcher>关闭。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownFinished">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownFinished;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownFinished" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownFinished As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownFinished;" />
      <MemberSignature Language="F#" Value="member this.ShutdownFinished : EventHandler " Usage="member this.ShutdownFinished : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="T:System.Windows.Threading.Dispatcher" /> finishes shutting down.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当关闭进程的<xref:System.Windows.Threading.Dispatcher>启动时，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>设置为`true`。  
  
 <xref:System.Windows.Threading.Dispatcher>事件队列展开之前完全没有关闭。  
  
 调度程序完成的情况下，关闭时<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>属性设置为`true`。  
  
 关闭流程开始之后，所有挂起的工作将中止队列中的项。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownStarted">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownStarted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownStarted As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownStarted;" />
      <MemberSignature Language="F#" Value="member this.ShutdownStarted : EventHandler " Usage="member this.ShutdownStarted : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="T:System.Windows.Threading.Dispatcher" /> begins to shut down.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当关闭进程的<xref:System.Windows.Threading.Dispatcher>启动时，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>设置为`true`。  
  
 <xref:System.Windows.Threading.Dispatcher>事件队列展开之前完全没有关闭。  
  
 调度程序完成的情况下，关闭时<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>引发事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>属性设置为`true`。  
  
 关闭流程开始之后，所有挂起的工作将中止队列中的项。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="Thread">
      <MemberSignature Language="C#" Value="public System.Threading.Thread Thread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Thread Thread" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Thread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Thread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Thread ^ Thread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Thread : System.Threading.Thread" Usage="System.Windows.Threading.Dispatcher.Thread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the thread this <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <value>线程。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Event UnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a thread exception is thrown and uncaught during execution of a delegate by way of <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> or <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过委托执行期间引发的异常时，将引发此事件<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>未捕获。  
  
 处理程序可以将该异常标记为已处理，这会阻止内部的异常处理程序调用。  
  
 必须小心来避免创建辅助异常并发现出现任何的写入此事件的事件处理程序。 建议避免分配内存或执行处理程序中的密集型操作的任何资源。  
  
 <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>事件提供了一种方法不会引发<xref:System.Windows.Threading.Dispatcher.UnhandledException>事件。  <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>首先，将引发事件; 如果<xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>上<xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs>设置为`false`、<xref:System.Windows.Threading.Dispatcher.UnhandledException>不会引发事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledExceptionFilter">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledExceptionFilter As DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionFilterEventHandler ^ UnhandledExceptionFilter;" />
      <MemberSignature Language="F#" Value="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " Usage="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a thread exception is thrown and uncaught during execution of a delegate by way of <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> or <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> when in the filter stage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将通过委托执行期间引发的异常的筛选器阶段引发此事件<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>且未能捕获。  
  
 调用堆栈不展开这一时刻 （首次异常）。  
  
 必须小心来避免创建辅助异常并发现出现任何的写入此事件的事件处理程序。  建议避免分配内存或执行处理程序中的密集型操作的任何资源。  
  
 <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>事件提供了一种方法不会引发<xref:System.Windows.Threading.Dispatcher.UnhandledException>事件。  <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>首先，将引发事件; 如果<xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>上<xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs>设置为`false`、<xref:System.Windows.Threading.Dispatcher.UnhandledException>不会引发事件。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">添加或删除此事件的处理程序。  关联的枚举：  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ValidatePriority">
      <MemberSignature Language="C#" Value="public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ValidatePriority(valuetype System.Windows.Threading.DispatcherPriority priority, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ValidatePriority (priority As DispatcherPriority, parameterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ValidatePriority(System::Windows::Threading::DispatcherPriority priority, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="static member ValidatePriority : System.Windows.Threading.DispatcherPriority * string -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ValidatePriority (priority, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="priority">The priority to check.</param>
        <param name="parameterName">A string that will be returned by the exception that occurs if the priority is invalid.</param>
        <summary>Determines whether the specified <see cref="T:System.Windows.Threading.DispatcherPriority" /> is a valid priority.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyAccess">
      <MemberSignature Language="C#" Value="public void VerifyAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void VerifyAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      <MemberSignature Language="VB.NET" Value="Public Sub VerifyAccess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void VerifyAccess();" />
      <MemberSignature Language="F#" Value="member this.VerifyAccess : unit -&gt; unit" Usage="dispatcher.VerifyAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determines whether the calling thread has access to this <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有线程<xref:System.Windows.Threading.Dispatcher>创建在可以访问<xref:System.Windows.Threading.Dispatcher>。  
  
 此方法是公共的;因此，可以检查任何线程以查看它是否有权访问<xref:System.Windows.Threading.Dispatcher>。  
  
 之间的差异<xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>和<xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>是<xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>返回一个布尔值，如果调用线程不具有访问<xref:System.Windows.Threading.Dispatcher>和<xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>引发异常。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>以确定线程是否有权访问该线程，<xref:System.Windows.Controls.Button>上创建。  该方法采用一个对象作为参数，它被强制转换为<xref:System.Windows.Controls.Button>。  <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>方法<xref:System.Windows.Threading.Dispatcher>的<xref:System.Windows.Controls.Button>调用以验证是否可以访问该线程。  
  
 如果调用线程可以访问<xref:System.Windows.Threading.Dispatcher>、<xref:System.Windows.Controls.Button>只需访问的成员更新<xref:System.Windows.Controls.Button>。  
  
 如果调用线程不具有访问权限，<xref:System.InvalidOperationException>引发。  此示例中捕获异常并将推送委托，它接受<xref:System.Windows.Controls.Button>作为自变量，到<xref:System.Windows.Threading.Dispatcher>的<xref:System.Windows.Controls.Button>。  这<xref:System.Windows.Threading.Dispatcher>将执行更新的工作<xref:System.Windows.Controls.Button>。  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccessverifyaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccessverifyaccess)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The calling thread does not have access to this <see cref="T:System.Windows.Threading.Dispatcher" />.</exception>
        <altmember cref="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Yield">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an awaitable object that asynchronously yields control back to the current dispatcher and provides an opportunity for the dispatcher to process other events.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an awaitable object that asynchronously yields control back to the current dispatcher and provides an opportunity for the dispatcher to process other events.</summary>
        <returns>An awaitable object that asynchronously yields control back to the current dispatcher and provides an opportunity for the dispatcher to process other events.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使你能够暂时释放到当前的调度程序的执行控件，以便它可以执行其他工作，就像处理其他事件的方法。 使用`await`，或`Await`在 Visual Basic 中，运算符的返回值来将控制返回到当前的调度程序。 使用此方法，如果想要让你的应用程序有机会处理事件，而你应用程序执行大量的 UI 线程上的工作。 例如，你可以在更新控件的运行时间较长循环中使用此方法。  
  
 此方法等效于调用<xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29>方法并传入<xref:System.Windows.Threading.DispatcherPriority.Background?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield (priority As DispatcherPriority) As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="static member Yield : System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">The priority at which to schedule the continuation.</param>
        <summary>Creates an awaitable object that asynchronously yields control back to the current dispatcher and provides an opportunity for the dispatcher to process other events.  The work that occurs when control returns to the code awaiting the result of this method is scheduled with the specified priority.</summary>
        <returns>An awaitable object that asynchronously yields control back to the current dispatcher and provides an opportunity for the dispatcher to process other events.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使你能够暂时释放到当前的调度程序的执行控件，以便它可以执行其他工作，就像处理其他事件的方法。 使用`await`，或`Await`在 Visual Basic 中，运算符的返回值来将控制返回到当前的调度程序。 使用此方法，如果想要让你的应用程序有机会处理事件，而你应用程序执行大量的 UI 线程上的工作。 例如，你可以在更新控件的运行时间较长循环中使用此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>