<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="610471fbf0d011485114fda063427ce017aac1e7" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51931409" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示字符编码。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 编码是将一组 Unicode 字符转换为一个字节序列的过程。 与此相反，解码是转换为一系列 Unicode 字符编码字节的序列的过程。 有关 Unicode 转换格式 (Utf) 和支持的其他编码信息<xref:System.Text.Encoding>，请参阅[.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)。  
  
 请注意，<xref:System.Text.Encoding>旨在对 Unicode 字符，而不是任意的二进制数据，如字节数组。 如果必须将任意二进制数据编码为文本，则应使用协议如 uuencode，实现方法如<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>。  
  
 .NET 提供的以下实现<xref:System.Text.Encoding>类，以支持当前的 Unicode 编码和其他编码：  
  
-   <xref:System.Text.ASCIIEncoding> 将 Unicode 字符编码为单个 7 位 ASCII 字符。 此编码仅支持之间的字符值 0000 和 U + 007F。 代码页 20127。 也可通过<xref:System.Text.Encoding.ASCII%2A>属性。  
  
-   <xref:System.Text.UTF7Encoding> 将使用 utf-7 编码的 Unicode 字符编码。 此编码支持所有 Unicode 字符值。 代码页 65000。 也可通过<xref:System.Text.Encoding.UTF7%2A>属性。  
  
-   <xref:System.Text.UTF8Encoding> 将使用 utf-8 编码的 Unicode 字符编码。 此编码支持所有 Unicode 字符值。 代码页 65001。 也可通过<xref:System.Text.Encoding.UTF8%2A>属性。  
  
-   <xref:System.Text.UnicodeEncoding> 将使用 utf-16 编码的 Unicode 字符编码。 支持这两个 little endian 和大 endian 字节顺序。 也可通过<xref:System.Text.Encoding.Unicode%2A>属性和<xref:System.Text.Encoding.BigEndianUnicode%2A>属性。  
  
-   <xref:System.Text.UTF32Encoding> 将使用 UTF-32 编码的 Unicode 字符编码。 同时小 endian （代码页 12000） 和大端 （代码页 12001） 字节支持顺序。 也可通过<xref:System.Text.Encoding.UTF32%2A>属性。  
  
 <xref:System.Text.Encoding>类主要用于不同的编码与 Unicode 之间转换。 通常派生的 Unicode 类之一是您的应用程序的正确选择。  
  
 使用<xref:System.Text.Encoding.GetEncoding%2A>方法来获取其他编码，并调用<xref:System.Text.Encoding.GetEncodings%2A>方法以获取所有编码的列表。  
  
 下表列出了.NET Framework 和.NET Core 支持的编码。 它列出了每个编码的代码页编号和编码的值<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>和<xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType>属性。 中的复选标记 **.NET Framework 的支持**并 **.NET Core 支持**列指示该.NET 实现，而不考虑基础平台本身就支持代码页。 对于.NET Framework 中，表中列出的其他编码的可用性取决于操作系统。 对于.NET Core，其他编码可通过使用<xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType>类或通过派生自<xref:System.Text.EncodingProvider?displayProperty=nameWithType>类。  

> [!NOTE]
> 代码页的<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>属性对应于一种国际标准不一定符合该标准填满中。 

|代码页|name|显示名称|.NET framework 的支持| .NET Core 支持 | 
|---------|----|------------|----------------------|-------------------|    
|37|IBM037|IBM EBCDIC （美国-加拿大）|||  
|437|IBM437|OEM 美国|||  
|500|IBM500|IBM EBCDIC （国际）|||  
|708|ASMO-708|阿拉伯语 (ASMO 708)|||  
|720|DOS-720|阿拉伯语 (DOS)|||  
|737|ibm737|希腊语 (DOS)|||  
|775|ibm775|波罗的语 (DOS)|||  
|850|ibm850|西欧语 (DOS)|||  
|852|ibm852|中欧 (DOS)|||  
|855|IBM855|OEM 西里尔文|||  
|857|ibm857|土耳其语 (DOS)|||  
|858|IBM00858|OEM 多语言拉丁语 I|||  
|860|IBM860|葡萄牙语 (DOS)|||  
|861|ibm861|冰岛语 (DOS)|||  
|862|DOS-862|希伯来语 (DOS)|||  
|863|IBM863|加拿大法语 (DOS)|||  
|864|IBM864|阿拉伯语 (864)|||  
|865|IBM865|日耳曼语 (DOS)|||  
|866|cp866|西里尔语 (DOS)|||  
|869|ibm869|(DOS) 现代希腊语|||  
|870|IBM870|IBM EBCDIC (多语言拉丁语-2)|||  
|874|windows-874|泰语 (Windows)|||  
|875|cp875|IBM EBCDIC （现代希腊语）|||  
|932|shift_jis|日语 (JIS)|||  
|936|gb2312|简体中文 (GB2312)|✓||  
|949|ks_c_5601-1987|朝鲜语|||  
|950|big5|繁体中文 (Big5)|||  
|1026|IBM1026|IBM EBCDIC (土耳其语拉丁语-5)|||  
|1047|IBM01047|IBM Latin 1|||  
|1140|IBM01140|IBM EBCDIC （美国-加拿大-欧洲）|||  
|1141|IBM01141|IBM EBCDIC (德国-Euro)|||  
|1142|IBM01142|IBM EBCDIC （丹麦-挪威-欧洲）|||  
|1143|IBM01143|IBM EBCDIC （芬兰-瑞典-欧洲）|||  
|1144|IBM01144|IBM EBCDIC （意大利-欧洲）|||  
|1145|IBM01145|IBM EBCDIC (西班牙-Euro)|||  
|1146|IBM01146|IBM EBCDIC （英国-欧洲）|||  
|1147|IBM01147|IBM EBCDIC (法国-Euro)|||  
|1148|IBM01148|IBM EBCDIC （国际-欧洲）|||  
|1149|IBM01149|IBM EBCDIC (冰岛语-Euro)|||  
|1200|utf-16|Unicode|✓|✓|  
|1201|unicodeFFFE|Unicode (Big endian)|✓|✓|  
|1250|windows-1250|中欧语 (Windows)|||  
|1251|windows-1251|西里尔语 (Windows)|||  
|1252|Windows-1252|西欧语 (Windows)|✓||  
|1253|windows-1253|希腊语 (Windows)|||  
|1254|windows-1254|土耳其语 (Windows)|||  
|1255|windows-1255|希伯来语 (Windows)|||  
|1256|windows-1256|阿拉伯语 (Windows)|||  
|1257|windows-1257|波罗的语 (Windows)|||  
|1258|windows-1258|越南语 (Windows)|||  
|1361|Johab|朝鲜语 (Johab)|||  
|10000|macintosh|西欧语 (Mac)|||  
|10001|x-mac-日语|日语 (Mac)|||  
|10002|x-mac-chinesetrad|繁体中文 (Mac)|||  
|10003|x-mac-韩语|朝鲜语 (Mac)|✓||  
|10004|x-mac-阿拉伯语|阿拉伯语 (Mac)|||  
|10005|x-mac-希伯来语|希伯来语 (Mac)|||  
|10006|x-mac-希腊语|希腊语 (Mac)|||  
|10007|x-mac-西里尔语|西里尔语 (Mac)|||  
|10008|x mac chinesesimp|简体中文 (Mac)|✓||  
|10010|罗马尼亚语 mac x|罗马尼亚语 (Mac)|||  
|10017|x-mac-乌克兰语|乌克兰语 (Mac)|||  
|10021|x-mac-泰语|泰语 (Mac)|||  
|10029|x mac ce|中欧 (Mac)|||  
|10079|x-mac-冰岛语|冰岛语 (Mac)|||  
|10081|x-mac-土耳其语|土耳其语 (Mac)|||  
|10082|x-mac-克罗地亚语|克罗地亚语 (Mac)|||  
|12000|utf-32|Unicode (UTF-32)|✓|✓|  
|12001|utf-32BE|Unicode (UTF-32 Big endian)|✓|✓|  
|20000|x 中文 CN|繁体中文 (CNS)|||  
|20001|x-cp20001|Tca|||  
|20002|x 中文 Eten|繁体中文 (Eten)|||  
|20003|x-cp20003|Ibm5550|||  
|20004|x-cp20004|TeleText 中国台湾|||  
|20005|x-cp20005|Wang 中国台湾|||  
|20105|x-IA5|西欧语 (IA5)|||  
|20106|x-IA5-德语|德语 (IA5)|||  
|20107|x-IA5-瑞典语|瑞典语 (IA5)|||  
|20108|x-IA5-Norwegian|挪威语 (IA5)|||  
|20127|我们 ascii|US-ASCII|✓|✓|  
|20261|x-cp20261|T.61|||  
|20269|x-cp20269|ISO-6937|||  
|20273|IBM273|IBM EBCDIC （德国）|||  
|20277|IBM277|IBM EBCDIC （丹麦-挪威）|||  
|20278|IBM278|IBM EBCDIC （芬兰-瑞典）|||  
|20280|IBM280|IBM EBCDIC （意大利）|||  
|20284|IBM284|IBM EBCDIC （西班牙）|||  
|20285|IBM285|IBM EBCDIC （英国）|||  
|20290|IBM290|IBM EBCDIC （日语的片假名）|||  
|20297|IBM297|IBM EBCDIC （法国）|||  
|20420|IBM420|IBM EBCDIC （阿拉伯语）|||  
|20423|IBM423|IBM EBCDIC （希腊语）|||  
|20424|IBM424|IBM EBCDIC （希伯来语）|||  
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC （朝鲜语扩展）|||  
|20838|IBM 泰语|IBM EBCDIC （泰语）|||  
|20866|koi8-r|西里尔语 (KOI8-R)|||  
|20871|IBM871|IBM EBCDIC （冰岛语）|||  
|20880|IBM880|IBM EBCDIC （西里尔俄语）|||  
|20905|IBM905|IBM EBCDIC （土耳其语）|||  
|20924|IBM00924|IBM Latin 1|||  
|20932|EUC-JP|日语 (JIS 0208 1990年和 0212年 1990年)|||  
|20936|x-cp20936|简体中文 (GB2312-80)|✓||  
|20949|x-cp20949|朝鲜语 Wansung|✓||  
|21025|cp1025|IBM EBCDIC （西里尔塞尔维亚语-保加利亚语）|||  
|21866|koi8-u|西里尔语 (KOI8-U)|||  
|28591|iso-8859-1|西欧语 (ISO)|✓|✓|  
|28592|iso-8859-2|中欧语 (ISO)|||  
|28593|iso-8859-3|拉丁文 3 (ISO)|||  
|28594|iso-8859-4|波罗的语 (ISO)|||  
|28595|iso-8859-5|西里尔语 (ISO)|||  
|28596|iso-8859-6|阿拉伯语 (ISO)|||  
|28597|iso-8859-7|希腊语 (ISO)|||  
|28598|iso-8859-8|希伯来语 (Iso-visual)|✓||  
|28599|iso-8859-9|土耳其语 (ISO)|||  
|28603|iso-8859-13|爱沙尼亚语 (ISO)|||  
|28605|iso-8859-15|拉丁语 9 (ISO)|||  
|29001|x-Europa|Europa|||  
|38598|iso-8859-8-i|希伯来语 （ISO 逻辑）|✓||  
|50220|iso-2022年-jp|日语 (JIS)|✓||  
|50221|csISO2022JP|日语 （JIS-允许 1 字节假名）|✓||  
|50222|iso-2022年-jp|日语 (JIS-允许 1 字节 Kana-因此 / SI)|✓||  
|50225|iso-2022年-韩国|朝鲜语 (ISO)|✓||  
|50227|x-cp50227|简体中文 (ISO-2022)|✓||  
|51932|euc jp|日语 (EUC)|✓||  
|51936|EUC CN|简体中文 (EUC)|✓||  
|51949|euc 韩国|朝鲜语 (EUC)|✓||  
|52936|hz-gb-2312|简体中文 (HZ)|✓||  
|54936|GB18030|简体中文 (GB18030)|✓||  
|57002|x iscii-de|ISCII 梵文字母|✓||  
|57003|x-iscii-be|ISCII 孟加拉语|✓||  
|57004|x-iscii-ta|Iscii-泰米尔语|✓||  
|57005|x iscii te|Iscii-泰卢固语|✓||  
|57006|x-作为 iscii|ISCII 阿萨姆语|✓||  
|57007|x iscii 或|ISCII 奥里雅语|✓||  
|57008|x iscii ka|Iscii-埃纳德语|✓||  
|57009|x iscii ma|Iscii 马来亚拉姆语|✓||  
|57010|x iscii gu|Iscii-古吉拉特语|✓||  
|57011|x-iscii-pa|ISCII 旁遮普语|✓||  
|65000|utf-7|Unicode (utf-7)|✓|✓|  
|65001|utf-8|Unicode (UTF-8)|✓|✓|  
  
 下面的示例调用<xref:System.Text.Encoding.GetEncoding%28System.Int32%29>和<xref:System.Text.Encoding.GetEncoding%28System.String%29>方法来获取希腊语 (Windows) 的代码页编码。 它将进行比较<xref:System.Text.Encoding>方法调用，以显示它们是否相等，并映射然后希腊字母表中显示了 Unicode 码位和每个字符的相应代码页值所返回的对象。  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 如果要转换的数据仅在顺序块 （如从流中读取的数据） 中不可用或数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供的<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。  
  
 UTF 16 和 UTF-32 编码器可以使用 big endian 字节顺序 (最高有效字节第一个) 或 little-endian 字节顺序 (最低有效字节第一个)。 例如，拉丁文大写字母 (u+0041) 序列化为 （十六进制） 如下所示：  
  
-   Utf-16 big endian 字节顺序： 00 41  
  
-   Utf-16 little-endian 字节顺序： 41 00  
  
-   UTF-32 big endian 字节顺序： 00 00 00 41  
  
-   UTF-32 little-endian 字节顺序： 41 00 00 00  
  
 它是通常使用本机字节顺序的 Unicode 字符存储更高效。 例如，最好在小 endian 平台，如 Intel 的计算机上使用 little-endian 字节顺序。  
  
 <xref:System.Text.Encoding.GetPreamble%2A>方法检索包含字节顺序标记 (BOM) 的字节数组。 如果此字节数组编码流的前缀，它可帮助确定使用的编码格式的解码器。  
  
 有关字节顺序和字节顺序标记的详细信息，请参阅 Unicode Standard [Unicode 主页](https://go.microsoft.com/fwlink/?LinkId=37123)。  
  
 请注意，编码的类允许将错误记录到：  
  
-   以无提示方式将更改为"？"字符。  
  
-   使用"best fit"字符。  
  
-   通过使用特定于应用程序的行为更改<xref:System.Text.EncoderFallback>和<xref:System.Text.DecoderFallback>具有 U + FFFD Unicode 替换字符的类。  
  
 在任何数据流的错误，应引发异常。 应用使用"throwonerror"标志时适用或使用<xref:System.Text.EncoderExceptionFallback>和<xref:System.Text.DecoderExceptionFallback>类。 通常不建议最佳匹配的回退，因为它可能会导致数据丢失或混淆，而且比简单的字符替换。 对于 ANSI 编码最佳行为是默认行为。  
  
   
  
## Examples  
 下面的示例将字符串转换到另一个编码。  
  
> [!NOTE]
>  Byte [] 数组是在此示例中包含已编码的数据的唯一类型。 .NET 的 Char 和字符串类型是本身 Unicode，因此<xref:System.Text.Encoding.GetChars%2A>调用返回到 Unicode 数据进行解码。  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Text.Encoding" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Text.Encoding" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生的类重写此构造函数。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">首选编码的代码页标识符。  
  
或 
0，使用默认编码。</param>
        <summary>初始化对应于指定代码页的 <see cref="T:System.Text.Encoding" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生的类重写此构造函数。  
  
 从派生类调用此构造函数创建<xref:System.Text.Encoding>编码和解码操作中使用最佳回退的对象。 同时<xref:System.Text.Encoding.DecoderFallback%2A>和<xref:System.Text.Encoding.EncoderFallback%2A>属性是只读的不能修改。 若要控制回退策略，一个类派生自<xref:System.Text.Encoding>，调用<xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>构造函数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> 小于零。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">编码的代码页标识符。</param>
        <param name="encoderFallback">一个对象，在无法用当前编码对字符进行编码时，该对象可用来提供错误处理过程。</param>
        <param name="decoderFallback">一个对象，在无法用当前编码对字节序列进行解码时，该对象可用来提供错误处理过程。</param>
        <summary>使用指定编码器和解码器回退策略初始化对应于指定代码页的 <see cref="T:System.Text.Encoding" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数是`protected`; 派生类重写它。  
  
 从派生类来控制回退编码和解码策略调用此构造函数。 <xref:System.Text.Encoding>类构造函数创建不允许编码器或解码器回退对象创建之后设置的只读的编码对象。  
  
 如果任一`encoderFallback`或`decoderFallback`为 null，最佳回退用作相应回退策略。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 ASCII（7 位）字符集的编码。</summary>
        <value>ASCII（7 位）字符集的编码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASCII 字符仅限于从 u+0000 到 U + 007F 的最小 128 个 Unicode 字符。  
  
 选择您的应用程序的 ASCII 编码时, 考虑以下方面：  
  
-   ASCII 编码是通常适用于需要 ASCII 的协议。  
  
-   如果您需要 8 位编码 （这有时会错误地称为"ASCII"），utf-8 编码建议而不是将 ASCII 编码。 对于字符 0 7F，结果是相同的但使用 utf-8，从而可表示的所有 Unicode 字符的表示形式可避免数据丢失。 请注意，ASCII 编码有 8 位二义性，可允许恶意使用，但 utf-8 编码中移除第八位的不明确性。  
  
-   在低于.NET Framework 2.0 版中，.NET Framework 允许通过忽略第八位欺骗。 从.NET Framework 2.0 开始，非 ASCII 码位，故障回复期间进行解码。  
  
 <xref:System.Text.ASCIIEncoding>此属性返回的对象可能不具有您的应用程序的适当行为。 它使用替换回退将每个字符串，它不能进行编码和每个不能进行解码的字节替换为问号 ("？") 字符。 相反，您可以调用<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>方法来实例化<xref:System.Text.ASCIIEncoding>对象，它的回退是个<xref:System.Text.EncoderFallbackException>或<xref:System.Text.DecoderFallbackException>，如下面的示例所示。  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 下面的示例演示了将 ASCII 编码字符超出 ASCII 范围的上的效果。  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取使用 Big Endian 字节顺序的 UTF-16 格式的编码。</summary>
        <value>使用 Big Endian 字节顺序的 UTF-16 格式的编码对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding>此属性返回的对象可能没有为你的应用的适当行为。 它使用替换回退将每个字符串，它不能进行编码和每个不能进行解码的字节替换为问号 ("？") 字符。 相反，您可以调用<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>构造函数实例化大 endian<xref:System.Text.UnicodeEncoding>对象，它的回退是个<xref:System.Text.EncoderFallbackException>或<xref:System.Text.DecoderFallbackException>，如下面的示例所示。  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 返回<xref:System.Text.UnicodeEncoding>对象具有<xref:System.Text.Encoding.BodyName%2A>， <xref:System.Text.Encoding.HeaderName%2A>，和<xref:System.Text.Encoding.WebName%2A>属性，这些值生成的名称"unicodeFFFE"。 尽管 utf-16 big endian 字节顺序标记是十六进制 FEFF，但已选择名称"unicodeFFFE"，原因是字节顺序标记显示为十六进制 FFFE 小字节序的 Windows 计算机上。  
  
   
  
## Examples  
 下面的示例读取一个文本文件与使用 big endian 字节顺序的 utf-16 编码。  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 下面的示例确定进行编码的字符数组所需的字节数、 编码字符，并显示所产生的字节。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取可与邮件代理正文标记一起使用的当前编码的名称。</summary>
        <value>可与邮件代理正文标记一起使用的当前 <see cref="T:System.Text.Encoding" /> 的名称。  
  
或 
如果当前 <see cref="T:System.Text.Encoding" /> 无法使用，则为空字符串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您需要正文名称的编码，则应调用<xref:System.Text.Encoding.GetEncoding%2A>与<xref:System.Text.Encoding.BodyName%2A>属性。 通常方法检索不同的编码从调用中提供的测试编码。 通常只有电子邮件应用程序需要检索此类编码;其他需要描述的编码的大多数应用程序应使用其<xref:System.Text.Encoding.WebName%2A>。  
  
 在某些情况下，值<xref:System.Text.Encoding.BodyName%2A>属性对应于定义编码的国际标准。 这并不意味着实现符合该标准填满中。  
  
   
  
## Examples  
 下面的示例检索每个编码不同的名称，并显示具有一个或多个名称不同的编码<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>。 它将显示<xref:System.Text.Encoding.EncodingName%2A>但不会对其比较。  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，创建当前 <see cref="T:System.Text.Encoding" /> 对象的一个卷影副本。</summary>
        <returns>当前 <see cref="T:System.Text.Encoding" /> 对象的副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 克隆是可写即使原始<xref:System.Text.Encoding>对象是只读的。 因此，可以修改克隆的属性。  
  
 一个对象的浅表副本是仅对象的副本。 如果对象包含对其他对象的引用，浅表副本不创建所引用对象的副本。 它而是指原始对象。 与此相反，对象的深层副本创建的对象的副本和所有内容直接或间接引用该对象的副本。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取当前 <see cref="T:System.Text.Encoding" /> 的代码页标识符。</summary>
        <value>当前 <see cref="T:System.Text.Encoding" /> 的代码页标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例检索每个编码不同的名称，并显示具有一个或多个名称不同的编码<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>。 它将显示<xref:System.Text.Encoding.EncodingName%2A>但不会对其比较。  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将字节数组从一种编码转换为另一种。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">
          <c>bytes</c> 的编码格式。</param>
        <param name="dstEncoding">目标编码格式。</param>
        <param name="bytes">要转换的字节。</param>
        <summary>将整个字节数组从一种编码转换为另一种编码。</summary>
        <returns>
          <see cref="T:System.Byte" /> 类型的数组，其中包含将 <paramref name="bytes" /> 从 <paramref name="srcEncoding" /> 转换为 <paramref name="dstEncoding" /> 的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例将使用 Unicode 编码的字符串转换为 ASCII 编码的字符串。 由于 ASCII 编码对象返回的<xref:System.Text.Encoding.ASCII%2A>属性使用替换回退，并且 Pi 字符不是 ASCII 字符集的一部分，Pi 字符将替换为问号，如中的示例所示的输出。  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> 为 <see langword="null" />。  
  
或 
 <paramref name="dstEncoding" /> 为 <see langword="null" />。  
  
或 
 <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 **srcEncoding.** 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 **dstEncoding.** 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">源数组 <c>bytes</c> 的编码。</param>
        <param name="dstEncoding">输出数组的编码。</param>
        <param name="bytes">要转换的字节数组。</param>
        <param name="index">要转换的 <c>bytes</c> 中第一个元素的索引。</param>
        <param name="count">要转换的字节数。</param>
        <summary>将字节数组内某个范围的字节从一种编码转换为另一种编码。</summary>
        <returns>一个 <see cref="T:System.Byte" /> 类型的数组，其中包含将 <paramref name="bytes" /> 中某个范围的字节从 <paramref name="srcEncoding" /> 转换为 <paramref name="dstEncoding" /> 的结果。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> 为 <see langword="null" />。  
  
或 
 <paramref name="dstEncoding" /> 为 <see langword="null" />。  
  
或 
 <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 和 <paramref name="count" /> 不指定字节数组中的有效范围。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 **srcEncoding.** 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 **dstEncoding.** 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前 <see cref="T:System.Text.DecoderFallback" /> 对象的 <see cref="T:System.Text.Encoding" /> 对象。</summary>
        <value>当前 <see cref="T:System.Text.Encoding" /> 对象的解码器回退对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback>对象表示的错误处理程序不能进行编码的字节序列解码为字符时调用。 支持以下处理程序类型之一：  
  
-   最佳回退处理程序，它用合适的替换字符替换无法解码的字节数。  
  
-   替换回退处理程序，它使用任意替换字符替换无法解码的字节数。 .NET 包括一个替换回退处理程序， <xref:System.Text.DecoderFallback>，默认情况下将不能进行解码的字节替换为问号 ("？") 字符。  
  
-   异常回退处理程序，将不能对字节进行解码时引发异常。 .NET 包括一个异常回退处理程序， <xref:System.Text.DecoderExceptionFallback>，该类会引发<xref:System.Text.DecoderFallbackException>当无法解码字节。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">设置操作中的值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">由于当前 <see cref="T:System.Text.Encoding" /> 对象为只读，所以无法在设置操作中赋值。</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 .NET 实现的默认编码。</summary>
        <value>默认的编码此.NET 实现。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  不同的计算机可以使用不同的编码为默认值，并且默认编码可以更改在单台计算机上。 如果使用<xref:System.Text.Encoding.Default%2A>编码进行编码和解码流式传输的计算机之间或在同一台计算机上的不同时间检索数据，也可以将该数据不正确。 此外，返回的编码<xref:System.Text.Encoding.Default%2A>属性使用最佳回退将不支持的字符映射到代码页支持的字符。 出于这些原因，不建议使用默认编码。 若要确保能够正确解码已编码的字节，应使用 Unicode 编码，如<xref:System.Text.UTF8Encoding>或<xref:System.Text.UnicodeEncoding>。 此外可以使用更高级别的协议以确保相同的格式用于编码和解码。  

### <a name="the-default-property-in-the-net-framework"></a>.NET Framework 中的默认属性

在 Windows 桌面上，.NET Framework 中<xref:System.Text.Encoding.Default%2A>属性始终获取系统的活动的代码页，并创建<xref:System.Text.Encoding>与之相对应的对象。 活动的代码页可能的 ANSI 代码页，其中包括按代码页集和不同的其他字符的 ASCII 字符。 因为所有<xref:System.Text.Encoding.Default%2A>基于 ANSI 代码页编码会丢失数据，请考虑使用<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>改为编码。 Utf-8 通常是在 U + 00 到 U + 7F 范围相同，但可以对而不会丢失 ASCII 范围以外的字符进行编码。

## <a name="the-default-property-on-net-core"></a>.NET Core 中的默认属性

在.NET Core<xref:System.Text.Encoding.Default%2A>属性始终返回<xref:System.Text.UTF8Encoding>。 所有操作系统 （Windows、 Linux 和最大 OS X） 上运行的.NET Core 应用程序都支持 utf-8。
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前 <see cref="T:System.Text.EncoderFallback" /> 对象的 <see cref="T:System.Text.Encoding" /> 对象。</summary>
        <value>当前 <see cref="T:System.Text.Encoding" /> 对象的编码器回退对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.EncoderFallback>对象都表示一个字符不能转换为编码的字节序列时，将调用错误处理程序。 支持以下处理程序类型之一：  
  
-   最佳回退处理程序，它用合适的替换字符替换无法编码的字符。  
  
-   替换回退处理程序，它用任意替换字符替换无法编码的字符。 .NET 包括一个替换回退处理程序， <xref:System.Text.EncoderFallback>，默认情况下不能进行编码的字符替换为问号 ("？") 字符。  
  
-   异常回退处理程序，该字符不能进行编码时将引发异常。 .NET 包括一个异常回退处理程序， <xref:System.Text.EncoderExceptionFallback>，该类会引发<xref:System.Text.EncoderFallbackException>字符无法解码时。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">设置操作中的值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">由于当前 <see cref="T:System.Text.Encoding" /> 对象为只读，所以无法在设置操作中赋值。</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取当前编码的用户可读说明。</summary>
        <value>当前 <see cref="T:System.Text.Encoding" /> 的用户可读说明。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.EncodingName%2A>属性供显示。 若要查找的名称，可传递给<xref:System.Text.Encoding.GetEncoding%2A>方法，请使用<xref:System.Text.Encoding.WebName%2A>属性。  
  
   
  
## Examples  
 下面的示例检索每个编码不同的名称，并显示具有一个或多个名称不同的编码<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>。 它将显示<xref:System.Text.Encoding.EncodingName%2A>但不会对其比较。  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">与当前实例进行比较的 <see cref="T:System.Object" />。</param>
        <summary>确定指定的 <see cref="T:System.Object" /> 是否等同于当前实例。</summary>
        <returns>如果 <paramref name="value" /> 是 <see cref="T:System.Text.Encoding" /> 的一个实例并且等于当前实例，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 两个实例<xref:System.Text.Encoding>被视为相等，如果它们对应于相同的代码页和他们`EncoderFallback`和`DecoderFallback`对象是否相等。 特别是，导出的代码页都有 0 的代码页和其回退一般都`null`(`Nothing`在 Visual Basic.NET)。 因此它们均被视为等于另一个。 一个后果是，当<xref:System.Text.Encoding.Equals%2A>用于填充哈希表中，所有派生编码比较相等并属于相同的哈希表槽。  
  
   
  
## Examples  
 下面的示例获取的相同的编码 （代码页的一个），按名称的另一个、 两个实例，并检查其相等。  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，计算对一组字符进行编码所产生的字节数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">包含要编码的字符的字符数组。</param>
        <summary>在派生类中重写时，计算对指定字符数组中的所有字符进行编码所产生的字节数。</summary>
        <returns>对指定字符数组中的所有字符进行编码后产生的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要计算所需的确切的数组大小<xref:System.Text.Encoding.GetBytes%2A>若要存储所产生的字节，调用<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要计算最大数组大小，请调用<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许您分配的内存越少，而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常更快地执行。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法确定多少个字节进行编码的一组 Unicode 字符和<xref:System.Text.Encoding.GetBytes%2A>方法执行实际的编码。 <xref:System.Text.Encoding.GetBytes%2A>方法需要与离散的转换，<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，该处理单个输入流上的多个转换方法。  
  
 多个版本<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要为代码页的多个输入的字符进行编码和处理使用多个调用的字符。 在这种情况下，可能需要考虑到是否持久状态的调用之间维护状态<xref:System.Text.Encoder>对象正在使用。  
  
-   如果您的应用程序处理字符串输入，则应使用的字符串版本<xref:System.Text.Encoding.GetBytes%2A>方法。  
  
-   Unicode 字符缓冲区版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于使用多个调用<xref:System.Text.Encoder>对象或将其插入到现有的缓冲区。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，您应重复使用的输出缓冲区。 在这种情况下，<xref:System.Text.Encoding.GetBytes%2A>支持字节数组的版本是最佳选择。  
  
-   请考虑使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetByteCount%2A>。 转换方法将为尽可能多的数据，并会引发异常，如果输出缓冲区太小。 对于连续编码流，此方法通常是最佳选择。  
  
   
  
## Examples  
 下面的示例确定进行编码的字符数组所需的字节数、 编码字符，并显示所产生的字节。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">包含要编码的字符集的字符串。</param>
        <summary>在派生类中重写时，计算对指定字符串中的字符进行编码所产生的字节数。</summary>
        <returns>对指定字符进行编码后生成的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要计算所需的确切的数组大小<xref:System.Text.Encoding.GetBytes%2A>若要存储所产生的字节，调用<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要计算最大数组大小，请调用<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许您分配的内存越少，而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常更快地执行。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法确定多少个字节进行编码的一组 Unicode 字符和<xref:System.Text.Encoding.GetBytes%2A>方法执行实际的编码。 <xref:System.Text.Encoding.GetBytes%2A>方法需要与离散的转换，<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，该处理单个输入流上的多个转换方法。  
  
 多个版本<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要为代码页的多个输入的字符进行编码和处理使用多个调用的字符。 在这种情况下，可能需要考虑到是否持久状态的调用之间维护状态<xref:System.Text.Encoder>对象正在使用。  
  
-   如果应用程序处理字符串输入的字符串版本<xref:System.Text.Encoding.GetBytes%2A>建议。  
  
-   Unicode 字符缓冲区版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于使用多个调用<xref:System.Text.Encoder>对象或将其插入到现有的缓冲区。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，<xref:System.Text.Encoding.GetBytes%2A>支持字节数组的版本是最佳选择。  
  
-   请考虑使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetByteCount%2A>。 转换方法将为尽可能多的数据，并会引发异常，如果输出缓冲区太小。 对于连续编码流，此方法通常是最佳选择。  
  
   
  
## Examples  
 下面的示例确定进行编码的字符串或字符串中的范围所需的字节数、 编码字符，并显示所产生的字节。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">指向第一个要编码的字符的指针。</param>
        <param name="count">要编码的字符的数目。</param>
        <summary>在派生类中重写时，计算对一组字符（从指定的字符指针处开始）进行编码所产生的字节数。</summary>
        <returns>对指定字符进行编码后生成的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要计算确切的数组大小，<xref:System.Text.Encoding.GetBytes%2A>需要用于存储所产生的字节，应调用<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要计算最大数组大小，请调用<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许您分配的内存越少，而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常更快地执行。  
  
 <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29>方法确定多少个字节进行编码的一组 Unicode 字符和<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>方法执行实际的编码。 <xref:System.Text.Encoding.GetBytes%2A>方法需要与离散的转换，<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，该处理单个输入流上的多个转换方法。  
  
 多个版本<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支持。 以下是使用这些方法的一些注意事项：  
  
-   您的应用程序可能需要为代码页的多个输入的字符进行编码和处理使用多个调用的字符。 在这种情况下，可能需要考虑到是否持久状态的调用之间维护状态<xref:System.Text.Encoder>对象正在使用。  
  
-   如果您的应用程序处理字符串输入，则应使用的字符串版本<xref:System.Text.Encoding.GetBytes%2A>方法。  
  
-   Unicode 字符缓冲区版本<xref:System.Text.Encoding.GetBytes%2A>允许一些快速技巧，尤其是对于使用多个调用<xref:System.Text.Encoder>对象或将其插入到现有的缓冲区。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，<xref:System.Text.Encoding.GetBytes%2A>支持字节数组的版本是最佳选择。  
  
-   请考虑使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetByteCount%2A>。 转换方法将为尽可能多的数据，并会引发异常，如果输出缓冲区太小。 对于连续编码流，此方法通常是最佳选择。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">包含要编码的字符集的字符数组。</param>
        <param name="index">第一个要编码的字符的索引。</param>
        <param name="count">要编码的字符的数目。</param>
        <summary>在派生类中重写时，计算对指定字符数组中的一组字符进行编码所产生的字节数。</summary>
        <returns>对指定字符进行编码后生成的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要计算所需的确切的数组大小<xref:System.Text.Encoding.GetBytes%2A>若要存储所产生的字节，调用<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要计算最大数组大小，请调用<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许您分配的内存越少，而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常更快地执行。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法确定多少个字节进行编码的一组 Unicode 字符和<xref:System.Text.Encoding.GetBytes%2A>方法执行实际的编码。 <xref:System.Text.Encoding.GetBytes%2A>方法需要与离散的转换，<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，该处理单个输入流上的多个转换方法。  
  
 多个版本<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要为代码页的多个输入的字符进行编码和处理使用多个调用的字符。 在这种情况下，可能需要考虑到是否持久状态的调用之间维护状态<xref:System.Text.Encoder>对象正在使用。  
  
-   如果应用程序处理字符串输入的字符串版本<xref:System.Text.Encoding.GetBytes%2A>建议。  
  
-   Unicode 字符缓冲区版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于使用多个调用<xref:System.Text.Encoder>对象或将其插入到现有的缓冲区。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，<xref:System.Text.Encoding.GetBytes%2A>支持字节数组的版本是最佳选择。  
  
-   请考虑使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetByteCount%2A>。 转换方法将为尽可能多的数据，并会引发异常，如果输出缓冲区太小。 对于连续编码流，此方法通常是最佳选择。  
  
   
  
## Examples  
 下面的示例确定所需字符数组中的三个字符进行编码的字节数、 编码字符，并显示所产生的字节。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="index" /> 和 <paramref name="count" /> 不表示 <paramref name="chars" /> 中的有效范围。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，将一组字符编码为一个字节序列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">包含要编码的字符的字符数组。</param>
        <summary>在派生类中重写时，将指定字符数组中的所有字符编码为一个字节序列。</summary>
        <returns>一个字节数组，包含对指定的字符集进行编码的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要转换的数据仅在顺序块 （如从流中读取的数据） 中不可用或数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供的<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法确定多少个字节进行编码的一组 Unicode 字符和<xref:System.Text.Encoding.GetBytes%2A>方法执行实际的编码。 <xref:System.Text.Encoding.GetBytes%2A>方法需要与离散的转换，<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，该处理单个输入流上的多个转换方法。  
  
 多个版本<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要为代码页的多个输入的字符进行编码和处理使用多个调用的字符。 在这种情况下，可能需要考虑到是否持久状态的调用之间维护状态<xref:System.Text.Encoder>对象正在使用。 （例如，包含代理项对的字符序列可能以结束一个高代理项。 <xref:System.Text.Encoder>将记住该高代理项，以便它可以结合以下调用开始处的低代理项。 <xref:System.Text.Encoding> 不能维护状态，以使该字符将被发送到<xref:System.Text.EncoderFallback>。)  
  
-   如果您的应用程序处理字符串输入，则应调用的字符串版本<xref:System.Text.Encoding.GetBytes%2A>方法。  
  
-   Unicode 字符缓冲区版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于使用多个调用<xref:System.Text.Encoder>对象或将其插入到现有的缓冲区。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，<xref:System.Text.Encoding.GetBytes%2A>支持字节数组的版本是最佳选择。  
  
-   请考虑使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetByteCount%2A>。 转换方法将为尽可能多的数据，并会引发异常，如果输出缓冲区太小。 对于连续编码流，此方法通常是最佳选择。  
  
   
  
## Examples  
 下面的示例确定进行编码的字符数组所需的字节数、 编码字符，并显示所产生的字节。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">包含要编码的字符的字符串。</param>
        <summary>在派生类中重写时，将指定字符串中的所有字符编码为一个字节序列。</summary>
        <returns>一个字节数组，包含对指定的字符集进行编码的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要转换的数据仅在顺序块 （如从流中读取的数据） 中不可用或数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供的<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法确定多少个字节进行编码的一组 Unicode 字符和<xref:System.Text.Encoding.GetBytes%2A>方法执行实际的编码。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法需要与离散的转换，<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，该处理单个输入流上的多个转换方法。  
  
 多个版本<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要为代码页的多个输入的字符进行编码和处理使用多个调用的字符。 在这种情况下，可能需要考虑到是否持久状态的调用之间维护状态<xref:System.Text.Encoder>对象正在使用。 （例如，包含代理项对的字符序列可能以结束一个高代理项。 <xref:System.Text.Encoder>将记住该高代理项，以便它可以结合以下调用开始处的低代理项。 <xref:System.Text.Encoding> 不能维护状态，以使该字符将被发送到<xref:System.Text.EncoderFallback>。)  
  
-   如果您的应用程序处理字符串输入，则应使用的字符串版本<xref:System.Text.Encoding.GetBytes%2A>。  
  
-   Unicode 字符缓冲区版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于使用多个调用<xref:System.Text.Encoder>对象或将其插入到现有的缓冲区。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，<xref:System.Text.Encoding.GetBytes%2A>支持字节数组的版本是最佳选择。  
  
-   请考虑使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetByteCount%2A>。 转换方法将为尽可能多的数据，并会引发异常，如果输出缓冲区太小。 对于连续编码流，此方法通常是最佳选择。  
  
   
  
## Examples  
 下面的示例确定进行编码的字符串或字符串中的范围所需的字节数、 编码字符，并显示所产生的字节。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">包含要编码的字符集的字符数组。</param>
        <param name="index">第一个要编码的字符的索引。</param>
        <param name="count">要编码的字符的数目。</param>
        <summary>在派生类中重写时，将指定字符数组中的一组字符编码为一个字节序列。</summary>
        <returns>一个字节数组，包含对指定的字符集进行编码的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要转换的数据仅在顺序块 （如从流中读取的数据） 中不可用或数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供的<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法确定多少个字节进行编码的一组 Unicode 字符和<xref:System.Text.Encoding.GetBytes%2A>方法执行实际的编码。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法需要与离散的转换，<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，该处理单个输入流上的多个转换方法。  
  
 多个版本<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要为代码页的多个输入的字符进行编码和处理使用多个调用的字符。 在这种情况下，可能需要考虑到是否持久状态的调用之间维护状态<xref:System.Text.Encoder>对象正在使用。 （例如，包含代理项对的字符序列可能以结束一个高代理项。 <xref:System.Text.Encoder>将记住该高代理项，以便它可以结合以下调用开始处的低代理项。 <xref:System.Text.Encoding> 不能维护状态，以使该字符将被发送到<xref:System.Text.EncoderFallback>。)  
  
-   如果您的应用程序处理字符串输入，则应使用的字符串版本<xref:System.Text.Encoding.GetBytes%2A>。  
  
-   Unicode 字符缓冲区版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于使用多个调用<xref:System.Text.Encoder>对象或将其插入到现有的缓冲区。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，<xref:System.Text.Encoding.GetBytes%2A>支持字节数组的版本是最佳选择。  
  
-   请考虑使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetByteCount%2A>。 转换方法将为尽可能多的数据，并会引发异常，如果输出缓冲区太小。 对于连续编码流，此方法通常是最佳选择。  
  
   
  
## Examples  
 下面的示例确定所需字符数组中的三个字符进行编码的字节数、 编码字符，并显示所产生的字节。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="index" /> 和 <paramref name="count" /> 不表示 <paramref name="chars" /> 中的有效范围。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">指向第一个要编码的字符的指针。</param>
        <param name="charCount">要编码的字符的数目。</param>
        <param name="bytes">一个指针，指向开始写入所产生的字节序列的位置。</param>
        <param name="byteCount">最多写入的字节数。</param>
        <summary>在派生类中重写时，将一组字符（从指定的字符指针开始）编码为一个字节序列，并从指定的字节指针开始存储该字节序列。</summary>
        <returns>在由 <paramref name="bytes" /> 参数指示的位置处写入的实际字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要计算确切的数组大小，<xref:System.Text.Encoding.GetBytes%2A>需要用于存储所产生的字节，调用<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要计算最大数组大小，请调用<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许您分配的内存越少，而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常更快地执行。  
  
 如果要转换的数据仅在 （如从流中读取的数据） 的顺序块中可用，或者如果数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供对象<xref:System.Text.Encoding.GetDecoder%2A>或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法确定多少个字节进行编码的一组 Unicode 字符和<xref:System.Text.Encoding.GetBytes%2A>方法执行实际的编码。 <xref:System.Text.Encoding.GetBytes%2A>方法需要与离散的转换，<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，该处理单个输入流上的多个转换方法。  
  
 多个版本<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要为代码页的多个输入的字符进行编码和处理使用多个调用的字符。 在这种情况下，可能需要考虑到是否持久状态的调用之间维护状态<xref:System.Text.Encoder>对象正在使用。 （例如，包含代理项对的字符序列可能以结束一个高代理项。 <xref:System.Text.Encoder>将记住该高代理项，以便它可以结合以下调用开始处的低代理项。 <xref:System.Text.Encoding> 不能维护状态，以使该字符将被发送到<xref:System.Text.EncoderFallback>。)  
  
-   如果您的应用程序处理字符串输入，则应使用的字符串版本<xref:System.Text.Encoding.GetBytes%2A>。  
  
-   Unicode 字符缓冲区版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于使用多个调用<xref:System.Text.Encoder>对象或将其插入到现有的缓冲区。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，<xref:System.Text.Encoding.GetBytes%2A>支持字节数组的版本是最佳选择。  
  
-   请考虑使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetByteCount%2A>。 转换方法将为尽可能多的数据，并会引发异常，如果输出缓冲区太小。 对于连续编码流，此方法通常是最佳选择。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 为 <see langword="null" />。  
  
或 
 <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> 或 <paramref name="byteCount" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> 少于所产生的字节数。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">包含要编码的字符集的字符数组。</param>
        <param name="charIndex">第一个要编码的字符的索引。</param>
        <param name="charCount">要编码的字符的数目。</param>
        <param name="bytes">要包含所产生的字节序列的字节数组。</param>
        <param name="byteIndex">要开始写入所产生的字节序列的索引位置。</param>
        <summary>在派生类中重写时，将指定字符数组中的一组字符编码为指定的字节数组。</summary>
        <returns>写入 <paramref name="bytes" /> 的实际字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要计算所需的确切的数组大小<xref:System.Text.Encoding.GetBytes%2A>若要存储所产生的字节，应调用<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要计算最大数组大小，请调用<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许您分配的内存越少，而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常更快地执行。  
  
 如果要转换的数据仅在顺序块 （如从流中读取的数据） 中不可用或数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供的<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法确定多少个字节进行编码的一组 Unicode 字符和<xref:System.Text.Encoding.GetBytes%2A>方法执行实际的编码。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法需要与离散的转换，<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，该处理单个输入流上的多个转换方法。  
  
 多个版本<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要为代码页的多个输入的字符进行编码和处理使用多个调用的字符。 在这种情况下，可能需要考虑到是否持久状态的调用之间维护状态<xref:System.Text.Encoder>对象正在使用。 （例如，包含代理项对的字符序列可能以结束一个高代理项。 <xref:System.Text.Encoder>将记住该高代理项，以便它可以结合以下调用开始处的低代理项。 <xref:System.Text.Encoding> 不能维护状态，以使该字符将被发送到<xref:System.Text.EncoderFallback>。)  
  
-   如果您的应用程序处理字符串输入，则应使用的字符串版本<xref:System.Text.Encoding.GetBytes%2A>。  
  
-   Unicode 字符缓冲区版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于使用多个调用<xref:System.Text.Encoder>对象或将其插入到现有的缓冲区。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，<xref:System.Text.Encoding.GetBytes%2A>支持字节数组的版本是最佳选择。  
  
-   请考虑使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetByteCount%2A>。 转换方法将为尽可能多的数据，并会引发异常，如果输出缓冲区太小。 对于连续编码流，此方法通常是最佳选择。  
  
   
  
## Examples  
 下面的示例确定所需字符数组中的三个字符进行编码的字节数、 编码字符，并显示所产生的字节。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 为 <see langword="null" />。  
  
或 
 <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />、<paramref name="charCount" /> 或 <paramref name="byteIndex" /> 小于零。  
  
或 
 <paramref name="charIndex" /> 和 <paramref name="charCount" /> 不表示 <paramref name="chars" /> 中的有效范围。  
  
或 
 <paramref name="byteIndex" /> 不是 <paramref name="bytes" /> 中的有效索引。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> 中从 <paramref name="byteIndex" /> 到数组结尾没有足够的容量来容纳所产生的字节。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">包含要编码的字符集的字符串。</param>
        <param name="charIndex">第一个要编码的字符的索引。</param>
        <param name="charCount">要编码的字符的数目。</param>
        <param name="bytes">要包含所产生的字节序列的字节数组。</param>
        <param name="byteIndex">要开始写入所产生的字节序列的索引位置。</param>
        <summary>在派生类中重写时，将指定字符串中的一组字符编码为指定的字节数组。</summary>
        <returns>写入 <paramref name="bytes" /> 的实际字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要计算所需的确切的数组大小<xref:System.Text.Encoding.GetBytes%2A>若要存储所产生的字节，应调用<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要计算最大数组大小，请调用<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许您分配的内存越少，而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常更快地执行。  
  
 如果要转换的数据仅在顺序块 （如从流中读取的数据） 中不可用或数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供的<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法确定多少个字节进行编码的一组 Unicode 字符和<xref:System.Text.Encoding.GetBytes%2A>方法执行实际的编码。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法需要与离散的转换，<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，该处理单个输入流上的多个转换方法。  
  
 多个版本<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要为代码页的多个输入的字符进行编码和处理使用多个调用的字符。 在这种情况下，可能需要考虑到是否持久状态的调用之间维护状态<xref:System.Text.Encoder>对象正在使用。 （例如，包含代理项对的字符序列可能以结束一个高代理项。 <xref:System.Text.Encoder>将记住该高代理项，以便它可以结合以下调用开始处的低代理项。 <xref:System.Text.Encoding> 不能维护状态，以使该字符将被发送到<xref:System.Text.EncoderFallback>。)  
  
-   如果您的应用程序处理字符串输入，则应使用的字符串版本<xref:System.Text.Encoding.GetBytes%2A>。  
  
-   Unicode 字符缓冲区版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于使用多个调用<xref:System.Text.Encoder>对象或将其插入到现有的缓冲区。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，<xref:System.Text.Encoding.GetBytes%2A>支持字节数组的版本是最佳选择。  
  
-   请考虑使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetByteCount%2A>。 转换方法将为尽可能多的数据，并会引发异常，如果输出缓冲区太小。 对于连续编码流，此方法通常是最佳选择。  
  
   
  
## Examples  
 下面的示例确定进行编码的字符串或字符串中的范围所需的字节数、 编码字符，并显示所产生的字节。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 为 <see langword="null" />。  
  
或 
 <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />、<paramref name="charCount" /> 或 <paramref name="byteIndex" /> 小于零。  
  
或 
 <paramref name="charIndex" /> 和 <paramref name="charCount" /> 不表示 <paramref name="chars" /> 中的有效范围。  
  
或 
 <paramref name="byteIndex" /> 不是 <paramref name="bytes" /> 中的有效索引。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> 中从 <paramref name="byteIndex" /> 到数组结尾没有足够的容量来容纳所产生的字节。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，计算对字节序列进行解码所产生的字符数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解码的字节序列的字节数组。</param>
        <summary>在派生类中重写时，计算对指定字节数组中的所有字节进行解码所产生的字符数。</summary>
        <returns>对指定字节序列进行解码所产生的字符数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要计算所需的确切的数组大小<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29>要存储所产生的字符，应使用<xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>方法。 若要计算的最大数组大小，应使用<xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29>方法。 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>方法通常允许您分配的内存越少，而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常更快地执行。  
  
 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>方法确定多少个字符产生的字节序列进行解码和<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29>方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法需要与离散的转换，<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用于处理多个传递的单个输入流。  
  
 多个版本<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要对代码页从多个输入的字符进行解码和处理使用多个调用的字节数。 在这种情况下，可能需要调用之间维护状态。  
  
-   如果您的应用程序处理字符串输出，则应使用<xref:System.Text.Encoding.GetString%2A>方法。 由于此方法必须检查字符串长度，并分配缓冲区，则速度稍慢，但生成<xref:System.String>类型是首选方法。  
  
-   字节新版<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于大型缓冲区多次调用。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支持输出字符的版本缓冲区是最佳选择。  
  
-   请考虑使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetCharCount%2A>。 转换方法将尽可能多的数据，并将引发异常，如果输出缓冲区太小。 对于连续解码，此方法通常是流的最佳选择。  
  
   
  
## Examples  
 下面的示例将字符串编码为一个字节，数组，然后字节解码为一个字符的数组。  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">指向第一个要解码的字节的指针。</param>
        <param name="count">要解码的字节数。</param>
        <summary>在派生类中重写时，计算对字节序列（从指定的字节指针开始）进行解码所产生的字符数。</summary>
        <returns>对指定字节序列进行解码所产生的字符数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要计算确切的数组大小，<xref:System.Text.Encoding.GetChars%2A>要求要存储所产生的字符，应使用<xref:System.Text.Encoding.GetCharCount%2A>方法。 若要计算最大数组大小，请使用<xref:System.Text.Encoding.GetMaxCharCount%2A>方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常允许您分配的内存越少，而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常更快地执行。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>方法确定多少个字符产生的字节序列进行解码和<xref:System.Text.Encoding.GetChars%2A>方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A>方法需要与离散的转换，<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用于处理多个传递的单个输入流。  
  
 多个版本<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要对代码页从多个输入的字符进行解码和处理使用多个调用的字节数。 在这种情况下，可能需要调用之间维护状态。  
  
-   如果您的应用程序处理字符串输出，则建议使用<xref:System.Text.Encoding.GetString%2A>方法。 由于此方法必须检查字符串长度，并分配缓冲区，则速度稍慢，但生成<xref:System.String>类型是首选方法。  
  
-   字节新版<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于大型缓冲区多次调用。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支持输出字符的版本缓冲区是最佳选择。  
  
-   请考虑使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetCharCount%2A>。 转换方法将尽可能多的数据，并将引发异常，如果输出缓冲区太小。 对于连续解码，此方法通常是流的最佳选择。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解码的字节序列的字节数组。</param>
        <param name="index">第一个要解码的字节的索引。</param>
        <param name="count">要解码的字节数。</param>
        <summary>在派生类中重写时，计算对字节序列（从指定字节数组开始）进行解码所产生的字符数。</summary>
        <returns>对指定字节序列进行解码所产生的字符数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要计算所需的确切的数组大小<xref:System.Text.Encoding.GetChars%2A>要存储所产生的字符，应使用<xref:System.Text.Encoding.GetCharCount%2A>方法。 若要计算最大数组大小，请使用<xref:System.Text.Encoding.GetMaxCharCount%2A>方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常允许您分配的内存越少，而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常更快地执行。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>方法确定多少个字符产生的字节序列进行解码和<xref:System.Text.Encoding.GetChars%2A>方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A>方法需要与离散的转换，<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用于处理多个传递的单个输入流。  
  
 多个版本<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要对代码页从多个输入的字符进行解码和处理使用多个调用的字节数。 在这种情况下，可能需要调用之间维护状态。  
  
-   如果您的应用程序处理字符串输出，则建议使用<xref:System.Text.Encoding.GetString%2A>方法。 由于此方法必须检查字符串长度，并分配缓冲区，则速度稍慢，但生成<xref:System.String>类型是首选方法。  
  
-   字节新版<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于大型缓冲区多次调用。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支持输出字符的版本缓冲区是最佳选择。  
  
-   请考虑使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetCharCount%2A>。 转换方法将尽可能多的数据，并将引发异常，如果输出缓冲区太小。 对于连续解码，此方法通常是流的最佳选择。  
  
   
  
## Examples  
 下面的示例将字符串转换到另一个编码。  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 下面的示例将字符串编码为一个字节，数组，然后将某个范围的字节解码为字符数组。  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="index" /> 和 <paramref name="count" /> 不表示 <paramref name="bytes" /> 中的有效范围。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，将一个字节序列解码为一组字符。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解码的字节序列的字节数组。</param>
        <summary>在派生类中重写时，将指定字节数组中的所有字节解码为一组字符。</summary>
        <returns>一个字节数组，包含对指定的字节序列进行解码的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 获取字符从输入的字节序列。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 不同于<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>因为<xref:System.Text.Encoding>需要离散的转换，而<xref:System.Text.Decoder>专为多个传递的单个输入流。  
  
 如果要转换的数据仅在顺序块 （如从流中读取的数据） 中不可用或数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供的<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。  
  
 **请注意**此方法旨在对 Unicode 字符，不是在任意二进制数据，如字节数组。 如果需要任意二进制数据编码为文本，则应使用协议如 uuencode，实现方法如<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>方法确定多少个字符产生的字节序列进行解码和<xref:System.Text.Encoding.GetChars%2A>方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法需要与离散的转换，<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用于处理多个传递的单个输入流。  
  
 多个版本<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要对代码页从多个输入的字符进行解码和处理使用多个调用的字节数。 在这种情况下，您可能需要维护状态之间的调用，由于批中处理时，可以中断字节序列。 (例如，ISO-2022 shift 序列的一部分可能结束一次<xref:System.Text.Encoding.GetChars%2A>调用，并继续下一步开始处<xref:System.Text.Encoding.GetChars%2A>调用。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 对于那些不完整的序列，调用回退但<xref:System.Text.Decoder>会记住这些序列的下一个调用。)  
  
-   如果您的应用程序处理字符串输出，则建议使用<xref:System.Text.Encoding.GetString%2A>方法。 由于此方法必须检查字符串长度，并分配缓冲区，则速度稍慢，但生成<xref:System.String>类型是首选方法。  
  
-   字节新版<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于大型缓冲区多次调用。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支持输出字符的版本缓冲区是最佳选择。  
  
-   请考虑使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetCharCount%2A>。 转换方法将尽可能多的数据，并将引发异常，如果输出缓冲区太小。 对于连续解码，此方法通常是流的最佳选择。  
  
   
  
## Examples  
 下面的示例将字符串编码为一个字节，数组，然后字节解码为一个字符的数组。  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解码的字节序列的字节数组。</param>
        <param name="index">第一个要解码的字节的索引。</param>
        <param name="count">要解码的字节数。</param>
        <summary>在派生类中重写时，将指定字节数组中的一个字节序列解码为一组字符。</summary>
        <returns>一个字节数组，包含对指定的字节序列进行解码的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 获取字符从输入的字节序列。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 不同于<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>因为<xref:System.Text.Encoding>需要离散的转换，而<xref:System.Text.Decoder>专为多个传递的单个输入流。  
  
 如果要转换的数据仅在顺序块 （如从流中读取的数据） 中不可用或数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供的<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。  
  
 **请注意**此方法旨在对 Unicode 字符，不是在任意二进制数据，如字节数组。 如果需要任意二进制数据编码为文本，则应使用协议如 uuencode，实现方法如<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>方法确定多少个字符产生的字节序列进行解码和<xref:System.Text.Encoding.GetChars%2A>方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法需要与离散的转换，<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用于处理多个传递的单个输入流。  
  
 多个版本<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要对代码页从多个输入的字符进行解码和处理使用多个调用的字节数。 在这种情况下，您可能需要维护状态之间的调用，由于批中处理时，可以中断字节序列。 (例如，ISO-2022 shift 序列的一部分可能结束一次<xref:System.Text.Encoding.GetChars%2A>调用，并继续下一步开始处<xref:System.Text.Encoding.GetChars%2A>调用。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 对于那些不完整的序列，调用回退但<xref:System.Text.Decoder>会记住这些序列的下一个调用。)  
  
-   如果您的应用程序处理字符串输出，则建议使用<xref:System.Text.Encoding.GetString%2A>方法。 由于此方法必须检查字符串长度，并分配缓冲区，则速度稍慢，但生成<xref:System.String>类型是首选方法。  
  
-   字节新版<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于大型缓冲区多次调用。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支持输出字符的版本缓冲区是最佳选择。  
  
-   请考虑使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetCharCount%2A>。 转换方法将尽可能多的数据，并将引发异常，如果输出缓冲区太小。 对于连续解码，此方法通常是流的最佳选择。  
  
   
  
## Examples  
 下面的示例将字符串编码为一个字节，数组，然后将某个范围的字节解码为字符数组。  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="index" /> 和 <paramref name="count" /> 不表示 <paramref name="bytes" /> 中的有效范围。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">指向第一个要解码的字节的指针。</param>
        <param name="byteCount">要解码的字节数。</param>
        <param name="chars">一个指针，指向开始写入所产生的字符集的位置。</param>
        <param name="charCount">要写入的最大字符数。</param>
        <summary>在派生类中重写时，将一个字节序列（从指定的字节指针开始）解码为一组字符，并从指定的字符指针开始存储该组字符。</summary>
        <returns>在由 <paramref name="chars" /> 参数指示的位置处写入的实际字符数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要计算确切的数组大小，<xref:System.Text.Encoding.GetChars%2A>要求要存储所产生的字符，应使用<xref:System.Text.Encoding.GetCharCount%2A>方法。 若要计算最大数组大小，请使用<xref:System.Text.Encoding.GetMaxCharCount%2A>方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常允许您分配的内存越少，而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常更快地执行。  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 获取字符从输入的字节序列。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 不同于<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>因为<xref:System.Text.Encoding>需要离散的转换，而<xref:System.Text.Decoder>专为多个传递的单个输入流。  
  
 如果要转换的数据仅在 （如从流中读取的数据） 的顺序块中可用，或者如果数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供对象<xref:System.Text.Encoding.GetDecoder%2A>或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。  
  
 **请注意**此方法旨在对 Unicode 字符，不是在任意二进制数据，如字节数组。 如果需要任意二进制数据编码为文本，则应使用协议如 uuencode，实现方法如<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>方法确定多少个字符产生的字节序列进行解码和<xref:System.Text.Encoding.GetChars%2A>方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法需要与离散的转换，<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用于处理多个传递的单个输入流。  
  
 多个版本<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要对代码页从多个输入的字符进行解码和处理使用多个调用的字节数。 在这种情况下，您可能需要维护状态之间的调用，由于批中处理时，可以中断字节序列。 (例如，ISO-2022 shift 序列的一部分可能结束一次<xref:System.Text.Encoding.GetChars%2A>调用，并继续下一步开始处<xref:System.Text.Encoding.GetChars%2A>调用。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 对于那些不完整的序列，调用回退但<xref:System.Text.Decoder>会记住这些序列的下一个调用。)  
  
-   如果您的应用程序处理字符串输出<xref:System.Text.Encoding.GetString%2A>建议方法。 由于此方法必须检查字符串长度，并分配缓冲区，则速度稍慢，但生成<xref:System.String>类型是首选方法。  
  
-   字节新版<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于大型缓冲区多次调用。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支持输出字符的版本缓冲区是最佳选择。  
  
-   请考虑使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetCharCount%2A>。 转换方法将尽可能多的数据，并将引发异常，如果输出缓冲区太小。 对于连续解码，此方法通常是流的最佳选择。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 为 <see langword="null" />。  
  
或 
 <paramref name="chars" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> 或 <paramref name="charCount" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> 少于所产生的字符数。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直接调用方需要完全信任。 不能由部分受信任的或透明的代码使用此成员。</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解码的字节序列的字节数组。</param>
        <param name="byteIndex">第一个要解码的字节的索引。</param>
        <param name="byteCount">要解码的字节数。</param>
        <param name="chars">要用于包含所产生的字符集的字符数组。</param>
        <param name="charIndex">开始写入所产生的字符集的索引位置。</param>
        <summary>在派生类中重写时，将指定字节数组中的字节序列解码为指定的字符数组。</summary>
        <returns>写入 <paramref name="chars" /> 的实际字符数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要计算所需的确切的数组大小<xref:System.Text.Encoding.GetChars%2A>要存储所产生的字符，应使用<xref:System.Text.Encoding.GetCharCount%2A>方法。 若要计算最大数组大小，请使用<xref:System.Text.Encoding.GetMaxCharCount%2A>方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常允许您分配的内存越少，而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常更快地执行。  
  
 [\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 获取字符从输入的字节序列。 [\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 不同于<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>因为<xref:System.Text.Encoding>需要离散的转换，而<xref:System.Text.Decoder>专为单个输入流的多个传递。  
  
 如果要转换的数据仅在顺序块 （如从流中读取的数据） 中不可用或数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供的<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。  
  
 **请注意**此方法旨在对 Unicode 字符，不是在任意二进制数据，如字节数组。 如果需要任意二进制数据编码为文本，则应使用协议如 uuencode，实现方法如<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>方法确定多少个字符产生的字节序列进行解码和<xref:System.Text.Encoding.GetChars%2A>方法执行实际解码。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法需要与离散的转换，<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用于处理多个传递的单个输入流。  
  
 多个版本<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支持。 使用这些方法的一些编程注意事项如下：  
  
-   您的应用程序可能需要对代码页从多个输入的字符进行解码和处理使用多个调用的字节数。 在这种情况下，您可能需要维护状态之间的调用，由于批中处理时，可以中断字节序列。 (例如，ISO-2022 shift 序列的一部分可能结束一次 [\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%2A > 调用并继续下一步开头 [\]，Int32，Int32，Char\<xref: System.Text.Encoding.GetChars%2A > 调用。 [\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 将对于这些不完整的序列，调用回退但<xref:System.Text.Decoder>会记住这些序列的下一个调用。)  
  
-   如果您的应用程序处理字符串输出<xref:System.Text.Encoding.GetString%2A>建议方法。 由于此方法必须检查字符串长度，并分配缓冲区，则速度稍慢，但生成<xref:System.String>类型是首选方法。  
  
-   字节新版<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>允许一些快速技巧，尤其是对于大型缓冲区多次调用。 请记住，但是，此方法版本是有时不安全，因为需要的指针。  
  
-   如果您的应用程序必须将大量的数据转换，它应重复使用的输出缓冲区。 在这种情况下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支持输出字符的版本缓冲区是最佳选择。  
  
-   请考虑使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法而不是<xref:System.Text.Encoding.GetCharCount%2A>。 转换方法将尽可能多的数据，并将引发异常，如果输出缓冲区太小。 对于连续解码，此方法通常是流的最佳选择。  
  
   
  
## Examples  
 下面的示例将字符串转换到另一个编码。  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 下面的示例将字符串编码为一个字节，数组，然后将某个范围的字节解码为字符数组。  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 为 <see langword="null" />。  
  
或 
 <paramref name="chars" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />、<paramref name="byteCount" /> 或 <paramref name="charIndex" /> 小于零。  
  
或 
 <paramref name="byteindex" /> 和 <paramref name="byteCount" /> 不表示 <paramref name="bytes" /> 中的有效范围。  
  
或 
 <paramref name="charIndex" /> 不是 <paramref name="chars" /> 中的有效索引。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> 中从 <paramref name="charIndex" /> 到数组结尾没有足够容量来容纳所产生的字符。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，获取一个解码器，该解码器将已编码的字节序列转换为字符序列。</summary>
        <returns>一个 <see cref="T:System.Text.Decoder" />，它将已编码的字节序列转换为字符序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法将连续的字节块转换为连续的字符，方式类似于块<xref:System.Text.Encoding.GetChars%2A>此类的方法。 但是，<xref:System.Text.Decoder>以便它可以正确地对跨块的字节序列进行解码的调用之间维护状态信息。 <xref:System.Text.Decoder>还保留数据块的末尾的尾随字节并将在下一步的解码操作中的尾随字节。 因此，<xref:System.Text.Encoding.GetDecoder%2A>和<xref:System.Text.Encoding.GetEncoder%2A>在网络传输和文件操作很有用，因为这些操作通常处理的数据而不是完整的数据流块。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>默认实现返回<see cref="T:System.Text.Decoder" />的调用<see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />并<see cref="M:System.Text.Encoding.GetChars(System.Byte[])" />的当前方法<see cref="T:System.Text.Encoding" />。 必须重写此方法以返回<see cref="T:System.Text.Decoder" />，其调用之间维护状态。</para>
        </block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，获取一个解码器，该解码器将 Unicode 字符序列转换为已编码的字节序列。</summary>
        <returns>一个 <see cref="T:System.Text.Encoder" />，它将 Unicode 字符序列转换为已编码的字节序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法将连续的字符块转换为连续的字节，方式类似于块<xref:System.Text.Encoding.GetBytes%2A>此类的方法。 但是，<xref:System.Text.Encoder>以便它可以正确地对跨块的字符序列进行编码的调用之间维护状态信息。 <xref:System.Text.Encoder>还保留尾随字符数据块的末尾，并在下一步的编码操作中使用尾随字符。 例如，数据块可能结尾不匹配的高代理项，且匹配的低代理项可能在下一个数据块。 因此，<xref:System.Text.Encoding.GetDecoder%2A>和<xref:System.Text.Encoding.GetEncoder%2A>在网络传输和文件操作很有用，因为这些操作通常处理的数据而不是完整的数据流块。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>默认实现返回<see cref="T:System.Text.Encoder" />的调用<see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />并<see cref="M:System.Text.Encoding.GetBytes(System.Char[])" />的当前方法<see cref="T:System.Text.Encoding" />。 必须重写此方法以返回<see cref="T:System.Text.Encoder" />，其调用之间维护状态。</para>
        </block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回指定代码页的编码。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">首选编码的代码页标识符。 可能值均在 <see cref="T:System.Text.Encoding" /> 类主题中出现的表的“代码页”一列中列出。  
  
或 
0（零），使用默认编码。</param>
        <summary>返回与指定代码页标识符关联的编码。</summary>
        <returns>与指定代码页关联的编码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 回退处理程序依赖的编码类型`codepage`。 如果`codepage`是代码页或双字节字符集 (DBCS) 编码、 使用最佳回退处理程序。 否则，使用替换回退处理程序。 这些回退处理程序可能不一定适合您的应用程序。 若要指定使用指定的编码的回退处理程序`codepage`，可以调用<xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>重载。  
  
 在.NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A>方法依赖于基础平台来支持大多数代码页。 但是，.NET Framework 本机支持某些编码。 有关代码页的列表，请参阅<xref:System.Text.Encoding>类主题。 在.NET Core 中，<xref:System.Text.Encoding.GetEncoding%2A>方法返回.NET Core 的本机支持的编码。 在这两个.NET 实现中，可以调用<xref:System.Text.Encoding.GetEncodings%2A>方法以获取数组的<xref:System.Text.EncodingInfo>包含有关所有可用的编码信息的对象。 

 除了编码以本机方式提供.NET Core 上或在特定平台版本的.NET Framework 中，本质上支持的<xref:System.Text.Encoding.GetEncoding%2A>方法返回可由注册任何其他编码<xref:System.Text.EncodingProvider>对象。 如果通过多个已注册相同的编码<xref:System.Text.EncodingProvider>对象，此方法将返回最后一个注册。  

你也可以提供值为 0，`codepage`参数。 其确切行为取决于是否任何编码可由已注册<xref:System.Text.EncodingProvider>对象：

- 如果已注册一个或多个编码提供程序，它将返回已选返回编码时的最后一个已注册提供程序的编码<xref:System.Text.Encoding.GetEncoding%2A>方法传递`codepage`自变量为 0。     

- 在.NET Framework 中，如果没有编码提供程序已注册，如果<xref:System.Text.CodePagesEncodingProvider>是已注册的编码提供程序，或如果没有已注册的编码提供程序处理`codepage`值为 0，它返回操作系统的活动的代码页。 若要确定 Windows 系统上的活动的代码页，请调用 Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)从.NET Framework 在 Windows 桌面上的函数。

- 在.NET Core，如果没有已注册编码提供程序，或如果没有已注册的编码提供程序处理`codepage`值为 0，它将返回<xref:System.Text.UTF8Encoding>。
  
> [!NOTE]
>  某些不受支持的代码页的原因<xref:System.ArgumentException>引发，而其他人会导致<xref:System.NotSupportedException>。 因此，你的代码必须捕获所有异常节中所述的异常。  
  
> [!NOTE]
>  ANSI 代码页不同的计算机上可以不同，并且可以更改在一台计算机，从而导致数据损坏。 出于此原因，如果活动的代码页是 ANSI 代码页，编码和解码数据使用的默认代码页返回`Encoding.GetEncoding(0)`不建议。 对于最一致的结果，应使用 Unicode 编码，例如 utf-8 （代码页 65001） 或 utf-16，而不特定的代码页。  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 返回具有默认设置的缓存的实例。 应使用派生类的构造函数来获取实例使用不同的设置。 例如，<xref:System.Text.UTF32Encoding>类提供构造函数，用于启用错误检测。  

   
  
## Examples  
 下面的示例获取的相同的编码 （代码页的一个），按名称的另一个、 两个实例，并检查其相等。  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> 小于零或大于 65535。</exception>
        <exception cref="T:System.ArgumentException">基础平台不支持 <paramref name="codepage" />。</exception>
        <exception cref="T:System.NotSupportedException">基础平台不支持 <paramref name="codepage" />。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">首选编码的代码页名称。 <see cref="P:System.Text.Encoding.WebName" /> 属性返回的所有值均有效。 可能值均在 <see cref="T:System.Text.Encoding" /> 类主题中出现的表的“名称”一列中列出。</param>
        <summary>返回与指定代码页名称关联的编码。</summary>
        <returns>与指定代码页关联的编码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 回退处理程序依赖的编码类型`name`。 如果`name`是代码页或双字节字符集 (DBCS) 编码、 使用最佳回退处理程序。 否则，使用替换回退处理程序。 这些回退处理程序可能不一定适合您的应用程序。 若要指定使用指定的编码的回退处理程序`name`，可以调用<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>重载。  

在.NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A>方法依赖于基础平台来支持大多数代码页。 但是，.NET Framework 本机支持某些编码。 有关代码页的列表，请参阅<xref:System.Text.Encoding>类主题。 在.NET Core 中，<xref:System.Text.Encoding.GetEncoding%2A>方法返回.NET Core 的本机支持的编码。 在这两个.NET 实现中，可以调用<xref:System.Text.Encoding.GetEncodings%2A>方法以获取数组的<xref:System.Text.EncodingInfo>包含有关所有可用的编码信息的对象。 

 除了编码以本机方式提供.NET Core 上或在特定平台版本的.NET Framework 中，本质上支持的<xref:System.Text.Encoding.GetEncoding%2A>方法返回可由注册任何其他编码<xref:System.Text.EncodingProvider>对象。 如果通过多个已注册相同的编码<xref:System.Text.EncodingProvider>对象，此方法将返回最后一个注册。  
   
> [!NOTE]
>  ANSI 代码页不同的计算机上可以不同，或者可以更改为一台计算机，从而导致数据损坏。 为最一致的结果，应使用 Unicode，如 utf-8 （代码页 65001） 或 utf-16，而不是特定的代码页。  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> 返回具有默认设置的缓存的实例。 应使用派生类的构造函数来获取实例使用不同的设置。 例如，<xref:System.Text.UTF32Encoding>类提供构造函数，用于启用错误检测。  
  
## Examples  
 下面的示例获取的相同的编码 （代码页的一个），按名称的另一个、 两个实例，并检查其相等。  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 不是有效的代码页名称。  
  
或 
基础平台不支持 <paramref name="name" /> 所指示的代码页。</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">首选编码的代码页标识符。 可能值均在 <see cref="T:System.Text.Encoding" /> 类主题中出现的表的“代码页”一列中列出。  
  
或 
0（零），使用默认编码。</param>
        <param name="encoderFallback">一个对象，在无法用当前编码对字符进行编码时，该对象可用来提供错误处理过程。</param>
        <param name="decoderFallback">一个对象，在无法用当前编码对字节序列进行解码时，该对象可用来提供错误处理过程。</param>
        <summary>返回与指定代码页标识符关联的编码。 参数指定一个错误处理程序，用于处理无法编码的字符和无法解码的字节序列。</summary>
        <returns>与指定代码页关联的编码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  某些不受支持的代码页会导致异常<xref:System.ArgumentException>引发，而其他人会导致<xref:System.NotSupportedException>。 因此，你的代码必须捕获所有异常节中所述的异常。  

在.NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A>方法依赖于基础平台来支持大多数代码页。 但是，.NET Framework 本机支持某些编码。 有关代码页的列表，请参阅<xref:System.Text.Encoding>类主题。 在.NET Core 中，<xref:System.Text.Encoding.GetEncoding%2A>方法返回.NET Core 的本机支持的编码。 在这两个.NET 实现中，可以调用<xref:System.Text.Encoding.GetEncodings%2A>方法以获取数组的<xref:System.Text.EncodingInfo>包含有关所有可用的编码信息的对象。 

 除了编码以本机方式提供.NET Core 上或在特定平台版本的.NET Framework 中，本质上支持的<xref:System.Text.Encoding.GetEncoding%2A>方法返回可由注册任何其他编码<xref:System.Text.EncodingProvider>对象。 如果通过多个已注册相同的编码<xref:System.Text.EncodingProvider>对象，此方法将返回最后一个注册。  

你也可以提供值为 0，`codepage`参数。 其确切行为取决于是否任何编码可由已注册<xref:System.Text.EncodingProvider>对象：

- 如果已注册一个或多个编码提供程序，它将返回已选返回编码时的最后一个已注册提供程序的编码<xref:System.Text.Encoding.GetEncoding%2A>方法传递`codepage`自变量为 0。     

- 在.NET Framework 中，如果没有编码提供程序已注册，如果<xref:System.Text.CodePagesEncodingProvider>是已注册的编码提供程序，或如果没有已注册的编码提供程序处理`codepage`值为 0，它返回活动的代码页。

- 在.NET Core，如果没有已注册编码提供程序，或如果没有已注册的编码提供程序处理`codepage`值为 0，它将返回<xref:System.Text.UTF8Encoding>编码。

> [!NOTE]
>  ANSI 代码页不同的计算机上可以不同，并且可以更改在一台计算机，从而导致数据损坏。 出于此原因，如果活动的代码页是 ANSI 代码页，编码和解码数据使用的默认代码页返回`Encoding.GetEncoding(0)`不建议。 为最一致的结果，应使用 Unicode，如 utf-8 （代码页 65001） 或 utf-16，而不是特定的代码页。 
  
 若要获取与活动的代码页关联的编码，可以提供值为 0，`codepage`自变量或如果在 Windows 桌面上在.NET Framework 上运行你的代码，检索的值<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>属性。 若要确定当前活动的代码页，请调用 Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)从.NET Framework 在 Windows 桌面上的函数。  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 返回具有默认设置的缓存的实例。 应使用派生类的构造函数来获取实例使用不同的设置。 例如，<xref:System.Text.UTF32Encoding>类提供构造函数，用于启用错误检测。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType>方法。  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> 小于零或大于 65535。</exception>
        <exception cref="T:System.ArgumentException">基础平台不支持 <paramref name="codepage" />。</exception>
        <exception cref="T:System.NotSupportedException">基础平台不支持 <paramref name="codepage" />。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">首选编码的代码页名称。 <see cref="P:System.Text.Encoding.WebName" /> 属性返回的所有值均有效。 可能值均在 <see cref="T:System.Text.Encoding" /> 类主题中出现的表的“名称”一列中列出。</param>
        <param name="encoderFallback">一个对象，在无法用当前编码对字符进行编码时，该对象可用来提供错误处理过程。</param>
        <param name="decoderFallback">一个对象，在无法用当前编码对字节序列进行解码时，该对象可用来提供错误处理过程。</param>
        <summary>返回与指定代码页名称关联的编码。 参数指定一个错误处理程序，用于处理无法编码的字符和无法解码的字节序列。</summary>
        <returns>与指定代码页关联的编码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

在.NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A>方法依赖于基础平台来支持大多数代码页。 但是，.NET Framework 本机支持某些编码。 有关代码页的列表，请参阅<xref:System.Text.Encoding>类主题。 在.NET Core 中，<xref:System.Text.Encoding.GetEncoding%2A>方法返回.NET Core 的本机支持的编码。 在这两个.NET 实现中，可以调用<xref:System.Text.Encoding.GetEncodings%2A>方法以获取数组的<xref:System.Text.EncodingInfo>包含有关所有可用的编码信息的对象。 

 除了编码以本机方式提供.NET Core 上或在特定平台版本的.NET Framework 中，本质上支持的<xref:System.Text.Encoding.GetEncoding%2A>方法返回可由注册任何其他编码<xref:System.Text.EncodingProvider>对象。 如果通过多个已注册相同的编码<xref:System.Text.EncodingProvider>对象，此方法将返回最后一个注册。  
  
> [!NOTE]
>  ANSI 代码页不同的计算机上可以不同，并且可以更改在一台计算机，从而导致数据损坏。 对于最一致的结果，应使用 Unicode 编码，例如 utf-8 （代码页 65001） 或 utf-16，而不特定的代码页。  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 返回具有默认设置的缓存的实例。 应使用派生类的构造函数来获取实例使用不同的设置。 例如，<xref:System.Text.UTF32Encoding>类提供构造函数，用于启用错误检测。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType>方法。  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 不是有效的代码页名称。  
  
或 
基础平台不支持 <paramref name="name" /> 所指示的代码页。</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回包含所有编码的数组。</summary>
        <returns>包含所有编码的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回受支持的编码，唯一不同的代码页的列表。 列出了受支持的编码的表，请参阅<xref:System.Text.Encoding>类主题。  
  
> [!NOTE]
>  返回的受支持的编码的列表<xref:System.Text.Encoding.GetEncodings%2A>方法不包含任何可由任何其他的编码<xref:System.Text.EncodingProvider>注册的对的调用实现<xref:System.Text.Encoding.RegisterProvider%2A>方法。  
  
 在.NET Framework 中，编码 50220 和 50222 都具有名称"iso-2022年-jp"关联但不完全相同。 编码 50220 半角片假名字符转换为全角片假名字符，而编码 50222 使用 shift/移出序列半角片假名字符进行编码。 编码 50222 的显示名称为"日语 (JIS-允许 1 个字节 Kana-因此 / SI)"来区分从编码 50220，具有显示命名为"日语 (JIS)"。  
  
 如果您请求编码名称"iso-2022年-jp"，编码 50220 返回的.NET Framework。 但是，适合于您的应用程序的编码取决于首选的半角片假名字符处理。  
  
 若要获取特定的编码，应使用<xref:System.Text.Encoding.GetEncoding%2A>方法。  
  
 <xref:System.Text.Encoding.GetEncodings%2A> 有时用来为用户提供一组文件中的编码**另存为**对话框。 但是，许多非 Unicode 编码是不完整，并且转换到的许多字符"？"，或在不同平台上有略有不同的行为。 请考虑使用 utf-8 或 utf-16 作为默认值。  
  
   
  
## Examples  
 以下示例检查的每个编码的布尔属性的值。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前实例的哈希代码。</summary>
        <returns>当前实例的哈希代码。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">要编码的字符的数目。</param>
        <summary>在派生类中重写时，计算对指定数目的字符进行编码所产生的最大字节数。</summary>
        <returns>对指定数目的字符进行编码所产生的最大字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `charCount`参数实际上指定了数<xref:System.Char>表示 Unicode 字符进行编码，因为.NET 在内部使用 utf-16 来表示 Unicode 字符的对象。 因此，大多数的 Unicode 字符可表示由一个<xref:System.Char>对象，但由代理项对，例如，表示一个 Unicode 字符需要两个<xref:System.Char>对象。  
  
 若要计算所需的确切的数组大小<xref:System.Text.Encoding.GetBytes%2A>要存储所产生的字节，应使用<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要计算最大数组大小，请使用<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常允许您分配的内存越少，而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常更快地执行。  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> 检索最坏的情况的数目，包括当前所选最差情形下<xref:System.Text.EncoderFallback>。 如果有可能较大字符串中，选择了回退<xref:System.Text.Encoding.GetMaxByteCount%2A>检索大值，尤其是在最坏的情况下的编码涉及切换每个字符的模式的情况下。 例如，发生这种情况 ISO-2022年-JP。 有关详细信息，请参阅博客文章"[Encoding.GetMaxByteCount() 和 Encoding.GetMaxCharCount() 是什么？](https://go.microsoft.com/fwlink/?LinkId=153702)" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 在大多数情况下，此方法检索用于小字符串的合理值。 对于大型字符串，可能需要使用非常大的缓冲区和时更合理缓冲区因过小，在极少数情况下捕获错误之间进行选择。 您可能还需要考虑不同的方法使用<xref:System.Text.Encoding.GetByteCount%2A>或<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>。  
  
 当使用<xref:System.Text.Encoding.GetMaxByteCount%2A>，应分配基于输入缓冲区的最大大小的输出缓冲区。 如果输出缓冲区的大小受到约束，则可能会使用<xref:System.Text.Encoding.Convert%2A>方法。  
  
 请注意，<xref:System.Text.Encoding.GetMaxByteCount%2A>考虑从以前的解码器操作潜在剩余的代理项。 解码器，由于传递给方法的值为 1 检索 2 表示单字节编码，如 ASCII。 应使用<xref:System.Text.ASCIIEncoding.IsSingleByte%2A>如果此信息是必需的属性。  
  
> [!NOTE]
>  `GetMaxByteCount(N)` 不一定是相同的值`N* GetMaxByteCount(1)`。  
  
   
  
## Examples  
 下面的示例确定进行编码的字符数组所需的字节数、 编码字符，并显示所产生的字节。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> 小于零。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.EncoderFallback" /> 设置为 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <block subset="none" type="overrides">
          <para>所有<see cref="T:System.Text.Encoding" />实现必须保证，缓冲区溢出会发生任何异常根据该方法的计算结果的大小将调整缓冲区。</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">要解码的字节数。</param>
        <summary>在派生类中重写时，计算对指定数目的字节进行解码时所产生的最大字符数。</summary>
        <returns>对指定数目的字节进行解码时所产生的最大字符数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要计算所需的确切的数组大小<xref:System.Text.Encoding.GetChars%2A>要存储所产生的字符，应使用<xref:System.Text.Encoding.GetCharCount%2A>方法。 若要计算最大数组大小，请使用<xref:System.Text.Encoding.GetMaxCharCount%2A>方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常允许您分配的内存越少，而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常更快地执行。  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> 检索最坏的情况的数目，包括当前所选最差情形下<xref:System.Text.DecoderFallback>。 如果有可能较大字符串中，选择了回退<xref:System.Text.Encoding.GetMaxCharCount%2A>检索大值。  
  
 在大多数情况下，此方法检索用于小字符串合理的数字。 对于大型字符串，可能需要使用非常大的缓冲区和更合理的缓冲区因过小的情况很少捕获错误之间进行选择。 您可能还需要考虑不同的方法使用<xref:System.Text.Encoding.GetCharCount%2A>或<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>。  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> 与无关<xref:System.Text.Encoding.GetBytes%2A>。 如果需要使用具有相似的功能<xref:System.Text.Encoding.GetBytes%2A>，则应使用<xref:System.Text.Encoding.GetMaxByteCount%2A>。  
  
 当使用<xref:System.Text.Encoding.GetMaxCharCount%2A>，应分配基于输入缓冲区的最大大小的输出缓冲区。 如果输出缓冲区的大小受到约束，则可能会使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法。  
  
 请注意，<xref:System.Text.Encoding.GetMaxCharCount%2A>考虑最坏的情况下，从以前的编码器操作的剩余字节数。 对于大多数代码页，将 0 的值传递给此方法检索的值大于或等于 1。  
  
> [!NOTE]
>  `GetMaxCharCount(N)` 不一定是相同的值`N* GetMaxCharCount(1)`。  
  
   
  
## Examples  
 下面的示例将字符串编码为一个字节，数组，然后字节解码为一个字符的数组。  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> 小于零。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <block subset="none" type="overrides">
          <para>所有<see cref="T:System.Text.Encoding" />实现必须保证，缓冲区溢出会发生任何异常根据该方法的计算结果的大小将调整缓冲区。</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，返回指定所用编码的字节序列。</summary>
        <returns>一个字节数组，包含指定所用编码的字节序列。  
  
或 
长度为零的字节数组（如果不需要前导码）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 （可选）<xref:System.Text.Encoding>对象提供一个前导码，可以将作为前缀的编码过程中所产生的字节序列的字节数组。 如果该前导码包含字节顺序标记 （在 Unicode 码位 U + FEFF)，它可帮助确定的字节顺序转换格式或 UTF 的解码器。  
  
 （以十六进制格式），Unicode 字节顺序标记 (BOM) 序列化是按如下所示：  
  
-   UTF-8: EF BB BF  
  
-   Utf-16 big endian 字节顺序： FE FF  
  
-   Utf-16 little-endian 字节顺序： FF FE  
  
-   UTF-32 big endian 字节顺序： 00 00 FE FF  
  
-   UTF-32 little-endian 字节顺序： FF FE 00 00  
  
 应使用 BOM，因为它提供了近乎确定的编码的文件，否则为已失去对引用标识<xref:System.Text.Encoding>对象，例如，无标记或标记错误的 web 数据或存储时业务的随机文本文件没有具有国际问题或其他数据。 如果数据一致和正确的标记，最好是 utf-8 或 utf-16 中，可能避免通常用户问题。  
  
 提供编码类型的标准，BOM 是有点多余。 但是，它可以用于帮助发送正确的编码标头的服务器。 或者，它可以用作回退的编码是否则丢失的情况下。  
  
 有一些缺点使用 BOM。 例如，了解如何限制使用 BOM 的数据库字段很难。 文件串联可以也是个问题，例如，在此类合并的文件时不必要的字符可能出现的中间数据的方式。 但是，尽管有几个缺点下, 强烈建议使用一个 BOM。  
  
 有关字节顺序和字节顺序标记的详细信息，请参阅 Unicode Standard [Unicode 主页](https://go.microsoft.com/fwlink/?LinkId=37123)。  
  
> [!CAUTION]
>  若要确保正确解码已编码的字节，应前缀编码后带前导码的字节。 但是，大多数编码不提供一个前导码。 若要确保能够正确解码已编码的字节，应使用 Unicode 编码，即<xref:System.Text.UTF8Encoding>， <xref:System.Text.UnicodeEncoding>，或<xref:System.Text.UTF32Encoding>，带前导码。  
  
   
  
## Examples  
 下面的示例确定编码基于该前导码的字节的顺序。  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，将一个字节序列解码为一个字符串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解码的字节序列的字节数组。</param>
        <summary>在派生类中重写时，将指定字节数组中的所有字节解码为一个字符串。</summary>
        <returns>包含指定字节序列解码结果的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要转换的数据仅在顺序块 （如从流中读取的数据） 中不可用或数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>返回对象<xref:System.Text.Encoding.GetDecoder%2A>派生方法ved 类。  
  
 请参阅备注部分的<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>解码技术和注意事项的讨论的参考主题。  
  
 请注意的确切行为<xref:System.Text.Encoding.GetString%2A>方法为特定<xref:System.Text.Encoding>实现取决于为该定义的回退策略<xref:System.Text.Encoding>对象。 有关详细信息，请参阅的"选择回退策略"部分[.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)主题。  
  
   
  
## Examples  
 下面的示例从所表示的二进制文件中读取的 utf-8 编码字符串<xref:System.IO.FileStream>对象。 对于小于 2,048 个字节的文件，它将整个文件的内容读入一个字节数组和调用<xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29>方法进行解码。 对于较大的文件，它 2,048 个字节一次读取到字节数组，调用<xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法来确定多少个字符包含在数组中，并调用<xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType>方法进行解码。  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 该示例使用以下文本，应保存到名为 Utf8Example.txt 的 utf-8 编码文件。  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">字节数组中包含无效的 Unicode 码位。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">指向字节数组的指针。</param>
        <param name="byteCount">要解码的字节数。</param>
        <summary>在派生类中重写时，将在指定地址开始的指定字节数解码为字符串。</summary>
        <returns>包含指定字节序列解码结果的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetString%2A>方法，可以在具有指向一个字节数组的本机指针时优化性能。 而不是创建的托管的字节数组，然后对其进行解码，可以改为调用此方法，而无需创建任何中间对象。  
  
 如果要转换的数据仅在顺序块 （如从流中读取的数据） 中不可用或数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>返回对象<xref:System.Text.Encoding.GetDecoder%2A>派生方法ved 类。  
  
 请参阅备注部分的<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>解码技术和注意事项的讨论的参考主题。  
  
 请注意的确切行为<xref:System.Text.Encoding.GetString%2A>方法为特定<xref:System.Text.Encoding>实现取决于为该定义的回退策略<xref:System.Text.Encoding>对象。 有关详细信息，请参阅的"选择回退策略"部分[.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)主题。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 为 null 指针。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> 小于零。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解码的字节序列的字节数组。</param>
        <param name="index">第一个要解码的字节的索引。</param>
        <param name="count">要解码的字节数。</param>
        <summary>在派生类中重写时，将指定字节数组中的一个字节序列解码为一个字符串。</summary>
        <returns>包含指定字节序列解码结果的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要转换的数据仅在顺序块 （如从流中读取的数据） 中不可用或数据量很大，它需要划分为较小的块，则应使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>提供的<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分别的派生类。  
  
 请参阅备注部分的<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>解码技术和注意事项的讨论的参考主题。  
  
   
  
## Examples  
 下面的示例从二进制文件由表示读取 utf-8 编码字符串<xref:System.IO.FileStream>对象。 对于小于 2,048 个字节的文件，它将整个文件的内容读入一个字节数组和调用<xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29>方法进行解码。 对于较大的文件，它 2,048 个字节一次读取到字节数组，调用<xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法来确定多少个字符包含在数组中，并调用<xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType>方法进行解码。  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 该示例使用以下文本，应保存到名为 Utf8Example.txt 的 utf-8 编码文件。  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">字节数组中包含无效的 Unicode 码位。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="index" /> 和 <paramref name="count" /> 不表示 <paramref name="bytes" /> 中的有效范围。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">发生了回退（如需完整说明，请参阅 [.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)） 
－和－ 
 将 <see cref="P:System.Text.Encoding.DecoderFallback" /> 设置为 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取可与邮件代理头标记一起使用的当前编码的名称。</summary>
        <value>与邮件代理头标记一起使用的当前 <see cref="T:System.Text.Encoding" /> 的名称。  
  
或 
如果当前 <see cref="T:System.Text.Encoding" /> 无法使用，则为空字符串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您需要的标头名称的编码，则应调用<xref:System.Text.Encoding.GetEncoding%2A>方法替换<xref:System.Text.Encoding.HeaderName%2A>属性。 通常方法检索不同的编码从调用中提供的测试编码。 通常只有电子邮件应用程序需要检索此类编码。  
  
 在某些情况下，值<xref:System.Text.Encoding.BodyName%2A>属性对应于定义编码的国际标准。 这并不意味着实现符合该标准填满中。  
  
 请注意，<xref:System.Text.Encoding.WebName%2A>返回要用来描述的编码的名称。 <xref:System.Text.Encoding.HeaderName%2A>属性定义一个不同的编码可能更适用于电子邮件应用程序，例如。 但是，不建议使用要定义的编码的属性。  
  
   
  
## Examples  
 下面的示例检索每个编码不同的名称，并显示具有一个或多个名称不同的编码<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>。 它将显示<xref:System.Text.Encoding.EncodingName%2A>但不会对其比较。  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取一个值，该值指示当前编码是否始终被规范化。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用默认范式获取一个值，该值指示当前编码是否始终被规范化。</summary>
        <returns>如果当前 <see cref="T:System.Text.Encoding" /> 始终被规范化，则为 <see langword="true" />；否则，为 <see langword="false" />。 默认值为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认规范化窗体是<xref:System.Text.NormalizationForm.FormC>，它使用完全标准分解，如有可能后跟其主复合序列替换。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">
          <see cref="T:System.Text.NormalizationForm" /> 值之一。</param>
        <summary>在派生类中重写时，使用指定范式获取一个值，该值指示当前编码是否始终被规范化。</summary>
        <returns>如果始终使用指定的 <see langword="true" /> 值规范化当前 <see cref="T:System.Text.Encoding" /> 对象，则为 <see cref="T:System.Text.NormalizationForm" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认规范化窗体是<xref:System.Text.NormalizationForm.FormC>，它使用完全标准分解，如有可能后跟其主复合序列替换。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个值，该值指示浏览器客户端是否可以使用当前的编码显示内容。</summary>
        <value>如果浏览器客户端可以使用当前的 <see cref="T:System.Text.Encoding" /> 显示内容，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例检查的每个编码的布尔属性的值。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个值，该值指示浏览器客户端是否可以使用当前的编码保存内容。</summary>
        <value>如果浏览器客户端可以使用当前的 <see cref="T:System.Text.Encoding" /> 保存内容，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例检查的每个编码的布尔属性的值。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个值，该值指示邮件和新闻客户端是否可以使用当前的编码显示内容。</summary>
        <value>如果邮件和新闻客户端可以使用当前的 <see cref="T:System.Text.Encoding" /> 显示内容，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例检查的每个编码的布尔属性的值。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个值，该值指示邮件和新闻客户端是否可以使用当前的编码保存内容。</summary>
        <value>如果邮件和新闻客户端可以使用当前 <see langword="true" /> 保存内容，则为 <see cref="T:System.Text.Encoding" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例检查的每个编码的布尔属性的值。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个值，该值指示当前的编码是否为只读。</summary>
        <value>如果当前 <see langword="true" /> 为只读，则为 <see cref="T:System.Text.Encoding" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取一个值，该值指示当前的编码是否使用单字节码位。</summary>
        <value>如果当前 <see langword="true" /> 使用单字节码位，则为 <see cref="T:System.Text.Encoding" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 单字节编码，例如， <xref:System.Text.ASCIIEncoding>，此属性检索`true`。  
  
> [!CAUTION]
>  应当小心在您的应用程序的值与<xref:System.Text.Encoding.IsSingleByte%2A>。 编码将如何进行假设仍可能有误。 例如，Windows 1252 具有值`true`为<xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>，但 Encoding.GetMaxByteCount(1) 返回 2。 这是因为该方法将从以前的解码器操作潜在剩余的代理项。  
  
   
  
## Examples  
 以下示例检查的每个编码的布尔属性的值。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">提供对其他字符编码的访问权限的 <see cref="T:System.Text.EncodingProvider" /> 的子类。</param>
        <summary>注册编码提供程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.RegisterProvider%2A>方法，可注册派生自的类<xref:System.Text.EncodingProvider>进行字符编码不支持它们的平台上可用。 它支持的编码的编码提供程序注册后，可以检索通过调用任何<xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType>重载。 如果有多个编码提供程序，<xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType>方法尝试检索指定的编码从开始使用最新注册每个提供程序。

使用注册编码提供程序<xref:System.Text.Encoding.RegisterProvider%2A>方法还会修改的行为[Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>)和[EncodingProvider.GetEncoding (Int32，EncoderFallback，DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))方法时传递的参数`0`:

- 如果已注册的提供程序是<xref:System.Text.CodePagesEncodingProvider>，该方法将返回 Windows 操作系统上运行时与系统活动的代码页相匹配的编码。

- 自定义编码提供程序可以选择编码时要返回其中一种<xref:System.Text.Encoding.GetEncoding%2A>方法重载传递的参数`0`。 此外可以选择提供程序不会返回通过让编码<xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType>方法将返回`null`。 
  
从.NET Framework 4.6 开始，.NET Framework 包括一个编码提供程序， <xref:System.Text.CodePagesEncodingProvider>，这样可以提供完整的.NET Framework 中存在但在通用 Windows 平台中不可用的编码。 默认情况下，通用 Windows 平台仅支持 Unicode 编码、 ASCII 和代码页 28591。  
  
 如果多个调用使用相同的编码提供程序<xref:System.Text.Encoding.RegisterProvider%2A>方法，仅第一个方法调用注册提供程序。 后续调用将被忽略。  
  
 如果<xref:System.Text.Encoding.RegisterProvider%2A>调用方法来注册处理相同的编码的多个提供程序，最后一个已注册提供程序是使用的所有编码和解码操作。 任何以前注册的提供程序将被忽略。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取使用 Little-Endian 字节顺序的 UTF-16 格式的编码。</summary>
        <value>使用 Little-Endian 字节顺序的 UTF-16 格式的编码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关支持.NET 并讨论了使用编码的 Unicode 编码的信息，请参阅[.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)。  
  
 <xref:System.Text.UnicodeEncoding>此属性返回的对象可能没有为你的应用的适当行为。 它使用替换回退将每个字符串，它不能进行编码和每个不能进行解码的字节替换为问号 ("？") 字符。 相反，您可以调用<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>构造函数实例化一个小 endian<xref:System.Text.UnicodeEncoding>对象，它的回退是个<xref:System.Text.EncoderFallbackException>或<xref:System.Text.DecoderFallbackException>，如下面的示例所示。  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 下面的示例确定进行编码的字符数组所需的字节数、 编码字符，并显示所产生的字节。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取使用 Little-Endian 字节顺序的 UTF-32 格式的编码。</summary>
        <value>使用 Little-Endian 字节顺序的 UTF-32 格式的编码对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding>此属性返回的对象可能没有为你的应用的适当行为。 它使用替换回退替换 Unicode 替换字符 (U + FFFE) 为每个不能进行编码的字符串和不能进行解码的每个字节。 相反，您可以调用<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>构造函数实例化<xref:System.Text.UTF32Encoding>对象，它的回退是个<xref:System.Text.EncoderFallbackException>或<xref:System.Text.DecoderFallbackException>，如下面的示例所示。  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Little-endian 字节顺序的讨论，请参阅<xref:System.Text.Encoding>类主题。  
  
 有关支持的.NET 和讨论使用编码的 Unicode 编码的信息，请参阅[.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)。  
  
   
  
## Examples  
 下面的示例确定进行编码的字符数组所需的字节数、 编码字符，并显示所产生的字节。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 UTF-7 格式的编码。</summary>
        <value>UTF-7 格式的编码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 主要在以前已被限制到 7 位，如 NNTP 和一些电子邮件应用程序的环境中使用 utf-7 编码。 由于具有可靠性和安全性问题，您不应使用 UTF7 编码在 8 位环境中的 utf-8 编码可改为使用。  
  
   
  
## Examples  
 下面的示例确定进行编码的字符数组所需的字节数、 编码字符，并显示所产生的字节。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 UTF-8 格式的编码。</summary>
        <value>UTF-8 格式的编码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回<xref:System.Text.UTF8Encoding>对象，它为每个字符，一到四个字节序列进行编码 （UTF 16 编码） 的 Unicode 字符和解码为 Unicode （UTF 16 编码） 个字符的 UTF-8 编码的字节数组。 有关.NET 和讨论使用编码的 Unicode 支持的字符编码的信息，请参阅[.NET 中的字符编码](~/docs/standard/base-types/character-encoding.md)。  
  
 <xref:System.Text.UTF8Encoding>此属性返回的对象可能不具有您的应用程序的适当行为。  
  
-   它将返回<xref:System.Text.UTF8Encoding>提供 Unicode 字节顺序标记 (BOM) 的对象。 若要实例化并不提供 BOM 的 UTF8 编码，请调用的任何重载<xref:System.Text.UTF8Encoding.%23ctor%2A>构造函数。  
  
-   它将返回<xref:System.Text.UTF8Encoding>都使用替换回退用问号来替换每个不能进行编码的字符串和不能进行解码的每个字节的对象 ("？") 字符。 相反，您可以调用<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>构造函数实例化<xref:System.Text.UTF8Encoding>对象，它的回退是个<xref:System.Text.EncoderFallbackException>或<xref:System.Text.DecoderFallbackException>，如下面的示例所示。  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 下面的示例定义一个数组，其中包含以下字符：  
  
-   拉丁文小写字母 Z (U + 007A)  
  
-   拉丁文小写字母 (U + 0061)  
  
-   组合铁 (U + 0306)  
  
-   拉丁文小写字母 AE 与新兴 (U + 01FD)  
  
-   希腊文小写字母 BETA (U + 03B2)  
  
-   窗体 GREEK ACROPHONIC ATTIC 一个千位 STATERS (U + 10154) 一个代理项对 (U + D800 U + DD54)。  
  
 它显示每个字符的 utf-16 代码单位并确定 utf-8 编码器进行编码的字符数组所需的字节数。 然后对字符进行编码，并显示结果的 UTF-8 编码的字节数。  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解编码</related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取在 Internet 编号分配管理机构 (IANA) 注册的当前编码的名称。</summary>
        <value>当前 <see cref="T:System.Text.Encoding" /> 的 IANA 名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.WebName%2A>属性等同于<xref:System.Text.EncodingInfo.Name%2A>属性。  
  
 请注意，<xref:System.Text.Encoding.WebName%2A>返回的编码的 IANA 注册名称。 其值为一种标准的名称，编码的实现可能不符合完全对该标准。 <xref:System.Text.Encoding.HeaderName%2A>属性定义一个不同的编码可能更好地适用于电子邮件标头。 但是，大多数应用程序应使用<xref:System.Text.Encoding.WebName%2A>相反。  
  
 有关 IANA 的更多信息，请转到[www.iana.org](https://www.iana.org/)。  
  
 <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType>等同于<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>返回的<xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>。 某些 web 名称是重复项;请参阅备注<xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>有关详细信息。  
  
   
  
## Examples  
 下面的示例包括<xref:System.Text.Encoding.WebName%2A>HTML 标头中。  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 下面的示例检索每个编码不同的名称，并显示具有一个或多个名称不同的编码<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>。 它将显示<xref:System.Text.Encoding.EncodingName%2A>但不会对其比较。  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取与当前编码最紧密对应的 Windows 操作系统代码页。</summary>
        <value>与当前 <see cref="T:System.Text.Encoding" /> 最紧密对应的 Windows 操作系统代码页。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性被用于与兼容 Windows 多语言 (MLang) Api，例如，在确定字体系列。 全球化，使用 Unicode 编码之一被建议改为。 它还建议使用<xref:System.Text.Encoding.WebName%2A>而不是<xref:System.Text.Encoding.WindowsCodePage%2A>来标识的代码页。  
  
   
  
## Examples  
 下面的示例确定为每个编码最紧密对应的 Windows 代码页。  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>