<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="be19bdb3283edd18f1fefcc8e73a6e60f1c1de24" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911215" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示可变字符字符串。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类表示其值是可变的字符序列的类似字符串的对象。  
  
 本节内容：  
  
-   [字符串和 StringBuilder 类型](#StringAndSB)  
  
-   [StringBuilder 的工作原理](#HowWorks)  
  
-   [内存分配](#Memory)  
  
-   [实例化 StringBuilder 对象](#Instantiating)  
  
-   [调用 StringBuilder 方法](#Calling)  
  
-   [执行 StringBuilder 操作](#Operations)  
  
    -   [循环 StringBuilder 字符](#Iterating)  
  
    -   [将文本添加到 StringBuilder 对象](#Adding)  
  
    -   [从 StringBuilder 对象中删除文本](#Deleting)  
  
    -   [修改 StringBuilder 对象中的文本](#Modifying)  
  
-   [StringBuilder 对象中搜索的文本](#Searching)  
  
-   [将 StringBuilder 对象转换为字符串](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>字符串和 StringBuilder 类型  
 尽管<xref:System.Text.StringBuilder>和<xref:System.String>二者都表示序列的字符，它们实现方式有所不同。 <xref:System.String> 是不可变的类型。 也就是说，看起来可以修改每个操作<xref:System.String>对象实际创建一个新字符串。  
  
 例如，调用<xref:System.String.Concat%2A?displayProperty=nameWithType>方法在下面的 C# 示例显示一个名为的字符串变量的值更改`value`。 事实上，<xref:System.String.Concat%2A>方法返回`value`具有不同的值和从地址对象`value`传递给方法的对象。 请注意，必须使用编译该示例`/unsafe`编译器选项。  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 对于执行广泛的字符串操作 （如修改在循环中多次字符串的应用） 的例程，反复修改字符串可以准确显著的性能损失。 替代方法是使用<xref:System.Text.StringBuilder>，它是一个可变字符串类。 可变性意味着，一旦创建类的实例后，它可以修改通过追加、 删除、 替换或插入字符。 A<xref:System.Text.StringBuilder>对象维护一个缓冲区以适应扩展到字符串。 如果没有可用; 空间，新数据追加到缓冲区否则为在分配新的、 更大的缓冲区、 原始缓冲区中的数据复制到新的缓冲区，和新的数据随后会追加到新的缓冲区。  
  
> [!IMPORTANT]
>  尽管<xref:System.Text.StringBuilder>类通常提供更好的性能比<xref:System.String>类，则应不会自动将<xref:System.String>与<xref:System.Text.StringBuilder>每当你想要操作的字符串。 性能取决于字符串，并将其分配的新字符串，其执行你的应用程序，系统和操作的类型的内存量的大小。 你应该准备好测试您的应用程序，以确定是否<xref:System.Text.StringBuilder>实际带来了显著的性能改进。  
  
 请考虑使用<xref:System.String>在这些情况下的类：  
  
-   当你的应用程序将对字符串进行的更改的数量很小。 在这些情况下，<xref:System.Text.StringBuilder>可能不会改善性能转移或产品可以忽略不计<xref:System.String>。  
  
-   当您正在执行固定的数量的串联运算，特别是对于字符串文本。 在这种情况下，编译器可能将合并到单个操作串联运算。  
  
-   当需要时要生成你的字符串，执行广泛的搜索操作。 <xref:System.Text.StringBuilder>类缺少搜索方法，如`IndexOf`或`StartsWith`。 你将需要转换<xref:System.Text.StringBuilder>对象传递给<xref:System.String>为这些操作，这可以 negate 从使用的性能优势<xref:System.Text.StringBuilder>。 有关详细信息，请参阅[StringBuilder 对象中搜索的文本](#Searching)部分。  
  
 请考虑使用<xref:System.Text.StringBuilder>在这些情况下的类：  
  
-   当您希望您的应用程序 （例如，在使用循环来连接包含用户输入的字符串的一个随机数时） 的设计时对字符串进行的更改数未知。  
  
-   当您希望您的应用程序对字符串进行大量更改。  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>StringBuilder 的工作原理  
 <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType>属性指示的字符数<xref:System.Text.StringBuilder>当前包含的对象。 如果您添加到字符<xref:System.Text.StringBuilder>对象，它等于的大小之前，其长度增加<xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType>属性，定义的对象可以包含的字符数。 如果添加的字符数导致的长度<xref:System.Text.StringBuilder>对象超过其当前容量，新的内存分配的值<xref:System.Text.StringBuilder.Capacity%2A>属性增加了一倍，新字符添加到<xref:System.Text.StringBuilder>对象，并且其<xref:System.Text.StringBuilder.Length%2A>调整属性。 其他内存以进行<xref:System.Text.StringBuilder>对象动态分配的直到它达到由定义值<xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType>属性。 当达到最大容量时，可为没有更多的内存分配的<xref:System.Text.StringBuilder>对象，并尝试添加字符或将其展开超出其最大容量引发或者<xref:System.ArgumentOutOfRangeException>或<xref:System.OutOfMemoryException>异常。  
  
 下面的示例演示如何<xref:System.Text.StringBuilder>对象分配新内存，并会动态增加其容量为分配给对象的字符串展开时展开。 该代码创建<xref:System.Text.StringBuilder>通过调用其默认 （无参数） 构造函数的对象。 此对象的默认容量是 16 个字符，其最大容量为多个 20 亿个字符。 追加字符串"This is 句子"。 导致新的内存分配，因为字符串长度 （19 个字符） 超过了默认容量<xref:System.Text.StringBuilder>对象。 该对象的容量增加一倍到 32 个字符，添加的新字符串，并且对象的长度现在等于 19 个字符。 代码然后追加的字符串"This is 其他句子"。 值<xref:System.Text.StringBuilder>对象 11 次。 每当追加操作导致的长度<xref:System.Text.StringBuilder>翻倍对象超过其容量，其现有的容量和<xref:System.Text.StringBuilder.Append%2A>操作成功。  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>内存分配  
 默认容量<xref:System.Text.StringBuilder>对象是 16 个字符，且其默认最大容量<xref:System.Int32.MaxValue?displayProperty=nameWithType>。 如果调用，则使用这些默认值<xref:System.Text.StringBuilder.%23ctor>和<xref:System.Text.StringBuilder.%23ctor%28System.String%29>构造函数。  
  
 你可以显式定义的初始容量<xref:System.Text.StringBuilder>对象通过以下方式：  
  
-   通过调用的任何<xref:System.Text.StringBuilder>构造函数包含`capacity`参数创建对象时。  
  
-   通过显式分配新值赋给<xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType>要扩展的现有属性<xref:System.Text.StringBuilder>对象。 请注意，该属性将引发异常的新容量是否小于现有容量或更高<xref:System.Text.StringBuilder>对象的最大容量。  
  
-   通过调用<xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType>具有新容量的方法。 新容量必须不能大于<xref:System.Text.StringBuilder>对象的最大容量。 但是，与分配给不同<xref:System.Text.StringBuilder.Capacity%2A>属性，<xref:System.Text.StringBuilder.EnsureCapacity%2A>不会引发异常，如果所需的新容量小于现有容量; 在这种情况下，方法调用不起作用。  
  
 如果字符串的长度分配给<xref:System.Text.StringBuilder>构造函数调用中的对象超过默认容量或指定的容量，<xref:System.Text.StringBuilder.Capacity%2A>属性设置为与指定的字符串的长度`value`参数。  
  
 你可以显式定义的最大容量<xref:System.Text.StringBuilder>对象通过调用<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>构造函数。 无法分配到一个新值来更改的最大容量<xref:System.Text.StringBuilder.MaxCapacity%2A>属性，因为它是只读的。  
  
 如上一节所分配所示，只要现有容量不足、 附加内存的容量和<xref:System.Text.StringBuilder>对象定义的值的双精度型值<xref:System.Text.StringBuilder.MaxCapacity%2A>属性。  
  
 一般情况下，默认的容量和最大容量是足够对于大多数应用程序。 你可以考虑设置以下情况下的这些值：  
  
-   如果最终大小<xref:System.Text.StringBuilder>对象很可能变得极其庞大，通常超过几兆字节。 在这种情况下，可能有一些性能受益于设置初始<xref:System.Text.StringBuilder.Capacity%2A>为很高的值，以消除了太多内存重新分配而需要的属性。  
  
-   如果你的应用具有有限的内存的系统上运行。 在这种情况下，你可能想要考虑设置<xref:System.Text.StringBuilder.MaxCapacity%2A>属性设置为小于<xref:System.Int32.MaxValue?displayProperty=nameWithType>如果你的应用程序正在处理可能导致其在内存约束的环境中执行的大的字符串。  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>实例化 StringBuilder 对象  
 实例化<xref:System.Text.StringBuilder>通过调用其六个的重载的类构造下, 表中列出了这些函数之一的对象。 三个构造函数实例化<xref:System.Text.StringBuilder>对象，其值为空字符串，但设置其<xref:System.Text.StringBuilder.Capacity%2A>和<xref:System.Text.StringBuilder.MaxCapacity%2A>值以不同的方式。 剩余的三个构造函数定义<xref:System.Text.StringBuilder>具有特定的字符串值和容量的对象。 两个三个构造函数使用的默认最大容量<xref:System.Int32.MaxValue?displayProperty=nameWithType>，而第三个允许你设置的最大容量。  
  
|构造函数|字符串值|容量|最大容量|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|通过定义`capacity`参数|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|通过定义`capacity`参数|通过定义`maxCapacity`参数|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|通过定义`value`参数|16 或`value`。 <xref:System.String.Length%2A>两者中较大|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|通过定义`value`参数|通过定义`capacity`参数或`value`。 <xref:System.String.Length%2A>两者中较大。|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|通过定义`value`。 <xref:System.String.Substring%2A>(`startIndex`, `length`)|通过定义`capacity`参数或`value`。 <xref:System.String.Length%2A>两者中较大。|通过定义`maxCapacity`参数|  
  
 下面的示例使用三个这些构造函数重载来实例化<xref:System.Text.StringBuilder>对象。  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>调用 StringBuilder 方法  
 修改中的字符串的方法的大多数<xref:System.Text.StringBuilder>实例返回到该同一实例的引用。 这使您可以调用<xref:System.Text.StringBuilder>两种方式的方法：  
  
-   可以进行单个方法调用，并忽略返回值，如以下示例执行。  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   你可以一系列方法调用在单个语句中。 这会很方便，如果你想要编写链接连续的操作的单个语句。 下面的示例将上一示例中的三个方法调用整合到单个行的代码。  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>执行 StringBuilder 操作  
 你可以使用的方法<xref:System.Text.StringBuilder>类循环、 添加、 删除或修改中的字符<xref:System.Text.StringBuilder>对象。  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>循环 StringBuilder 字符  
 你可以访问中的字符<xref:System.Text.StringBuilder>对象使用<xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>属性。 在 C# 中，<xref:System.Text.StringBuilder.Chars%2A>是一个索引器; 在 Visual Basic 中，它是默认属性<xref:System.Text.StringBuilder>类。 这使您可以设置或通过其索引仅，无需显式引用检索各个字符<xref:System.Text.StringBuilder.Chars%2A>属性。 中的字符<xref:System.Text.StringBuilder>对象开始索引 0 （零），并继续进行索引<xref:System.Text.StringBuilder.Length%2A>-1。  
  
 下面的示例演示<xref:System.Text.StringBuilder.Chars%2A>属性。 追加到 10 个随机数字<xref:System.Text.StringBuilder>对象，，然后循环的每个字符。 如果该字符的 Unicode 类别是<xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>，它减少了 1 的数 （或数更改为 9，如果其值为 0）。 该示例显示的内容<xref:System.Text.StringBuilder>对象同时之前和之后的每个字符的值已更改。  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>将文本添加到 StringBuilder 对象  
 <xref:System.Text.StringBuilder>类包括以下方法以扩展的内容<xref:System.Text.StringBuilder>对象：  
  
-   <xref:System.Text.StringBuilder.Append%2A>方法追加字符串、 一个子字符串，字符数组、 一部分的字符数组，单个字符重复多次，或的字符串表示形式基元数据类型更改为<xref:System.Text.StringBuilder>对象。  
  
-   <xref:System.Text.StringBuilder.AppendLine%2A>方法将行终止符或行终止符写入沿的字符串追加<xref:System.Text.StringBuilder>对象。  
  
-   <xref:System.Text.StringBuilder.AppendFormat%2A>方法将追加到<xref:System.Text.StringBuilder>对象。 在结果字符串中包含的对象的字符串表示可以反映当前系统区域性或指定的区域性的格式设置约定。  
  
-   <xref:System.Text.StringBuilder.Insert%2A>方法插入一个字符串，一个子字符串，字符串中的多个重复的字符数组、 一部分的字符数组或的字符串表示形式基元数据类型中指定位置处<xref:System.Text.StringBuilder>对象。 从零开始的索引定义位置。  
  
 下面的示例使用<xref:System.Text.StringBuilder.Append%2A>， <xref:System.Text.StringBuilder.AppendLine%2A>， <xref:System.Text.StringBuilder.AppendFormat%2A>，和<xref:System.Text.StringBuilder.Insert%2A>方法，以展开的文本<xref:System.Text.StringBuilder>对象。  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>从 StringBuilder 对象中删除文本  
 <xref:System.Text.StringBuilder>类包括可以减小的当前大小的方法<xref:System.Text.StringBuilder>实例。 <xref:System.Text.StringBuilder.Clear%2A>方法中删除所有字符并将设置<xref:System.Text.StringBuilder.Length%2A>为零的属性。 <xref:System.Text.StringBuilder.Remove%2A>方法删除了指定的数量的字符从特定索引位置开始。 此外，从末尾删除字符<xref:System.Text.StringBuilder>对象通过设置其<xref:System.Text.StringBuilder.Length%2A>属性小于当前实例的长度的值。  
  
 下面的示例删除某些中的文本<xref:System.Text.StringBuilder>对象，显示其生成容量、 最大容量和长度属性值，然后调用<xref:System.Text.StringBuilder.Clear%2A>方法移除所有字符<xref:System.Text.StringBuilder>对象。  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>修改 StringBuilder 对象中的文本  
 <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType>方法替换所有匹配项的字符或字符串中整个<xref:System.Text.StringBuilder>对象或特定的字符范围中。 下面的示例使用<xref:System.Text.StringBuilder.Replace%2A>方法将替换为问号 （？） 中的所有感叹号 （！）<xref:System.Text.StringBuilder>对象。  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>StringBuilder 对象中搜索的文本  
 <xref:System.Text.StringBuilder>类不包括方法类似于<xref:System.String.Contains%2A?displayProperty=nameWithType>， <xref:System.String.IndexOf%2A?displayProperty=nameWithType>，和<xref:System.String.StartsWith%2A?displayProperty=nameWithType>提供方法<xref:System.String>类，该类允许您搜索特定字符或子字符串的对象。 确定是否存在或起始字符位置的子字符串需要你搜索<xref:System.String>使用字符串搜索方法或正则表达式方法的值。 有四种方式来实现此类搜索，以下表所示。  
  
|技术|专业人员|Cons|  
|---------------|----------|----------|  
|将它们添加到之前搜索的字符串值<xref:System.Text.StringBuilder>对象。|可用于确定是否存在某个子字符串。|不能重要的子字符串的索引位置时。|  
|调用<xref:System.Text.StringBuilder.ToString%2A>和搜索返回<xref:System.String>对象。|易于使用如果分配到的所有文本<xref:System.Text.StringBuilder>对象，，然后开始对其进行修改。|轻松地重复调用<xref:System.Text.StringBuilder.ToString%2A>如果所有文本都添加到之前，必须进行修改<xref:System.Text.StringBuilder>对象。<br /><br /> 你必须记得工作结尾处<xref:System.Text.StringBuilder>对象的文本，如果您正在进行更改。|  
|使用<xref:System.Text.StringBuilder.Chars%2A>属性以按顺序搜索的字符范围。|如果你担心与单个字符或小写的子字符串很有用。|要搜索的字符的数量很大或复杂的搜索逻辑是否繁琐。<br /><br />已增加通过反复进行方法调用非常大的对象的性能很差的结果。  |  
|将转换<xref:System.Text.StringBuilder>对象传递给<xref:System.String>对象，并在执行修改<xref:System.String>对象。|如果修改的数量较少时很有用。|求反的性能优势<xref:System.Text.StringBuilder>类如果修改的数量很大。|  
  
 我们来查看更详细介绍这些技术。  
  
-   如果搜索的目标是确定是否存在某个特定的子字符串的 （即，如果你不感兴趣的子字符串的位置），你可以将它们存储在之前搜索字符串<xref:System.Text.StringBuilder>对象。 下面的示例提供了一种可能实现。 它定义`StringBuilderFinder`类其构造函数已传递到了引用<xref:System.Text.StringBuilder>对象和要在字符串中查找的子字符串。 在这种情况下，此示例尝试确定记录的温度华氏或摄氏，是否将相应的介绍性文本添加到的开头<xref:System.Text.StringBuilder>对象。 随机数生成器用于选择包含摄氏度或华氏度中的数据的数组。  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   调用<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>方法将转换<xref:System.Text.StringBuilder>对象传递给<xref:System.String>对象。 您可以通过使用以下方法搜索字符串<xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>或<xref:System.String.StartsWith%2A?displayProperty=nameWithType>，或者可以使用正则表达式和<xref:System.Text.RegularExpressions.Regex>类搜索模式。 因为同时<xref:System.Text.StringBuilder>和<xref:System.String>对象使用 utf-16 编码存储字符，子字符串，索引位置的字符和正则表达式匹配项是在这两个对象相同。 这使你可以使用<xref:System.Text.StringBuilder>方法，以便可以在同一位置中找到该文本的更改<xref:System.String>对象。  
  
    > [!NOTE]
    >  如果采用这种方法，你应从结尾处中工作<xref:System.Text.StringBuilder>对象对其开始，以便无需重复转换<xref:System.Text.StringBuilder>为 string 的对象。  
  
     下面的示例阐释了这种方法。 它存储在英语字母表中的每个字母的四个匹配项<xref:System.Text.StringBuilder>对象。 然后将转换为文本<xref:System.String>对象，并使用正则表达式来标识每个四个字符序列的起始位置。 最后，它添加下划线之前除第一个序列，每个四个字符序列，并将转换为大写的序列的第一个字符。  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   使用<xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>属性以按顺序搜索中的字符范围<xref:System.Text.StringBuilder>对象。 如果要搜索的字符的数量很大或搜索逻辑是特别复杂，这种方法可能不可行。 对性能产生影响的逐字符基于索引的访问非常大，chunked<xref:System.Text.StringBuilder>对象，请参阅的文档<xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>属性。 
  
     下面的示例在功能与前面的示例相同，但在实现中不同。 它使用<xref:System.Text.StringBuilder.Chars%2A>属性来检测何时字符值已更改，在该位置中，插入下划线，并将新序列中的第一个字符转换为大写。  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   存储中的所有未修改的文本<xref:System.Text.StringBuilder>对象，请调用<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>方法将转换<xref:System.Text.StringBuilder>对象传递给<xref:System.String>对象，并在执行修改<xref:System.String>对象。 你可以使用此方法，如果你有仅几修改;否则，使用不可变的字符串的成本，因此可能不使用的性能优势<xref:System.Text.StringBuilder>对象。  
  
     下面的示例在功能与前面的两个示例相同，但在实现中不同。 它将创建<xref:System.Text.StringBuilder>对象，请将其转换为<xref:System.String>对象，，然后使用正则表达式来对字符串执行剩余的所有修改。 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>方法使用 lambda 表达式来对每个匹配项执行替换。  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>将 StringBuilder 对象转换为字符串  
 必须先将 <xref:System.Text.StringBuilder> 对象转换为 <xref:System.String> 对象，然后才能将 <xref:System.Text.StringBuilder> 对象表示的字符串传递给包含 <xref:System.String> 参数的方法，或在用户界面中显示它。 通过调用来执行此转换<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>方法。 有关说明，请参阅前面的示例，其中调用<xref:System.Text.StringBuilder.ToString%2A>方法将转换<xref:System.Text.StringBuilder>对象为一个字符串，以便它可以传递给正则表达式方法。  
  
   
  
## Examples  
 下面的示例演示如何调用许多由定义的方法<xref:System.Text.StringBuilder>类。  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
    </block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实例的字符串值设置为<xref:System.String.Empty?displayProperty=nameWithType>，和容量设置为特定于实现的默认容量。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Text.StringBuilder.%23ctor%2A>不带任何参数的构造函数。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">此实例的建议起始大小。</param>
        <summary>使用指定的容量初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`参数定义的最大可以存储在内存中当前实例所分配的字符数。 其值分配给<xref:System.Text.StringBuilder.Capacity%2A>属性。 如果要存储的当前实例中的字符数超过了此`capacity`值，<xref:System.Text.StringBuilder>对象分配额外的内存来将其存储。  
  
 此实例的字符串值设置为<xref:System.String.Empty?displayProperty=nameWithType>。 如果`capacity`为零，则使用特定于实现的默认容量。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Text.StringBuilder.%23ctor%2A>具有指定容量的构造函数。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> 小于零。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">用于初始化实例值的字符串。 如果 <c>value</c> 为 <see langword="null" />，则新的 <see cref="T:System.Text.StringBuilder" /> 将包含空字符串（即，包含 <see cref="F:System.String.Empty" />）。</param>
        <summary>使用指定的字符串初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `value` 为 `null`，则新的 <xref:System.Text.StringBuilder> 将包含空字符串（即包含 <xref:System.String.Empty>）。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Text.StringBuilder.%23ctor%2A>构造函数使用指定的字符串。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Text.StringBuilder" /> 的建议起始大小。</param>
        <param name="maxCapacity">当前字符串可包含的最大字符数。</param>
        <summary>初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例，该类起始于指定容量并且可增长到指定的最大容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`参数定义的最大可以存储在内存中当前实例所分配的字符数。 其值分配给<xref:System.Text.StringBuilder.Capacity%2A>属性。 如果要存储的当前实例中的字符数超过了此`capacity`值，<xref:System.Text.StringBuilder>对象分配额外的内存来将其存储。  
  
 如果`capacity`为零，则使用特定于实现的默认容量。  
  
 `maxCapacity`属性定义最大的当前实例可容纳的字符数。 其值分配给<xref:System.Text.StringBuilder.MaxCapacity%2A>属性。 如果要存储的当前实例中的字符数超过了此`maxCapacity`值，<xref:System.Text.StringBuilder>对象不会分配更多内存，但改为引发异常。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Text.StringBuilder.%23ctor%2A>具有指定的容量和最大容量构造函数。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxCapacity" /> 小于一，<paramref name="capacity" /> 小于零，或 <paramref name="capacity" /> 大于 <paramref name="maxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">用于初始化实例值的字符串。 如果 <c>value</c> 为 <see langword="null" />，则新的 <see cref="T:System.Text.StringBuilder" /> 将包含空字符串（即，包含 <see cref="F:System.String.Empty" />）。</param>
        <param name="capacity">
          <see cref="T:System.Text.StringBuilder" /> 的建议起始大小。</param>
        <summary>使用指定的字符串和容量初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`参数定义的最大可以存储在内存中当前实例所分配的字符数。 其值分配给<xref:System.Text.StringBuilder.Capacity%2A>属性。 如果要存储的当前实例中的字符数超过了此`capacity`值，<xref:System.Text.StringBuilder>对象分配额外的内存来将其存储。  
  
 如果`capacity`为零，则使用特定于实现的默认容量。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Text.StringBuilder.%23ctor%2A>用初始字符串和指定的容量的构造函数。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> 小于零。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">字符串包含用于初始化此实例值的子字符串。 如果 <c>value</c> 为 <see langword="null" />，则新的 <see cref="T:System.Text.StringBuilder" /> 将包含空字符串（即，包含 <see cref="F:System.String.Empty" />）。</param>
        <param name="startIndex">
          <c>value</c> 中子字符串开始的位置。</param>
        <param name="length">子字符串中的字符数。</param>
        <param name="capacity">
          <see cref="T:System.Text.StringBuilder" /> 的建议起始大小。</param>
        <summary>从指定的子字符串和容量初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`参数定义的最大可以存储在内存中当前实例所分配的字符数。 其值分配给<xref:System.Text.StringBuilder.Capacity%2A>属性。 如果要存储的当前实例中的字符数超过了此`capacity`值，<xref:System.Text.StringBuilder>对象分配额外的内存来将其存储。  
  
 如果`capacity`为零，则使用特定于实现的默认容量。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Text.StringBuilder.%23ctor%2A>构造函数使用指定的字符串。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> 小于零。  
  
 或  
  
 <paramref name="startIndex" /> 加上 <paramref name="length" /> 不是 <paramref name="value" /> 中的位置。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向此实例追加指定对象的字符串表示形式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">要追加的布尔值。</param>
        <summary>向此实例追加指定的布尔值的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29>方法调用<xref:System.Boolean.ToString?displayProperty=nameWithType>方法以获取的字符串表示形式`value`。 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 8 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29>方法调用<xref:System.Byte.ToString%28System.IFormatProvider%29>方法以获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">要追加的 UTF 16 编码的代码单元。</param>
        <summary>将指定的 <see cref="T:System.Char" /> 对象的字符串表示形式追加到此实例。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符数组。</param>
        <summary>向此实例追加指定数组中的 Unicode 字符的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将指定数组中的所有字符都追加到当前实例相同的顺序与出现在`value`。 如果`value`是`null`，不进行任何更改。  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的十进制数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29>方法调用<xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法以获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的双精度浮点数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Double%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Double%29>方法调用<xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法以获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 16 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29>方法调用<xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法以获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 32 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29>方法调用<xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法以获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 64 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29>方法调用<xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>若要获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要追加的对象。</param>
        <summary>向此实例追加指定对象的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Object%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。 它定义`Dog`类中，创建`Dog`对象，并调用三到<xref:System.Text.StringBuilder.Append%2A>方法来创建包含 dog 的名称和同类的字符串。  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Object%29>方法调用<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法以获取的字符串表示形式`value`。 如果`value`是`null`，对进行任何更改<xref:System.Text.StringBuilder>对象。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 8 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29>方法调用<xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法以获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的单精度浮点数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Single%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Single%29>方法调用<xref:System.Single.ToString%2A?displayProperty=nameWithType>方法以获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符串。</param>
        <summary>向此实例追加指定字符串的副本。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.String%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 如果`value`是`null`，不进行任何更改。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 16 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29>方法调用<xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法以获取的字符串表示形式`value`。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 32 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29>调用<xref:System.UInt32.ToString%2A?displayProperty=nameWithType>方法以获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 64 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29>方法调用<xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法以获取的字符串表示形式`value`为当前区域性。 若要控制的格式`value`，调用<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符。</param>
        <param name="repeatCount">要追加 <c>value</c> 的次数。</param>
        <summary>向此实例追加 Unicode 字符的字符串表示形式指定数目的副本。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="repeatCount" /> 小于零。  
  
 或  
  
 增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <exception cref="T:System.OutOfMemoryException">内存不足。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="valueCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指向字符数组的指针。</param>
        <param name="valueCount">数组中的字符数。</param>
        <summary>将从指定地址开始的 Unicode 字符数组追加到此实例。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将追加`valueCount`从地址开始的字符`value`到当前实例。  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="valueCount" /> 小于零。  
  
 或  
  
 增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> 为 null 指针。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">字符数组。</param>
        <param name="startIndex">
          <c>value</c> 中的开始位置。</param>
        <param name="charCount">要追加的字符数。</param>
        <summary>向此实例追加指定的 Unicode 字符子数组的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将指定的范围中的字符追加`value`到当前实例。 如果`value`是`null`和`startIndex`和`count`都是零，则没有更改。  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />，且 <paramref name="startIndex" /> 和 <paramref name="charCount" /> 不为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> 小于零。  
  
 或  
  
 <paramref name="startIndex" /> 小于零。  
  
 或  
  
 <paramref name="startIndex" /> + <paramref name="charCount" /> 大于 <paramref name="value" /> 的长度。  
  
 或  
  
 增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">包含要追加的子字符串的字符串。</param>
        <param name="startIndex">
          <c>value</c> 中子字符串开始的位置。</param>
        <param name="count">
          <c>value</c> 中要追加的字符数。</param>
        <summary>向此实例追加指定子字符串的副本。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将指定的范围中的字符追加`value`到当前实例。 如果`value`是`null`和`startIndex`和`count`都是零，则没有更改。  
  
 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法修改此类的现有实例; 它不返回新的类实例。 因此，可以调用的方法或属性上的现有的引用，不需要分配返回值以<xref:System.Text.StringBuilder>对象，如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />，且 <paramref name="startIndex" /> 和 <paramref name="count" /> 不为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 小于零。  
  
 或  
  
 <paramref name="startIndex" /> 小于零。  
  
 或  
  
 <paramref name="startIndex" /> + <paramref name="count" /> 大于 <paramref name="value" /> 的长度。  
  
 或  
  
 增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都由相应的对象自变量的字符串表示形式替换。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置其格式的对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都替换为一个自变量的字符串表示形式。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都替换为 <paramref name="arg0" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)要将对象的值转换为它的文本表示形式，并将该表示形式嵌入在当前的.NET framework<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本与零个或多个索引占位符称为格式项混合。 格式项的索引必须为 0，以对应于`arg0`，此方法的参数列表中的单个对象。 格式化进程会将每个格式项替换的字符串表示形式`arg0`。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 如果没有在参数*索引*位置，<xref:System.FormatException>引发。|  
|*长度*|最小的字符串表示形式参数中的字符数。 如果为正数，该参数是右对齐;如果为负数，它是左对齐。|  
|:*formatString*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 有关与数值一起使用的标准和自定义格式字符串，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `arg0` 表示要设置格式的对象。 在每个格式项`format`替换的字符串表示形式`arg0`。 如果格式项包含`formatString`和`arg0`实现<xref:System.IFormattable>接口，则`arg0.ToString(formatString, null)`定义格式设置。 否则为`arg0.ToString()`定义格式设置。  
  
 如果字符串分配给`format`是"谢谢您捐赠 {0: # # #} 罐食品给我们的慈善组织。" 和`arg0`是一个整数值为 10，则返回值将是"感谢您的 10 罐食品给我们的慈善组织"。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
 或  
  
 格式项的索引小于 0（零），或者大于或等于 1。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="args">要设置其格式的对象的数组。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都由参数数组中相应参数的字符串表示形式替换。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都由相应的对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)要将对象的值转换为它的文本表示形式，并将该表示形式嵌入在当前的.NET framework<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本混和组成，零个或多个索引占位符称为格式项，对应于此方法的参数列表中的对象。 格式设置的过程将每个格式项替换的字符串表示形式的相应对象。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 如果没有在参数*索引*位置，<xref:System.FormatException>引发。|  
|*长度*|最小的字符串表示形式参数中的字符数。 如果为正数，该参数是右对齐;如果为负数，它是左对齐。|  
|:*formatString*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 有关与数值一起使用的标准和自定义格式字符串，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `args` 表示要设置格式的对象。 在每个格式项`format`替换的字符串表示形式中相应对象`args`。 如果格式项包含`formatString`和中的相应对象`args`实现<xref:System.IFormattable>接口，则`args[index].ToString(formatString, provider)`定义格式设置。 否则为`args[index].ToString()`定义格式设置。  
  
 如果字符串分配给`format`是"谢谢您捐赠 {0: # # #} 罐食品给我们的慈善组织。" 和`arg0`是一个整数值为 10，则返回值将是"感谢您的 10 罐食品给我们的慈善组织"。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 或 <paramref name="args" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
 或  
  
 格式项的索引小于 0（零），或者大于或等于 <paramref name="args" /> 数组的长度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序替换为单个参数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由 <paramref name="arg0" /> 的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)要转换的值的.NET framework`arg0`为其文本表示形式，并将该表示形式嵌入在当前<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本与零个或多个索引占位符称为格式项混合。 每个格式项的索引必须为零 (0)，因为此方法包括使用单个自变量自变量列表。 格式化进程会将每个格式项替换的字符串表示形式`arg0`。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 在这种情况下，由于<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29>方法自变量列表、 的值中包含一个自变量*索引*必须始终为 0。 如果不是，<xref:System.FormatException>引发。|  
|*长度*|最小的字符串表示形式参数中的字符数。 如果为正数，该参数是右对齐;如果为负数，它是左对齐。|  
|:*formatString*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 有关与数值一起使用的标准和自定义格式字符串，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `provider`参数指定<xref:System.IFormatProvider>可以提供格式设置信息中的对象的实现`args`。 `provider` 可以是以下任意形式：  
  
-   A<xref:System.Globalization.CultureInfo>提供区域性特定格式设置信息的对象。  
  
-   A<xref:System.Globalization.NumberFormatInfo>提供区域性特定格式设置信息的对象`arg0`如果它是数字值。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>提供区域性特定格式设置信息的对象`arg0`如果它是日期和时间值。  
  
-   自定义<xref:System.IFormatProvider>提供格式设置信息的实现`arg0`。 通常情况下，此类实现还实现<xref:System.ICustomFormatter>接口。  
  
 如果`provider`参数是`null`、 格式设置信息的均来自当前区域性。  
  
 `arg0` 表示要设置格式的对象。 在每个格式项`format`替换的字符串表示形式`arg0`。 如果格式项包含`formatString`和`arg0`实现<xref:System.IFormattable>接口，则`arg0.ToString(formatString, provider)`定义格式设置。 否则为`arg0.ToString()`定义格式设置。  
  
   
  
## Examples  
 以下包含两个调用<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29>方法。 它们都使用英语出色英国 (EN-GB) 区域性的格式设置约定。 第一个插入的字符串表示形式<xref:System.Decimal>值在结果字符串中的货币。 第二个插入<xref:System.DateTime>字符串在结果中的两个位置的值，第一个包括，仅短日期字符串和第二个短时间字符串。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
 或  
  
 格式项的索引小于 0（零），或者大于等于一 (1)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="args">要设置其格式的对象的数组。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序由参数数组中相应参数的字符串表示形式替换。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由相应对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)要将对象的值转换为它的文本表示形式，并将该表示形式嵌入在当前的.NET framework<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本混和组成，零个或多个索引占位符称为格式项，对应于此方法的参数列表中的对象。 格式设置的过程将每个格式项替换的字符串表示形式的相应对象。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 如果没有在参数*索引*位置，<xref:System.FormatException>引发。|  
|*长度*|最小的字符串表示形式参数中的字符数。 如果为正数，该参数是右对齐;如果为负数，它是左对齐。|  
|:*formatString*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 有关与数值一起使用的标准和自定义格式字符串，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `provider`参数指定<xref:System.IFormatProvider>可以提供格式设置信息中的对象的实现`args`。 `provider` 可以是以下任意形式：  
  
-   A<xref:System.Globalization.CultureInfo>提供区域性特定格式设置信息的对象。  
  
-   A<xref:System.Globalization.NumberFormatInfo>提供区域性特定格式设置信息中的数字值的对象`args`。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>提供区域性特定格式设置信息中的日期和时间值的对象`args`。  
  
-   自定义<xref:System.IFormatProvider>实现，提供一个或多个中的对象的格式设置信息`args`。 通常情况下，此类实现还实现<xref:System.ICustomFormatter>接口。 下一节中的第二个示例阐释了<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>具有自定义的方法调用<xref:System.IFormatProvider>实现。  
  
 如果`provider`参数是`null`，来自当前区域性获取格式提供程序信息。  
  
 `args` 表示要设置格式的对象。 在每个格式项`format`替换的字符串表示形式中相应对象`args`。 如果格式项包含`formatString`和中的相应对象`args`实现<xref:System.IFormattable>接口，则`args[index].ToString(formatString, provider)`定义格式设置。 否则为`args[index].ToString()`定义格式设置。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 下面的示例定义一个自定义<xref:System.IFormatProvider>实现名为`CustomerFormatter`后的第四个和第七个数字进行格式设置的 10 位数客户编号以连字符。 传递给<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>方法来创建包含格式化的客户编号和客户名称的字符串。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
 或  
  
 格式项的索引小于 0（零），或者大于或等于 <paramref name="args" /> 数组的长度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都替换为这两个参数中任意一个参数的字符串表示形式。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都由相应的对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)要将对象的值转换为它的文本表示形式，并将该表示形式嵌入在当前的.NET framework<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本与零个或多个索引占位符称为格式项，对应于混合`arg0`和`arg1`，此方法的参数列表中的两个对象。 格式设置的过程将每个格式项替换的字符串表示形式的相应对象。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 如果没有在参数*索引*位置，<xref:System.FormatException>引发。|  
|*长度*|最小的字符串表示形式参数中的字符数。 如果为正数，该参数是右对齐;如果为负数，它是左对齐。|  
|:*formatString*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 有关与数值一起使用的标准和自定义格式字符串，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `arg0` 和`arg1`表示要设置格式的对象。 在每个格式项`format`替换的字符串表示形式是`arg0`或`arg1`。 如果格式项包含`formatString`和相应的对象实现<xref:System.IFormattable>接口，则`arg` *x* `.ToString(formatString, provider)`定义格式设置，其中*x*是自变量的索引。 否则为`arg` *x* `.ToString()`定义格式设置。  
  
 如果字符串分配给`format`是"谢谢您捐赠 {0: # # #} 罐食品给我们的慈善组织。" 和`arg0`是一个整数值为 10，则返回值将是"感谢您的 10 罐食品给我们的慈善组织"。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
 或  
  
 格式项的索引小于 0（零），或者大于等于 2。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序替换为两个参数中任一个的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由相应对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)要将对象的值转换为它的文本表示形式，并将该表示形式嵌入在当前的.NET framework<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本混和组成，零个或多个索引占位符称为格式项，对应于此方法的参数列表中的对象。 格式设置的过程将每个格式项替换的字符串表示形式的相应对象。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 如果没有在参数*索引*位置，<xref:System.FormatException>引发。|  
|*长度*|最小的字符串表示形式参数中的字符数。 如果为正数，该参数是右对齐;如果为负数，它是左对齐。|  
|:*formatString*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 有关与数值一起使用的标准和自定义格式字符串，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `provider`参数指定<xref:System.IFormatProvider>可以提供格式设置信息的实现`arg0`和`arg1`。 `provider` 可以是以下任意形式：  
  
-   A<xref:System.Globalization.CultureInfo>提供区域性特定格式设置信息的对象。  
  
-   A<xref:System.Globalization.NumberFormatInfo>提供区域性特定格式设置信息的对象`arg0`或`arg1`如果它们是数值型的值。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>提供区域性特定格式设置信息的对象`arg0`或`arg1`如果它们是日期和时间值。  
  
-   自定义<xref:System.IFormatProvider>提供格式设置信息的实现`arg0`和`arg1`。 通常情况下，此类实现还实现<xref:System.ICustomFormatter>接口。  
  
 如果`provider`参数是`null`，来自当前区域性获取格式提供程序信息。  
  
 `arg0` 和`arg1`表示要设置格式的对象。 在每个格式项`format`替换的字符串表示形式具有相应的索引的对象。 如果格式项包含`formatString`并实现相应的自变量<xref:System.IFormattable>接口，则自变量的`ToString(formatString, provider)`方法定义格式设置。 否则为自变量的`ToString()`方法定义格式设置。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29>方法以显示时间和温度数据存储在一个泛型<xref:System.Collections.Generic.Dictionary%602>对象。 请注意，格式字符串将有三个格式项，尽管有仅对要格式化的对象。 这是因为在列表中 （日期和时间值） 的第一个对象由两个格式项： 第一个格式项目将显示时间和第二个显示的日期。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
 或  
  
 格式项的索引小于 0（零）或者大于或等于 2。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <param name="arg2">要设置格式的第三个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都替换为这三个参数中任意一个参数的字符串表示形式。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都由相应的对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)要将对象的值转换为它的文本表示形式，并将该表示形式嵌入在当前的.NET framework<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本与零个或多个索引占位符称为格式项，对应于混合`arg0`通过`arg2`，此方法的参数列表中的对象。 格式设置的过程将每个格式项替换的字符串表示形式的相应对象。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 如果没有在参数*索引*位置，<xref:System.FormatException>引发。|  
|*长度*|最小的字符串表示形式参数中的字符数。 如果为正数，该参数是右对齐;如果为负数，它是左对齐。|  
|:*formatString*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 有关与数值一起使用的标准和自定义格式字符串，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `arg0``arg1`，和`arg2`表示要设置格式的对象。 在每个格式项`format`替换的字符串表示形式是`arg0`， `arg1`，或`arg2`，取决于格式项的索引。 如果格式项包含`formatString`和中的相应对象`args`实现<xref:System.IFormattable>接口，则`arg` *x* `.ToString(formatString, null)`定义格式设置，其中*x*是自变量的索引。 否则为`arg` *x* `.ToString()`定义格式设置。  
  
 如果字符串分配给`format`是"谢谢您捐赠 {0: # # #} 罐食品给我们的慈善组织。" 和`arg0`是一个整数值为 10，则返回值将是"感谢您的 10 罐食品给我们的慈善组织"。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
 或  
  
 格式项的索引小于 0（零）或者大于或等于 3。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <param name="arg2">要设置格式的第三个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序替换为三个参数中任一个的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由相应对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)要将对象的值转换为它的文本表示形式，并将该表示形式嵌入在当前的.NET framework<xref:System.Text.StringBuilder>对象。  
  
 `format`参数由零个或多个文本混和组成，零个或多个索引占位符称为格式项，对应于此方法的参数列表中的对象。 格式设置的过程将每个格式项替换的字符串表示形式的相应对象。  
  
 格式项的语法如下所示：  
  
 {*索引*[，*长度*] [:*formatString*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|参数列表中要进行格式化的对象的从零开始位置。 如果指定的对象*索引*是`null`，格式项都替换为<xref:System.String.Empty?displayProperty=nameWithType>。 如果没有在参数*索引*位置，<xref:System.FormatException>引发。|  
|*长度*|最小的字符串表示形式参数中的字符数。 如果为正数，该参数是右对齐;如果为负数，它是左对齐。|  
|:*formatString*|由参数支持标准或自定义格式字符串。|  
  
> [!NOTE]
>  使用日期和时间值的标准和自定义格式字符串，请参阅[标准日期和时间格式字符串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 有关与数值一起使用的标准和自定义格式字符串，请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 用于枚举的标准格式字符串，请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `provider`参数指定<xref:System.IFormatProvider>可以提供格式设置信息的实现`arg0`和`arg1`。 `provider` 可以是以下任意形式：  
  
-   A<xref:System.Globalization.CultureInfo>提供区域性特定格式设置信息的对象。  
  
-   A<xref:System.Globalization.NumberFormatInfo>提供区域性特定格式设置信息的对象`arg0`或`arg1`如果它们是数值型的值。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>提供区域性特定格式设置信息的对象`arg0`， `arg1`，或`arg2`如果它们是日期和时间值。  
  
-   自定义<xref:System.IFormatProvider>提供格式设置信息的实现`arg0`， `arg1`，和`arg2`。 通常情况下，此类实现还实现<xref:System.ICustomFormatter>接口。  
  
 如果`provider`参数是`null`，来自当前区域性获取格式提供程序信息。  
  
 `arg0``arg1`，和`arg2`表示要设置格式的对象。 在每个格式项`format`替换的字符串表示形式具有相应的索引的对象。 如果格式项包含`formatString`并实现相应的自变量<xref:System.IFormattable>接口，则自变量的`ToString(formatString, provider)`方法定义格式设置。 否则为自变量的`ToString()`方法定义格式设置。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>方法来说明一个布尔值的结果`And`整数值操作。 请注意，格式字符串包括六个格式项，但方法具有只有三个项在其自变量列表中，因为每个项格式化两个不同的方式。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> 无效。  
  
 或  
  
 格式项的索引小于 0（零）或者大于或等于 3。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将默认的行终止符（或指定字符串的副本和默认的行终止符）追加到此实例的末尾。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将默认的行终止符追加到当前 <see cref="T:System.Text.StringBuilder" /> 对象的末尾。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认的行终止符是当前值<xref:System.Environment.NewLine%2A?displayProperty=nameWithType>属性。  
  
 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendLine%2A>方法。  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符串。</param>
        <summary>将后面跟有默认行终止符的指定字符串的副本追加到当前 <see cref="T:System.Text.StringBuilder" /> 对象的末尾。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认的行终止符是当前值<xref:System.Environment.NewLine%2A?displayProperty=nameWithType>属性。  
  
 根据需要调整此实例的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<see cref="T:System.Text.StringBuilder" />对象通过调用<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />构造函数，长度和的容量<see cref="T:System.Text.StringBuilder" />实例可以增长到的值超过其<see cref="P:System.Text.StringBuilder.MaxCapacity" />属性。 实现这一点尤其是当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />方法将小字符串追加。</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置可包含在当前实例所分配的内存中的最大字符数。</summary>
        <value>可包含在当前实例所分配的内存中的最大字符数。 其值可以从 <see cref="P:System.Text.StringBuilder.Length" /> 到 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> 不会影响当前实例的字符串值。 <xref:System.Text.StringBuilder.Capacity%2A> 因为它不是可以减少小于<xref:System.Text.StringBuilder.Length%2A>。  
  
 <xref:System.Text.StringBuilder>动态分配在需要时更多的空间并增加<xref:System.Text.StringBuilder.Capacity%2A>相应地。 出于性能原因，<xref:System.Text.StringBuilder>可能会分配更多的内存超过合理需求。 分配量是内存的特定于实现的。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Capacity%2A>属性。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">为集运算指定的值小于此实例的当前长度。  
  
 或  
  
 为集运算指定的值大于最大容量。</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">字符的位置。</param>
        <summary>获取或设置此实例中指定字符位置处的字符。</summary>
        <value>
          <paramref name="index" /> 位置处的 Unicode 字符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index`参数是中的字符的位置<xref:System.Text.StringBuilder>。 在字符串中的第一个字符位于索引 0 处。 一个字符串的长度为它包含的字符数。 可访问的最后一个字符<xref:System.Text.StringBuilder>实例位于索引<xref:System.Text.StringBuilder.Length%2A>-1。  
  
 <xref:System.Text.StringBuilder.Chars%2A> 是默认属性<xref:System.Text.StringBuilder>类。 在 C# 中，它是一个索引器。 这意味着，可以从检索各个字符<xref:System.Text.StringBuilder.Chars%2A>属性，如以下示例中的数量进行计数的字母中, 所示空格和字符串中的标点字符。  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>性能和基于字符的索引

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          设置字符时，<paramref name="index" /> 在此实例的范围之外。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          获取字符时，<paramref name="index" /> 在此实例的范围之外。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前 <see cref="T:System.Text.StringBuilder" /> 实例中移除所有字符。</summary>
        <returns>其 <see cref="P:System.Text.StringBuilder.Length" /> 为 0（零）的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Clear%2A> 是一种便利方法，它等效于设置<xref:System.Text.StringBuilder.Length%2A>为 0 （零） 的当前实例的属性。  
  
 调用<xref:System.Text.StringBuilder.Clear%2A>方法没有修改当前实例的<xref:System.Text.StringBuilder.Capacity%2A>或<xref:System.Text.StringBuilder.MaxCapacity%2A>属性。  
  
   
  
## Examples  
 下面的示例实例化<xref:System.Text.StringBuilder>替换字符串，调用的对象<xref:System.Text.StringBuilder.Clear%2A>方法，然后再追加一个新字符串。  
  
 [!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">此实例中开始复制字符的位置。 索引是从零开始的。</param>
        <param name="destination">将从中复制字符的数组。</param>
        <param name="destinationIndex">
          <c>destination</c> 中将从其开始复制字符的起始位置。 索引是从零开始的。</param>
        <param name="count">要复制的字符数。</param>
        <summary>将此实例的指定段中的字符复制到目标 <see cref="T:System.Char" /> 数组的指定段中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.CopyTo%2A>方法旨在用于极少数情况下，当你需要高效地将复制的连续部分<xref:System.Text.StringBuilder>到一个数组对象。 数组应具有固定的大小，预分配、 可重复使用，且可能是全局访问。  
  
 例如，你的应用程序无法填充<xref:System.Text.StringBuilder>对象具有大量字符，然后使用<xref:System.Text.StringBuilder.CopyTo%2A>方法可将复制的小连续部分<xref:System.Text.StringBuilder>到一个数组，其中部分被处理的对象。 当中的所有数据<xref:System.Text.StringBuilder>处理对象时，大小<xref:System.Text.StringBuilder>对象设置为零，并且重复周期。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.CopyTo%2A>方法。  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />、<paramref name="destinationIndex" /> 或 <paramref name="count" /> 小于零。  
  
 或  
  
 <paramref name="sourceIndex" /> 大于此实例的长度。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceIndex" /> + <paramref name="count" /> 大于此实例的长度。  
  
 或  
  
 <paramref name="destinationIndex" /> + <paramref name="count" /> 大于 <paramref name="destination" /> 的长度。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">要确保的最小容量。</param>
        <summary>确保 <see cref="T:System.Text.StringBuilder" /> 的此实例的容量至少是指定值。</summary>
        <returns>此实例的新容量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前容量小于`capacity`参数，此实例重新分配内存以容纳至少`capacity`字符数; 否则为更改任何内存。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.EnsureCapacity%2A>方法。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> 小于零。  
  
 或  
  
 增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">与此实例进行比较的对象，或为 <see langword="null" />。</param>
        <summary>返回一个值，该值指示此实例是否等于指定的对象。</summary>
        <returns>
          如果此实例和 <paramref name="sb" /> 具有相等的字符串、<see cref="P:System.Text.StringBuilder.Capacity" /> 和 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 值，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码使用<xref:System.Text.StringBuilder.Equals%2A>方法来检查两个<xref:System.Text.StringBuilder>对象是否相等。 对每个对象，进行少量更改，并且结果显示到控制台后，将重复调用该方法。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将指定对象的字符串表示形式插入到此实例中的指定字符位置。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将布尔值的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符以便腾出空间供新的文本。 根据需要调整容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，对此方法的调用引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 8 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符以便腾出空间供新的文本。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，对此方法的调用引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 Unicode 字符的字符串表示形式插入到此实例中的指定位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符以便腾出空间供新的文本。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。  
  
 或  
  
 增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的字符数组。</param>
        <summary>将指定的 Unicode 字符数组的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 移动现有字符以便腾出空间供新的文本。 根据需要调整此实例的容量。  
  
 如果`value`是`null`、<xref:System.Text.StringBuilder>不会更改。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。  
  
 或  
  
 增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将十进制数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符以便腾出空间供新的文本。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，对此方法的调用引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将双精度浮点数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符以便腾出空间供新的文本。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，对此方法的调用引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 16 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符以便腾出空间供新的文本。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，对此方法的调用引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 32 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符以便腾出空间供新的文本。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，对此方法的调用引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 64 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符以便腾出空间供新的文本。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，对此方法的调用引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的对象，或 <see langword="null" />。</param>
        <summary>将对象的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符以便腾出空间供新的文本。 根据需要调整此实例的容量。  
  
 如果`value`是`null`，此实例的值保持不变。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，对此方法的调用引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 8 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符以便腾出空间供新的文本。 根据需要调整容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，对此方法的调用引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将单精度浮点数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符以便腾出空间供新的文本。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，对此方法的调用引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的字符串。</param>
        <summary>将字符串插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 移动现有字符以便腾出空间供新的文本。 根据需要调整容量。  
  
 此实例<xref:System.Text.StringBuilder>未发生更改时如果`value`是`null`，或`value`不`null`但其长度为零。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的当前长度。  
  
 或  
  
 此 <see cref="T:System.Text.StringBuilder" /> 对象的当前长度加上 <paramref name="value" /> 的长度超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 16 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符以便腾出空间供新的文本。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，对此方法的调用引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 32 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符以便腾出空间供新的文本。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，对此方法的调用引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 64 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> 用于获取的字符串表示形式`value`。 移动现有字符以便腾出空间供新的文本。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage">
          <para>在[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和早期版本中，对此方法的调用引发<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，该方法将引发<see cref="T:System.OutOfMemoryException" />。</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的字符串。</param>
        <param name="count">要插入 <c>value</c> 的次数。</param>
        <summary>将指定字符串的一个或更多副本插入到此实例中的指定字符位置。</summary>
        <returns>完成插入后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 移动现有字符以便腾出空间供新的文本。 根据需要调整此实例的容量。  
  
 这<xref:System.Text.StringBuilder>如果对象不会更改`value`是`null`，`value`不`null`但其长度为零，或`count`为零。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零或大于此实例的当前长度。  
  
 或  
  
 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.OutOfMemoryException">此 <see cref="T:System.Text.StringBuilder" /> 对象的当前长度加上 <paramref name="value" /> 的长度乘以 <paramref name="count" /> 的值超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">字符数组。</param>
        <param name="startIndex">
          <c>value</c> 中的起始索引。</param>
        <param name="charCount">要插入的字符数。</param>
        <summary>将指定的 Unicode 字符子数组的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 移动现有字符以便腾出空间供新的文本。 根据需要调整此实例的容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> 为 <see langword="null" />，且 <paramref name="startIndex" /> 和 <paramref name="charCount" /> 不为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />、<paramref name="startIndex" /> 或 <paramref name="charCount" /> 小于零。  
  
 或  
  
 <paramref name="index" /> 大于此实例的长度。  
  
 或  
  
 <paramref name="startIndex" /> 加上 <paramref name="charCount" /> 不是 <paramref name="value" /> 中的位置。  
  
 或  
  
 增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前 <see cref="T:System.Text.StringBuilder" /> 对象的长度。</summary>
        <value>此实例的长度。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 长度<xref:System.Text.StringBuilder>对象由其数定义<xref:System.Char>对象。  
  
 如<xref:System.String.Length%2A?displayProperty=nameWithType>属性，<xref:System.Text.StringBuilder.Length%2A>属性指示当前字符串对象的长度。 与不同<xref:System.String.Length%2A?displayProperty=nameWithType>属性，它是只读的<xref:System.Text.StringBuilder.Length%2A>属性允许你修改存储到的字符串的长度<xref:System.Text.StringBuilder>对象。  
  
 如果指定的长度小于当前的长度，当前<xref:System.Text.StringBuilder>对象将被截断到指定的长度。 如果指定的长度大于当前的长度，当前的字符串值的末尾<xref:System.Text.StringBuilder>对象填充以 Unicode NULL 字符 (U + 0000)。  
  
 如果指定的长度大于当前的容量，<xref:System.Text.StringBuilder.Capacity%2A>增加，以便它大于或等于指定的长度。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Length%2A>属性。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">为设置操作指定的值小于零或大于 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例的最大容量。</summary>
        <value>此实例可容纳的最大字符数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于此实现的最大容量<xref:System.Int32.MaxValue?displayProperty=nameWithType>。 但是，此值特定于实现，并且可能在其他或更高版本实现不同。 你可以显式设置的最大容量<xref:System.Text.StringBuilder>对象通过调用<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>构造函数。  
  
 在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]和[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，当实例化时<xref:System.Text.StringBuilder>对象通过调用<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>构造函数，长度和的容量<xref:System.Text.StringBuilder>实例可以增长到的值超过其<xref:System.Text.StringBuilder.MaxCapacity%2A>属性。 实现这一点尤其是当调用<xref:System.Text.StringBuilder.Append%2A>和<xref:System.Text.StringBuilder.AppendFormat%2A>方法将小字符串追加。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <param name="length">要删除的字符数。</param>
        <summary>将指定范围的字符从此实例中移除。</summary>
        <returns>切除操作完成后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前方法从当前实例中移除指定的范围的字符。 在字符 (`startIndex` + `length`) 移动到`startIndex`，并且当前实例的字符串值缩短通过`length`。 当前实例的容量不受影响。  
  
> [!NOTE]
>  <xref:System.Text.StringBuilder.Remove%2A>方法修改的当前值<xref:System.Text.StringBuilder>实例，并返回该实例。 它不创建和返回一个新<xref:System.Text.StringBuilder>对象。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Remove%2A>方法。  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">如果 <paramref name="startIndex" /> 或 <paramref name="length" /> 小于零，或者 <paramref name="startIndex" /> + <paramref name="length" /> 大于此实例的长度。</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例中出现的所有指定字符或字符串替换为其他的指定字符或字符串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">要替换的字符。</param>
        <param name="newChar">替换 <c>oldChar</c> 的字符。</param>
        <summary>将此实例中出现的所有指定字符替换为其他指定字符。</summary>
        <returns>对此实例的引用，其中 <paramref name="oldChar" /> 被 <paramref name="newChar" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行序号、 区分大小写比较来标识的匹配项`oldChar`当前实例中。 当前的大小<xref:System.Text.StringBuilder>实例在更换后保持不变。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">要替换的字符串。</param>
        <param name="newValue">替换 <c>oldValue</c> 的字符串，或 <see langword="null" />。</param>
        <summary>将此实例中出现的所有指定字符串的替换为其他指定字符串。</summary>
        <returns>对此实例的引用，其中 <paramref name="oldValue" /> 的所有实例被 <paramref name="newValue" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行序号、 区分大小写比较来标识的匹配项`oldValue`当前实例中。 如果`newValue`是`null`或<xref:System.String.Empty?displayProperty=nameWithType>，出现的所有`oldValue`会删除。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> 的长度为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">要替换的字符。</param>
        <param name="newChar">替换 <c>oldChar</c> 的字符。</param>
        <param name="startIndex">此实例中子字符串开始的位置。</param>
        <param name="count">子字符串的长度。</param>
        <summary>将此实例的子字符串中出现的所有指定字符替换为其他指定字符。</summary>
        <returns>对此实例的引用，其中从 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> -1 范围内的 <paramref name="oldChar" /> 被 <paramref name="newChar" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行序号、 区分大小写比较来标识的匹配项`oldChar`当前实例中。 当前的大小<xref:System.Text.StringBuilder>对象在更换后保持不变。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> + <paramref name="count" /> 大于此实例的值的长度。  
  
 或  
  
 <paramref name="startIndex" /> 或 <paramref name="count" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">要替换的字符串。</param>
        <param name="newValue">替换 <c>oldValue</c> 的字符串，或 <see langword="null" />。</param>
        <param name="startIndex">此实例中子字符串开始的位置。</param>
        <param name="count">子字符串的长度。</param>
        <summary>将此实例的子字符串中出现的所有指定字符串替换为其他指定字符串。</summary>
        <returns>对此实例的引用，其中从 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> - 1 的范围内 <paramref name="oldValue" /> 的所有实例被 <paramref name="newValue" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行序号、 区分大小写比较来标识的匹配项`oldValue`中指定的子字符串。 如果`newValue`是`null`或<xref:System.String.Empty?displayProperty=nameWithType>，出现的所有`oldValue`会删除。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> 的长度为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 或 <paramref name="count" /> 小于零。  
  
 或  
  
 <paramref name="startIndex" /> 与 <paramref name="count" /> 之和指示一个不在此实例内的字符位置。  
  
 或  
  
 增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">要用序列化信息填充的对象。</param>
        <param name="context">存储和检索序列化数据的位置。 留待将来使用。</param>
        <summary>使用所需的数据填充 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象来反序列化当前 <see cref="T:System.Text.StringBuilder" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `context`参数是保留供将来使用，不参与此操作。  
  
 有关更多信息，请参见 <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Text.StringBuilder" /> 的值转换为 <see cref="T:System.String" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此实例的值转换为 <see cref="T:System.String" />。</summary>
        <returns>其值与此实例相同的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须调用<xref:System.Text.StringBuilder.ToString%2A>方法将转换<xref:System.Text.StringBuilder>对象传递给<xref:System.String>对象，然后可以将传递所表示的字符串<xref:System.Text.StringBuilder>对象的方法的具有<xref:System.String>参数或在用户界面中显示它。  
  
   
  
## Examples  
 下面的示例演示如何调用 <xref:System.Text.StringBuilder.ToString%2A> 方法。 此示例摘自更大的示例为提供<xref:System.Text.StringBuilder>类。  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">此实例内子字符串的起始位置。</param>
        <param name="length">子字符串的长度。</param>
        <summary>将此实例中子字符串的值转换为 <see cref="T:System.String" />。</summary>
        <returns>一个字符串，其值与此实例的指定子字符串相同。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须调用<xref:System.Text.StringBuilder.ToString%2A>方法将转换<xref:System.Text.StringBuilder>对象传递给<xref:System.String>对象，然后可以将传递所表示的字符串<xref:System.Text.StringBuilder>对象的方法的具有<xref:System.String>参数或在用户界面中显示它。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。  
  
 或  
  
 <paramref name="startIndex" /> 与 <paramref name="length" /> 的和大于当前实例的长度。</exception>
      </Docs>
    </Member>
  </Members>
</Type>