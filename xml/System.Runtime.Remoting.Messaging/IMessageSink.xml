<Type Name="IMessageSink" FullName="System.Runtime.Remoting.Messaging.IMessageSink">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1dd3980c6db096c63bf5a16dc14529fdeaebe51c" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36631069" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IMessageSink" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IMessageSink" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.Messaging.IMessageSink" />
  <TypeSignature Language="VB.NET" Value="Public Interface IMessageSink" />
  <TypeSignature Language="C++ CLI" Value="public interface class IMessageSink" />
  <TypeSignature Language="F#" Value="type IMessageSink = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>定义消息接收器的接口。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当方法调用的代理服务器上时，远程处理基础结构用于将自变量传递到实际的对象，与在远程处理边界之间提供必要的支持，调用带有参数的实际对象方法并返回结果回代理对象的客户端。  
  
 远程方法调用是从客户端将转到服务器端的消息，并可能返回。 远程方法调用它的方式跨越远程处理边界，因为传递的链`IMessageSink`对象。 链中的每个接收器接收该消息对象，执行特定操作时，委托给链中的下一个接收器。 代理对象包含与第一个引用`IMessageSink`它需要使用来开始该链。  
  
 对于异步调用时的委派，每个接收器都提供答复接收器 (另一个`IMessageSink`) 在其返回途中答复时将由下一个接收器调用的。  
  
 不同类型的接收器执行不同操作，具体取决于收到的消息对象的类型。 例如，一个接收器可能会导致要执行的锁、 另一个可能强制实施调用安全、 另一个可能执行流调用控件和可靠性服务和而另一个无法传输到其他调用<xref:System.AppDomain>，进程或计算机。 链中的两个或多个消息接收器可以进行相互交互与每个特定的操作有关。  
  
   
  
## Examples  
 下面的代码示例演示实现<xref:System.Runtime.Remoting.Messaging.IMessageSink>接口。 请注意，该示例假设类型定义和必须提供的示例待办编译的程序集引用。  
  
 [!code-cpp[IMessageSink_Client#3](~/samples/snippets/cpp/VS_Snippets_Remoting/IMessageSink_Client/CPP/imessagesink_client.cpp#3)]
 [!code-csharp[IMessageSink_Client#3](~/samples/snippets/csharp/VS_Snippets_Remoting/IMessageSink_Client/CS/imessagesink_client.cs#3)]
 [!code-vb[IMessageSink_Client#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IMessageSink_Client/VB/imessagesink_client.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>务必要注意实现当前接口的代码必须提供两个实现<see cref="M:System.Runtime.Remoting.Messaging.IMessageSink.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)" />和<see cref="M:System.Runtime.Remoting.Messaging.IMessageSink.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)" />，因为同步调用可以转换为异步调用，反之亦然。必须实现这两种方法，即使接收器不支持异步处理。</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName="AsyncProcessMessage">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(class System.Runtime.Remoting.Messaging.IMessage msg, class System.Runtime.Remoting.Messaging.IMessageSink replySink) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.IMessageSink.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)" />
      <MemberSignature Language="VB.NET" Value="Public Function AsyncProcessMessage (msg As IMessage, replySink As IMessageSink) As IMessageCtrl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::Messaging::IMessageCtrl ^ AsyncProcessMessage(System::Runtime::Remoting::Messaging::IMessage ^ msg, System::Runtime::Remoting::Messaging::IMessageSink ^ replySink);" />
      <MemberSignature Language="F#" Value="abstract member AsyncProcessMessage : System.Runtime.Remoting.Messaging.IMessage * System.Runtime.Remoting.Messaging.IMessageSink -&gt; System.Runtime.Remoting.Messaging.IMessageCtrl" Usage="iMessageSink.AsyncProcessMessage (msg, replySink)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageCtrl</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMessage" />
        <Parameter Name="replySink" Type="System.Runtime.Remoting.Messaging.IMessageSink" />
      </Parameters>
      <Docs>
        <param name="msg">要处理的消息。</param>
        <param name="replySink">答复消息的答复接收器。</param>
        <summary>异步处理给定的消息。</summary>
        <returns>返回 <see cref="T:System.Runtime.Remoting.Messaging.IMessageCtrl" /> 接口，该接口提供一种在调度异步消息之后控制这些消息的方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过远程处理基础结构或异步消息的上一个接收器，在消息接收器上调用此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">直接调用方通过引用接口进行调用，且没有基础结构权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于操作基础结构代码。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NextSink">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.Messaging.IMessageSink NextSink { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Remoting.Messaging.IMessageSink NextSink" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.IMessageSink.NextSink" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextSink As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Remoting::Messaging::IMessageSink ^ NextSink { System::Runtime::Remoting::Messaging::IMessageSink ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextSink : System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.Messaging.IMessageSink.NextSink" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取接收器链中的下一个消息接收器。</summary>
        <value>接收器链中的下一个消息接收器。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">直接调用方通过引用接口进行调用，且没有基础结构权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于操作基础结构代码。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SyncProcessMessage">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(class System.Runtime.Remoting.Messaging.IMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.IMessageSink.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Function SyncProcessMessage (msg As IMessage) As IMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::Messaging::IMessage ^ SyncProcessMessage(System::Runtime::Remoting::Messaging::IMessage ^ msg);" />
      <MemberSignature Language="F#" Value="abstract member SyncProcessMessage : System.Runtime.Remoting.Messaging.IMessage -&gt; System.Runtime.Remoting.Messaging.IMessage" Usage="iMessageSink.SyncProcessMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMessage" />
      </Parameters>
      <Docs>
        <param name="msg">要处理的消息。</param>
        <summary>同步处理给定的消息。</summary>
        <returns>响应请求的答复消息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.Messaging.IMessageSink.SyncProcessMessage%2A>方法调用在消息接收器上通过远程处理基础结构或同步消息的上一个接收器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">直接调用方通过引用接口进行调用，且没有基础结构权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于操作基础结构代码。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>