<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ChangeMonitor.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5ef439688d7b98a238cf8640eb07e63804432a3ba.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ef439688d7b98a238cf8640eb07e63804432a3ba</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Provides a base class for a derived custom type that monitors changes in the state of the data which a cache item depends on.</source>
          <target state="translated">为用于监视缓存项所依赖数据的状态更改的派生自定义类型提供基类。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class is used as the base class for derived monitor classes that are specialized for particular cache implementations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>类用作专用于特定的缓存实现的派生的监视器类的基类。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance monitors changes in the state of data which a cache item depends on.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>实例监视数据，具体取决于缓存项的状态中的更改。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For example, the item can be a file or data entity whose contents are cached.</source>
          <target state="translated">例如，可以将项其内容进行缓存的文件或数据实体。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the file or data entity is updated, the associated cache entry must be changed also.</source>
          <target state="translated">如果更新文件或数据实体，则必须还更改关联的缓存项。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Common items that can be monitored include data entities (such as database fields, values, rows, or tables), another cache entry, and files and file attributes.</source>
          <target state="translated">可以监视的通用项包括数据实体 （如数据库字段、 值、 行或表）、 另一个缓存项时，和文件和文件属性。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A dependency change is a change in the state of a dependency.</source>
          <target state="translated">依赖项更改是中的依赖项的状态的更改。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>In a typical cache implementation, after a <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance notifies the cache that a dependency has changed, the cache performs the required action, such as invalidating the inserted cache entry.</source>
          <target state="translated">在典型的缓存实现中之后,<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>实例通知缓存依赖项已更改，缓存执行所需的操作，如正在使插入的缓存条目无效。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Derived <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> classes can be customized to monitor dependency changes for specific different data stores.</source>
          <target state="translated">派生<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>可以自定义类，以监视特定的不同数据存储区的依赖项更改。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For example, there are cache implementations for a file system, physical memory, or a database.</source>
          <target state="translated">例如，有的文件系统、 物理内存或数据库的缓存实现。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class examines changes that occur outside the cache, and then alerts the cache that changes have occurred.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>类检查缓存中，外部发生的更改，然后警报缓存中已发生更改。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> includes the following classes that derive from <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class:</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>包括派生自的以下类<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>类：</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Each of these classes works with different types of dependencies.</source>
          <target state="translated">其中每个类可用于不同类型的依赖关系。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For example, the derived <ph id="ph1">&lt;xref:System.Runtime.Caching.FileChangeMonitor&gt;</ph> class monitors changes to a cache for file system data (files and folders) that the cache item depends on.</source>
          <target state="translated">例如，派生<ph id="ph1">&lt;xref:System.Runtime.Caching.FileChangeMonitor&gt;</ph>类监视对文件系统数据 （文件和文件夹） 的缓存的缓存项所依赖的更改。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>This type is thread safe.</source>
          <target state="translated">此类型是线程安全的。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If you create a custom cache implementation or a derived change monitor type, you must follow certain guidelines.</source>
          <target state="translated">如果创建自定义的缓存实现或派生的更改监视器类型，必须遵循特定的准则。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The following list summarizes these guidelines.</source>
          <target state="translated">以下列表总结了这些准则。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For more information, see the documentation for individual methods or properties.</source>
          <target state="translated">有关详细信息，请参阅各个方法或属性的文档。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The constructor of a derived class must set the <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph> property, begin monitoring, and call <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method before the method returns.</source>
          <target state="translated">派生类的构造函数必须设置<ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph>属性，开始监视，并调用<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph>在方法返回之前的方法。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If a constructor encounters an error during constructions and must have to dispose of resources, the constructor can only call the <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload after the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method is called because the <ph id="ph3">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload will throw an <ph id="ph4">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> exception if initialization is not completed.</source>
          <target state="translated">如果一个构造函数在构造过程中遇到错误，并且必须以释放资源，构造函数只能调用<ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>重载后<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph>调用方法，因为<ph id="ph3">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>重载将引发<ph id="ph4">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph>如果初始化未完成的异常。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If changes occur in the data that is being monitored before initialization is complete, the constructor must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method before calling the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method.</source>
          <target state="translated">如果在未发生更改之前初始化是正在监视的数据完成，则构造函数必须调用<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph>方法之前调用<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After a derived <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> type is instantiated, you must insert the monitor into a custom <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation.</source>
          <target state="translated">后派生<ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>实例化类型时，你必须插入自定义监视器<ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph>实现。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Or if you are finished using the change monitor, call the <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method.</source>
          <target state="translated">如果要使用更改监视器完毕后，调用或<ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After a <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance is inserted into a <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation, the <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> instance require that the change monitor is disposed.</source>
          <target state="translated">后<ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>实例插入到<ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph>实现，<ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph>实例需要更改监视器已释放。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Even if the insertion is invalid and causes an exception, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation must call the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload.</source>
          <target state="translated">即使插入无效并导致异常，<ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph>实现必须调用<ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>重载。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After a derived change monitor is inserted into a cache, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation must call <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>, by passing a <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> object.</source>
          <target state="translated">派生的更改监视器插入到缓存后,<ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph>实现必须调用<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>，通过传递<ph id="ph3">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method can be called only one time.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>可以调用仅一次的方法。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If a dependency change has already occurred, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called immediately when <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is called.</source>
          <target state="translated">如果已发生了依赖项更改，<ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph>实例将立即调用时<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>调用。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Otherwise, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called only one time.</source>
          <target state="translated">否则为<ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph>实例将会调用一次。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>This one time call occurs either when the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called because the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance detected a change, or when the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called on the <ph id="ph4">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>, whichever occurs first.</source>
          <target state="translated">这一次调用将发生种情况时<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph>调用方法，因为<ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>实例检测到更改，或当<ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>方法调用<ph id="ph4">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>，以先发生者为准。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance that is provided by an <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation should remove the associated cache entry and specify a reason by using the <ph id="ph3">&lt;see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /&gt;</ph> enumeration.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph>由提供的实例<ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph>实现应删除此关联的缓存项，通过使用指定的原因<ph id="ph3">&lt;see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /&gt;</ph>枚举。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance can call the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method either before a cache implementation has called <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method or after.</source>
          <target state="translated">A<ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>实例可以调用<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph>方法之前已调用的缓存实现<ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>方法还是之后。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called before <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is called, the base <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> implementation will notify the cache that this has occurred and will trigger the callback to be passed to <ph id="ph4">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> immediately when <ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is invoked.</source>
          <target state="translated">如果<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph>方法之前调用<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>名为 base<ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>实现将通知发生这种情况的缓存，将触发要传递给回调<ph id="ph4">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>时立即<ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>调用。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Any state data that is passed to the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is saved by the change monitor and subsequently passed to the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method when the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method is invoked.</source>
          <target state="translated">传递给任何状态数据<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph>方法保存的更改监视器并随后传递到<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>方法时<ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A change monitor must implement the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method.</source>
          <target state="translated">更改监视器必须实现<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For more information, see the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method documentation.</source>
          <target state="translated">有关更多信息，请参见 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> 方法文档。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method overload must be called to dispose of the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>必须调用方法重载，若要释放<ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The rules for calling Dispose are as follows:</source>
          <target state="translated">调用 Dispose 的规则如下所示：</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Before an item is inserted into the cache, it is the responsibility of caller to dispose of a <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance.</source>
          <target state="translated">某个项插入缓存之前，它是调用方，若要释放的责任<ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Once cache item and the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instances that are associated with it are passed to a cache, the cache implementer must make sure that that the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called, even if the insert fails.</source>
          <target state="translated">一次缓存项和<ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>与其关联的实例传递到缓存中，缓存实施者必须确保，<ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>调用方法时，即使插入操作失败。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After an item and its associated <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instances are passed to a cache, the caller must not dispose the dependency because when the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called, the call is treated as if the dependency has changed.</source>
          <target state="translated">在将项及其关联<ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>实例传递到缓存中，调用方必须不会释放依赖项，因为当<ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>方法调用，因此调用将被视为依赖项已更改。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>As a result, the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is automatically invoked.</source>
          <target state="translated">因此，<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph>自动调用方法。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Taking these rules into consideration, the <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method must be called in one of the following ways:</source>
          <target state="translated">考虑到，这些规则<ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>必须按以下方式之一调用方法：</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Users must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method overload if they decide not to insert the derived change-monitor instance into a cache.</source>
          <target state="translated">用户必须调用<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>方法重载，如果他们决定不向缓存中插入派生的更改监视器实例。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the implementation tries to insert the change-monitor instance into an object cache but the insertion fails, the cache implementation is responsible for calling the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload.</source>
          <target state="translated">如果实现尝试插入对象缓存的更改监视器实例，但插入失败，缓存实现负责调用<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>重载。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>When the insertion attempt causes an exception, the cache implementation must dispose of any associated dependencies.</source>
          <target state="translated">在插入尝试会导致异常，必须释放任何关联的依赖关系类型的缓存实现。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the cache entry is removed, the cache implementation must also dispose of the dependency.</source>
          <target state="translated">如果删除缓存项，则缓存实现还必须释放依赖项的类型。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The internal implementation of the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method automatically calls the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method after it calls a callback that is registered through <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>.</source>
          <target state="translated">内部实现<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph>方法将自动调用<ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>方法在调用回调，之后注册通过<ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>This automatic call to the dispose method during the event firing only occurs if the initialization of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance was previously completed.</source>
          <target state="translated">自动对在事件激发期间的 dispose 方法调用时才会出现的初始化<ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>以前完成实例。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>When a derived change monitor's constructor calls the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method, if the state of the change monitor has already changed (that is, the state that is monitored already changed when the constructor was still active) then the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method will automatically dispose of the change monitor.</source>
          <target state="translated">当派生的更改监视器的构造函数调用<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph>方法时，如果更改监视器的状态已更改 （构造函数时仍处于活动状态监视已更改状态） 则<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph>方法将自动释放此更改监视器的类型。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /&gt;</ph> property is set to <ph id="ph2">&lt;see langword="true" /&gt;</ph> after the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called by the derived change-monitor instance, regardless of whether a <ph id="ph4">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> object has been set by a call to the <ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method or not.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /&gt;</ph>属性设置为<ph id="ph2">&lt;see langword="true" /&gt;</ph>后<ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph>方法由派生的更改监视器实例，而不管是否调用<ph id="ph4">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph>已通过调用设置对象<ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>方法或不。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>This constructor is called from constructors in derived classes to initialize the base class.</source>
          <target state="translated">从派生类中的构造函数调用此构造函数以初始化基类。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class has a default constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>类具有一个默认构造函数。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>However, classes that inherit from the base <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class and define custom change-monitoring behavior must perform initialization in the constructor.</source>
          <target state="translated">但是，类继承自基类<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>类并定义自定义的更改监视行为必须在构造函数中执行初始化。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>For more information, see the Notes for Inheritors section.</source>
          <target state="translated">有关详细信息，请参阅继承者部分的说明。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>The constructor of a derived class must set the <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph> property, begin monitoring, and call the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> class before it returns.</source>
          <target state="translated">派生类的构造函数必须设置<ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph>属性，开始监视，并调用<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph>类之前它将返回。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>If a dependency changes before initialization is complete (for example, if a dependent cache key is not found in the cache), the constructor must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method before it calls the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method.</source>
          <target state="translated">如果在初始化之前的依赖项发生更改已完成 （例如，如果在缓存中找不到依赖的缓存密钥时），则构造函数必须调用<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph>方法之前调用<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>In this case, constructor can call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method only after the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method is called, because the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method throws an exception if initialization is not completed.</source>
          <target state="translated">在这种情况下，构造函数可以调用<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>方法之后才<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph>调用方法，因为<ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>方法引发异常，如果未完成初始化。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated">释放 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 类的当前实例所使用的所有资源。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is used to release the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance and related resources.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>方法用于释放<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>实例和相关的资源。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The public <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is invoked to coordinate the disposal process with key life-cycle events of derived change-monitor classes (such as initialization), and to release the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance so that the instance can be garbage collected.</source>
          <target state="translated">公共<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>，协调处置流程与密钥生命周期事件的派生的更改监视器类 （如初始化），并释放调用方法<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>实例，使该实例可以作为垃圾回收。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is implemented by derived change-monitor classes to dispose of their managed and unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>方法由实现派生的更改监视器类，若要释放其托管和非托管资源。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Releases all resources that are used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated">释放由 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 类的当前实例占用的所有资源。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method invokes the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method of derived classes only one time, the first time it is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>方法调用<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>派生的类仅一次，第一次调用时的方法。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Subsequent calls to the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method have no effect.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>方法不起任何作用。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>After the method has been called, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A&gt;</ph> property is set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">调用该方法后，<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A&gt;</ph>属性设置为<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> overload must be called to dispose of a <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>必须调用重载，若要释放<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The following are the rules for calling the dispose method:</source>
          <target state="translated">规则调用的 dispose 方法如下：</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Before an item is inserted into the cache, it is the caller's responsibility to dispose of a <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated">某个项插入缓存之前，它是调用方负责释放<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Once cache item and the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instances that are associated with it are passed to a cache, the cache implementer that must make sure that <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> is called, even if the insert fails.</source>
          <target state="translated">一次缓存项和<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>与其关联的实例传递到缓存中，必须确保缓存实施者<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>调用，即使插入操作失败。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>After an item and its associated <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instances are passed to a cache, the caller must not dispose the dependency because when the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is called, the call is treated as if the dependency has changed.</source>
          <target state="translated">在将项及其关联<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>实例传递到缓存中，调用方必须不会释放依赖项，因为当<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>方法调用，因此调用将被视为依赖项已更改。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>As a result, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is automatically invoked.</source>
          <target state="translated">因此，<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph>自动调用方法。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Taking these rules into consideration, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method must be called in one of the following ways:</source>
          <target state="translated">考虑到，这些规则<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>必须按以下方式之一调用方法：</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Users must call the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method overload if they decide not to insert the derived change-monitor instance into a cache.</source>
          <target state="translated">用户必须调用<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>方法重载，如果他们决定不向缓存中插入派生的更改监视器实例。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The cache implementation is responsible for calling the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> overload if the implementation tries to insert the change-monitor instance into an object cache but the insertion fails.</source>
          <target state="translated">缓存实现负责调用<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>重载如果实现尝试插入对象缓存的更改监视器实例，但插入操作将失败。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>When the insertion attempt causes an exception, the cache implementation must dispose any associated dependencies.</source>
          <target state="translated">当插入尝试导致异常时，则缓存实现必须释放任何关联的依赖关系。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>If the cache entry is removed, the cache implementation must also dispose the dependency.</source>
          <target state="translated">如果删除缓存项，则缓存实现还必须释放依赖项。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The internal implementation of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method automatically calls the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method after it calls a callback that is registered through the <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method.</source>
          <target state="translated">内部实现<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph>方法将自动调用<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>方法在调用回调，之后注册通过<ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>This automatic dispose during the event firing only occurs if the initialization of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance previously completed.</source>
          <target state="translated">在事件激发期间此自动释放时，才出现的初始化<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>以前完成的实例。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>When a derived change monitor's constructor calls the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> method, if the state of the change monitor has already changed (that is, the state that is monitored has already changed when the constructor was still active) then <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> method will automatically dispose the change monitor.</source>
          <target state="translated">当派生的更改监视器的构造函数调用<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph>方法时，如果更改监视器的状态已更改 （即，将监视的状态已更改构造函数时仍处于活动状态） 然后<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph>方法将自动释放更改监视器。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Users should not call the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">用户不应调用<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>However, you cannot prevent users from calling the method.</source>
          <target state="translated">但是，不能防止用户调用方法。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Therefore, if they do, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is invoked.</source>
          <target state="translated">因此，如果他们这样做，<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>In that case, the cache entry is notified as if the dependency has changed.</source>
          <target state="translated">在这种情况下，就像依赖项已更改，都会收到通知的缓存项。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>To prevent derived classes from overriding <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method, the method is not an explicit interface implementation.</source>
          <target state="translated">若要防止派生的类重写<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>方法，该方法不是显式接口实现。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Initialization is not complete in the derived change-monitor class that called the base <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method.</source>
          <target state="translated">在调用 <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> 基方法的派生更改监视器类中，初始化未完成。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release managed and unmanaged resources and any references to a <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance; <ph id="ph3">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated">若要释放托管资源和非托管资源，以及对 <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 实例的任何引用，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；若要仅释放非托管资源，则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>When <ph id="ph1">&lt;see langword="false" /&gt;</ph> is passed, the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method is called by a <ph id="ph3">&lt;see langword="finalizer" /&gt;</ph> thread and any external managed references are likely no longer valid because they have already been garbage collected.</source>
          <target state="translated">传递 <ph id="ph1">&lt;see langword="false" /&gt;</ph> 时，<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> 方法由 <ph id="ph3">&lt;see langword="finalizer" /&gt;</ph> 线程调用，所有外部托管引用由于已经作为垃圾回收，因此可能不再有效。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>Releases all managed and unmanaged resources and any references to the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance.</source>
          <target state="translated">释放所有托管资源和非托管资源，以及对 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 实例的任何引用。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>This overload must be implemented by derived change-monitor classes.</source>
          <target state="translated">此重载必须由派生的更改监视器类实现。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>When the value of <ph id="ph1">`disposing`</ph> value is <ph id="ph2">`true`</ph>, all managed and unmanaged resources are disposed and any references to this object are released so that the derived change-monitor instance can be garbage collected.</source>
          <target state="translated">时的值<ph id="ph1">`disposing`</ph>值是<ph id="ph2">`true`</ph>，释放所有的托管和非托管资源，并且对此对象的任何引用都释放，以便派生的更改监视器实例可以被垃圾回收。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>It is guaranteed that the base <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method will invoke the implemented <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method only one time.</source>
          <target state="translated">这样就保证基<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>方法将调用实现<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>方法仅一次。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>A change monitor must implement the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> overload to release all managed and unmanaged resources when the value of <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">更改监视器必须实现<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph>重载以释放所有托管和非托管资源时的值<ph id="ph2">&lt;paramref name="disposing" /&gt;</ph>是<ph id="ph3">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method overload that has a <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> value of <ph id="ph3">&lt;see langword="true" /&gt;</ph> is called only one time, namely, when the instance is disposed for the first time.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph>具有方法重载<ph id="ph2">&lt;paramref name="disposing" /&gt;</ph>值<ph id="ph3">&lt;see langword="true" /&gt;</ph>只调用一次，即，当第一次释放实例时。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>A change monitor must not call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> overload directly.</source>
          <target state="translated">更改监视器不能调用<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph>直接重载。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>A derived change monitor can call the public parameter-less <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method on the base <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated">派生的更改监视器可以调用公共参数的<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>方法对基础<ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>Alternatively, a change monitor can implement a finalizer method.</source>
          <target state="translated">或者，更改监视器可以实现终结器方法。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>In that case, the finalizer can invoke the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method and pass it a <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> value of <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">在这种情况下，可以调用终结器<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph>方法并将其传递<ph id="ph2">&lt;paramref name="disposing" /&gt;</ph>值<ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>However, this is usually unnecessary.</source>
          <target state="translated">但是，这是通常不必要的。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>Monitoring for dependency changes is typically performed by a service that maintains a reference to the change-monitor instance.</source>
          <target state="translated">通常，由保留的更改监视器实例的引用的服务执行对依赖项更改的监视。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>The reference prevents the instance from being garbage collected, and therefore makes a finalizer method unnecessary.</source>
          <target state="translated">引用避免被垃圾回收，该实例，因此不必要的终结器方法。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>To avoid memory leaks, when a dependency changes, the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method disposes the change-monitor instance (unless initialization has not finished).</source>
          <target state="translated">若要在一个依赖项更改时, 避免内存泄露，<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph>方法释放更改监视器实例 （除非初始化尚未完成）。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>Gets a value that indicates that the state that is monitored by the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class has changed.</source>
          <target state="translated">获取一个值，该值指示由 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 类监视的状态已发生更改。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the state that is monitored by the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance has changed; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果由 <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 实例监视的状态已发生更改，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>You can check the value of this property in a derived <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class to see whether a dependency has changed.</source>
          <target state="translated">你可以检查在派生的此属性的值<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>类，以查看是否已更改依赖项。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>The value is set to <ph id="ph1">`true`</ph> when a dependency change occurs (that is, when the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called).</source>
          <target state="translated">值设置为<ph id="ph1">`true`</ph>依赖项更改发生时 (即，当<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph>调用方法)。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>After the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called by the derived class, the value of the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property will be <ph id="ph3">`true`</ph>, regardless of whether a <ph id="ph4">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> instance has been notified by a call to the <ph id="ph5">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method.</source>
          <target state="translated">后<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph>方法由派生类的值调用<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph>属性将为<ph id="ph3">`true`</ph>，无论<ph id="ph4">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph>已通过调用通知实例<ph id="ph5">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>Callers can check the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property to see whether a dependency has changed.</source>
          <target state="translated">调用方可以检查<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph>属性以查看是否已更改依赖项。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>However, in a multi-threaded environment, a simpler and more maintainable approach is to insert data into a cache implementation without checking the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property.</source>
          <target state="translated">但是，在多线程环境中，更简单且更易于维护的方法是将数据插入的缓存实现，而不会检查<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>Cache implementations must check the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property for you and must not perform an insert or set operation if one or more associated dependencies have already changed.</source>
          <target state="translated">缓存实现必须检查<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph>为你的属性和必须不执行 insert 或设置操作，如果一个或多个关联的依赖关系已更改。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>Called from the constructor of derived classes to indicate that initialization is finished.</source>
          <target state="translated">从派生类的构造函数进行调用以指示初始化已完成。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>If a dependency changes before initialization is complete in a derived class, the constructor of the derived class must invoke the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method.</source>
          <target state="translated">如果一个依赖项更改之前初始化已完成在派生类，派生类的构造函数必须调用<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>When the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is invoked, the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property is automatically set to <ph id="ph3">`true`</ph> by the change monitor.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph>调用方法时，<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph>属性自动设置为<ph id="ph3">`true`</ph>更改监视器。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>As a result, when the change monitor's constructor calls the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> method, the base class will automatically call the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">因此，当更改监视器的构造函数调用<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph>方法时，将自动调用基类<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>If initialization is complete, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method automatically disposes the derived change-monitor instance.</source>
          <target state="translated">如果初始化已完成，<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph>方法自动释放派生的更改监视器实例。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>The constructor of a derived class must call the base <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method before the constructor returns.</source>
          <target state="translated">派生类的构造函数必须调用基<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph>构造函数将返回之前的方法。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>The constructor of a derived class can call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method only after <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> is called, because the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method throws an exception if initialization is not completed.</source>
          <target state="translated">派生类的构造函数可以调用<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>方法之后才<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph>调用，因为<ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>方法引发异常，如果未完成初始化。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="P:System.Runtime.Caching.ChangeMonitor.IsDisposed">
          <source>Gets a value that indicates that the derived instance of a <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class is disposed.</source>
          <target state="translated">获取一个值，该值指示释放 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 类的派生实例。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.IsDisposed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the instance is disposed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果释放该实例，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.IsDisposed">
          <source>The property is set to <ph id="ph1">`true`</ph> after the base <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method calls the <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method in a derived class to dispose of the instance.</source>
          <target state="translated">属性设置为<ph id="ph1">`true`</ph>后基<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>方法调用<ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph>派生的类，若要释放的实例中的方法。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>A reference to a method that is invoked when a dependency has changed.</source>
          <target state="translated">对在某个依赖项更改时要调用的方法的引用。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Called by Cache implementers to register a callback and notify an <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> instance through the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> delegate when a dependency has changed.</source>
          <target state="translated">由缓存实施者调用来注册回调，并在某个依赖项已更改时通过 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> 委托通知 <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> 实例。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Cache implementers use this method to wire themselves up to a change monitor.</source>
          <target state="translated">缓存实施者使用此方法连接到的更改监视器。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If you associate one or more change monitors with the cache item, you pass a <ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy&gt;</ph> instance with a populated change monitors property to the cache item.</source>
          <target state="translated">如果你将一个或多个更改与缓存项的监视器，则传递<ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy&gt;</ph>具有的针对缓存项的填充的更改监视器属性实例。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>A cache implementer that supports change monitors is responsible for iterating over the <ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A&gt;</ph> property and register the <ph id="ph2">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> delegates with each change monitor that it finds.</source>
          <target state="translated">支持更改监视器缓存实施者负责遍历<ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A&gt;</ph>属性和寄存器<ph id="ph2">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph>委托与每个更改它找到的监视器。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Because the <ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> delegate includes an optional state parameter, a concrete change monitor implementation can pass optional state information.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph>委托包括可选状态参数，则具体更改监视器实现可以传递可选状态信息。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The cache implementer determines whether an explicit dependency on the type of state that a custom change monitor passes as part of the callback can be taken.</source>
          <target state="translated">缓存实施者确定是否可将显式依赖类型的回调的一部分传递的自定义更改监视器的状态。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The base cache extensibility API has no requirement for explicit dependency on the type of state.</source>
          <target state="translated">基缓存可扩展性 API 将显式依赖项，不要求对类型的状态。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The implementation of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method automatically determines whether the state of the monitor has already changed at the time <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method is called.</source>
          <target state="translated">实现<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph>方法自动确定监视器的状态是否已更改时<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property is <ph id="ph2">`true`</ph>, then the method automatically calls the <ph id="ph3">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> event handler, that was registered, through the <ph id="ph4">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph>属性是<ph id="ph2">`true`</ph>，则该方法会自动调用<ph id="ph3">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph>事件处理程序中，已注册，通过<ph id="ph4">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>This occurs because it is possible that from the time a cache implementation creates a change monitor, to the time a cache implementation gets the monitor and wires itself up to it, the underlying monitored state has changed.</source>
          <target state="translated">发生这种情况是因为它是可能，从缓存实现创建的更改监视器，缓存实现获取监视器和最多，线本身的时间的时间的基础的监视的状态已更改。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If the state has already changed then the object that is passed to the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">如果状态已更改的对象传递给<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph>方法是<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method can be invoked only one time, and will throw an exception on subsequent calls.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph>方法可以调用仅一次，并将在后续调用中引发异常。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The callback method has already been invoked.</source>
          <target state="translated">已调用回调方法。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source><ph id="ph1">&lt;paramref name="onChangedCallback" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="onChangedCallback" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>You must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method to be notified of any dependency changes.</source>
          <target state="translated">必须调用<ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>方法的任何依赖项更改的通知。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If a dependency change has already occurred, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called when <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is called.</source>
          <target state="translated">如果已发生了依赖项更改，<ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph>实例时将会调用<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>调用。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Otherwise, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called one time, either when the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called or when the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called, whichever occurs first.</source>
          <target state="translated">否则为<ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph>实例将会调用一次时<ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph>调用方法时，或者当<ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph>调用方法，以先发生者为准。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance provided by the cache implementation should remove the cache entry and if it is requested by the cache caller, raise the necessary change or update event back to the original cache caller.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph>提供缓存实现实例应删除缓存项，如果请求的缓存调用方，则引发必要的更改或更新事件，回退到原始缓存调用方。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The object cache implementation must remove the cache entry that is associated with a dependency change.</source>
          <target state="translated">对象缓存实现必须删除与依赖关系更改相关联的缓存项。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>The data for the change event.</source>
          <target state="translated">更改事件的数据。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>This value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">此值可为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>Called by derived classes to raise the event when a dependency changes.</source>
          <target state="translated">由派生类调用以在某个依赖项发生更改时引发事件。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>Typically, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called when dependency changes occur.</source>
          <target state="translated">通常情况下，<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph>发生依赖项更改时调用方法。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is also invoked when a change-monitor instance is disposed but the disposal occurs only if the callback has not already been invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph>释放更改监视器实例，但仅当尚未调用回调时，才会发生释放时也会调用方法。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called before the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method is called, the state data from the call to the <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is saved by the cache implementation.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph>方法之前调用<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph>调用方法时，调用的状态数据<ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph>方法保存的缓存实现。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>Also, the callback to the <ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> method is invoked immediately when the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method is invoked.</source>
          <target state="translated">此外，到回调<ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph>立即调用方法时<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>Gets a value that represents the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class instance.</source>
          <target state="translated">获取一个表示 <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> 类实例的值。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The identifier for a change-monitor instance.</source>
          <target state="translated">某个更改监视器实例的标识符。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph> property value typically consists of dependency names combined string data that uniquely identifiers the data that is being monitored by a <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph>属性值通常包括依赖关系名称组合字符串数据的唯一标识符的数据的所监视的<ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The value of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph> property is a string.</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph>属性是一个字符串。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The value of the string is used to assign the unique ID of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated">字符串的值用于分配的唯一 ID<ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>By overriding the property, you can define a custom implementation for the string value of the property in order to assign it a unique ID.</source>
          <target state="translated">通过重写属性，可以定义的属性的字符串值的自定义实现，以便将其分配唯一 id。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>In derived classes, you must set the value of the property in the constructor.</source>
          <target state="translated">在派生类中，必须在构造函数中设置属性的值。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>