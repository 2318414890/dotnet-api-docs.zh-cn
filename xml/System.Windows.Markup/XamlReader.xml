<Type Name="XamlReader" FullName="System.Windows.Markup.XamlReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="eb09b92c85f6899f8f0386e85d5fda59b541d871" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39361136" /></Metadata><TypeSignature Language="C#" Value="public class XamlReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlReader extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.XamlReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlReader" />
  <TypeSignature Language="F#" Value="type XamlReader = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="47e24-101">使用 WPF 默认 XAML 读取器和关联的 XAML 对象编写器读取 XAML 输入并创建对象图。</span><span class="sxs-lookup"><span data-stu-id="47e24-101">Reads XAML input and creates an object graph, using the WPF default XAML reader and an associated XAML object writer.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="47e24-102">同步<xref:System.Windows.Markup.XamlReader.Load%2A>方法是静态的但异步<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>方法不是静态的需要的实例<xref:System.Windows.Markup.XamlReader>类使用。</span><span class="sxs-lookup"><span data-stu-id="47e24-102">The synchronous <xref:System.Windows.Markup.XamlReader.Load%2A> methods are static, but the asynchronous <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> methods are not static and require an instance of the <xref:System.Windows.Markup.XamlReader> class to use.</span></span>  
  
 <span data-ttu-id="47e24-103">输出`Load`方法是单个对象，该对象表示创建的对象树或对象图的根对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-103">The output of the `Load` methods is a single object, which represents the root object of a created object tree or object graph.</span></span> <span data-ttu-id="47e24-104">对象图创建的<xref:System.Windows.Markup.XamlReader>通常添加到现有的 WPF 应用程序在运行时对象树。</span><span class="sxs-lookup"><span data-stu-id="47e24-104">Object graphs that are created by <xref:System.Windows.Markup.XamlReader> are typically added to the existing object tree of a WPF application at run time.</span></span> <span data-ttu-id="47e24-105">否则新的对象关系图被视为 WPF 应用程序模型而断开连接。</span><span class="sxs-lookup"><span data-stu-id="47e24-105">Otherwise the new object graph is considered disconnected for purposes of the WPF application model.</span></span> <span data-ttu-id="47e24-106">也就是说，不会呈现，并且不能访问使用任何对象树的技术为应用于 WPF 应用程序的主对象树 (例如，Api <xref:System.Windows.FrameworkElement.FindName%2A>， <xref:System.Windows.LogicalTreeHelper>， <xref:System.Windows.Media.VisualTreeHelper>)。</span><span class="sxs-lookup"><span data-stu-id="47e24-106">This means that it does not render, and cannot be accessed using any of the object tree techniques as applied to the WPF application's main object tree (for example, the APIs <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>).</span></span> <span data-ttu-id="47e24-107">在对象树概念的详细信息，请参阅[WPF 中的树](~/docs/framework/wpf/advanced/trees-in-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="47e24-107">For more information on object tree concepts, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 <span data-ttu-id="47e24-108"><xref:System.Windows.Markup.XamlReader> 支持以下主要方案：</span><span class="sxs-lookup"><span data-stu-id="47e24-108"><xref:System.Windows.Markup.XamlReader> supports the following primary scenarios:</span></span>  
  
-   <span data-ttu-id="47e24-109">**克隆对象工厂**： 如果没有其他机制，引用类型通常不能包含在 WPF 对象树中的多个位置中。</span><span class="sxs-lookup"><span data-stu-id="47e24-109">**Cloning/object factory**: Without additional mechanisms, a reference type generally cannot be included in more than one position in a WPF object tree.</span></span> <span data-ttu-id="47e24-110">(提供对共享的支持或重复使用在 WPF 中的其他机制的示例包括基于的对象<xref:System.Windows.Freezable>，或如支持通常可共享的对象<xref:System.Windows.Media.Brush>中的项作为引用的<xref:System.Windows.ResourceDictionary>。)一种方法要克隆的对象已存在于对象树是序列化对象使用<xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="47e24-110">(Examples of additional mechanisms that offer support for sharing or re-use in WPF include objects that are based on <xref:System.Windows.Freezable>, or support for commonly shareable objects such as <xref:System.Windows.Media.Brush> that are referenced as an item from a <xref:System.Windows.ResourceDictionary>.) One way to clone an object that is already in the object tree is to serialize the object using <xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="47e24-111">然后，使用序列化的字符串作为输入调用<xref:System.Windows.Markup.XamlReader.Load%2A>，并将流或<xref:System.Xml.XmlReader>作为中介。</span><span class="sxs-lookup"><span data-stu-id="47e24-111">You then use the serialized string as input for a call to <xref:System.Windows.Markup.XamlReader.Load%2A>, with a stream or <xref:System.Xml.XmlReader> as an intermediary.</span></span>  
  
-   <span data-ttu-id="47e24-112">**构造对象基于中实时信息**： 通常有其他方法来使用后期绑定或用户提供的输入来更改现有对象的状态。</span><span class="sxs-lookup"><span data-stu-id="47e24-112">**Constructing objects based on just-in-time information**: There are often other ways to have late-binding or user-supplied input change the state of existing objects.</span></span> <span data-ttu-id="47e24-113">例如可以使用相同的值来设置多个属性，或使用数据绑定。</span><span class="sxs-lookup"><span data-stu-id="47e24-113">For example you could use the same value to set more than one property, or use data binding.</span></span> <span data-ttu-id="47e24-114">如果有其中甚至要创建的对象类型或时，才可确定在运行时与用户交互的解决方案，然后创建此类对象通过构建为一个字符串，但<xref:System.Windows.Markup.XamlReader.Load%2A>输入通常是有用的技术。</span><span class="sxs-lookup"><span data-stu-id="47e24-114">But if you have a scenario where even the type of object to create is only determinable at run time or with user interaction, then creating such an object by building up a string for <xref:System.Windows.Markup.XamlReader.Load%2A> input is often a useful technique.</span></span>  
  
-   <span data-ttu-id="47e24-115">**使用现有资源技术**:<xref:System.IO.Stream>类型通常在中使用其他框架或技术用于跨应用程序边界传输数据或对象或类似的情况。</span><span class="sxs-lookup"><span data-stu-id="47e24-115">**Using existing resource techniques**: The <xref:System.IO.Stream> type is used frequently in other frameworks or technologies for transferring data or objects across application boundaries or for similar situations.</span></span> <span data-ttu-id="47e24-116">然后，可以使用<xref:System.IO.Stream>技术来存储或获取最终用来创建你的应用程序的一部分的对象的 XAML 格式的数据。</span><span class="sxs-lookup"><span data-stu-id="47e24-116">You can then use the <xref:System.IO.Stream> techniques to store or obtain XAML-formatted data that you eventually use to create an object as part of your application.</span></span>  
  
-   <span data-ttu-id="47e24-117">**固定文档：** 你的应用程序可能会加载包含在 WPF 应用程序对象树和 UI 中的本地或下载的 XPS 文档。</span><span class="sxs-lookup"><span data-stu-id="47e24-117">**Fixed documents:** Your application might load local or downloaded XPS documents for inclusion in a WPF application object tree and UI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="47e24-118">有时，此文档介绍了对象关系图，而不是对象树。</span><span class="sxs-lookup"><span data-stu-id="47e24-118">This documentation sometimes describes an object graph, as opposed to an object tree.</span></span> <span data-ttu-id="47e24-119">严格的父-子关系不始终存在运行的时 WPF 应用程序，在运行的时对象关系中，因此对象关系图是更广泛适用的术语。</span><span class="sxs-lookup"><span data-stu-id="47e24-119">A strict parent-child relationship does not always exist in the run time object relationships of a run time WPF application, so an object graph is a more widely applicable terminology.</span></span> <span data-ttu-id="47e24-120">但是，因为 WPF 还包括两个不同的树概念化 Api (<xref:System.Windows.LogicalTreeHelper>， <xref:System.Windows.Media.VisualTreeHelper>) 树来比喻仍充分地应用到 WPF 中的大多数实际情况下。</span><span class="sxs-lookup"><span data-stu-id="47e24-120">However, because WPF also includes two different tree conceptualization APIs (<xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>) the tree metaphor still applies adequately to most real-world cases in WPF.</span></span> <span data-ttu-id="47e24-121">从 XAML 语言角度来看，对象图但通常最好考虑创建对象的方式从 XAML，由于 XAML 语言本身不一定是指定将关系的详细信息的帮助器类方法到再次树状结构。</span><span class="sxs-lookup"><span data-stu-id="47e24-121">From the XAML language perspective however, the object graph is often the best way to think about how objects are created out of XAML, because the XAML language itself does not necessarily specify helper class methodologies that bring the relationships more into a tree structure again.</span></span>  
  
## <a name="code-access-security-loose-xaml-and-xamlreader"></a><span data-ttu-id="47e24-122">代码访问安全性、 松散 XAML 和 XamlReader</span><span class="sxs-lookup"><span data-stu-id="47e24-122">Code Access Security, Loose XAML, and XamlReader</span></span>  
 <span data-ttu-id="47e24-123">XAML 是一种直接表示对象实例化和执行的标记语言。</span><span class="sxs-lookup"><span data-stu-id="47e24-123">XAML is a markup language that directly represents object instantiation and execution.</span></span> <span data-ttu-id="47e24-124">因此，在 XAML 中创建的元素能够像等效的生成代码那样与系统资源（如网络访问、文件系统 IO）进行交互。</span><span class="sxs-lookup"><span data-stu-id="47e24-124">Therefore, elements created in XAML have the same ability to interact with system resources (network access, file system IO, for example) as the equivalent generated code does.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="47e24-125">支持[!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)]安全框架[!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="47e24-125">supports the [!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)] security framework [!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)].</span></span> <span data-ttu-id="47e24-126">这意味着在 Internet 区域中运行的 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 内容具有缩减的执行权限。</span><span class="sxs-lookup"><span data-stu-id="47e24-126">This means that [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] content running in the internet zone has reduced execution permissions.</span></span> <span data-ttu-id="47e24-127">“宽松型 XAML”（由 XAML 查看器在加载时解释的非编译 XAML 的页面）和 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] 通常在此 Internet 区域中运行，并且使用相同的权限集。</span><span class="sxs-lookup"><span data-stu-id="47e24-127">"Loose XAML" (pages of noncompiled XAML interpreted at load time by a XAML viewer) and [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] are usually run in this internet zone and use the same permission set.</span></span>  <span data-ttu-id="47e24-128">但是，加载到完全受信任的应用程序中的 XAML 与承载应用程序具有相同的系统资源访问权限。</span><span class="sxs-lookup"><span data-stu-id="47e24-128">However, XAML loaded in to a fully trusted application has the same access to the system resources as the hosting application does.</span></span> <span data-ttu-id="47e24-129">有关详细信息，请参阅 [WPF 部分信任安全性](~/docs/framework/wpf/wpf-partial-trust-security.md)。</span><span class="sxs-lookup"><span data-stu-id="47e24-129">For more information, see [WPF Partial Trust Security](~/docs/framework/wpf/wpf-partial-trust-security.md).</span></span>  
  
 <span data-ttu-id="47e24-130">有关这些语句的影响<xref:System.Windows.Markup.XamlReader>是应用程序设计必须使您决定要加载 XAML 的信任决定。</span><span class="sxs-lookup"><span data-stu-id="47e24-130">The implications of these statements for <xref:System.Windows.Markup.XamlReader> is that your application design must make trust decisions about the XAML you decide to load.</span></span> <span data-ttu-id="47e24-131">如果你加载不受信任的 XAML 中，请考虑实施您自己的沙盒技术来加载生成的对象图的方式。</span><span class="sxs-lookup"><span data-stu-id="47e24-131">If you are loading XAML that is not trusted, consider implementing your own sandboxing technique for how you load the resulting object graph.</span></span>  
  
 <span data-ttu-id="47e24-132"><xref:System.Windows.Markup.XamlReader> 此外可以由部分受信任代码调用。</span><span class="sxs-lookup"><span data-stu-id="47e24-132"><xref:System.Windows.Markup.XamlReader> can also be called by partial trust code.</span></span> <span data-ttu-id="47e24-133">在这种情况下，Internet 安全区域被应用于代码访问安全性。</span><span class="sxs-lookup"><span data-stu-id="47e24-133">In this case, Internet security zone is applied for code access security.</span></span> <span data-ttu-id="47e24-134">如果加载的 XAML 中的任何内容无效 Internet 安全区域下，XAML 分析异常引发。</span><span class="sxs-lookup"><span data-stu-id="47e24-134">If anything in the loaded XAML is invalid under Internet security zone, a XAML parse exception is thrown.</span></span> <span data-ttu-id="47e24-135">XBAP 和部分信任级别的平台的其他情况下下其中<xref:System.Windows.Markup.XamlReader>属于与显式部分信任的调用的执行，获取相同的异常行为。</span><span class="sxs-lookup"><span data-stu-id="47e24-135">Under XBAP and other cases that are partial trust at the platform level, where <xref:System.Windows.Markup.XamlReader> is part of the execution, you get the same exception behavior as with explicit partial trust calls.</span></span>  
  
## <a name="wpf-xaml-xaml-readerswriters-and-xaml-language-versioning"></a><span data-ttu-id="47e24-136">WPF XAML、 XAML 读取器/编写器和 XAML 语言版本控制</span><span class="sxs-lookup"><span data-stu-id="47e24-136">WPF XAML, XAML Readers/Writers, and XAML Language Versioning</span></span>  
 <span data-ttu-id="47e24-137">XAML2009 包括语言功能，如[X:reference](~/docs/framework/xaml-services/x-reference-markup-extension.md)并[X:factorymethod](~/docs/framework/xaml-services/x-factorymethod-directive.md)。</span><span class="sxs-lookup"><span data-stu-id="47e24-137">XAML2009 includes language features such as [x:Reference](~/docs/framework/xaml-services/x-reference-markup-extension.md) and [x:FactoryMethod](~/docs/framework/xaml-services/x-factorymethod-directive.md).</span></span> <span data-ttu-id="47e24-138">你可以使用的签名`Load`或`Parse`加载使用这些功能的 XAML。</span><span class="sxs-lookup"><span data-stu-id="47e24-138">You can use signatures of `Load` or `Parse` to load XAML that uses these features.</span></span> <span data-ttu-id="47e24-139">但是，这些语言功能不支持需要标记编译的 XAML (例如为 XAML**页**生成 WPF 应用程序或标记编译任务在生成操作中的涉及到任何 XAML 中的操作)。</span><span class="sxs-lookup"><span data-stu-id="47e24-139">However, those language features are not supported for XAML that needs to be markup compiled (such as XAML for the **Page** build action in a WPF application, or any XAML that involves the markup compile task in the build actions).</span></span>  
  
 <span data-ttu-id="47e24-140">WPF 类型和 WPF 技术在一般情况下支持依赖于使用 WPF 内部结构的概念。</span><span class="sxs-lookup"><span data-stu-id="47e24-140">WPF types and the WPF technology in general support concepts that rely on access to WPF internals.</span></span> <span data-ttu-id="47e24-141">例如，WPF 如何实现依赖关系属性依赖于有效的类型成员查找的内部方法。</span><span class="sxs-lookup"><span data-stu-id="47e24-141">For instance, how WPF implements dependency properties relies on internal techniques for efficient type-member lookup.</span></span> <span data-ttu-id="47e24-142">XAML 读取和写入中提供的 Api 支持访问这些内部<xref:System.Windows.Markup.XamlWriter>并<xref:System.Windows.Markup.XamlReader>从<xref:System.Windows.Markup>命名空间和 PresentationFramework 程序集中。</span><span class="sxs-lookup"><span data-stu-id="47e24-142">Access to these internals is enabled by the XAML reading and writing APIs provided in <xref:System.Windows.Markup.XamlWriter> and <xref:System.Windows.Markup.XamlReader> from the <xref:System.Windows.Markup> namespace and PresentationFramework assembly.</span></span> <span data-ttu-id="47e24-143">但是，较低级别 XAML 读取器和 XAML 编写器从 System.Xaml 程序集 (类基于<xref:System.Xaml.XamlReader?displayProperty=nameWithType>， <xref:System.Xaml.XamlWriter?displayProperty=nameWithType>) 不能访问到 WPF 内部结构。</span><span class="sxs-lookup"><span data-stu-id="47e24-143">However, the lower-level XAML readers and XAML writers from the System.Xaml assembly (classes based on <xref:System.Xaml.XamlReader?displayProperty=nameWithType>, <xref:System.Xaml.XamlWriter?displayProperty=nameWithType>) do not have access to the WPF internals.</span></span> <span data-ttu-id="47e24-144">对任何特定于 WPF 程序集没有依赖项从 System.Xaml。</span><span class="sxs-lookup"><span data-stu-id="47e24-144">There is no dependency from System.Xaml to any WPF-specific assembly.</span></span> <span data-ttu-id="47e24-145">如果不访问 WPF 内部机制，System.Xaml 阅读器和编写器无法正确加载或保存所有 WPF 类型基于 WPF 类型。</span><span class="sxs-lookup"><span data-stu-id="47e24-145">Without access to the WPF internals, System.Xaml readers and writers cannot correctly load or save all WPF types, or types based on WPF types.</span></span> <span data-ttu-id="47e24-146">具体而言，System.Xaml 阅读器和编写器不了解概念，如 WPF 依赖属性支持属性存储区或 WPF 如何使用样式、 资源字典和模板的所有的具体信息。</span><span class="sxs-lookup"><span data-stu-id="47e24-146">In particular, the System.Xaml readers and writers do not understand concepts such as the WPF dependency property backing property store, or all the specifics of how WPF uses styles, resource dictionaries and templates.</span></span> <span data-ttu-id="47e24-147">因此，您可以选择进行：</span><span class="sxs-lookup"><span data-stu-id="47e24-147">Therefore you have a choice to make:</span></span>  
  
-   <span data-ttu-id="47e24-148">如果您正在加载 WPF 类型和/或以任何方式的 BAML 形式使用 XAML，使用 PresentationFramework XAML 读取器和 XAML 编写器。</span><span class="sxs-lookup"><span data-stu-id="47e24-148">If you are loading WPF types, and/or you are using XAML in BAML form in any way, use the PresentationFramework XAML readers and XAML writers.</span></span>  
  
-   <span data-ttu-id="47e24-149">如果您不依赖于任何 WPF 类型也的 BAML 形式的 XAML，并为特定于该框架的原因而未使用另一种特定技术的 XAML 读取器或 XAML 编写器实现，使用 System.Xaml XAML 读取器和 XAML 编写器。</span><span class="sxs-lookup"><span data-stu-id="47e24-149">If you are not relying on any WPF types or the BAML form of XAML, and are not using another specific technology's XAML reader or XAML writer implementation for reasons that are specific to that framework, use the System.Xaml XAML readers and XAML writers.</span></span>  
  
## <a name="systemxaml-backing-implementation-in-net-4"></a><span data-ttu-id="47e24-150">System.Xaml 支持.NET 4 中的实现</span><span class="sxs-lookup"><span data-stu-id="47e24-150">System.Xaml Backing Implementation in .NET 4</span></span>  
 <span data-ttu-id="47e24-151"><xref:System.Windows.Markup.XamlReader> 是 WPF 框架级 XAML 分析器可调用的 API 图面。</span><span class="sxs-lookup"><span data-stu-id="47e24-151"><xref:System.Windows.Markup.XamlReader> is the callable API surface for the WPF framework-level XAML parser.</span></span> <span data-ttu-id="47e24-152">相同的基础 XAML 分析器还执行运行时 XAML 加载和分析的 WPF 应用程序面向[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]和[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="47e24-152">The same underlying XAML parser also performs the run-time XAML loading and parsing for WPF applications that target [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] and [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)].</span></span>  
  
 <span data-ttu-id="47e24-153">如果你正面向[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，外部 API 是相同的但实现的部分基于[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]在 System.Xaml 程序集中，这将提高许多分析 XAML 的技术和报告方面的常规 XAML 实现。</span><span class="sxs-lookup"><span data-stu-id="47e24-153">If you are targeting [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the external API is the same, but parts of the implementation are built on the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] general XAML implementation in the System.Xaml assembly, which improves many of the technical and reporting aspects of parsing XAML.</span></span> <span data-ttu-id="47e24-154">面向[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]一定需要包括 System.Xaml 作为一个引用和实现的详细信息，如报告异常可能来自 System.Xaml 定义的类型。</span><span class="sxs-lookup"><span data-stu-id="47e24-154">Targeting [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] necessarily entails including System.Xaml as a reference, and details of implementation such as the exceptions reported may come from System.Xaml defined types.</span></span>  
  
## Examples  
 <span data-ttu-id="47e24-155">以下示例将转换<xref:System.Windows.Controls.Button>为字符串，并使用<xref:System.Windows.Markup.XamlWriter>类。</span><span class="sxs-lookup"><span data-stu-id="47e24-155">The following example converts a <xref:System.Windows.Controls.Button> into a string using the <xref:System.Windows.Markup.XamlWriter> class.</span></span>  <span data-ttu-id="47e24-156">字符串随后被加载回<xref:System.Windows.Controls.Button>使用静态<xref:System.Windows.Markup.XamlReader.Load%2A>方法<xref:System.Windows.Markup.XamlReader>类。</span><span class="sxs-lookup"><span data-stu-id="47e24-156">The string is then loaded back into a <xref:System.Windows.Controls.Button> using the static <xref:System.Windows.Markup.XamlReader.Load%2A> method on the <xref:System.Windows.Markup.XamlReader> class.</span></span>  
  
 [!code-csharp[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.XamlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="47e24-157">初始化 <see cref="T:System.Windows.Markup.XamlReader" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="47e24-157">Initializes a new instance of the <see cref="T:System.Windows.Markup.XamlReader" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="xamlReader.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="47e24-158">如果有挂起的异步加载操作，则中止当前的异步加载操作。</span><span class="sxs-lookup"><span data-stu-id="47e24-158">Aborts the current asynchronous load operation, if there is an asynchronous load operation pending.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="47e24-159"><xref:System.Windows.Markup.XamlReader.CancelAsync%2A> 是一个异步操作;因此，中止此操作之前，可能会出现一些加载。</span><span class="sxs-lookup"><span data-stu-id="47e24-159"><xref:System.Windows.Markup.XamlReader.CancelAsync%2A> is an asynchronous operation; therefore, some loading may occur before the operation is aborted.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWpfSchemaContext">
      <MemberSignature Language="C#" Value="public static System.Xaml.XamlSchemaContext GetWpfSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xaml.XamlSchemaContext GetWpfSchemaContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetWpfSchemaContext () As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xaml::XamlSchemaContext ^ GetWpfSchemaContext();" />
      <MemberSignature Language="F#" Value="static member GetWpfSchemaContext : unit -&gt; System.Xaml.XamlSchemaContext" Usage="System.Windows.Markup.XamlReader.GetWpfSchemaContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="47e24-160">返回一个 <see cref="T:System.Xaml.XamlSchemaContext" /> 对象，该对象表示 <see cref="T:System.Windows.Markup.XamlReader" /> 的 WPF 架构上下文设置。</span><span class="sxs-lookup"><span data-stu-id="47e24-160">Returns a <see cref="T:System.Xaml.XamlSchemaContext" /> object that represents the WPF schema context settings for a <see cref="T:System.Windows.Markup.XamlReader" />.</span></span></summary>
        <returns><span data-ttu-id="47e24-161">一个 <see cref="T:System.Xaml.XamlSchemaContext" /> 对象，该对象表示 <see cref="T:System.Windows.Markup.XamlReader" /> 的 WPF 架构上下文设置。</span><span class="sxs-lookup"><span data-stu-id="47e24-161">A <see cref="T:System.Xaml.XamlSchemaContext" /> object that represents the WPF schema context settings for a <see cref="T:System.Windows.Markup.XamlReader" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="47e24-162">读取 XAML 输入，并返回相应对象树的根。</span><span class="sxs-lookup"><span data-stu-id="47e24-162">Reads XAML input and returns the root of the corresponding object tree.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="47e24-163">要加载的 XAML，以流形式表示。</span><span class="sxs-lookup"><span data-stu-id="47e24-163">The XAML to load, in stream form.</span></span></param>
        <summary><span data-ttu-id="47e24-164">读取指定 <see cref="T:System.IO.Stream" /> 中的 XAML 输入，并返回作为相应对象树根的 <see cref="T:System.Object" />。</span><span class="sxs-lookup"><span data-stu-id="47e24-164">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns an <see cref="T:System.Object" /> that is the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="47e24-165">所创建的对象树根处的对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-165">The object at the root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="47e24-166">以下示例将保存<xref:System.Windows.Controls.Button>成<xref:System.IO.MemoryStream>使用<xref:System.Windows.Markup.XamlWriter>类。</span><span class="sxs-lookup"><span data-stu-id="47e24-166">The following example saves a <xref:System.Windows.Controls.Button> into a <xref:System.IO.MemoryStream> using the <xref:System.Windows.Markup.XamlWriter> class.</span></span> <span data-ttu-id="47e24-167">该流随后被加载回<xref:System.Windows.Controls.Button>使用静态<xref:System.Windows.Markup.XamlReader.Load%2A>方法<xref:System.Windows.Markup.XamlReader>类。</span><span class="sxs-lookup"><span data-stu-id="47e24-167">The stream is then loaded back into a <xref:System.Windows.Controls.Button> using the static <xref:System.Windows.Markup.XamlReader.Load%2A> method on the <xref:System.Windows.Markup.XamlReader> class.</span></span>  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="47e24-168"><paramref name="stream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="47e24-168"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xaml.XamlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xaml.XamlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XamlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xaml::XamlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xaml.XamlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xaml.XamlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="47e24-169"><see cref="T:System.Xaml.XamlReader" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-169">A <see cref="T:System.Xaml.XamlReader" /> object.</span></span> <span data-ttu-id="47e24-170">应使用输入 XAML 初始化此对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-170">This is expected to be initialized with input XAML.</span></span></param>
        <summary><span data-ttu-id="47e24-171">通过所提供的 <see cref="T:System.Xaml.XamlReader" /> 读取 XAML 输入，并返回作为相应对象树根的对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-171">Reads the XAML input through a provided <see cref="T:System.Xaml.XamlReader" /> and returns an object that is the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="47e24-172">已创建的对象树的根对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-172">The object that is the root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="47e24-173">输入<xref:System.Xaml.XamlReader>可以是<xref:System.Windows.Baml2006.Baml2006Reader>。</span><span class="sxs-lookup"><span data-stu-id="47e24-173">The input <xref:System.Xaml.XamlReader> can be <xref:System.Windows.Baml2006.Baml2006Reader>.</span></span> <span data-ttu-id="47e24-174">这是如何在运行时，或对本地化工具来说负载 BAML。</span><span class="sxs-lookup"><span data-stu-id="47e24-174">This is how you can load BAML at run time, or for localization tool purposes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="47e24-175"><paramref name="reader" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="47e24-175"><paramref name="reader" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="47e24-176">已经以 XML 形式加载了要加载的 XAML 输入的 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="47e24-176">The <see cref="T:System.Xml.XmlReader" /> that has already loaded the XAML input to load in XML form.</span></span></param>
        <summary><span data-ttu-id="47e24-177">读取指定 <see cref="T:System.Xml.XmlReader" /> 中的 XAML 输入，并返回作为相应对象树根的对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-177">Reads the XAML input in the specified <see cref="T:System.Xml.XmlReader" /> and returns an object that is the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="47e24-178">已创建的对象树的根对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-178">The object that is the root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="47e24-179">以下示例将转换<xref:System.Windows.Controls.Button>为字符串，并使用<xref:System.Windows.Markup.XamlWriter>类。</span><span class="sxs-lookup"><span data-stu-id="47e24-179">The following example converts a <xref:System.Windows.Controls.Button> into a string using the <xref:System.Windows.Markup.XamlWriter> class.</span></span>  <span data-ttu-id="47e24-180">字符串随后被加载回<xref:System.Windows.Controls.Button>使用静态<xref:System.Windows.Markup.XamlReader.Load%2A>方法<xref:System.Windows.Markup.XamlReader>类。</span><span class="sxs-lookup"><span data-stu-id="47e24-180">The string is then loaded back into a <xref:System.Windows.Controls.Button> using the static <xref:System.Windows.Markup.XamlReader.Load%2A> method on the <xref:System.Windows.Markup.XamlReader> class.</span></span>  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="47e24-181"><paramref name="reader" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="47e24-181"><paramref name="reader" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="47e24-182">包含要加载的 XAML 输入的流。</span><span class="sxs-lookup"><span data-stu-id="47e24-182">The stream that contains the XAML input to load.</span></span></param>
        <param name="parserContext"><span data-ttu-id="47e24-183">由分析器使用的上下文信息。</span><span class="sxs-lookup"><span data-stu-id="47e24-183">Context information used by the parser.</span></span></param>
        <summary><span data-ttu-id="47e24-184">读取指定 <see cref="T:System.IO.Stream" /> 中的 XAML 输入，并返回作为相应对象树根的对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-184">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns an object that is the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="47e24-185">已创建的对象树的根对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-185">The object that is the root of the created object tree.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="47e24-186"><paramref name="stream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="47e24-186"><paramref name="stream" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="47e24-187">或</span><span class="sxs-lookup"><span data-stu-id="47e24-187">-or-</span></span> 
 <span data-ttu-id="47e24-188"><paramref name="parserContext" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="47e24-188"><paramref name="parserContext" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadAsync">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="47e24-189">读取 XAML 标记，并返回与指定标记的根对应的对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-189">Reads XAML markup and returns an object that corresponds to the root of the specified markup.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream -&gt; obj" Usage="xamlReader.LoadAsync stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="47e24-190">包含要加载的 XAML 输入的流。</span><span class="sxs-lookup"><span data-stu-id="47e24-190">The stream containing the XAML input to load.</span></span></param>
        <summary><span data-ttu-id="47e24-191">读取指定 <see cref="T:System.IO.Stream" /> 中的 XAML 输入，并返回相应对象树的根。</span><span class="sxs-lookup"><span data-stu-id="47e24-191">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="47e24-192">已创建的对象树的根对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-192">The object that is the root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="47e24-193">异步的 XAML 加载操作最初将返回一个对象，是纯粹的根对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-193">An asynchronous XAML load operation will initially return an object that is purely the root object.</span></span> <span data-ttu-id="47e24-194">以异步方式，然后分析 XAML 将继续，并在根目录下填充任何子对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-194">Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</span></span> <span data-ttu-id="47e24-195">这与典型的 WPF XAML 处理行为和及其与 WPF 对象生存期概念的交互。</span><span class="sxs-lookup"><span data-stu-id="47e24-195">This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</span></span> <span data-ttu-id="47e24-196">中的典型 （非异步） 交互，返回一个元素并将其加载汇报之前都是包括所有子集合的对象的所有属性。</span><span class="sxs-lookup"><span data-stu-id="47e24-196">In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</span></span> <span data-ttu-id="47e24-197">该行为等同于自下而上的方法，用于创建的树的根对象所在的最后一个对象变为可用。</span><span class="sxs-lookup"><span data-stu-id="47e24-197">That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</span></span>  
  
 <span data-ttu-id="47e24-198">通常会将返回的对象分配到 WPF 应用程序的对象树中的某个位置、 与内容的知识可能仍会填入和作为 UI 的一部分公开的全部内容可能会导致增量布局更新。</span><span class="sxs-lookup"><span data-stu-id="47e24-198">You typically would assign the returned object to some location in your WPF application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</span></span> <span data-ttu-id="47e24-199">出于此原因，它是典型隔离或虚拟化任何以异步方式加载的对象从 XAML，并使用特定于应用程序逻辑或应用程序状态时进行通知<xref:System.Windows.Markup.XamlReader.LoadCompleted>进行处理。</span><span class="sxs-lookup"><span data-stu-id="47e24-199">For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.</span></span>  
  
 <span data-ttu-id="47e24-200">为了使<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>若要加载以异步方式输入 XAML，XAML 输入中的根元素必须包含的属性和值`x:SynchronousMode="Async"`。</span><span class="sxs-lookup"><span data-stu-id="47e24-200">In order for <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to load XAML input asynchronously, the root element in the XAML input must contain the attribute and value `x:SynchronousMode="Async"`.</span></span> <span data-ttu-id="47e24-201">值被视为区分大小写。</span><span class="sxs-lookup"><span data-stu-id="47e24-201">The value is treated as case sensitive.</span></span> <span data-ttu-id="47e24-202">如果 XAML 输入的根不包含`x:SynchronousMode="Async"`，不会引发异常，并调用被处理为同步加载 (请参阅<xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>)。</span><span class="sxs-lookup"><span data-stu-id="47e24-202">If the XAML input root does not contain `x:SynchronousMode="Async"`, no exception is thrown, and the call is processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>).</span></span>  
  
 <span data-ttu-id="47e24-203">每个实例只有一个异步加载操作<xref:System.Windows.Markup.XamlReader>类可以执行一次。</span><span class="sxs-lookup"><span data-stu-id="47e24-203">Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.</span></span>  <span data-ttu-id="47e24-204">如果将多个异步操作尝试在同一个实例上<xref:System.Windows.Markup.XamlReader>类<xref:System.InvalidOperationException>引发。</span><span class="sxs-lookup"><span data-stu-id="47e24-204">If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="47e24-205"><paramref name="stream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="47e24-205"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="47e24-206">对同一个 <see cref="T:System.Windows.Markup.XamlReader" /> 的多个加载操作用时挂起。</span><span class="sxs-lookup"><span data-stu-id="47e24-206">Multiple load operations are pending concurrently with the same <see cref="T:System.Windows.Markup.XamlReader" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadAsync (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.Xml.XmlReader -&gt; obj" Usage="xamlReader.LoadAsync reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="47e24-207">已加载/读取了 XAML 输入的现有 <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="47e24-207">An existing  <see cref="T:System.Xml.XmlReader" /> that has already loaded/read the XAML input.</span></span></param>
        <summary><span data-ttu-id="47e24-208">读取指定 <see cref="T:System.Xml.XmlReader" /> 中的 XAML 输入，并返回相应对象树的根。</span><span class="sxs-lookup"><span data-stu-id="47e24-208">Reads the XAML input in the specified <see cref="T:System.Xml.XmlReader" /> and returns the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="47e24-209">已创建的对象树的根。</span><span class="sxs-lookup"><span data-stu-id="47e24-209">The root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="47e24-210">异步的 XAML 加载操作最初将返回一个对象，是纯粹的根对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-210">An asynchronous XAML load operation will initially return an object that is purely the root object.</span></span> <span data-ttu-id="47e24-211">以异步方式，然后分析 XAML 将继续，并在根目录下填充任何子对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-211">Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</span></span> <span data-ttu-id="47e24-212">这与典型的 WPF XAML 处理行为和及其与 WPF 对象生存期概念的交互。</span><span class="sxs-lookup"><span data-stu-id="47e24-212">This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</span></span> <span data-ttu-id="47e24-213">中的典型 （非异步） 交互，返回一个元素并将其加载汇报之前都是包括所有子集合的对象的所有属性。</span><span class="sxs-lookup"><span data-stu-id="47e24-213">In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</span></span> <span data-ttu-id="47e24-214">该行为等同于自下而上的方法，用于创建的树的根对象所在的最后一个对象变为可用。</span><span class="sxs-lookup"><span data-stu-id="47e24-214">That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</span></span>  
  
 <span data-ttu-id="47e24-215">通常会分配从返回的对象<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>到应用程序的对象树中的某个位置，熟悉内容可能仍会填入和作为的一部分公开的全部内容可能会导致增量布局更新用户界面。</span><span class="sxs-lookup"><span data-stu-id="47e24-215">You typically would assign the returned object from <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</span></span> <span data-ttu-id="47e24-216">出于此原因，它是典型隔离或虚拟化任何以异步方式加载的对象从 XAML，并使用特定于应用程序逻辑或应用程序状态时进行通知<xref:System.Windows.Markup.XamlReader.LoadCompleted>进行处理。</span><span class="sxs-lookup"><span data-stu-id="47e24-216">For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.</span></span>  
  
 <span data-ttu-id="47e24-217">为了使<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>若要加载以异步方式输入 XAML，XAML 标记中的根元素必须包含的属性和值`x:SynchronousMode="Async"`。</span><span class="sxs-lookup"><span data-stu-id="47e24-217">In order for <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to load XAML input asynchronously, the root element in the XAML markup must contain the attribute and value `x:SynchronousMode="Async"`.</span></span> <span data-ttu-id="47e24-218">值被视为区分大小写。</span><span class="sxs-lookup"><span data-stu-id="47e24-218">The value is treated as case sensitive.</span></span> <span data-ttu-id="47e24-219">如果 XAML 标记根不包含`x:SynchronousMode="Async"`，不会引发异常，且调用改为处理为同步加载 (请参阅<xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>)。</span><span class="sxs-lookup"><span data-stu-id="47e24-219">If the XAML markup root does not contain `x:SynchronousMode="Async"`, no exception is thrown, and the call is instead processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>).</span></span>  
  
 <span data-ttu-id="47e24-220">每个实例只有一个异步加载操作<xref:System.Windows.Markup.XamlReader>类可以执行一次。</span><span class="sxs-lookup"><span data-stu-id="47e24-220">Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.</span></span>  <span data-ttu-id="47e24-221">如果将多个异步操作尝试在同一个实例上<xref:System.Windows.Markup.XamlReader>类<xref:System.InvalidOperationException>引发。</span><span class="sxs-lookup"><span data-stu-id="47e24-221">If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="47e24-222"><paramref name="reader" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="47e24-222"><paramref name="reader" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="47e24-223">对同一个 <see cref="T:System.Windows.Markup.XamlReader" /> 同时执行多个加载操作。</span><span class="sxs-lookup"><span data-stu-id="47e24-223">Multiple load operations are performed concurrently with the same <see cref="T:System.Windows.Markup.XamlReader" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="xamlReader.LoadAsync (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="47e24-224">包含要加载的 XAML 输入的流。</span><span class="sxs-lookup"><span data-stu-id="47e24-224">A stream containing the XAML input to load.</span></span></param>
        <param name="parserContext"><span data-ttu-id="47e24-225">由分析器使用的上下文信息。</span><span class="sxs-lookup"><span data-stu-id="47e24-225">Context information used by the parser.</span></span></param>
        <summary><span data-ttu-id="47e24-226">读取指定 <see cref="T:System.IO.Stream" /> 中的 XAML 输入，并返回相应对象树的根。</span><span class="sxs-lookup"><span data-stu-id="47e24-226">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="47e24-227">已创建的对象树的根。</span><span class="sxs-lookup"><span data-stu-id="47e24-227">The root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="47e24-228">异步的 XAML 加载操作最初将返回一个对象，是纯粹的根对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-228">An asynchronous XAML load operation will initially return an object that is purely the root object.</span></span> <span data-ttu-id="47e24-229">以异步方式，然后分析 XAML 将继续，并在根目录下填充任何子对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-229">Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</span></span> <span data-ttu-id="47e24-230">这与典型的 WPF XAML 处理行为和及其与 WPF 对象生存期概念的交互。</span><span class="sxs-lookup"><span data-stu-id="47e24-230">This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</span></span> <span data-ttu-id="47e24-231">中的典型 （非异步） 交互，返回一个元素并将其加载汇报之前都是包括所有子集合的对象的所有属性。</span><span class="sxs-lookup"><span data-stu-id="47e24-231">In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</span></span> <span data-ttu-id="47e24-232">该行为等同于自下而上的方法，用于创建的树的根对象所在的最后一个对象变为可用。</span><span class="sxs-lookup"><span data-stu-id="47e24-232">That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</span></span>  
  
 <span data-ttu-id="47e24-233">通常会将返回的对象分配到应用程序的对象树中的某个位置、 与内容的知识可能仍会填入和作为 UI 的一部分公开的全部内容可能会导致增量布局更新。</span><span class="sxs-lookup"><span data-stu-id="47e24-233">You typically would assign the returned object to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</span></span> <span data-ttu-id="47e24-234">出于此原因，它是典型隔离或虚拟化任何以异步方式加载的对象从 XAML，并使用特定于应用程序逻辑或应用程序状态时进行通知<xref:System.Windows.Markup.XamlReader.LoadCompleted>进行处理。</span><span class="sxs-lookup"><span data-stu-id="47e24-234">For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.</span></span>  
  
 <span data-ttu-id="47e24-235">为了使<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>若要以异步方式加载标记，在 XAML 标记中的根元素必须包含的属性和值`x:SynchronousMode="Async"`。</span><span class="sxs-lookup"><span data-stu-id="47e24-235">In order for <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to load markup asynchronously, the root element in the XAML markup must contain the attribute and value `x:SynchronousMode="Async"`.</span></span> <span data-ttu-id="47e24-236">值被视为区分大小写。</span><span class="sxs-lookup"><span data-stu-id="47e24-236">The value is treated as case sensitive.</span></span> <span data-ttu-id="47e24-237">如果 XAML 标记根不包含`x:SynchronousMode="Async"`，不会引发异常，并调用被处理为同步加载 (请参阅<xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>)。</span><span class="sxs-lookup"><span data-stu-id="47e24-237">If the XAML markup root does not contain `x:SynchronousMode="Async"`, no exception is thrown, and the call is processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>).</span></span>  
  
 <span data-ttu-id="47e24-238">每个实例只有一个异步加载操作<xref:System.Windows.Markup.XamlReader>类可以执行一次。</span><span class="sxs-lookup"><span data-stu-id="47e24-238">Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.</span></span>  <span data-ttu-id="47e24-239">如果将多个异步操作尝试在同一个实例上<xref:System.Windows.Markup.XamlReader>类<xref:System.InvalidOperationException>引发。</span><span class="sxs-lookup"><span data-stu-id="47e24-239">If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="47e24-240"><paramref name="stream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="47e24-240"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="47e24-241">对同一个 <see cref="T:System.Windows.Markup.XamlReader" /> 同时执行多个加载操作。</span><span class="sxs-lookup"><span data-stu-id="47e24-241">Multiple load operations are performed concurrently with the same <see cref="T:System.Windows.Markup.XamlReader" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AsyncCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AsyncCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Markup.XamlReader.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As AsyncCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AsyncCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " Usage="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AsyncCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="47e24-242">在异步加载操作完成时发生。</span><span class="sxs-lookup"><span data-stu-id="47e24-242">Occurs when an asynchronous load operation completes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="47e24-243"><xref:System.Windows.Markup.XamlReader.LoadCompleted> 此外异步加载操作中止时引发。</span><span class="sxs-lookup"><span data-stu-id="47e24-243"><xref:System.Windows.Markup.XamlReader.LoadCompleted> is also raised when an asynchronous load operation aborts.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.AsyncCompletedEventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="47e24-244">读取指定文本字符串中的标记，并返回与指定标记的根对应的对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-244">Reads the markup in the specified text string and returns an object that corresponds to the root of the specified markup.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (xamlText As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse xamlText" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlText"><span data-ttu-id="47e24-245">输入 XAML，作为单个文本字符串。</span><span class="sxs-lookup"><span data-stu-id="47e24-245">The input XAML, as a single text string.</span></span></param>
        <summary><span data-ttu-id="47e24-246">读取指定文本字符串中的 XAML 输入，并返回与指定标记的根对应的对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-246">Reads the XAML input in the specified text string and returns an object that corresponds to the root of the specified markup.</span></span></summary>
        <returns><span data-ttu-id="47e24-247">已创建的对象树的根。</span><span class="sxs-lookup"><span data-stu-id="47e24-247">The root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="47e24-248">实现调用<xref:System.Windows.Markup.XamlReader.Load%2A>从字符串创建流后在内部。</span><span class="sxs-lookup"><span data-stu-id="47e24-248">The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string.</span></span> <span data-ttu-id="47e24-249">请参阅<xref:System.Windows.Markup.XamlReader.Load%2A>的其他信息，例如可能的异常。</span><span class="sxs-lookup"><span data-stu-id="47e24-249">See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse (xamlText, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="xamlText"><span data-ttu-id="47e24-250">输入 XAML，作为单个文本字符串。</span><span class="sxs-lookup"><span data-stu-id="47e24-250">The input XAML, as a single text string.</span></span></param>
        <param name="parserContext"><span data-ttu-id="47e24-251">由分析器使用的上下文信息。</span><span class="sxs-lookup"><span data-stu-id="47e24-251">Context information used by the parser.</span></span></param>
        <summary><span data-ttu-id="47e24-252">（使用指定的 <see cref="T:System.Windows.Markup.ParserContext" />）读取指定文本字符串中的 XAML 标记，并返回与指定标记的根对应的对象。</span><span class="sxs-lookup"><span data-stu-id="47e24-252">Reads the XAML markup in the specified text string (using a specified <see cref="T:System.Windows.Markup.ParserContext" />) and returns an object that corresponds to the root of the specified markup.</span></span></summary>
        <returns><span data-ttu-id="47e24-253">已创建的对象树的根。</span><span class="sxs-lookup"><span data-stu-id="47e24-253">The root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="47e24-254">实现调用<xref:System.Windows.Markup.XamlReader.Load%2A>从字符串创建流后在内部。</span><span class="sxs-lookup"><span data-stu-id="47e24-254">The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string.</span></span> <span data-ttu-id="47e24-255">请参阅<xref:System.Windows.Markup.XamlReader.Load%2A>的其他信息，例如可能的异常。</span><span class="sxs-lookup"><span data-stu-id="47e24-255">See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>