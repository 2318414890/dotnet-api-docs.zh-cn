<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="XamlReader.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cb6251512dd75740e1b01a33ceb7e3470f3a68d1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cb6251512dd75740e1b01a33ceb7e3470f3a68d1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads XAML input and creates an object graph, using the WPF default XAML reader and an associated XAML object writer.</source>
          <target state="translated">使用 WPF 默认 XAML 读取器和关联的 XAML 对象编写器读取 XAML 输入并创建对象图。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The synchronous <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> methods are static, but the asynchronous <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> methods are not static and require an instance of the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class to use.</source>
          <target state="translated">同步<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>方法是静态的但异步<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph>方法不是静态和需要的实例<ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>要使用的类。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The output of the <ph id="ph1">`Load`</ph> methods is a single object, which represents the root object of a created object tree or object graph.</source>
          <target state="translated">输出<ph id="ph1">`Load`</ph>方法是单个对象，它表示创建的对象树或对象图的根对象。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Object graphs that are created by <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> are typically added to the existing object tree of a WPF application at run time.</source>
          <target state="translated">对象创建的关系图<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>通常会将其添加到 WPF 应用程序在运行时的现有对象树。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Otherwise the new object graph is considered disconnected for purposes of the WPF application model.</source>
          <target state="translated">否则新的对象图，被视为出于的 WPF 应用程序模型断开连接。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>This means that it does not render, and cannot be accessed using any of the object tree techniques as applied to the WPF application's main object tree (for example, the APIs <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>).</source>
          <target state="translated">也就是说，不会呈现，并且不能访问使用任一对象树技巧作为应用于 WPF 应用程序的主对象树 (例如，Api <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>， <ph id="ph3">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For more information on object tree concepts, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">在对象树概念的详细信息，请参阅<bpt id="p1">[</bpt>WPF 中的树<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> supports the following primary scenarios:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 支持以下主要方案：</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Cloning/object factory<ept id="p1">**</ept>: Without additional mechanisms, a reference type generally cannot be included in more than one position in a WPF object tree.</source>
          <target state="translated"><bpt id="p1">**</bpt>克隆对象工厂<ept id="p1">**</ept>： 没有附加机制，引用类型通常不能包含 WPF 对象树中的多个位置。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>(Examples of additional mechanisms that offer support for sharing or re-use in WPF include objects that are based on <ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph>, or support for commonly shareable objects such as <ph id="ph2">&lt;xref:System.Windows.Media.Brush&gt;</ph> that are referenced as an item from a <ph id="ph3">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.) One way to clone an object that is already in the object tree is to serialize the object using <ph id="ph4">&lt;xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">(其他机制来提供对共享支持或在 WPF 中重新使用的示例包括基于的对象<ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph>，或如支持通常可共享对象<ph id="ph2">&lt;xref:System.Windows.Media.Brush&gt;</ph>，引用为中的一个项<ph id="ph3">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>。)一种方法克隆一个对象，它已在对象树是序列化对象使用<ph id="ph4">&lt;xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>You then use the serialized string as input for a call to <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>, with a stream or <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> as an intermediary.</source>
          <target state="translated">然后将其序列化的字符串作为输入用于调用<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>，并将流或<ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>作为中介。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Constructing objects based on just-in-time information<ept id="p1">**</ept>: There are often other ways to have late-binding or user-supplied input change the state of existing objects.</source>
          <target state="translated"><bpt id="p1">**</bpt>构造对象基于在实时信息<ept id="p1">**</ept>： 通常还有其他方法来使用晚期绑定或用户提供的输入来更改现有对象的状态。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For example you could use the same value to set more than one property, or use data binding.</source>
          <target state="translated">例如你无法使用相同的值来设置多个属性，或使用数据绑定。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>But if you have a scenario where even the type of object to create is only determinable at run time or with user interaction, then creating such an object by building up a string for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> input is often a useful technique.</source>
          <target state="translated">但如果你有其中甚至要创建的对象的类型为仅可确定在运行时或与用户交互的方案，然后通过在生成的字符串来创建此类对象<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>输入通常是有用的技术。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Using existing resource techniques<ept id="p1">**</ept>: The <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> type is used frequently in other frameworks or technologies for transferring data or objects across application boundaries or for similar situations.</source>
          <target state="translated"><bpt id="p1">**</bpt>使用现有资源技术<ept id="p1">**</ept>:<ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph>类型常用于其他框架或技术用于跨应用程序边界传输数据或对象或类似情况。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>You can then use the <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> techniques to store or obtain XAML-formatted data that you eventually use to create an object as part of your application.</source>
          <target state="translated">然后，可以使用<ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph>技术来存储或获取最终用于你的应用程序的一部分中创建对象的 XAML 格式的数据。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Fixed documents:<ept id="p1">**</ept> Your application might load local or downloaded XPS documents for inclusion in a WPF application object tree and UI.</source>
          <target state="translated"><bpt id="p1">**</bpt>固定文档：<ept id="p1">**</ept>你的应用程序可能会加载以包含在 WPF 应用程序对象树和 UI 中的本地或下载 XPS 文档。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>This documentation sometimes describes an object graph, as opposed to an object tree.</source>
          <target state="translated">有时，此文档介绍对象图，而不是对象树。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>A strict parent-child relationship does not always exist in the run time object relationships of a run time WPF application, so an object graph is a more widely applicable terminology.</source>
          <target state="translated">严格的父-子关系不始终存在中运行的时 WPF 应用程序的运行的时对象关系，因此对象图是更广泛适用的术语。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, because WPF also includes two different tree conceptualization APIs (<ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>) the tree metaphor still applies adequately to most real-world cases in WPF.</source>
          <target state="translated">但是，原因是 WPF 还包括两个不同的树概念化 Api (<ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>) 树隐喻仍充分地应用到 WPF 中的大多数现实情况。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>From the XAML language perspective however, the object graph is often the best way to think about how objects are created out of XAML, because the XAML language itself does not necessarily specify helper class methodologies that bring the relationships more into a tree structure again.</source>
          <target state="translated">从 XAML 语言角度来看但是，对象图通常是考虑如何将对象创建超出 XAML 中，因为 XAML 语言本身并不一定指定将关系的详细信息的帮助器类方法的最佳方式到再次树状结构。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Code Access Security, Loose XAML, and XamlReader</source>
          <target state="translated">代码访问安全性、 宽松 XAML，以及 xamlreader 形式提供</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>XAML is a markup language that directly represents object instantiation and execution.</source>
          <target state="translated">XAML 是一种直接表示对象实例化和执行的标记语言。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Therefore, elements created in XAML have the same ability to interact with system resources (network access, file system IO, for example) as the equivalent generated code does.</source>
          <target state="translated">因此，在 XAML 中创建的元素能够像等效的生成代码那样与系统资源（如网络访问、文件系统 IO）进行交互。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> supports the <ph id="ph2">[!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)]</ph> security framework <ph id="ph3">[!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> 支持<ph id="ph2">[!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)]</ph>安全框架<ph id="ph3">[!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>This means that <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> content running in the internet zone has reduced execution permissions.</source>
          <target state="translated">这意味着在 Internet 区域中运行的 <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> 内容具有缩减的执行权限。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>"Loose XAML" (pages of noncompiled XAML interpreted at load time by a XAML viewer) and <ph id="ph1">[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]</ph> are usually run in this internet zone and use the same permission set.</source>
          <target state="translated">“宽松型 XAML”（由 XAML 查看器在加载时解释的非编译 XAML 的页面）和 <ph id="ph1">[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]</ph> 通常在此 Internet 区域中运行，并且使用相同的权限集。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, XAML loaded in to a fully trusted application has the same access to the system resources as the hosting application does.</source>
          <target state="translated">但是，加载到完全受信任的应用程序中的 XAML 与承载应用程序具有相同的系统资源访问权限。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For more information, see <bpt id="p1">[</bpt>WPF Partial Trust Security<ept id="p1">](~/docs/framework/wpf/wpf-partial-trust-security.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅 <bpt id="p1">[</bpt>WPF 部分信任安全性<ept id="p1">](~/docs/framework/wpf/wpf-partial-trust-security.md)</ept>。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The implications of these statements for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> is that your application design must make trust decisions about the XAML you decide to load.</source>
          <target state="translated">有关这些语句的含义<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>是应用程序设计必须使你决定要加载的 xaml 的信任决定。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are loading XAML that is not trusted, consider implementing your own sandboxing technique for how you load the resulting object graph.</source>
          <target state="translated">如果你要将加载不受信任的 XAML，请考虑实现你自己的沙盒技术来加载生成的对象图的方式。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> can also be called by partial trust code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 此外可以由部分信任代码调用。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>In this case, Internet security zone is applied for code access security.</source>
          <target state="translated">在这种情况下，Internet 安全区域被应用于代码访问安全性。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If anything in the loaded XAML is invalid under Internet security zone, a XAML parse exception is thrown.</source>
          <target state="translated">如果加载的 XAML 中的任何内容无效 Internet 安全区域下，会引发一个 XAML 分析异常。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Under XBAP and other cases that are partial trust at the platform level, where <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> is part of the execution, you get the same exception behavior as with explicit partial trust calls.</source>
          <target state="translated">XBAP 和部分信任级别的平台的其他情况下在其中<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>是一部分与显式的部分信任的调用的执行，获取相同的异常行为。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>WPF XAML, XAML Readers/Writers, and XAML Language Versioning</source>
          <target state="translated">WPF XAML、 XAML 读取器/编写器，和 XAML 语言版本控制</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">[!INCLUDE[xaml2009](~/includes/xaml2009-md.md)]</ph> includes language features such as  and .</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[xaml2009](~/includes/xaml2009-md.md)]</ph> 包括语言功能，如和。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>You can use signatures of <ph id="ph1">`Load`</ph> or <ph id="ph2">`Parse`</ph> to load XAML that uses these features.</source>
          <target state="translated">您可以使用的签名<ph id="ph1">`Load`</ph>或<ph id="ph2">`Parse`</ph>来加载使用这些功能的 XAML。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, those language features are not supported for XAML that needs to be markup compiled (such as XAML for the <bpt id="p1">**</bpt>Page<ept id="p1">**</ept> build action in a WPF application, or any XAML that involves the markup compile task in the build actions).</source>
          <target state="translated">但是，这些语言功能不支持针对需要标记编译的 XAML (如 XAML<bpt id="p1">**</bpt>页<ept id="p1">**</ept>生成 WPF 应用程序或涉及的生成操作中的标记编译任务任何 XAML 中的操作)。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>WPF types and the WPF technology in general support concepts that rely on access to WPF internals.</source>
          <target state="translated">WPF 类型和 WPF 技术通常支持依赖于对 WPF 内部结构的访问的概念。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For instance, how WPF implements dependency properties relies on internal techniques for efficient type-member lookup.</source>
          <target state="translated">例如，WPF 如何实施依赖项属性依赖于用于高效的类型成员查找内部技术。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Access to these internals is enabled by the XAML reading and writing APIs provided in <ph id="ph1">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> from the <ph id="ph3">&lt;xref:System.Windows.Markup&gt;</ph> namespace and PresentationFramework assembly.</source>
          <target state="translated">对这些内部结构的访问通过读取和写入中提供的 Api 的 XAML<ph id="ph1">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph>和<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>从<ph id="ph3">&lt;xref:System.Windows.Markup&gt;</ph>命名空间和 PresentationFramework 程序集中。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, the lower-level XAML readers and XAML writers from the System.Xaml assembly (classes based on <ph id="ph1">&lt;xref:System.Xaml.XamlReader?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Xaml.XamlWriter?displayProperty=nameWithType&gt;</ph>) do not have access to the WPF internals.</source>
          <target state="translated">但是，较低级别 XAML 读取器和 XAML 编写器从 System.Xaml 程序集 (类基于<ph id="ph1">&lt;xref:System.Xaml.XamlReader?displayProperty=nameWithType&gt;</ph>， <ph id="ph2">&lt;xref:System.Xaml.XamlWriter?displayProperty=nameWithType&gt;</ph>) 不能访问到 WPF 内部结构。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>There is no dependency from System.Xaml to any WPF-specific assembly.</source>
          <target state="translated">从 System.Xaml 对任何特定于 WPF 程序集没有依赖关系。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Without access to the WPF internals, System.Xaml readers and writers cannot correctly load or save all WPF types, or types based on WPF types.</source>
          <target state="translated">无需 WPF 内部访问，System.Xaml 读取器和编写器无法正确加载或保存所有 WPF 类型基于 WPF 类型。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>In particular, the System.Xaml readers and writers do not understand concepts such as the WPF dependency property backing property store, or all the specifics of how WPF uses styles, resource dictionaries and templates.</source>
          <target state="translated">具体而言，System.Xaml 读取器和编写器不了解概念，如备份属性存储或 WPF 如何使用样式、 资源字典和模板的所有详细信息的 WPF 依赖项属性。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Therefore you have a choice to make:</source>
          <target state="translated">因此，你可以选择以：</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are loading WPF types, and/or you are using XAML in BAML form in any way, use the PresentationFramework XAML readers and XAML writers.</source>
          <target state="translated">如果您正在加载 WPF 类型和/或以任何方式的 BAML 形式使用 XAML，使用 PresentationFramework XAML 读取器和 XAML 编写器。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are not relying on any WPF types or the BAML form of XAML, and are not using another specific technology's XAML reader or XAML writer implementation for reasons that are specific to that framework, use the System.Xaml XAML readers and XAML writers.</source>
          <target state="translated">如果你不依赖于任何 WPF 类型或 BAML 形式的 XAML，并不将另一种特定技术的 XAML 读取器或 XAML 编写器实现的原因，特定于该框架，则使用 System.Xaml XAML 读取器和 XAML 编写器。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>System.Xaml Backing Implementation in .NET 4</source>
          <target state="translated">System.Xaml 支持.NET 4 中的实现</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> is the callable API surface for the WPF framework-level XAML parser.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> 是 WPF 框架级别 XAML 分析器可调用的 API 图面。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The same underlying XAML parser also performs the run-time XAML loading and parsing for WPF applications that target <ph id="ph1">[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]</ph> and <ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>.</source>
          <target state="translated">相同的基础 XAML 分析器还执行运行时 XAML 加载和分析 WPF 应用程序面向<ph id="ph1">[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]</ph>和<ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are targeting <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, the external API is the same, but parts of the implementation are built on the <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> general XAML implementation in the System.Xaml assembly, which improves many of the technical and reporting aspects of parsing XAML.</source>
          <target state="translated">如果你正面向<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>、 外部 API 相同，但实施部分都基于<ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>在 System.Xaml 程序集中，从而提高了许多分析 XAML 的技术和报告的方面的常规 XAML 实现。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Targeting <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> necessarily entails including System.Xaml as a reference, and details of implementation such as the exceptions reported may come from System.Xaml defined types.</source>
          <target state="translated">面向<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>一定需要一个引用，以及实现的详细信息包括 System.Xaml，如报告的异常可能来自于 System.Xaml 定义的类型。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The following example converts a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> into a string using the <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> class.</source>
          <target state="translated">以下示例将转换<ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>到字符串使用<ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The string is then loaded back into a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> using the static <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class.</source>
          <target state="translated">然后会将字符串加载回<ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>使用静态<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>方法<ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.CancelAsync">
          <source>Aborts the current asynchronous load operation, if there is an asynchronous load operation pending.</source>
          <target state="translated">如果有挂起的异步加载操作，则中止当前的异步加载操作。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.CancelAsync">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.CancelAsync%2A&gt;</ph> is an asynchronous operation; therefore, some loading may occur before the operation is aborted.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.CancelAsync%2A&gt;</ph> 是一个异步操作;因此，操作中止之前，可能会出现某些加载。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> object that represents the WPF schema context settings for a <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">返回一个 <ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> 对象，该对象表示 <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> 的 WPF 架构上下文设置。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> object that represents the WPF schema context settings for a <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> 对象，该对象表示 <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> 的 WPF 架构上下文设置。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads XAML input and returns the root of the corresponding object tree.</source>
          <target state="translated">读取 XAML 输入，并返回相应对象树的根。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The XAML to load, in stream form.</source>
          <target state="translated">要加载的 XAML，以流形式表示。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns an <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> that is the root of the corresponding object tree.</source>
          <target state="translated">读取指定 <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> 中的 XAML 输入，并返回作为相应对象树根的 <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The object at the root of the created object tree.</source>
          <target state="translated">所创建的对象树根处的对象。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The following example saves a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> into a <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph> using the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> class.</source>
          <target state="translated">下面的示例将保存<ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>到<ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph>使用<ph id="ph3">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The stream is then loaded back into a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> using the static <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class.</source>
          <target state="translated">然后，将流加载回<ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>使用静态<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>方法<ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>This is expected to be initialized with input XAML.</source>
          <target state="translated">应使用输入 XAML 初始化此对象。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>Reads the XAML input through a provided <ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">通过所提供的 <ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> 读取 XAML 输入，并返回作为相应对象树根的对象。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">已创建的对象树的根对象。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>The input <ph id="ph1">&lt;xref:System.Xaml.XamlReader&gt;</ph> can be <ph id="ph2">&lt;xref:System.Windows.Baml2006.Baml2006Reader&gt;</ph>.</source>
          <target state="translated">输入<ph id="ph1">&lt;xref:System.Xaml.XamlReader&gt;</ph>可以是<ph id="ph2">&lt;xref:System.Windows.Baml2006.Baml2006Reader&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>This is how you can load BAML at run time, or for localization tool purposes.</source>
          <target state="translated">这是如何加载 BAML 在运行时，或出于本地化工具目的。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that has already loaded the XAML input to load in XML form.</source>
          <target state="translated">已经以 XML 形式加载了要加载的 XAML 输入的 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">读取指定 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> 中的 XAML 输入，并返回作为相应对象树根的对象。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">已创建的对象树的根对象。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The following example converts a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> into a string using the <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> class.</source>
          <target state="translated">以下示例将转换<ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>到字符串使用<ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The string is then loaded back into a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> using the static <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class.</source>
          <target state="translated">然后会将字符串加载回<ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>使用静态<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>方法<ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The stream that contains the XAML input to load.</source>
          <target state="translated">包含要加载的 XAML 输入的流。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Context information used by the parser.</source>
          <target state="translated">由分析器使用的上下文信息。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns an object that is the root of the corresponding object tree.</source>
          <target state="translated">读取指定 <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> 中的 XAML 输入，并返回作为相应对象树根的对象。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">已创建的对象树的根对象。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source><ph id="ph1">&lt;paramref name="parserContext" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parserContext" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads XAML markup and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">读取 XAML 标记，并返回与指定标记的根对应的对象。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>The stream containing the XAML input to load.</source>
          <target state="translated">包含要加载的 XAML 输入的流。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns the root of the corresponding object tree.</source>
          <target state="translated">读取指定 <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> 中的 XAML 输入，并返回相应对象树的根。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>The object that is the root of the created object tree.</source>
          <target state="translated">已创建的对象树的根对象。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">异步的 XAML 加载操作最初将返回一个对象，它只是根对象。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">异步，XAML 分析然后仍然存在，并在根目录下填充任何子对象。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">这是典型的 WPF XAML 处理行为和该产品与对象生存期 WPF 概念交互相反。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">中的典型 （非异步） 交互，返回一个元素并将其加载汇报之前都是包括所有子集合对象的所有属性。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">该行为等同于自下而上的方法，用于创建的树的根对象所在的最后一个对象变为可用。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>You typically would assign the returned object to some location in your WPF application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">你通常会将返回的对象分配到 WPF 应用程序的对象树中的某个位置、 内容所知识可能仍会填入和如果作为 UI 的一部分公开的整个内容，则可能会导致增量布局更新。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is handled.</source>
          <target state="translated">为此，它是典型隔离或虚拟化从 XAML，任何以异步方式加载的对象并使用特定于应用程序逻辑或应用程序状态通知时<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph>处理。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>In order for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to load XAML input asynchronously, the root element in the XAML input must contain the attribute and value <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">为了使<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph>若要加载的 XAML 输入以异步方式，XAML 输入中的根元素必须包含的属性和值<ph id="ph2">`x:SynchronousMode="Async"`</ph>。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">值被视为区分大小写。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>If the XAML input root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;</ph>).</source>
          <target state="translated">如果 XAML 输入的根不包含<ph id="ph1">`x:SynchronousMode="Async"`</ph>，不会引发异常，且调用处理为同步负载 (请参阅<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Only one asynchronous load operation per instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class can be performed at a time.</source>
          <target state="translated">每个实例只有一个异步加载操作<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>类可以执行一次。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>If more than one asynchronous operation is attempted on the same instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">如果多个异步操作，将尝试对同一个实例<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>类<ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Multiple load operations are pending concurrently with the same <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">对同一个 <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> 的多个加载操作用时挂起。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>An existing  <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that has already loaded/read the XAML input.</source>
          <target state="translated">已加载/读取了 XAML 输入的现有 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> and returns the root of the corresponding object tree.</source>
          <target state="translated">读取指定 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> 中的 XAML 输入，并返回相应对象树的根。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>The root of the created object tree.</source>
          <target state="translated">已创建的对象树的根。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">异步的 XAML 加载操作最初将返回一个对象，它只是根对象。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">异步，XAML 分析然后仍然存在，并在根目录下填充任何子对象。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">这是典型的 WPF XAML 处理行为和该产品与对象生存期 WPF 概念交互相反。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">中的典型 （非异步） 交互，返回一个元素并将其加载汇报之前都是包括所有子集合对象的所有属性。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">该行为等同于自下而上的方法，用于创建的树的根对象所在的最后一个对象变为可用。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>You typically would assign the returned object from <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">你通常会将分配给返回的对象从<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph>到应用程序的对象树中的某个位置，所需知识内容可能仍会填入和如果作为的一部分公开的全部内容可能会导致增量布局更新UI。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is handled.</source>
          <target state="translated">为此，它是典型隔离或虚拟化从 XAML，任何以异步方式加载的对象并使用特定于应用程序逻辑或应用程序状态通知时<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph>处理。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>In order for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to load XAML input asynchronously, the root element in the XAML markup must contain the attribute and value <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">为了使<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph>若要加载的 XAML 输入以异步方式，在 XAML 标记中的根元素必须包含的属性和值<ph id="ph2">`x:SynchronousMode="Async"`</ph>。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">值被视为区分大小写。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>If the XAML markup root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is instead processed as a synchronous load (see <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;</ph>).</source>
          <target state="translated">如果 XAML 标记根不包含<ph id="ph1">`x:SynchronousMode="Async"`</ph>，不会引发异常，且调用改为处理为同步负载 (请参阅<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Only one asynchronous load operation per instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class can be performed at a time.</source>
          <target state="translated">每个实例只有一个异步加载操作<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>类可以执行一次。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>If more than one asynchronous operation is attempted on the same instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">如果多个异步操作，将尝试对同一个实例<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>类<ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Multiple load operations are performed concurrently with the same <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">对同一个 <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> 同时执行多个加载操作。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>A stream containing the XAML input to load.</source>
          <target state="translated">包含要加载的 XAML 输入的流。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Context information used by the parser.</source>
          <target state="translated">由分析器使用的上下文信息。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns the root of the corresponding object tree.</source>
          <target state="translated">读取指定 <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> 中的 XAML 输入，并返回相应对象树的根。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The root of the created object tree.</source>
          <target state="translated">已创建的对象树的根。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">异步的 XAML 加载操作最初将返回一个对象，它只是根对象。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">异步，XAML 分析然后仍然存在，并在根目录下填充任何子对象。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">这是典型的 WPF XAML 处理行为和该产品与对象生存期 WPF 概念交互相反。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">中的典型 （非异步） 交互，返回一个元素并将其加载汇报之前都是包括所有子集合对象的所有属性。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">该行为等同于自下而上的方法，用于创建的树的根对象所在的最后一个对象变为可用。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>You typically would assign the returned object to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">你通常会将返回的对象分配到应用程序的对象树中的某个位置、 内容所知识可能仍会填入和如果作为 UI 的一部分公开的整个内容，则可能会导致增量布局更新。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is handled.</source>
          <target state="translated">为此，它是典型隔离或虚拟化从 XAML，任何以异步方式加载的对象并使用特定于应用程序逻辑或应用程序状态通知时<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph>处理。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>In order for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to load markup asynchronously, the root element in the XAML markup must contain the attribute and value <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">为了使<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph>若要以异步方式加载标记，在 XAML 标记中的根元素必须包含的属性和值<ph id="ph2">`x:SynchronousMode="Async"`</ph>。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">值被视为区分大小写。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>If the XAML markup root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;</ph>).</source>
          <target state="translated">如果 XAML 标记根不包含<ph id="ph1">`x:SynchronousMode="Async"`</ph>，不会引发异常，且调用处理为同步负载 (请参阅<ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Only one asynchronous load operation per instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class can be performed at a time.</source>
          <target state="translated">每个实例只有一个异步加载操作<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>类可以执行一次。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>If more than one asynchronous operation is attempted on the same instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">如果多个异步操作，将尝试对同一个实例<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph>类<ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Multiple load operations are performed concurrently with the same <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          <target state="translated">对同一个 <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> 同时执行多个加载操作。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="E:System.Windows.Markup.XamlReader.LoadCompleted">
          <source>Occurs when an asynchronous load operation completes.</source>
          <target state="translated">在异步加载操作完成时发生。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.Markup.XamlReader.LoadCompleted">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is also raised when an asynchronous load operation aborts.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> 此外在异步加载操作中止时引发。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads the markup in the specified text string and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">读取指定文本字符串中的标记，并返回与指定标记的根对应的对象。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>The input XAML, as a single text string.</source>
          <target state="translated">输入 XAML，作为单个文本字符串。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>Reads the XAML input in the specified text string and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">读取指定文本字符串中的 XAML 输入，并返回与指定标记的根对应的对象。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>The root of the created object tree.</source>
          <target state="translated">已创建的对象树的根。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>The implementation calls <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> internally after creating a stream from the string.</source>
          <target state="translated">实现调用<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>内部后从字符串创建流。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> for additional information such as possible exceptions.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>有关其他信息，例如可能的异常。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>The input XAML, as a single text string.</source>
          <target state="translated">输入 XAML，作为单个文本字符串。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>Context information used by the parser.</source>
          <target state="translated">由分析器使用的上下文信息。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>Reads the XAML markup in the specified text string (using a specified <ph id="ph1">&lt;see cref="T:System.Windows.Markup.ParserContext" /&gt;</ph>) and returns an object that corresponds to the root of the specified markup.</source>
          <target state="translated">（使用指定的 <ph id="ph1">&lt;see cref="T:System.Windows.Markup.ParserContext" /&gt;</ph>）读取指定文本字符串中的 XAML 标记，并返回与指定标记的根对应的对象。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>The root of the created object tree.</source>
          <target state="translated">已创建的对象树的根。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>The implementation calls <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> internally after creating a stream from the string.</source>
          <target state="translated">实现调用<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>内部后从字符串创建流。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> for additional information such as possible exceptions.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>有关其他信息，例如可能的异常。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>