<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8d6cc6133d16271bd4d1423cc08106873390071c" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52217194" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ServiceBase = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.UserNTServiceDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>为将作为服务应用程序的一部分而存在的服务提供基类。 在创建新的服务类时，必须从 <see cref="T:System.ServiceProcess.ServiceBase" /> 派生。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生自<xref:System.ServiceProcess.ServiceBase>服务应用程序中定义您的服务类时。 任何有用的服务重写<xref:System.ServiceProcess.ServiceBase.OnStart%2A>和<xref:System.ServiceProcess.ServiceBase.OnStop%2A>方法。 对于其他功能，可以重写<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>与在响应中的服务状态的更改的特定行为。  
  
 服务是不支持用户界面的长时间运行可执行文件不可能登录的用户帐户下运行。 该服务可以没有任何用户在登录到计算机的情况下运行。  
  
 默认情况下，服务不是管理员帐户相同的系统帐户下运行。 不能更改系统帐户的权限。 或者，可以使用<xref:System.ServiceProcess.ServiceProcessInstaller>以指定将在其下运行服务的用户帐户。  
  
 可执行文件可以包含多个服务，但必须包含一个单独<xref:System.ServiceProcess.ServiceInstaller>为每个服务。 <xref:System.ServiceProcess.ServiceInstaller>实例向系统注册该服务。 安装程序还将每个服务的事件日志可用于记录服务命令相关联。 `main()`可执行文件中的函数定义应运行哪些服务。 该服务的当前工作目录是系统目录中，不是可执行文件所在的目录。  
  
 启动服务时，系统查找可执行文件并运行<xref:System.ServiceProcess.ServiceBase.OnStart%2A>可执行文件中包含该服务的方法。 但是，运行该服务不是与运行可执行文件相同。 可执行文件仅加载服务。 通过服务控制管理器中，在服务受访问 （例如，启动和停止）。  
  
 可执行文件调用<xref:System.ServiceProcess.ServiceBase>派生类的构造函数第一次调用服务上的开始。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>构造函数执行后立即调用命令处理方法。 构造函数不会执行后首次加载该服务，因此需要单独的执行从执行的构造函数的处理<xref:System.ServiceProcess.ServiceBase.OnStart%2A>。 可以通过释放任何资源<xref:System.ServiceProcess.ServiceBase.OnStop%2A>应在创建<xref:System.ServiceProcess.ServiceBase.OnStart%2A>。 在构造函数中创建资源阻止它们被正确创建，如果服务启动后再次<xref:System.ServiceProcess.ServiceBase.OnStop%2A>具有已释放的资源。  
  
 服务控制管理器 (SCM) 提供了一种方法与服务进行交互。 可以使用 SCM 将传递到该服务的启动、 停止、 暂停、 继续或自定义命令。 SCM 将使用的值<xref:System.ServiceProcess.ServiceBase.CanStop%2A>和<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>来确定服务是否接受停止、 暂停或继续命令。 停止、 暂停和继续启用 SCM 的上下文菜单仅当在相应的属性<xref:System.ServiceProcess.ServiceBase.CanStop%2A>或<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`true`服务类中。 如果启用，则将命令传递到服务，并<xref:System.ServiceProcess.ServiceBase.OnStop%2A>， <xref:System.ServiceProcess.ServiceBase.OnPause%2A>，或<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>调用。 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>， <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>，或<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`，相应的命令处理方法 (如<xref:System.ServiceProcess.ServiceBase.OnStop%2A>) 将不会处理，即使已实现该方法。  
  
 可以使用<xref:System.ServiceProcess.ServiceController>类以编程方式执行 SCM 执行使用用户界面。 可以自动执行可在控制台中的任务。 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>， <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>，或<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`true`但尚未实现相应的命令处理方法 (如<xref:System.ServiceProcess.ServiceBase.OnStop%2A>) 系统引发异常，并将忽略该命令。  
  
 不需要实现<xref:System.ServiceProcess.ServiceBase.OnStart%2A>， <xref:System.ServiceProcess.ServiceBase.OnStop%2A>，或在任何其他方法<xref:System.ServiceProcess.ServiceBase>。 但是中, 介绍了服务的行为<xref:System.ServiceProcess.ServiceBase.OnStart%2A>，因此最小值，应重写此成员。 `main()`函数的可执行文件中注册服务可执行文件与服务控制管理器中，通过调用<xref:System.ServiceProcess.ServiceBase.Run%2A>方法。 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>的属性<xref:System.ServiceProcess.ServiceBase>对象传递给<xref:System.ServiceProcess.ServiceBase.Run%2A>方法必须与匹配<xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A>该服务的服务安装程序的属性。  
  
 可以使用`InstallUtil.exe`若要在系统上安装服务。  
  
> [!NOTE]
>  可以指定应用程序事件日志，以接收通知的服务调用，但未一个日志<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>也不<xref:System.ServiceProcess.ServiceBase.EventLog%2A>属性可以写入自定义日志。 设置<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>到`false`如果您不想要使用自动日志记录。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>创建 <see cref="T:System.ServiceProcess.ServiceBase" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不创建的实例<xref:System.ServiceProcess.ServiceBase>类。 相反，派生<xref:System.ServiceProcess.ServiceBase>和实例化派生的类。 您需要从继承的类的构造函数中实现所需的最低<xref:System.ServiceProcess.ServiceBase>是设置<xref:System.ServiceProcess.ServiceBase.ServiceName%2A>上你的组件。 没有任何其他处理专门所需的构造函数中。 应处理中的大多数初始化<xref:System.ServiceProcess.ServiceBase.OnStart%2A>而不是在构造函数中。 否则，则对象将被重新初始化后，重新启动服务已停止时无法保证。  
  
 如果您在派生类中重写构造函数，在代码中调用基类构造函数。  
  
 <xref:System.ServiceProcess.ServiceBase>构造函数设置<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>到`true`。 如果不希望自动登录到服务调用从服务控制管理器 (SCM)，设置<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>到`false`。  
  
 如果可执行文件包含单个服务，系统将开始从 SCM，选择和运行析构函数，如果调用停止时调用服务的构造函数。  
  
 如果可执行文件包含多个服务，调用一个服务上的启动会导致构造函数调用的所有服务在可执行文件，但仅在指定的服务已启动。 当所有服务都停止后，不单独每个服务都停止时，将一起运行的服务的析构函数。  
  
> [!NOTE]
>  如果重写基类构造函数，则应在派生类的构造函数中显式调用它。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLog : bool with get, set" Usage="System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示是否在事件日志中报告“开始”、“停止”、“暂停”以及“继续”命令。</summary>
        <value>为 <see langword="true" /> 时在事件日志中报告信息；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>到`true`指示服务启动、 停止、 暂停、 用于报告命令失败，以及状态更改信息在应用程序事件日志并继续在服务上的事件。 服务的名称用作日志的<xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>。  
  
 要向自定义事件日志而不是应用程序日志中报告的信息，请将<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>到`false`和写入命令处理方法中的说明<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>， <xref:System.ServiceProcess.ServiceBase.OnPause%2A>，或<xref:System.ServiceProcess.ServiceBase.OnStop%2A>要发布到相应的日志。  
  
> [!NOTE]
>  <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>，提供为事件日志中，源字符串必须之前服务将尝试写入事件日志设置。 尝试访问事件日志设置的源名称之前引发异常。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandlePowerEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示服务是否可以处理计算机电源状态更改通知。</summary>
        <value>如果服务处理 <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> 类中指示的计算机电源状态更改，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当计算机电源状态更改时，服务控制管理器 (SCM) 验证该服务是否接受使用的值的电源事件命令<xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>是`true`，则将命令传递到服务和<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>如果定义调用方法。 如果<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>未实现在派生类中，则 SCM 处理通过空基类电源事件<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此属性将在服务启动后被修改。</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandleSessionChangeEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示服务是否可以处理从终端服务器会话接收到的会话更改事件。</summary>
        <value>如果服务可以处理终端服务器会话更改事件，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">此属性将在服务启动后被修改。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanPauseAndContinue : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置指示服务是否可以暂停并再继续的值。</summary>
        <value>如果服务可以暂停，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值设置<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>服务的构造函数中的属性。  
  
 暂停服务后，它会停止正在进行的工作。 如果继续操作 （无论是通过服务控制管理器或以编程方式），该服务<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>运行。  
  
 暂停请求发送到服务可以节省系统资源。 暂停可能不会释放所有系统资源，但停止。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 并<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>通常实现来执行较少的处理比<xref:System.ServiceProcess.ServiceBase.OnStop%2A>和<xref:System.ServiceProcess.ServiceBase.OnStart%2A>。  
  
 当<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`true`，重写<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>以指定服务控制管理器 (SCM) 将暂停或继续请求传递给你的服务时应发生的处理。 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 应实现撤消中的处理<xref:System.ServiceProcess.ServiceBase.OnPause%2A>。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`、 SCM 不会传递暂停或继续向该服务，因此请求<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>即使它们实现不会调用方法。 在 SCM 中`Pause`并`Continue`控件被禁用时<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">服务已启动。 在服务启动后不能更改 <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> 属性。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanShutdown : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示系统关闭时是否应通知服务。</summary>
        <value>如果系统关闭时应通知服务，则为 <see langword="true" />；否则为 <see langword="false" />。  默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>是`true`，当系统关闭时通知该服务。 在关机，<xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>如果已实现派生类中调用方法。  
  
> [!NOTE]
>  仅系统应该会导致<xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>方法来执行; 该服务可以调用它，但建议不这样做。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">服务已启动。 在服务启动后不能更改 <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> 属性。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanStop : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示服务启动后是否可以停止。</summary>
        <value>如果服务可以停止并调用了 <see cref="M:System.ServiceProcess.ServiceBase.OnStop" /> 方法，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 服务控制管理器 (SCM) 服务上调用停止时，验证该服务是否接受停止命令使用的值<xref:System.ServiceProcess.ServiceBase.CanStop%2A>。 对于大多数服务的值<xref:System.ServiceProcess.ServiceBase.CanStop%2A>是`true`，但某些操作系统服务，例如，不允许用户将其停止。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>是`true`，停止命令传递给服务和<xref:System.ServiceProcess.ServiceBase.OnStop%2A>如果它定义调用方法。 如果<xref:System.ServiceProcess.ServiceBase.OnStop%2A>未在派生类中，停止命令通过空基类的 SCM 句柄实现<xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">服务已启动。 在服务启动后不能更改 <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> 属性。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>处置由 <see cref="T:System.ServiceProcess.ServiceBase" /> 占用的资源（内存除外）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用<xref:System.ServiceProcess.ServiceBase.Dispose%2A>派生类中 (也通过它在<xref:System.ServiceProcess.ServiceBase>类) 完成后使用派生的类。 <xref:System.ServiceProcess.ServiceBase.Dispose%2A>方法将使派生的类中不可用状态。 在调用<xref:System.ServiceProcess.ServiceBase.Dispose%2A>，必须释放对派生类的所有引用和<xref:System.ServiceProcess.ServiceBase>以便可以通过垃圾回收收回它们占用的内存。  
  
> [!NOTE]
>  始终调用<xref:System.ServiceProcess.ServiceBase.Dispose%2A>发布到类派生自最后一个引用之前<xref:System.ServiceProcess.ServiceBase>。 否则为资源<xref:System.ServiceProcess.ServiceBase>并且派生的类使用的将垃圾回收调用对象的析构函数之前不会释放。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 通常实现来处理中的代码<xref:System.ServiceProcess.ServiceBase.OnPause%2A>组合使用调用<xref:System.ServiceProcess.ServiceBase.Dispose%2A>。 如果您选择执行此操作在派生类中，惯例做法是实现<xref:System.ServiceProcess.ServiceBase.OnStart%2A>以分配任何<xref:System.ServiceProcess.ServiceBase.Dispose%2A>发布。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventLog : System.Diagnostics.EventLog" Usage="System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个事件日志，它可用于将服务命令调用的通知（如“开始”和“停止”）写入“应用程序”事件日志。</summary>
        <value>
          <see cref="T:System.Diagnostics.EventLog" /> 实例，它的源注册到 Application 日志中。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 构造函数初始化<xref:System.ServiceProcess.ServiceBase.EventLog%2A>属性设置为与实例<xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>和<xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType>属性集。 源是<xref:System.ServiceProcess.ServiceBase.ServiceName%2A>的服务和日志是计算机的应用程序日志。 这些值自动设置，不能更改的服务命令自动日志记录功能。  
  
 当<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>是`true`，启动、 停止、 暂停、 继续、 和自定义命令在应用程序事件日志中自动记录。 可以使用<xref:System.ServiceProcess.ServiceBase.EventLog%2A>属性将其他消息写入该日志。 组件调用<xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType>使用此<xref:System.ServiceProcess.ServiceBase.EventLog%2A>成员。  
  
 要向自定义事件日志而不是应用程序日志中报告的信息，请将<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>到`false`和写入命令处理方法中的说明<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>， <xref:System.ServiceProcess.ServiceBase.OnPause%2A>，或<xref:System.ServiceProcess.ServiceBase.OnStop%2A>要发布到相应的日志。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置服务的退出代码。</summary>
        <value>服务的退出代码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.ServiceProcess.ServiceBase.ExitCode%2A>属性在停止服务，以指示错误到服务控制管理器之前的非零值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberSignature Language="F#" Value="val mutable MaxNameLength : int" Usage="System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>指示服务名称的最大大小。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ServiceName 和 DisplayName 都具有在服务类上设置属性时，必须遵守的大小限制。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberSignature Language="F#" Value="abstract member OnContinue : unit -&gt; unit&#xA;override this.OnContinue : unit -&gt; unit" Usage="serviceBase.OnContinue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中实现时，<see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> 于“服务控制管理器”(SCM) 将“继续”命令发送到服务时运行。 指定要在服务暂停后恢复正常功能时采取的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 实现<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>镜像应用程序的响应<xref:System.ServiceProcess.ServiceBase.OnPause%2A>。 如果继续操作 （无论是通过服务控制台或以编程方式），该服务<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>处理运行，并在服务再次变为活动状态。  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 需要时重写<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>属性是`true`。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`、 SCM 不会传递暂停或继续向该服务，因此请求<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>即使它们实现不会调用方法。 在 SCM 中`Pause`并`Continue`控件被禁用时<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberSignature Language="F#" Value="abstract member OnCustomCommand : int -&gt; unit&#xA;override this.OnCustomCommand : int -&gt; unit" Usage="serviceBase.OnCustomCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">发送给服务的命令消息。</param>
        <summary>在派生类中实现时，<see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> 于“服务控制管理器”(SCM) 向服务传递自定义命令时执行。 指定要在具有指定参数值的命令出现时采取的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> 可以指定启动、 停止、 暂停和继续服务以外的其他功能。  
  
 SCM 不检查自定义的命令来验证服务是否支持`command`传入参数。 它自定义命令将直接传递到该服务。 如果该服务无法识别`command`参数，它不执行任何操作。  
  
 引发自定义命令<xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A>中的语句<xref:System.ServiceProcess.ServiceController>组件。 使用 switch 语句或 if...然后使用条件来处理在服务定义的自定义命令。  
  
 可以在你的应用程序中定义，也可以在中使用的自定义命令的唯一值<xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A>是指介于 128 到 255 之间。 低于 128 的整数对应于系统保留值。  
  
 如果<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>属性是`true`，自定义命令，与所有其他命令一样将条目写入到事件日志来报告该方法的执行是成功还是失败。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberSignature Language="F#" Value="abstract member OnPause : unit -&gt; unit&#xA;override this.OnPause : unit -&gt; unit" Usage="serviceBase.OnPause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中实现时，该方法于“服务控制管理器”(SCM) 将“暂停”命令发送到服务时执行。 指定要在服务暂停时采取的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.OnPause%2A>以指定在服务收到暂停命令时，会发生的处理。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 需要时重写<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>属性是`true`。  
  
 如果继续操作已暂停的服务 （不管是通过服务控制台或以编程方式），<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>运行时处理，并在服务再次变为活动状态。  
  
 暂停命令仅允许应用程序以对特定事件做出反应。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 没有任何影响到的服务，您不定义要执行的操作。  
  
 暂停请求发送到服务可以节省系统资源，因为暂停需要释放的所有系统资源。 例如，如果线程已开启，过程暂停服务，而不是停止它可以使线程能够保持打开状态，因此不需要时，服务仍然重新分配。 如果定义暂停释放所有系统资源，它类似于停止命令。  
  
 设置<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>到`true`，并重写<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>指定 SCM 将暂停或继续请求传递给你的服务时应发生的处理。 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 应实现撤消中的处理<xref:System.ServiceProcess.ServiceBase.OnPause%2A>。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`、 SCM 不会传递暂停或继续向该服务，因此请求<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>即使实现不会调用方法。 在 SCM 中`Pause`并`Continue`控件被禁用时<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>是`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="F#" Value="abstract member OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool&#xA;override this.OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool" Usage="serviceBase.OnPowerEvent powerStatus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">
          <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />，指示来自系统的有关电源状态的通知。</param>
        <summary>当在派生类中实现时，该方法于计算机电源状态更改时执行。 这适用于膝上型计算机进入挂起模式时的情况，该模式不同于系统关闭。</summary>
        <returns>当在派生类中实现时，应用程序的需要将确定要返回的值。 例如，如果传递了 <see langword="QuerySuspend" /> 广播状态，则可以通过返回 <see langword="false" /> 来使应用程序拒绝查询。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>指定发生时的系统事件中指示的处理<xref:System.ServiceProcess.PowerBroadcastStatus>发生枚举-例如，当计算机处于挂起模式，或者指示电池电量不足。  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> 需要时重写<xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>属性是`true`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit&#xA;override this.OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit" Usage="serviceBase.OnSessionChange changeDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" />
      </Parameters>
      <Docs>
        <param name="changeDescription">标识更改类型的结构。</param>
        <summary>从终端服务器会话接收到更改事件时执行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须设置<xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A>属性设置为`true`若要启用此方法的执行。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="serviceBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中实现时，该方法于系统即将关闭时执行。 该方法指定应在系统即将关闭前执行的处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>以指定在系统关闭时，会发生的处理。  
  
 仅当操作系统时已关闭，未在计算机处于关闭状态时，将发生此事件。  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> 需要时重写<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>属性是`true`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnStart : string[] -&gt; unit&#xA;override this.OnStart : string[] -&gt; unit" Usage="serviceBase.OnStart args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">启动命令传递的数据。</param>
        <summary>当在派生类中实现时，在下列情况下执行：在“服务控制管理器”(SCM) 向服务发送“开始”命令时，或者在操作系统启动时（对于自动启动的服务）。 指定服务启动时采取的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.OnStart%2A>以指定当服务接收 Start 命令时发生的处理。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 是在其中指定服务的行为的方法。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 可以采用自变量作为一种方式传递数据，但此使用情况很少见。  
  
> [!CAUTION]
>  不要使用构造函数来执行处理，应为<xref:System.ServiceProcess.ServiceBase.OnStart%2A>。 使用<xref:System.ServiceProcess.ServiceBase.OnStart%2A>来处理你的服务的所有初始化。 当应用程序的可执行文件时调用的构造函数运行时，不是在该服务运行时。 可执行文件运行之前<xref:System.ServiceProcess.ServiceBase.OnStart%2A>。 如果您继续，例如，构造函数不会再调用因为 SCM 已保留在内存中的对象。 如果<xref:System.ServiceProcess.ServiceBase.OnStop%2A>释放分配的构造函数中而不是在资源<xref:System.ServiceProcess.ServiceBase.OnStart%2A>，所需的资源不会创建第二个调用该服务时，将再次。  
  
 可以将服务设置为自动启动时重启计算机通过设置<xref:System.ServiceProcess.ServiceInstaller.StartType%2A>上服务的安装程序分发给<xref:System.ServiceProcess.ServiceStartMode.Automatic>。 在这种情况下，<xref:System.ServiceProcess.ServiceBase.OnStart%2A>则在系统启动时调用。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 应在派生类中重写。 服务很有用，<xref:System.ServiceProcess.ServiceBase.OnStart%2A>和<xref:System.ServiceProcess.ServiceBase.OnStop%2A>应同时实现服务类中。  
  
 处理中的服务的初始化参数<xref:System.ServiceProcess.ServiceBase.OnStart%2A>方法，不在 Main 方法中。 中的自变量`args`可以在服务控制台中服务的属性窗口中手动设置参数数组。 不保存在控制台中输入的参数;从控制面板启动该服务时，它们是一次性传递服务。 必须为自动启动该服务时存在的参数可以放入服务的注册表项的 ImagePath 字符串值 (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\  *\<服务名称 >*)。 您可以从注册表使用获取自变量<xref:System.Environment.GetCommandLineArgs%2A>方法，例如： `string[] imagePathArgs = Environment.GetCommandLineArgs();`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberSignature Language="F#" Value="abstract member OnStop : unit -&gt; unit&#xA;override this.OnStop : unit -&gt; unit" Usage="serviceBase.OnStop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中实现时，该方法于“服务控制管理器”(SCM) 将“停止”命令发送到服务时执行。 指定服务停止运行时采取的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.OnStop%2A>以指定当服务收到停止命令时发生的处理。  
  
 在 SCM 接收停止命令，它使用的值<xref:System.ServiceProcess.ServiceBase.CanStop%2A>以验证该服务是否接受停止命令。 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>是`true`，停止命令传递给服务，和<xref:System.ServiceProcess.ServiceBase.OnStop%2A>如果它定义调用方法。 如果<xref:System.ServiceProcess.ServiceBase.OnStop%2A>未实现在服务中，则 SCM 处理停止命令。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>是`false`，SCM 会忽略停止命令。 它不被传递给该服务。 停止命令返回，会引发异常。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 应在派生类中重写。 服务很有用，<xref:System.ServiceProcess.ServiceBase.OnStart%2A>和<xref:System.ServiceProcess.ServiceBase.OnStop%2A>应同时实现服务类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.RequestAdditionalTime : int -&gt; unit" Usage="serviceBase.RequestAdditionalTime milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">请求的时间（以毫秒为单位）。</param>
        <summary>为挂起操作请求额外的时间。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A>方法应调用的重写<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>， <xref:System.ServiceProcess.ServiceBase.OnPause%2A>， <xref:System.ServiceProcess.ServiceBase.OnStart%2A>，或<xref:System.ServiceProcess.ServiceBase.OnStop%2A>方法来请求更多时间为挂起的操作，以防止服务控制管理器 (SCM) 标记为未响应的服务。  如果不继续、 暂停、 启动和停止、 挂起操作<xref:System.InvalidOperationException>引发。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">服务不处于挂起状态。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为服务可执行文件提供主入口点。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">
          <see cref="T:System.ServiceProcess.ServiceBase" />，指示要启动的服务。</param>
        <summary>在服务控制管理器 (SCM) 中注册服务的可执行文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此重载`main()`可执行文件来注册该服务与服务控制管理器服务的功能。 调用后<xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>，服务控制管理器发出一个 Start 命令，这会导致调用<xref:System.ServiceProcess.ServiceBase.OnStart%2A>服务中的方法。 直到执行启动命令，该服务才会开始。  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType>方法调用方法与大致相同<xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType>Windows 窗体应用程序。  
  
 如果<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>是`true`，向事件日志写入一个条目，如果指定的服务`service`参数无法启动。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="service" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase[] -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run services" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">一组 ServiceBase 实例，指示要启动的服务。</param>
        <summary>在服务控制管理器 (SCM) 中注册多项服务的可执行文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此重载`main()`可执行文件中注册这些服务与服务控制管理器服务的功能。 调用后<xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>，服务控制管理器发出启动命令，这会导致调用<xref:System.ServiceProcess.ServiceBase.OnStart%2A>中服务的方法。 直到执行 Start 命令后不会启动服务。  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType>方法调用方法与大致相同<xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType>Windows 窗体应用程序的方法。  
  
 如果<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>是`true`，向事件日志写入一个条目，如果数组中的任何服务无法启动。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">未提供要启动的服务。 该数组可能为 <see langword="null" /> 或空。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceHandle : nativeint" Usage="System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取服务的服务控制句柄。</summary>
        <value>一个 <see cref="T:System.IntPtr" /> 结构，包含服务的服务控制句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 服务控制句柄用于通信的服务控制管理器 (SCM)。  句柄可用于更新为使用非托管调用服务的服务控制管理器的状态信息`SetServiceStatus`函数。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于访问非托管代码。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberSignature Language="F#" Value="member this.ServiceMainCallback : int * nativeint -&gt; unit" Usage="serviceBase.ServiceMainCallback (argCount, argPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" />
        <Parameter Name="argPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="argCount">参数数组中的参数个数。</param>
        <param name="argPointer">指向参数数组的 <see cref="T:System.IntPtr" /> 结构。</param>
        <summary>注册命令处理程序并启动服务。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string with get, set" Usage="System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于向系统标识服务的简短名称。</summary>
        <value>服务的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>标识服务到服务控制管理器。 此属性的值必须与记录中的服务的名称相同<xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType>相应的安装程序类的属性。 在代码中，<xref:System.ServiceProcess.ServiceBase.ServiceName%2A>通常设置服务的`main()`函数的可执行文件。  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>还用于指定<xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>与关联<xref:System.ServiceProcess.ServiceBase.EventLog%2A>属性。 这<xref:System.ServiceProcess.ServiceBase.EventLog%2A>是服务的命令信息写入应用程序日志的实例。  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>，提供事件日志中，源字符串必须先在服务写入事件日志设置。 尝试访问事件日志之前设置的源名称会导致引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">服务已启动。 在服务启动后不能更改 <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> 属性。</exception>
        <exception cref="T:System.ArgumentException">指定的名称为零长度字符串，或长于 <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" />，就或者指定的名称包含前斜线或后斜线字符。</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="serviceBase.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>停止执行服务。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.Stop%2A>方法设置的服务状态，以表示停止处于挂起状态和调用<xref:System.ServiceProcess.ServiceBase.OnStop%2A>方法。  停止应用程序后，服务状态将设置为已停止。 如果应用程序是托管的服务，则卸载应用程序域。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>