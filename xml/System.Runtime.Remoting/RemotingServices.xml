<Type Name="RemotingServices" FullName="System.Runtime.Remoting.RemotingServices">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="df34dbf51b8244075b3c3956ad39257e19561998" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51939937" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class RemotingServices" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed RemotingServices extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingServices" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingServices" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingServices abstract sealed" />
  <TypeSignature Language="F#" Value="type RemotingServices = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="e5eba-101">提供多种使用和发布远程对象及代理的方法。</span>
      <span class="sxs-lookup">
        <span data-stu-id="e5eba-101">Provides several methods for using and publishing remoted objects and proxies.</span>
      </span>
      <span data-ttu-id="e5eba-102">此类不能被继承。</span>
      <span class="sxs-lookup">
        <span data-stu-id="e5eba-102">This class cannot be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-103">除非您是服务提供程序处理激活、 生存期管理或事务等的问题，您不需要区分代理引用和对象引用。</span><span class="sxs-lookup"><span data-stu-id="e5eba-103">Unless you are a service provider dealing with issues such as activation, lifetime management, or transactions, you do not need to distinguish between proxy references and object references.</span></span> <span data-ttu-id="e5eba-104">远程处理基础结构使用意味着远程对象驻留在客户端的空间的透明代理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-104">The remoting infrastructure uses transparent proxies that give the impression that the remote objects reside in the client's space.</span></span> <span data-ttu-id="e5eba-105">代理转发到远程位置的实际对象对其进行的调用来实现此目的。</span><span class="sxs-lookup"><span data-stu-id="e5eba-105">Proxies achieve this by forwarding calls made on them to the real objects at remote locations.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e5eba-106">为已知对象创建一个代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-106">Creates a proxy for a well-known object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classToProxy">
          <span data-ttu-id="e5eba-107">要连接到的位于服务器端的已知对象的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-107">The <see cref="T:System.Type" /> of a well-known object on the server end to which you want to connect.</span>
          </span>
        </param>
        <param name="url">
          <span data-ttu-id="e5eba-108">服务器类的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-108">The URL of the server class.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-109">使用给定的 <see cref="T:System.Type" /> 和 URL，为已知对象创建一个代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-109">Creates a proxy for a well-known object, given the <see cref="T:System.Type" /> and URL.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-110">远程对象的代理，指向由指定的已知对象提供的终结点。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-110">A proxy to the remote object that points to an endpoint served by the specified well-known object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-111">返回的代理对象指向由指定的已知对象提供服务的终结点。</span><span class="sxs-lookup"><span data-stu-id="e5eba-111">The returned proxy object points to an endpoint served by the specified well-known object.</span></span> <span data-ttu-id="e5eba-112">在代理上调用方法之前，是通过网络不发送任何消息。</span><span class="sxs-lookup"><span data-stu-id="e5eba-112">No messages are sent over the network until a method is called on the proxy.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5eba-113">下面的代码示例演示如何使用<xref:System.Runtime.Remoting.RemotingServices.Connect%2A>方法创建的已知对象的代理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-113">The following code example demonstrates how to use the <xref:System.Runtime.Remoting.RemotingServices.Connect%2A> method to create a proxy to a well-known object.</span></span>  
  
 [!code-cpp[RemotingServices.BasicSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/basicclient.cpp#1)]
 [!code-csharp[RemotingServices.BasicSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/basicclient.cs#1)]
 [!code-vb[RemotingServices.BasicSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/basicclient.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-114">直接调用方没有配置远程处理类型和通道的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-114">The immediate caller does not have permission to configure remoting types and channels.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-115">用于配置的远程处理基础结构。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-115">for configuration of the remoting infrastructure.</span>
          </span>
          <span data-ttu-id="e5eba-116">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-116">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String, data As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string * obj -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="classToProxy">
          <span data-ttu-id="e5eba-117">要连接到的已知对象的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-117">The <see cref="T:System.Type" /> of the well-known object to which you want to connect.</span>
          </span>
        </param>
        <param name="url">
          <span data-ttu-id="e5eba-118">已知对象的 URL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-118">The URL of the well-known object.</span>
          </span>
        </param>
        <param name="data">
          <span data-ttu-id="e5eba-119">信道特定的数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-119">Channel specific data.</span>
          </span>
          <span data-ttu-id="e5eba-120">可以为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-120">Can be <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-121">使用给定的 <see cref="T:System.Type" />、URL 和信道特定数据，为已知对象创建一个代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-121">Creates a proxy for a well-known object, given the <see cref="T:System.Type" />, URL, and channel-specific data.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-122">指向由所请求的已知对象提供的终结点的代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-122">A proxy that points to an endpoint that is served by the requested well-known object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-123">返回的代理对象指向由指定的已知对象提供服务的终结点。</span><span class="sxs-lookup"><span data-stu-id="e5eba-123">The returned proxy object points to an endpoint served by the specified well-known object.</span></span> <span data-ttu-id="e5eba-124">在代理上调用方法之前，是通过网络不发送任何消息。</span><span class="sxs-lookup"><span data-stu-id="e5eba-124">No messages are sent over the network until a method is called on the proxy.</span></span>  
  
 <span data-ttu-id="e5eba-125">`data`对象用于将信息传递给通道，并被传递到<xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="e5eba-125">The `data` object is used to communicate information to the channel, and is passed to the <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-126">直接调用方没有配置远程处理类型和通道的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-126">The immediate caller does not have permission to configure remoting types and channels.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-127">用于配置的远程处理基础结构。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-127">for configuration of the remoting infrastructure.</span>
          </span>
          <span data-ttu-id="e5eba-128">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-128">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public static bool Disconnect (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Disconnect(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Disconnect (obj As MarshalByRefObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Disconnect(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member Disconnect : MarshalByRefObject -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.Disconnect obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="e5eba-129">要与其信道断开连接的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-129">Object to disconnect from its channel.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-130">阻止对象通过注册的远程处理信道再接收任何消息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-130">Stops an object from receiving any further messages through the registered remoting channels.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-131">如果对象与注册的远程处理信道成功断开连接，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-131">
              <see langword="true" /> if the object was disconnected from the registered remoting channels successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e5eba-132">下面的代码示例演示如何使用<xref:System.Runtime.Remoting.RemotingServices.Disconnect%2A>方法断开与远程处理信道的连接对象。</span><span class="sxs-lookup"><span data-stu-id="e5eba-132">The following code example demonstrates how to use the <xref:System.Runtime.Remoting.RemotingServices.Disconnect%2A> method to disconnect an object from the remoting channels.</span></span>  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e5eba-133">
            <paramref name="obj" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-133">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e5eba-134">
            <paramref name="obj" /> 参数是一个代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-134">The <paramref name="obj" /> parameter is a proxy.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-135">直接调用方没有配置远程处理类型和通道的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-135">The immediate caller does not have permission to configure remoting types and channels.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-136">用于配置的远程处理基础结构。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-136">for configuration of the remoting infrastructure.</span>
          </span>
          <span data-ttu-id="e5eba-137">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-137">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMessage">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage(class System.MarshalByRefObject target, class System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExecuteMessage (target As MarshalByRefObject, reqMsg As IMethodCallMessage) As IMethodReturnMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMethodReturnMessage ^ ExecuteMessage(MarshalByRefObject ^ target, System::Runtime::Remoting::Messaging::IMethodCallMessage ^ reqMsg);" />
      <MemberSignature Language="F#" Value="static member ExecuteMessage : MarshalByRefObject * System.Runtime.Remoting.Messaging.IMethodCallMessage -&gt; System.Runtime.Remoting.Messaging.IMethodReturnMessage" Usage="System.Runtime.Remoting.RemotingServices.ExecuteMessage (target, reqMsg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMethodReturnMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.MarshalByRefObject" />
        <Parameter Name="reqMsg" Type="System.Runtime.Remoting.Messaging.IMethodCallMessage" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="e5eba-138">要调用其方法的远程对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-138">The remote object whose method you want to call.</span>
          </span>
        </param>
        <param name="reqMsg">
          <span data-ttu-id="e5eba-139">指定的远程对象的方法的方法调用消息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-139">A method call message to the specified remote object's method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-140">连接到指定的远程对象，并对其执行提供的 <see cref="T:System.Runtime.Remoting.Messaging.IMethodCallMessage" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-140">Connects to the specified remote object, and executes the provided <see cref="T:System.Runtime.Remoting.Messaging.IMethodCallMessage" /> on it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-141">远程方法的响应。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-141">The response of the remote method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-142">当前方法用于在特殊情况下由服务器转发到另一个可能是远程对象指定的方法调用。</span><span class="sxs-lookup"><span data-stu-id="e5eba-142">The current method is used in special cases by the server to forward the specified method call to another, possibly remote, object.</span></span> <span data-ttu-id="e5eba-143">仅当调用方是适当的上下文中时，可以调用此方法。</span><span class="sxs-lookup"><span data-stu-id="e5eba-143">This method can be called only when the caller is in the appropriate context.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5eba-144">下面的代码示例演示如何使用<xref:System.Runtime.Remoting.RemotingServices.ExecuteMessage%2A>方法转发对远程对象的方法调用。</span><span class="sxs-lookup"><span data-stu-id="e5eba-144">The following code example demonstrates how to use the <xref:System.Runtime.Remoting.RemotingServices.ExecuteMessage%2A> method to forward method calls to remote objects.</span></span>  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-145">直接调用方没有基础结构权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-145">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <span data-ttu-id="e5eba-146">该方法从除对象的本机上下文之外的上下文调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-146">The method was called from a context other than the native context of the object.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-147">用于操作的基础结构代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-147">for operating with infrastructure code.</span>
          </span>
          <span data-ttu-id="e5eba-148">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-148">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnvoyChainForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvoyChainForProxy (obj As MarshalByRefObject) As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMessageSink ^ GetEnvoyChainForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetEnvoyChainForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="e5eba-149">与请求的 Envoy 接收器关联的远程对象的代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-149">The proxy of the remote object that requested envoy sinks are associated with.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-150">返回在将消息发送到指定的代理所表示的远程对象时应使用的一系列 Envoy 接收器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-150">Returns a chain of envoy sinks that should be used when sending messages to the remote object represented by the specified proxy.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-151">与指定的代理关联的一系列 Envoy 接收器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-151">A chain of envoy sinks associated with the specified proxy.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-152">Envoy 接收器是接收器发送连同<xref:System.Runtime.Remoting.ObjRef>时向该对象返回消息使用的对象。</span><span class="sxs-lookup"><span data-stu-id="e5eba-152">Envoy sinks are sinks sent along with the <xref:System.Runtime.Remoting.ObjRef> of an object that is used when returning messages to that object.</span></span> <span data-ttu-id="e5eba-153">当前方法将返回的对象的代理服务器和对象本身之间进行通信时使用的 envoy 接收器。</span><span class="sxs-lookup"><span data-stu-id="e5eba-153">The current method returns the envoy sinks that are used during communication between the proxy of the object and the object itself.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-154">直接调用方没有基础结构权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-154">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-155">用于操作的基础结构代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-155">for operating with infrastructure code.</span>
          </span>
          <span data-ttu-id="e5eba-156">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-156">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.Remoting.IEnvoyInfo" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public static object GetLifetimeService (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLifetimeService(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLifetimeService (obj As MarshalByRefObject) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLifetimeService(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetLifetimeService : MarshalByRefObject -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.GetLifetimeService obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="e5eba-157">为其获得生存期服务的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-157">The object to obtain lifetime service for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-158">返回控制指定对象的生存期策略的生存期服务对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-158">Returns a lifetime service object that controls the lifetime policy of the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-159">控制 <paramref name="obj" /> 的生存期的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-159">The object that controls the lifetime of <paramref name="obj" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-160">对于默认生存期服务返回的对象将类型的对象<xref:System.Runtime.Remoting.Lifetime.ILease>。</span><span class="sxs-lookup"><span data-stu-id="e5eba-160">For the default lifetime service the returned object will be an object of type <xref:System.Runtime.Remoting.Lifetime.ILease>.</span></span> <span data-ttu-id="e5eba-161">如果`obj`参数是`null`，该方法将返回`null`。</span><span class="sxs-lookup"><span data-stu-id="e5eba-161">If the `obj` parameter is `null`, the method returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5eba-162">下面的代码示例演示如何使用<xref:System.Runtime.Remoting.RemotingServices.GetLifetimeService%2A>方法以获取指定对象的生存期租约。</span><span class="sxs-lookup"><span data-stu-id="e5eba-162">The following code example demonstrates how to use the <xref:System.Runtime.Remoting.RemotingServices.GetLifetimeService%2A> method to get a lifetime lease for the specified object.</span></span>  
  
 [!code-cpp[RemotingServices.TimerSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.TimerSample/CPP/timerclient.cpp#1)]
 [!code-csharp[RemotingServices.TimerSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerclient.cs#1)]
 [!code-vb[RemotingServices.TimerSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerclient.vb#1)]  
  
 <span data-ttu-id="e5eba-163">若要编译并运行此示例中，将需要进行编译和运行服务器、 timerserver.exe 和编译是共享库，timerservice.dll。</span><span class="sxs-lookup"><span data-stu-id="e5eba-163">To compile and run this example, you will need to compile and run a server, timerserver.exe, and compile a shared library, timerservice.dll.</span></span>  
  
 <span data-ttu-id="e5eba-164">Timerserver.exe 的源如下所示：</span><span class="sxs-lookup"><span data-stu-id="e5eba-164">The source for timerserver.exe follows:</span></span>  
  
 [!code-csharp[RemotingServices.TimerSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerserver.cs#2)]
 [!code-vb[RemotingServices.TimerSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerserver.vb#2)]  
  
 <span data-ttu-id="e5eba-165">Timerservice.dll 的源如下所示：</span><span class="sxs-lookup"><span data-stu-id="e5eba-165">The source for timerservice.dll follows:</span></span>  
  
 [!code-csharp[RemotingServices.TimerSample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerservice.cs#3)]
 [!code-vb[RemotingServices.TimerSample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerservice.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-166">直接调用方没有基础结构权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-166">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-167">用于操作的基础结构代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-167">for operating with infrastructure code.</span>
          </span>
          <span data-ttu-id="e5eba-168">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-168">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBaseFromMethodMessage">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodBaseFromMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodBaseFromMethodMessage (msg As IMethodMessage) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodBaseFromMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetMethodBaseFromMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; System.Reflection.MethodBase" Usage="System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">
          <span data-ttu-id="e5eba-169">从其中提取方法库的方法消息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-169">The method message to extract the method base from.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-170">从给定的 <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> 返回方法库。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-170">Returns the method base from the given <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-171">从 <paramref name="msg" /> 参数提取的方法库。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-171">The method base extracted from the <paramref name="msg" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-172">这会确定从基本的方法<xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>， <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>，并<xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A>的属性<xref:System.Runtime.Remoting.Messaging.IMethodMessage>，并由类实现<xref:System.Runtime.Remoting.Messaging.IMethodMessage>接口。</span><span class="sxs-lookup"><span data-stu-id="e5eba-172">This determines the method base from the <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>, <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>, and <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> properties of <xref:System.Runtime.Remoting.Messaging.IMethodMessage> and is used by classes implementing the <xref:System.Runtime.Remoting.Messaging.IMethodMessage> interface.</span></span> <span data-ttu-id="e5eba-173">使用者<xref:System.Runtime.Remoting.Messaging.IMethodMessage>类应引用<xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=nameWithType>属性。</span><span class="sxs-lookup"><span data-stu-id="e5eba-173">Consumers of <xref:System.Runtime.Remoting.Messaging.IMethodMessage> classes should reference the <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-174">直接调用方没有基础结构权限，或者调用堆栈上部至少有一个调用方没有检索非公共成员的类型信息的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-174">Either the immediate caller does not have infrastructure permission, or at least one of the callers higher in the callstack does not have permission to retrieve the type information of non-public members.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-175">用于操作的基础结构代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-175">for operating with infrastructure code.</span>
          </span>
          <span data-ttu-id="e5eba-176">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-176">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetObjectData(object obj, class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetObjectData (obj As Object, info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetObjectData(System::Object ^ obj, System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="static member GetObjectData : obj * System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.GetObjectData (obj, info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="e5eba-177">要序列化的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-177">The object to serialize.</span>
          </span>
        </param>
        <param name="info">
          <span data-ttu-id="e5eba-178">将对象序列化为的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-178">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> into which the object is serialized.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="e5eba-179">序列化的源和目标。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-179">The source and destination of the serialization.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-180">按引用对象将指定封送序列化为所提供的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-180">Serializes the specified marshal by reference object into the provided <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e5eba-181">
            <paramref name="obj" /> 或 <paramref name="info" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-181">The <paramref name="obj" /> or <paramref name="info" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-182">直接调用方没有基础结构权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-182">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-183">用于操作的基础结构代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-183">for operating with infrastructure code.</span>
          </span>
          <span data-ttu-id="e5eba-184">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-184">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectUri">
      <MemberSignature Language="C#" Value="public static string GetObjectUri (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetObjectUri(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectUri (obj As MarshalByRefObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetObjectUri(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectUri : MarshalByRefObject -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetObjectUri obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="e5eba-185">为其请求 URI 的 <see cref="T:System.MarshalByRefObject" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-185">The <see cref="T:System.MarshalByRefObject" /> for which a URI is requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-186">为指定的对象检索 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-186">Retrieves the URI for the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-187">如果指定的对象具有 URI，则为该对象的 URI；或者如果该对象尚未被封送，则为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-187">The URI of the specified object if it has one, or <see langword="null" /> if the object has not yet been marshaled.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#18)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#18)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-188">直接调用方没有基础结构权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-188">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-189">用于操作的基础结构代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-189">for operating with infrastructure code.</span>
          </span>
          <span data-ttu-id="e5eba-190">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-190">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjRefForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef GetObjRefForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjRefForProxy (obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ GetObjRefForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjRefForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.GetObjRefForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="e5eba-191">一个代理，连接到要为其创建 <see cref="T:System.Runtime.Remoting.ObjRef" /> 的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-191">A proxy connected to the object you want to create a <see cref="T:System.Runtime.Remoting.ObjRef" /> for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-192">从指定的代理返回表示远程对象的 <see cref="T:System.Runtime.Remoting.ObjRef" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-192">Returns the <see cref="T:System.Runtime.Remoting.ObjRef" /> that represents the remote object from the specified proxy.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-193">
            <see cref="T:System.Runtime.Remoting.ObjRef" />，它表示指定的代理要连接到的远程对象；或者如果对象或代理未被封送，则为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-193">A <see cref="T:System.Runtime.Remoting.ObjRef" /> that represents the remote object the specified proxy is connected to, or <see langword="null" /> if the object or proxy have not been marshaled.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-194">一个<xref:System.Runtime.Remoting.ObjRef>是用于跨应用程序域边界传输的对象引用的对象的可序列化表示形式。</span><span class="sxs-lookup"><span data-stu-id="e5eba-194">A <xref:System.Runtime.Remoting.ObjRef> is a serializable representation of an object used to transfer an object reference across an application domain boundary.</span></span> <span data-ttu-id="e5eba-195">创建<xref:System.Runtime.Remoting.ObjRef>的对象称为封送处理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-195">Creating a <xref:System.Runtime.Remoting.ObjRef> for an object is known as marshaling.</span></span> <span data-ttu-id="e5eba-196"><xref:System.Runtime.Remoting.ObjRef>可以通过信道传输到另一个应用程序域 （可能在另一个进程或计算机）。</span><span class="sxs-lookup"><span data-stu-id="e5eba-196">The <xref:System.Runtime.Remoting.ObjRef> can be transferred through a channel into another application domain (possibly on another process or computer).</span></span> <span data-ttu-id="e5eba-197">其他应用程序域中一次<xref:System.Runtime.Remoting.ObjRef>必须对其进行分析，以创建通常连接到真实的对象的对象的代理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-197">Once in the other application domain, the <xref:System.Runtime.Remoting.ObjRef> must be parsed to create a proxy for the object, generally connected to the real object.</span></span> <span data-ttu-id="e5eba-198">此操作称为取消。</span><span class="sxs-lookup"><span data-stu-id="e5eba-198">This operation is known as unmarshaling.</span></span> <span data-ttu-id="e5eba-199">在取消过程<xref:System.Runtime.Remoting.ObjRef>分析提取方法信息的远程对象和透明代理和<xref:System.Runtime.Remoting.Proxies.RealProxy>创建对象。</span><span class="sxs-lookup"><span data-stu-id="e5eba-199">During unmarshaling, the <xref:System.Runtime.Remoting.ObjRef> is parsed to extract the method information of the remote object and both the transparent proxy and <xref:System.Runtime.Remoting.Proxies.RealProxy> objects are created.</span></span>  
  
 <span data-ttu-id="e5eba-200">一个<xref:System.Runtime.Remoting.ObjRef>包含描述信息<xref:System.Type>被封送处理的对象类，URI 用于唯一标识的特定对象实例和通信相关的有关如何访问远程应用程序的信息和位置对象所在。</span><span class="sxs-lookup"><span data-stu-id="e5eba-200">A <xref:System.Runtime.Remoting.ObjRef> contains information that describes the <xref:System.Type> and class of the object being marshaled, a URI that uniquely identifies the specific object instance, and communication related information about how to reach the remote application where the object is located.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5eba-201">下面的代码示例演示如何获取<xref:System.Runtime.Remoting.ObjRef>指定的对象的实例。</span><span class="sxs-lookup"><span data-stu-id="e5eba-201">The following code example demonstrates how to get a <xref:System.Runtime.Remoting.ObjRef> instance for the specified object.</span></span>  
  
 [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CPP/client.cpp#1)]
 [!code-csharp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CS/client.cs#1)]
 [!code-vb[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-202">直接调用方没有基础结构权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-202">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-203">用于操作的基础结构代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-203">for operating with infrastructure code.</span>
          </span>
          <span data-ttu-id="e5eba-204">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-204">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetRealProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Proxies.RealProxy GetRealProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRealProxy (proxy As Object) As RealProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Proxies::RealProxy ^ GetRealProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member GetRealProxy : obj -&gt; System.Runtime.Remoting.Proxies.RealProxy" Usage="System.Runtime.Remoting.RemotingServices.GetRealProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Proxies.RealProxy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">
          <span data-ttu-id="e5eba-205">透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-205">A transparent proxy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-206">返回指定透明代理后面的真实代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-206">Returns the real proxy backing the specified transparent proxy.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-207">透明代理后面的真实代理实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-207">The real proxy instance backing the transparent proxy.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-208">使用一个对象，可跨任何类型的远程处理边界的客户端实际上通过的对象的透明代理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-208">A client that uses an object across any kind of remoting boundary is actually using a transparent proxy for the object.</span></span> <span data-ttu-id="e5eba-209">透明代理让人觉得实际对象驻留在客户端的空间。</span><span class="sxs-lookup"><span data-stu-id="e5eba-209">The transparent proxy gives the impression that the actual object resides in the client's space.</span></span> <span data-ttu-id="e5eba-210">通过将转发到使用远程处理基础结构的实际对象对其所做的调用来实现这。</span><span class="sxs-lookup"><span data-stu-id="e5eba-210">It achieves this by forwarding calls made on it to the real object using the remoting infrastructure.</span></span>  
  
 <span data-ttu-id="e5eba-211">由类型的托管运行时类的实例提供支持的透明代理<xref:System.Runtime.Remoting.Proxies.RealProxy>。</span><span class="sxs-lookup"><span data-stu-id="e5eba-211">The transparent proxy is backed by an instance of a managed runtime class of type <xref:System.Runtime.Remoting.Proxies.RealProxy>.</span></span> <span data-ttu-id="e5eba-212"><xref:System.Runtime.Remoting.Proxies.RealProxy>实现从透明代理转发操作所需的功能的一部分。</span><span class="sxs-lookup"><span data-stu-id="e5eba-212">The <xref:System.Runtime.Remoting.Proxies.RealProxy> implements a part of the functionality needed to forward the operations from the transparent proxy.</span></span>  
  
 <span data-ttu-id="e5eba-213">代理对象继承的托管对象，如垃圾回收相关联的语义和支持成员和方法，可以扩展到新窗体的类。</span><span class="sxs-lookup"><span data-stu-id="e5eba-213">A proxy object inherits the associated semantics of managed objects such as garbage collection, support for members and methods, and can be extended to form new classes.</span></span> <span data-ttu-id="e5eba-214">代理可作为远程对象 （透明代理），与相同的类的对象，也是一个托管的对象。</span><span class="sxs-lookup"><span data-stu-id="e5eba-214">The proxy acts as an object of the same class as the remote object (transparent proxy), and is also a managed object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-215">直接调用方没有基础结构权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-215">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-216">用于操作的基础结构代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-216">for operating with infrastructure code.</span>
          </span>
          <span data-ttu-id="e5eba-217">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-217">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetServerTypeForUri">
      <MemberSignature Language="C#" Value="public static Type GetServerTypeForUri (string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetServerTypeForUri(string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetServerTypeForUri (URI As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetServerTypeForUri(System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member GetServerTypeForUri : string -&gt; Type" Usage="System.Runtime.Remoting.RemotingServices.GetServerTypeForUri URI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="URI">
          <span data-ttu-id="e5eba-218">请求其 <see cref="T:System.Type" /> 的对象的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-218">The URI of the object whose <see cref="T:System.Type" /> is requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-219">返回具有指定 URI 的对象的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-219">Returns the <see cref="T:System.Type" /> of the object with the specified URI.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-220">具有指定 URI 的对象的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-220">The <see cref="T:System.Type" /> of the object with the specified URI.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-221">远程处理标识在终结点使用 Uri，因为<xref:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri%2A>方法是在使用远程处理基础结构 （例如，信道接收器、 动态接收器和上下文接收器） 的可插入部分中非常有用<xref:System.Runtime.Remoting.Messaging.IMessage>对象，因为当前方法从 URI 将返回关联的类型对象。</span><span class="sxs-lookup"><span data-stu-id="e5eba-221">Because remoting identifies endpoints using URIs, the <xref:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri%2A> method is very useful in the pluggable parts of the remoting infrastructure (for example, channel sinks, dynamic sinks, and context sinks) that use <xref:System.Runtime.Remoting.Messaging.IMessage> objects, because the current method will return the associated type object from the URI.</span></span>  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#7)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#7)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-222">直接调用方没有基础结构权限，或者调用堆栈上部至少有一个调用方没有检索非公共成员的类型信息的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-222">Either the immediate caller does not have infrastructure permission, or at least one of the callers higher in the callstack does not have permission to retrieve the type information of non-public members.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-223">用于操作的基础结构代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-223">for operating with infrastructure code.</span>
          </span>
          <span data-ttu-id="e5eba-224">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-224">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="e5eba-225">若要检索的非公共成员的类型信息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-225">to retrieve the type information of non-public members.</span>
          </span>
          <span data-ttu-id="e5eba-226">要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-226">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Permission value: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetSessionIdForMethodMessage">
      <MemberSignature Language="C#" Value="public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetSessionIdForMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSessionIdForMethodMessage (msg As IMethodMessage) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetSessionIdForMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetSessionIdForMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">
          <span data-ttu-id="e5eba-227">为其请求会话 ID 的 <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-227">The <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> for which a session ID is requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-228">检索消息的会话 ID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-228">Retrieves a session ID for a message.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-229">唯一标识当前会话的会话 ID 字符串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-229">A session ID string that uniquely identifies the current session.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-230">可能在同一应用程序中使用对象返回相同的会话 ID，但此方法将永远不会返回不同的远程应用程序中的两个对象相同的会话 ID。</span><span class="sxs-lookup"><span data-stu-id="e5eba-230">The same session ID might be returned for objects in the same application, but this method will never return the same session ID for two objects in different remote applications.</span></span>  
  
 <span data-ttu-id="e5eba-231">有关会话和会话 Id 标识的详细信息，请参阅 ASP.Net [ASP.NET 会话状态概述](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc)。</span><span class="sxs-lookup"><span data-stu-id="e5eba-231">For more information about identifying sessions and session IDs, see ASP.Net [ASP.NET Session State Overview](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5eba-232">下面的代码示例演示如何获取当前会话的会话 ID 字符串。</span><span class="sxs-lookup"><span data-stu-id="e5eba-232">The following code example demonstrates how to get the session ID string for the current session.</span></span>  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-233">直接调用方没有基础结构权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-233">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-234">用于操作的基础结构代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-234">for operating with infrastructure code.</span>
          </span>
          <span data-ttu-id="e5eba-235">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-235">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IsMethodOverloaded">
      <MemberSignature Language="C#" Value="public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMethodOverloaded(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMethodOverloaded (msg As IMethodMessage) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMethodOverloaded(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member IsMethodOverloaded : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsMethodOverloaded msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">
          <span data-ttu-id="e5eba-236">包含对上述方法的调用的消息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-236">The message that contains a call to the method in question.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-237">返回一个布尔值，该值指示是否重载给定消息中的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-237">Returns a Boolean value that indicates whether the method in the given message is overloaded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-238">如果重载 <paramref name="msg" /> 中调用的方法，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-238">
              <see langword="true" /> if the method called in <paramref name="msg" /> is overloaded; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-239">直接调用方没有基础结构权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-239">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-240">用于操作的基础结构代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-240">for operating with infrastructure code.</span>
          </span>
          <span data-ttu-id="e5eba-241">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-241">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfAppDomain">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfAppDomain (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfAppDomain(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfAppDomain (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfAppDomain(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfAppDomain : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">
          <span data-ttu-id="e5eba-242">要检查的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-242">The object to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-243">返回一个布尔值，该值指示给定透明代理指定的对象是否包含在与调用当前方法的对象不同的应用程序域中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-243">Returns a Boolean value that indicates whether the object specified by the given transparent proxy is contained in a different application domain than the object that called the current method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-244">如果该对象在当前应用程序域之外，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-244">
              <see langword="true" /> if the object is out of the current application domain; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-245">有关应用程序域的信息，请参阅[应用程序域](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90))。</span><span class="sxs-lookup"><span data-stu-id="e5eba-245">For information about application domains, see [Application Domains](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)).</span></span>  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">
          <span data-ttu-id="e5eba-246">应用程序域</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-246">Application Domains</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfContext">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfContext (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfContext(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfContext (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfContext(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfContext : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">
          <span data-ttu-id="e5eba-247">要检查的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-247">The object to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-248">返回一个布尔值，该值指示给定代理表示的对象是否包含在与调用当前方法的对象不同的上下文中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-248">Returns a Boolean value that indicates whether the object represented by the given proxy is contained in a different context than the object that called the current method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-249">如果该对象在当前上下文之外，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-249">
              <see langword="true" /> if the object is out of the current context; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-250">上下文是定义一个环境，用于驻留在其中的对象的属性有序的序列。</span><span class="sxs-lookup"><span data-stu-id="e5eba-250">A context is an ordered sequence of properties that define an environment for the objects that reside inside it.</span></span> <span data-ttu-id="e5eba-251">配置为要求某些自动服务，此类同步、 事务、 在实时激活、 安全性和等等的对象在激活过程会创建上下文。</span><span class="sxs-lookup"><span data-stu-id="e5eba-251">Contexts are created during the activation process for objects that are configured to require certain automatic services such synchronization, transactions, just-in-time activation, security, and so on.</span></span> <span data-ttu-id="e5eba-252">多个对象可以存留在一个上下文内。</span><span class="sxs-lookup"><span data-stu-id="e5eba-252">Multiple objects can live inside a context.</span></span>  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Contexts.Context" />
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public static bool IsOneWay (System.Reflection.MethodBase method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOneWay(class System.Reflection.MethodBase method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOneWay (method As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOneWay(System::Reflection::MethodBase ^ method);" />
      <MemberSignature Language="F#" Value="static member IsOneWay : System.Reflection.MethodBase -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsOneWay method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="e5eba-253">上述方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-253">The method in question.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-254">返回一个布尔值，该值指示调用给定消息中指定的方法的客户端在继续执行之前是否等待服务器完成该方法的处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-254">Returns a Boolean value that indicates whether the client that called the method specified in the given message is waiting for the server to finish processing the method before continuing execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-255">如果该方法是单向的，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-255">
              <see langword="true" /> if the method is one way; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-256">当调用一个单向方法时，客户端不等待服务器完成处理该消息。</span><span class="sxs-lookup"><span data-stu-id="e5eba-256">When a one-way method is called, the client does not wait for the server to finish processing the message.</span></span> <span data-ttu-id="e5eba-257">客户端方法返回的服务器将成功处理该消息不需要知道应用程序。</span><span class="sxs-lookup"><span data-stu-id="e5eba-257">The client method returns to the application with no knowledge of whether or not the server will successfully process the message.</span></span> <span data-ttu-id="e5eba-258">方法被标记为一种方法使用<xref:System.Runtime.Remoting.Messaging.OneWayAttribute>。</span><span class="sxs-lookup"><span data-stu-id="e5eba-258">Methods are marked as one way using the <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>.</span></span>  
  
 <span data-ttu-id="e5eba-259">单向方法不能有返回值或任何输出参数。</span><span class="sxs-lookup"><span data-stu-id="e5eba-259">One-way methods cannot have a return value or any out parameters.</span></span>  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#2)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#2)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-260">直接调用方没有基础结构权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-260">The immediate caller does not have infrastructure permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-261">用于操作的基础结构代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-261">for operating with infrastructure code.</span>
          </span>
          <span data-ttu-id="e5eba-262">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-262">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IsTransparentProxy">
      <MemberSignature Language="C#" Value="public static bool IsTransparentProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTransparentProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTransparentProxy (proxy As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTransparentProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member IsTransparentProxy : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsTransparentProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">
          <span data-ttu-id="e5eba-263">对要检查的对象的引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-263">The reference to the object to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-264">返回一个布尔值，该值指示给定的对象是透明代理还是实际对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-264">Returns a Boolean value that indicates whether the given object is a transparent proxy or a real object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-265">一个布尔值，该值指示 <paramref name="proxy" /> 参数中指定的对象是透明代理还是实际对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-265">A Boolean value that indicates whether the object specified in the <paramref name="proxy" /> parameter is a transparent proxy or a real object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-266">使用一个对象，可跨任何类型的远程处理边界的客户端实际上通过的对象的透明代理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-266">A client that uses an object across any kind of a remoting boundary is actually using a transparent proxy for the object.</span></span> <span data-ttu-id="e5eba-267">透明代理让人觉得实际对象驻留在客户端的空间。</span><span class="sxs-lookup"><span data-stu-id="e5eba-267">The transparent proxy gives the impression that the actual object resides in the client's space.</span></span> <span data-ttu-id="e5eba-268">通过将转发到使用远程处理基础结构的实际对象对其所做的调用来实现这。</span><span class="sxs-lookup"><span data-stu-id="e5eba-268">It achieves this by forwarding calls made on it to the real object using the remoting infrastructure.</span></span>  
  
 <span data-ttu-id="e5eba-269">透明代理是由类型的托管运行时类的实例本身<xref:System.Runtime.Remoting.Proxies.RealProxy>。</span><span class="sxs-lookup"><span data-stu-id="e5eba-269">The transparent proxy is itself housed by an instance of a managed runtime class of type <xref:System.Runtime.Remoting.Proxies.RealProxy>.</span></span> <span data-ttu-id="e5eba-270"><xref:System.Runtime.Remoting.Proxies.RealProxy>实现从透明代理转发操作所需的功能的一部分。</span><span class="sxs-lookup"><span data-stu-id="e5eba-270">The <xref:System.Runtime.Remoting.Proxies.RealProxy> implements a part of the functionality needed to forward the operations from the transparent proxy.</span></span> <span data-ttu-id="e5eba-271">代理对象继承的托管对象，如垃圾回收相关联的语义和支持成员和方法，可以扩展到新窗体的类。</span><span class="sxs-lookup"><span data-stu-id="e5eba-271">A proxy object inherits the associated semantics of managed objects such as garbage collection, support for members and methods, and can be extended to form new classes.</span></span> <span data-ttu-id="e5eba-272">因此，代理具有双重特性;一方面它需要使其作为与远程对象 （透明代理），相同的类的对象，并且在另一个托管的对象本身。</span><span class="sxs-lookup"><span data-stu-id="e5eba-272">Thus the proxy has a dual nature; on the one hand it needs to act as an object of the same class as the remote object (transparent proxy), and on the other it is a managed object itself.</span></span>  
  
 <span data-ttu-id="e5eba-273">可以使用代理对象中不考虑<xref:System.AppDomain>。</span><span class="sxs-lookup"><span data-stu-id="e5eba-273">A proxy object can be used without regard to any remoting subdivisions within a <xref:System.AppDomain>.</span></span> <span data-ttu-id="e5eba-274">应用程序不需要区分代理引用和对象引用。</span><span class="sxs-lookup"><span data-stu-id="e5eba-274">Applications need not distinguish between proxy references and object references.</span></span> <span data-ttu-id="e5eba-275">但是，服务提供商处理问题，如激活，生存期管理和事务需要进行这种区分。</span><span class="sxs-lookup"><span data-stu-id="e5eba-275">However, service providers dealing with issues such as activation, lifetime management, and transactions need to make such distinctions.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5eba-276">下面的代码示例演示如何将<xref:System.Runtime.Remoting.RemotingServices.IsTransparentProxy%2A>方法来确定对象是否为代理还是实际对象。</span><span class="sxs-lookup"><span data-stu-id="e5eba-276">The following code example demonstrates the use of the <xref:System.Runtime.Remoting.RemotingServices.IsTransparentProxy%2A> method to determine whether an object is a proxy or a real object.</span></span> <span data-ttu-id="e5eba-277">有关完整示例代码中，请参阅示例<xref:System.Runtime.Remoting.Messaging.AsyncResult>类。</span><span class="sxs-lookup"><span data-stu-id="e5eba-277">For the complete example code, see the example for the <xref:System.Runtime.Remoting.Messaging.AsyncResult> class.</span></span>  
  
 [!code-cpp[AsyncResult.NewExamples#6](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncResult.NewExamples/CPP/ad.cpp#6)]
 [!code-csharp[AsyncResult.NewExamples#6](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncResult.NewExamples/CS/ad.cs#6)]
 [!code-vb[AsyncResult.NewExamples#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncResult.NewExamples/VB/ad.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="LogRemotingStage">
      <MemberSignature Language="C#" Value="public static void LogRemotingStage (int stage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LogRemotingStage(int32 stage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LogRemotingStage (stage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LogRemotingStage(int stage);" />
      <MemberSignature Language="F#" Value="static member LogRemotingStage : int -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.LogRemotingStage stage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("REMOTING_PERF")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("It existed for only internal use in .NET and unimplemented in mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use of this method is not recommended. The LogRemotingStage existed for internal diagnostic purposes only.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stage">
          <span data-ttu-id="e5eba-278">标识远程处理交换中所处的阶段的内部定义常数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-278">An internally defined constant that identifies the stage in a remoting exchange.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-279">记录与外部调试器进行的远程处理交换所处的阶段。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-279">Logs the stage in a remoting exchange to an external debugger.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-280">一个`"REMOTING_PERF"`预处理符号应用于此方法通过使用<xref:System.Diagnostics.ConditionalAttribute>属性。</span><span class="sxs-lookup"><span data-stu-id="e5eba-280">A `"REMOTING_PERF"` preprocessing symbol is applied to the method by using the <xref:System.Diagnostics.ConditionalAttribute> attribute.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-281">用于配置的远程处理基础结构。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-281">for configuration of the remoting infrastructure.</span>
          </span>
          <span data-ttu-id="e5eba-282">要求值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-282">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Marshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e5eba-283">将给定的 <see cref="T:System.MarshalByRefObject" /> 转换为 <see cref="T:System.Runtime.Remoting.ObjRef" /> 类的实例，可以将该实例序列化以便在应用程序域之间以及通过网络进行传输。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-283">Converts the given <see cref="T:System.MarshalByRefObject" /> into an instance of the <see cref="T:System.Runtime.Remoting.ObjRef" /> class, which can be serialized for transmission between application domains and over a network.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal Obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="Obj">
          <span data-ttu-id="e5eba-284">要转换的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-284">The object to convert.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-285">接受 <see cref="T:System.MarshalByRefObject" />，将其注册到远程处理基础结构，然后将其转换为 <see cref="T:System.Runtime.Remoting.ObjRef" /> 类的实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-285">Takes a <see cref="T:System.MarshalByRefObject" />, registers it with the remoting infrastructure, and converts it into an instance of the <see cref="T:System.Runtime.Remoting.ObjRef" /> class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-286">
            <see cref="T:System.Runtime.Remoting.ObjRef" /> 类的一个实例，它表示 <paramref name="Obj" /> 参数中指定的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-286">An instance of the <see cref="T:System.Runtime.Remoting.ObjRef" /> class that represents the object specified in the <paramref name="Obj" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-287">一个<xref:System.Runtime.Remoting.ObjRef>是用于跨应用程序域边界传输的对象引用的对象的可序列化表示形式。</span><span class="sxs-lookup"><span data-stu-id="e5eba-287">A <xref:System.Runtime.Remoting.ObjRef> is a serializable representation of an object used to transfer an object reference across an application domain boundary.</span></span> <span data-ttu-id="e5eba-288">创建<xref:System.Runtime.Remoting.ObjRef>的对象称为封送处理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-288">Creating a <xref:System.Runtime.Remoting.ObjRef> for an object is known as marshaling.</span></span> <span data-ttu-id="e5eba-289"><xref:System.Runtime.Remoting.ObjRef>可以通过信道传输到另一个应用程序域 （可能在另一个进程或计算机）。</span><span class="sxs-lookup"><span data-stu-id="e5eba-289">The <xref:System.Runtime.Remoting.ObjRef> can be transferred through a channel into another application domain (possibly on another process or computer).</span></span> <span data-ttu-id="e5eba-290">其他应用程序域中一次<xref:System.Runtime.Remoting.ObjRef>必须对其进行分析，以创建通常连接到真实的对象的对象的代理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-290">Once in the other application domain, the <xref:System.Runtime.Remoting.ObjRef> must be parsed to create a proxy for the object, generally connected to the real object.</span></span> <span data-ttu-id="e5eba-291">此操作称为取消。</span><span class="sxs-lookup"><span data-stu-id="e5eba-291">This operation is known as unmarshaling.</span></span>  
  
 <span data-ttu-id="e5eba-292">一个<xref:System.Runtime.Remoting.ObjRef>包含描述信息<xref:System.Type>和正在封送的对象类，URI 用于唯一标识的特定对象实例和通信相关的有关如何到达远程处理分支信息对象所在位置。</span><span class="sxs-lookup"><span data-stu-id="e5eba-292">A <xref:System.Runtime.Remoting.ObjRef> contains information that describes the <xref:System.Type> and class of the object being marshaled, a URI that uniquely identifies the specific object instance, and communication related information about how to reach the remoting subdivision where the object is located.</span></span>  
  
 <span data-ttu-id="e5eba-293">在封送处理，使用从当前线程的上下文，不是用上下文的处于活动状态时创建对象时。</span><span class="sxs-lookup"><span data-stu-id="e5eba-293">During marshaling, the context from the current thread is used, not the context that was active when the object was created.</span></span> <span data-ttu-id="e5eba-294">如果 URI 不显式设置了<xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A>方法，由远程处理标识基础结构自动生成。</span><span class="sxs-lookup"><span data-stu-id="e5eba-294">If a URI was not explicitly set by the <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A> method, it is automatically generated by the remoting identity infrastructure.</span></span>  
  
 <span data-ttu-id="e5eba-295">无法将 URI 与代理关联的两个原因之一： 在它表示的对象在服务器端生成 URI 或该对象是很知名，这种情况下知晓 URI。</span><span class="sxs-lookup"><span data-stu-id="e5eba-295">You cannot associate a URI with a proxy for one of two reasons: either the URI was generated at the server side for the object it represents, or the object is well known, in which case the URI is known.</span></span> <span data-ttu-id="e5eba-296">出于此原因，如果`Obj`参数是一个代理，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="e5eba-296">For this reason, if the `Obj` parameter is a proxy, an exception will be thrown.</span></span> <span data-ttu-id="e5eba-297">对于自定义代理可以因为透明代理被视为该服务器对象放宽此限制。</span><span class="sxs-lookup"><span data-stu-id="e5eba-297">For custom proxies this restriction is relaxed because the transparent proxy is treated as the server object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <span data-ttu-id="e5eba-298">
            <paramref name="Obj" /> 参数是一个对象代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-298">The <paramref name="Obj" /> parameter is an object proxy.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-299">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-299">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-300">用于配置的远程处理基础结构。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-300">for configuration of the remoting infrastructure.</span>
          </span>
          <span data-ttu-id="e5eba-301">要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-301">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">
          <span data-ttu-id="e5eba-302">应用程序域</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-302">Application Domains</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, URI As String) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, URI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Obj">
          <span data-ttu-id="e5eba-303">要转换的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-303">The object to convert.</span>
          </span>
        </param>
        <param name="URI">
          <span data-ttu-id="e5eba-304">指定的 URI，使用它来初始化新 <see cref="T:System.Runtime.Remoting.ObjRef" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-304">The specified URI with which to initialize the new <see cref="T:System.Runtime.Remoting.ObjRef" />.</span>
          </span>
          <span data-ttu-id="e5eba-305">可以为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-305">Can be <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-306">将给定的 <see cref="T:System.MarshalByRefObject" /> 转换为具有指定 URI 的 <see cref="T:System.Runtime.Remoting.ObjRef" /> 类的实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-306">Converts the given <see cref="T:System.MarshalByRefObject" /> into an instance of the <see cref="T:System.Runtime.Remoting.ObjRef" /> class with the specified URI.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-307">
            <see cref="T:System.Runtime.Remoting.ObjRef" /> 类的一个实例，它表示 <paramref name="Obj" /> 参数中指定的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-307">An instance of the <see cref="T:System.Runtime.Remoting.ObjRef" /> class that represents the object specified in the <paramref name="Obj" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-308">一个<xref:System.Runtime.Remoting.ObjRef>是用于跨应用程序域边界传输的对象引用的对象的可序列化表示形式。</span><span class="sxs-lookup"><span data-stu-id="e5eba-308">A <xref:System.Runtime.Remoting.ObjRef> is a serializable representation of an object used to transfer an object reference across an application domain boundary.</span></span> <span data-ttu-id="e5eba-309">创建<xref:System.Runtime.Remoting.ObjRef>的对象称为封送处理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-309">Creating a <xref:System.Runtime.Remoting.ObjRef> for an object is known as marshaling.</span></span> <span data-ttu-id="e5eba-310"><xref:System.Runtime.Remoting.ObjRef>可以通过信道传输到另一个应用程序域 （可能在另一个进程或计算机）。</span><span class="sxs-lookup"><span data-stu-id="e5eba-310">The <xref:System.Runtime.Remoting.ObjRef> can be transferred through a channel into another application domain (possibly on another process or computer).</span></span> <span data-ttu-id="e5eba-311">其他应用程序域中一次<xref:System.Runtime.Remoting.ObjRef>必须对其进行分析，以创建通常连接到真实的对象的对象的代理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-311">Once in the other application domain, the <xref:System.Runtime.Remoting.ObjRef> must be parsed to create a proxy for the object, generally connected to the real object.</span></span> <span data-ttu-id="e5eba-312">此操作称为取消。</span><span class="sxs-lookup"><span data-stu-id="e5eba-312">This operation is known as unmarshaling.</span></span>  
  
 <span data-ttu-id="e5eba-313">一个<xref:System.Runtime.Remoting.ObjRef>包含描述信息<xref:System.Type>和正在封送的对象类，URI 用于唯一标识的特定对象实例和通信相关的有关如何到达远程处理分支信息对象所在位置。</span><span class="sxs-lookup"><span data-stu-id="e5eba-313">A <xref:System.Runtime.Remoting.ObjRef> contains information that describes the <xref:System.Type> and class of the object being marshaled, a URI that uniquely identifies the specific object instance, and communication related information about how to reach the remoting subdivision where the object is located.</span></span>  
  
 <span data-ttu-id="e5eba-314">在封送处理，使用从当前线程的上下文，不是用上下文的处于活动状态时创建对象时。</span><span class="sxs-lookup"><span data-stu-id="e5eba-314">During marshaling, the context from the current thread is used, not the context that was active when the object was created.</span></span>  
  
 <span data-ttu-id="e5eba-315">无法将 URI 与代理关联的两个原因之一： 在它表示的对象在服务器端生成 URI 或该对象是很知名，这种情况下知晓 URI。</span><span class="sxs-lookup"><span data-stu-id="e5eba-315">You cannot associate a URI with a proxy for one of two reasons: either the URI was generated at the server side for the object it represents, or the object is well known, in which case the URI is known.</span></span> <span data-ttu-id="e5eba-316">出于此原因，如果`Obj`参数是一个代理，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="e5eba-316">For this reason, if the `Obj` parameter is a proxy, an exception will be thrown.</span></span> <span data-ttu-id="e5eba-317">对于自定义代理可以因为透明代理被视为该服务器对象放宽此限制。</span><span class="sxs-lookup"><span data-stu-id="e5eba-317">For custom proxies this restriction is relaxed because the transparent proxy is treated as the server object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5eba-318">下面的代码示例演示如何使用当前<xref:System.Runtime.Remoting.RemotingServices.Marshal%2A>方法进行封送处理指定的对象。</span><span class="sxs-lookup"><span data-stu-id="e5eba-318">The following code example demonstrates how to use the current <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> method to marshal a specified object.</span></span>  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <span data-ttu-id="e5eba-319">
            <paramref name="Obj" /> 是一个对象代理，<paramref name="URI" /> 参数不为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-319">
              <paramref name="Obj" /> is an object proxy, and the <paramref name="URI" /> parameter is not <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-320">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-320">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-321">用于配置的远程处理基础结构。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-321">for configuration of the remoting infrastructure.</span>
          </span>
          <span data-ttu-id="e5eba-322">要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-322">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">
          <span data-ttu-id="e5eba-323">应用程序域</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-323">Application Domains</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string ObjURI, class System.Type RequestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, ObjURI As String, RequestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ ObjURI, Type ^ RequestedType);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string * Type -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, ObjURI, RequestedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="ObjURI" Type="System.String" />
        <Parameter Name="RequestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="Obj">
          <span data-ttu-id="e5eba-324">要转换为 <see cref="T:System.Runtime.Remoting.ObjRef" /> 的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-324">The object to convert into a <see cref="T:System.Runtime.Remoting.ObjRef" />.</span>
          </span>
        </param>
        <param name="ObjURI">
          <span data-ttu-id="e5eba-325">URI，使用它对 <c>Obj</c> 参数中指定的对象进行封送。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-325">The URI the object specified in the <c>Obj</c> parameter is marshaled with.</span>
          </span>
          <span data-ttu-id="e5eba-326">可以为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-326">Can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="RequestedType">
          <span data-ttu-id="e5eba-327">
            <c>Obj</c> 被封送为的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-327">The <see cref="T:System.Type" /><c>Obj</c> is marshaled as.</span>
          </span>
          <span data-ttu-id="e5eba-328">可以为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-328">Can be <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-329">接受 <see cref="T:System.MarshalByRefObject" />，并将其转换为具有指定 URI 和提供的 <see cref="T:System.Runtime.Remoting.ObjRef" /> 的 <see cref="T:System.Type" /> 类的实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-329">Takes a <see cref="T:System.MarshalByRefObject" /> and converts it into an instance of the <see cref="T:System.Runtime.Remoting.ObjRef" /> class with the specified URI, and the provided <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-330">
            <see cref="T:System.Runtime.Remoting.ObjRef" /> 类的一个实例，它表示 <paramref name="Obj" /> 参数中指定的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-330">An instance of the <see cref="T:System.Runtime.Remoting.ObjRef" /> class that represents the object specified in the <paramref name="Obj" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-331">一个<xref:System.Runtime.Remoting.ObjRef>是用于跨应用程序域边界传输的对象引用的对象的可序列化表示形式。</span><span class="sxs-lookup"><span data-stu-id="e5eba-331">A <xref:System.Runtime.Remoting.ObjRef> is a serializable representation of an object used to transfer an object reference across an application domain boundary.</span></span> <span data-ttu-id="e5eba-332">创建<xref:System.Runtime.Remoting.ObjRef>的对象称为封送处理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-332">Creating a <xref:System.Runtime.Remoting.ObjRef> for an object is known as marshaling.</span></span> <span data-ttu-id="e5eba-333"><xref:System.Runtime.Remoting.ObjRef>可以通过信道传输到另一个应用程序域 （可能在另一个进程或计算机）。</span><span class="sxs-lookup"><span data-stu-id="e5eba-333">The <xref:System.Runtime.Remoting.ObjRef> can be transferred through a channel into another application domain (possibly on another process or computer).</span></span> <span data-ttu-id="e5eba-334">其他应用程序域中一次<xref:System.Runtime.Remoting.ObjRef>必须对其进行分析，以创建通常连接到真实的对象的对象的代理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-334">Once in the other application domain, the <xref:System.Runtime.Remoting.ObjRef> must be parsed to create a proxy for the object, generally connected to the real object.</span></span> <span data-ttu-id="e5eba-335">此操作称为取消。</span><span class="sxs-lookup"><span data-stu-id="e5eba-335">This operation is known as unmarshaling.</span></span>  
  
 <span data-ttu-id="e5eba-336">一个<xref:System.Runtime.Remoting.ObjRef>包含描述信息<xref:System.Type>和正在封送的对象类，URI 用于唯一标识的特定对象实例和通信相关的有关如何到达远程处理分支信息对象所在位置。</span><span class="sxs-lookup"><span data-stu-id="e5eba-336">A <xref:System.Runtime.Remoting.ObjRef> contains information that describes the <xref:System.Type> and class of the object being marshaled, a URI that uniquely identifies the specific object instance, and communication related information about how to reach the remoting subdivision where the object is located.</span></span>  
  
 <span data-ttu-id="e5eba-337">指定<xref:System.Type>远程处理基础结构用于公开的类型层次结构的作用域限制。</span><span class="sxs-lookup"><span data-stu-id="e5eba-337">The specified <xref:System.Type> is used by the remoting infrastructure to limit the scope of the exposed type hierarchy.</span></span> <span data-ttu-id="e5eba-338">例如，如果对象 A 派生对象派生自 object C，B 和<xref:System.Runtime.Remoting.RemotingServices.Marshal%2A>调用，则客户端可以强制转换代理 C 和 B 之间，但不是到 a。</span><span class="sxs-lookup"><span data-stu-id="e5eba-338">For example, if object A derives from object B, which derives from object C, and <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> is called, then the client can cast the proxy between C and B but not to A.</span></span>  
  
 <span data-ttu-id="e5eba-339">在封送处理，使用从当前线程的上下文，不是用上下文的处于活动状态时创建对象时。</span><span class="sxs-lookup"><span data-stu-id="e5eba-339">During marshaling, the context from the current thread is used, not the context that was active when the object was created.</span></span>  
  
 <span data-ttu-id="e5eba-340">无法将 URI 与代理关联的两个原因之一： 在它表示的对象在服务器端生成 URI 或该对象是很知名，这种情况下知晓 URI。</span><span class="sxs-lookup"><span data-stu-id="e5eba-340">You cannot associate a URI with a proxy for one of two reasons: either the URI was generated at the server side for the object it represents, or the object is well known, in which case the URI is known.</span></span> <span data-ttu-id="e5eba-341">出于此原因，如果`Obj`参数是一个代理，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="e5eba-341">For this reason, if the `Obj` parameter is a proxy, an exception will be thrown.</span></span> <span data-ttu-id="e5eba-342">对于自定义代理可以因为透明代理被视为该服务器对象放宽此限制。</span><span class="sxs-lookup"><span data-stu-id="e5eba-342">For custom proxies this restriction is relaxed because the transparent proxy is treated as the server object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <span data-ttu-id="e5eba-343">
            <paramref name="Obj" /> 是远程对象的代理，<paramref name="ObjUri" /> 参数不为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-343">
              <paramref name="Obj" /> is a proxy of a remote object, and the <paramref name="ObjUri" /> parameter is not <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-344">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-344">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-345">用于配置的远程处理基础结构。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-345">for configuration of the remoting infrastructure.</span>
          </span>
          <span data-ttu-id="e5eba-346">要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-346">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">
          <span data-ttu-id="e5eba-347">应用程序域</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-347">Application Domains</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetObjectUriForMarshal">
      <MemberSignature Language="C#" Value="public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetObjectUriForMarshal(class System.MarshalByRefObject obj, string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetObjectUriForMarshal (obj As MarshalByRefObject, uri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetObjectUriForMarshal(MarshalByRefObject ^ obj, System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member SetObjectUriForMarshal : MarshalByRefObject * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal (obj, uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="e5eba-348">为其设置 URI 的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-348">The object to set a URI for.</span>
          </span>
        </param>
        <param name="uri">
          <span data-ttu-id="e5eba-349">要分配给指定对象的 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-349">The URI to assign to the specified object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-350">为后续的 <see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" /> 方法调用设置 URI。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-350">Sets the URI for the subsequent call to the <see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" /> method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-351">设置当前方法的 URI 用于封送处理给定的对象。</span><span class="sxs-lookup"><span data-stu-id="e5eba-351">The URI set by the current method is used when marshaling the given object.</span></span>  
  
 <span data-ttu-id="e5eba-352">封送后，将指定对象的 URI 设置为中的字符串`uri`参数追加到<xref:System.Guid>的当前<xref:System.AppDomain>。</span><span class="sxs-lookup"><span data-stu-id="e5eba-352">After marshaling, the URI of the specified object is set to the string in the `uri` parameter appended onto the <xref:System.Guid> of the current <xref:System.AppDomain>.</span></span>  
  
 <span data-ttu-id="e5eba-353">如果当前应用程序正在侦听的 HTTP 端口，则这两个字符串中指定`uri`参数和`uri`字符串附加到<xref:System.Guid>的当前<xref:System.AppDomain>路由到指定的对象。</span><span class="sxs-lookup"><span data-stu-id="e5eba-353">If the current application is listening on an HTTP port, then both the string specified in the `uri` parameter and the `uri` string appended onto the <xref:System.Guid> of the current <xref:System.AppDomain> route to the specified object.</span></span> <span data-ttu-id="e5eba-354">示例中，如果应用程序正在侦听 HTTP 端口 9000，则两者http://localhost:9000/objectUri，并http://localhost:9000/\<appdomainguid>/objectUri路由中指定的对象到`obj`参数。</span><span class="sxs-lookup"><span data-stu-id="e5eba-354">For example, if the application is listening on HTTP port 9000, then both http://localhost:9000/objectUri, and http://localhost:9000/\<appdomainguid>/objectUri route to the object specified in the `obj` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5eba-355">下面的代码示例演示如何设置将由 URI<xref:System.Runtime.Remoting.RemotingServices.Marshal%2A>方法时进行封送处理指定的对象。</span><span class="sxs-lookup"><span data-stu-id="e5eba-355">The following code example demonstrates how to set the URI that will be used by the <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> method when marshaling the specified object.</span></span>  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <span data-ttu-id="e5eba-356">
            <paramref name="obj" /> 不是局部对象、已被封送、或已对其调用了当前方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-356">
              <paramref name="obj" /> is not a local object, has already been marshaled, or the current method has already been called on.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-357">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-357">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-358">用于配置的远程处理基础结构。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-358">for configuration of the remoting infrastructure.</span>
          </span>
          <span data-ttu-id="e5eba-359">要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-359">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unmarshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e5eba-360">将给定的 <see cref="T:System.Runtime.Remoting.ObjRef" /> 转换为代理对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-360">Converts a given <see cref="T:System.Runtime.Remoting.ObjRef" /> into a proxy object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal objectRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
      </Parameters>
      <Docs>
        <param name="objectRef">
          <span data-ttu-id="e5eba-361">
            <see cref="T:System.Runtime.Remoting.ObjRef" />，它代表正在为其创建代理的远程对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-361">The <see cref="T:System.Runtime.Remoting.ObjRef" /> that represents the remote object for which the proxy is being created.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-362">接受 <see cref="T:System.Runtime.Remoting.ObjRef" /> 并从它创建一个代理对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-362">Takes a <see cref="T:System.Runtime.Remoting.ObjRef" /> and creates a proxy object out of it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-363">给定的 <see cref="T:System.Runtime.Remoting.ObjRef" /> 所代表对象的代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-363">A proxy to the object that the given <see cref="T:System.Runtime.Remoting.ObjRef" /> represents.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-364">一个<xref:System.Runtime.Remoting.ObjRef>是用于跨应用程序域边界传输的对象引用的对象的可序列化表示形式。</span><span class="sxs-lookup"><span data-stu-id="e5eba-364">A <xref:System.Runtime.Remoting.ObjRef> is a serializable representation of an object used to transfer an object reference across an application domain boundary.</span></span> <span data-ttu-id="e5eba-365">创建<xref:System.Runtime.Remoting.ObjRef>的对象称为封送处理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-365">Creating a <xref:System.Runtime.Remoting.ObjRef> for an object is known as marshaling.</span></span> <span data-ttu-id="e5eba-366"><xref:System.Runtime.Remoting.ObjRef>可以通过信道传输到另一个应用程序域 （可能在另一个进程或计算机）。</span><span class="sxs-lookup"><span data-stu-id="e5eba-366">The <xref:System.Runtime.Remoting.ObjRef> can be transferred through a channel into another application domain (possibly on another process or computer).</span></span> <span data-ttu-id="e5eba-367">其他应用程序域中一次<xref:System.Runtime.Remoting.ObjRef>必须对其进行分析，以创建通常连接到真实的对象的对象的代理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-367">Once in the other application domain, the <xref:System.Runtime.Remoting.ObjRef> must be parsed to create a proxy for the object, generally connected to the real object.</span></span> <span data-ttu-id="e5eba-368">此操作称为取消。</span><span class="sxs-lookup"><span data-stu-id="e5eba-368">This operation is known as unmarshaling.</span></span> <span data-ttu-id="e5eba-369">在取消过程<xref:System.Runtime.Remoting.ObjRef>分析提取方法信息的远程对象和透明代理和<xref:System.Runtime.Remoting.Proxies.RealProxy>创建对象。</span><span class="sxs-lookup"><span data-stu-id="e5eba-369">During unmarshaling, the <xref:System.Runtime.Remoting.ObjRef> is parsed to extract the method information of the remote object and both the transparent proxy and <xref:System.Runtime.Remoting.Proxies.RealProxy> objects are created.</span></span> <span data-ttu-id="e5eba-370">已分析的内容<xref:System.Runtime.Remoting.ObjRef>之前向公共语言运行时注册的透明代理添加到透明代理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-370">The content of the parsed <xref:System.Runtime.Remoting.ObjRef> is added to the transparent proxy before the transparent proxy is registered with the common language runtime.</span></span>  
  
 <span data-ttu-id="e5eba-371">一个<xref:System.Runtime.Remoting.ObjRef>包含描述信息<xref:System.Type>和正在封送的对象类，URI 用于唯一标识的特定对象实例和通信相关的有关如何到达远程处理分支信息对象所在位置。</span><span class="sxs-lookup"><span data-stu-id="e5eba-371">A <xref:System.Runtime.Remoting.ObjRef> contains information that describes the <xref:System.Type> and class of the object being marshaled, a URI that uniquely identifies the specific object instance, and communication related information about how to reach the remoting subdivision where the object is located.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e5eba-372">下面的代码示例演示如何取消封送对象。</span><span class="sxs-lookup"><span data-stu-id="e5eba-372">The following code example demonstrates how to unmarshal an object.</span></span>  
  
 [!code-cpp[RemotingServices.Unmarshal#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CPP/client.cpp#2)]
 [!code-csharp[RemotingServices.Unmarshal#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CS/client.cs#2)]
 [!code-vb[RemotingServices.Unmarshal#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.Unmarshal/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e5eba-373">
            <paramref name="objectRef" /> 参数中指定的 <see cref="T:System.Runtime.Remoting.ObjRef" /> 实例不是格式良好的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-373">The <see cref="T:System.Runtime.Remoting.ObjRef" /> instance specified in the <paramref name="objectRef" /> parameter is not well-formed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-374">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-374">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-375">用于配置的远程处理基础结构。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-375">for configuration of the remoting infrastructure.</span>
          </span>
          <span data-ttu-id="e5eba-376">要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-376">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef, bool fRefine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef, fRefine As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef, bool fRefine);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef * bool -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal (objectRef, fRefine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
        <Parameter Name="fRefine" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="objectRef">
          <span data-ttu-id="e5eba-377">
            <see cref="T:System.Runtime.Remoting.ObjRef" />，它代表正在为其创建代理的远程对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-377">The <see cref="T:System.Runtime.Remoting.ObjRef" /> that represents the remote object for which the proxy is being created.</span>
          </span>
        </param>
        <param name="fRefine">
          <span data-ttu-id="e5eba-378">如果为 <see langword="true" />，则将代理精炼为服务器上的类型；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-378">
              <see langword="true" /> to refine the proxy to the type on the server; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e5eba-379">接受 <see cref="T:System.Runtime.Remoting.ObjRef" /> 并从它创建一个代理对象，然后将其精炼为服务器上的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-379">Takes a <see cref="T:System.Runtime.Remoting.ObjRef" /> and creates a proxy object out of it, refining it to the type on the server.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e5eba-380">给定的 <see cref="T:System.Runtime.Remoting.ObjRef" /> 所代表对象的代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-380">A proxy to the object that the given <see cref="T:System.Runtime.Remoting.ObjRef" /> represents.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e5eba-381">一个<xref:System.Runtime.Remoting.ObjRef>是用于跨应用程序域边界传输的对象引用的对象的可序列化表示形式。</span><span class="sxs-lookup"><span data-stu-id="e5eba-381">A <xref:System.Runtime.Remoting.ObjRef> is a serializable representation of an object used to transfer an object reference across an application domain boundary.</span></span> <span data-ttu-id="e5eba-382">创建<xref:System.Runtime.Remoting.ObjRef>的对象称为封送处理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-382">Creating a <xref:System.Runtime.Remoting.ObjRef> for an object is known as marshaling.</span></span> <span data-ttu-id="e5eba-383"><xref:System.Runtime.Remoting.ObjRef>可以通过信道传输到另一个应用程序域 （可能在另一个进程或计算机）。</span><span class="sxs-lookup"><span data-stu-id="e5eba-383">The <xref:System.Runtime.Remoting.ObjRef> can be transferred through a channel into another application domain (possibly on another process or computer).</span></span> <span data-ttu-id="e5eba-384">其他应用程序域中一次<xref:System.Runtime.Remoting.ObjRef>必须对其进行分析，以创建通常连接到真实的对象的对象的代理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-384">Once in the other application domain, the <xref:System.Runtime.Remoting.ObjRef> must be parsed to create a proxy for the object, generally connected to the real object.</span></span> <span data-ttu-id="e5eba-385">此操作称为取消。</span><span class="sxs-lookup"><span data-stu-id="e5eba-385">This operation is known as unmarshaling.</span></span> <span data-ttu-id="e5eba-386">在取消过程<xref:System.Runtime.Remoting.ObjRef>分析提取方法信息的远程对象和透明代理和<xref:System.Runtime.Remoting.Proxies.RealProxy>创建对象。</span><span class="sxs-lookup"><span data-stu-id="e5eba-386">During unmarshaling, the <xref:System.Runtime.Remoting.ObjRef> is parsed to extract the method information of the remote object and both the transparent proxy and <xref:System.Runtime.Remoting.Proxies.RealProxy> objects are created.</span></span> <span data-ttu-id="e5eba-387">已分析的内容<xref:System.Runtime.Remoting.ObjRef>之前向公共语言运行时注册的透明代理添加到透明代理。</span><span class="sxs-lookup"><span data-stu-id="e5eba-387">The content of the parsed <xref:System.Runtime.Remoting.ObjRef> is added to the transparent proxy before the transparent proxy is registered with the common language runtime.</span></span>  
  
 <span data-ttu-id="e5eba-388">一个<xref:System.Runtime.Remoting.ObjRef>包含描述信息<xref:System.Type>和正在封送的对象类，URI 用于唯一标识的特定对象实例和通信相关的有关如何到达远程处理分支信息对象所在位置。</span><span class="sxs-lookup"><span data-stu-id="e5eba-388">A <xref:System.Runtime.Remoting.ObjRef> contains information that describes the <xref:System.Type> and class of the object being marshaled, a URI that uniquely identifies the specific object instance, and communication related information about how to reach the remoting subdivision where the object is located.</span></span>  
  
 <span data-ttu-id="e5eba-389">首次创建，该代理时，类型的<xref:System.MarshalByRefObject>。</span><span class="sxs-lookup"><span data-stu-id="e5eba-389">When first created, the proxy is of type <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="e5eba-390">将其转换为不同类型，如远程处理基础结构跟踪的最常用的类型，以避免不必要地加载该类型。</span><span class="sxs-lookup"><span data-stu-id="e5eba-390">As you cast it into different types, the remoting infrastructure keeps track of the most used type to avoid loading the type unnecessarily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e5eba-391">
            <paramref name="objectRef" /> 参数中指定的 <see cref="T:System.Runtime.Remoting.ObjRef" /> 实例不是格式良好的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-391">The <see cref="T:System.Runtime.Remoting.ObjRef" /> instance specified in the <paramref name="objectRef" /> parameter is not well-formed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e5eba-392">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-392">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e5eba-393">用于配置的远程处理基础结构。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-393">for configuration of the remoting infrastructure.</span>
          </span>
          <span data-ttu-id="e5eba-394">要求值： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e5eba-394">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
  </Members>
</Type>