<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f908dbd04f1ed17bee04e225536a93e5e092d9d1" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061692" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>创建和控制线程，设置其优先级并获取其状态。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程启动时，公共语言运行时将自动创建一个前台线程执行应用程序代码。 此主前台线程，以及一个进程可以创建一个或多个线程来执行与进程关联的程序代码的一部分。 在前台或在后台，可以执行这些线程。 此外，你可以使用<xref:System.Threading.ThreadPool>类在由公共语言运行时管理的工作线程上执行代码。  
  
 本节内容  
  
 [启动线程](#Starting)   
 [检索线程对象](#Retrieving)   
 [前台和后台线程](#Foreground)   
 [区域性和线程](#Culture)   
 [获取相关信息和控制线程](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>启动线程  
 通过提供一个委托，表示该线程是在其类构造函数中执行的方法启动线程。 然后，你调用<xref:System.Threading.Thread.Start%2A>方法，以开始执行。  
  
 <xref:System.Threading.Thread>构造函数可以采用两个委托类型，具体取决于是否可以将自变量传递给要执行的方法之一：  
  
-   如果该方法不具有任何参数，则传递<xref:System.Threading.ThreadStart>委托给构造函数。 它具有签名：  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     下面的示例创建并开始执行的线程`ExecuteInForeground`方法。 方法显示某些线程属性，有关的信息，然后执行它暂停半秒钟和显示已用的秒数的循环。 当线程执行至少五秒内时，则循环结束，并且该线程将终止执行。  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   如果该方法具有一个自变量，则传递<xref:System.Threading.ParameterizedThreadStart>委托给构造函数。 它具有签名：  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     然后，执行委托的方法可以强制转换 （在 C# 中) 或者 （在 Visual Basic 中) 将参数转换为适当的类型。  
  
     下面的示例是上一，相同，但它会调用<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>构造函数。 此版本的`ExecuteInForeground`方法只有一个参数表示的毫秒所要执行的循环的大致数目。  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 不需要保留对引用<xref:System.Threading.Thread>对象后启动线程。 线程继续执行，直到线程过程完成。  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>检索线程对象  
 您可以使用静态 (`Shared`在 Visual Basic 中)<xref:System.Threading.Thread.CurrentThread%2A>属性来检索对当前执行线程的线程正在执行的代码中的引用。 下面的示例使用<xref:System.Threading.Thread.CurrentThread%2A>属性来显示有关主应用程序线程、 另一个前台线程、 后台线程和一个线程池线程的信息。  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>前台和后台线程  
 实例<xref:System.Threading.Thread>类表示前台线程或后台线程。 后台线程相等前台线程有一个例外： 后台线程不会保留正运行的进程，如果所有前台线程已都终止。 所有前台线程已都停止后，运行时将停止所有后台线程，并关闭。  
  
 默认情况下，以下线程在前台执行：  
  
-   主应用程序中的线程。  
  
-   通过调用创建的所有线程<xref:System.Threading.Thread>类构造函数。  
  
 默认情况下，在后台执行的以下线程：  
  
-   线程池线程，是一个由运行时维护辅助线程池。  可以通过使用线程池线程上配置的线程池和计划工作<xref:System.Threading.ThreadPool>类。  
  
    > [!NOTE]
    >  在线程池线程上自动执行基于任务的异步操作。 基于任务的异步操作使用<xref:System.Threading.Tasks.Task>和<xref:System.Threading.Tasks.Task%601>类以实现[基于任务的异步模式](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)。  
  
-   从非托管代码进入托管的执行环境的所有线程。  
  
 你可以更改线程在后台执行通过设置<xref:System.Threading.Thread.IsBackground%2A>在任何时候的属性。  后台线程可用于任何操作都应继续，只要应用程序正在运行，但不是应阻止应用程序终止，如监视文件系统更改或传入套接字连接。  
  
 下面的示例演示前景色和背景线程之间的差异。 此操作就如同中的第一个示例[启动线程](#Starting)部分，只不过它将设置要在其开始之前在后台中执行的线程。 如输出所示，在它的五秒内执行之前中断循环。  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>区域性和线程  
 每个线程具有区域性，由表示<xref:System.Threading.Thread.CurrentCulture%2A>属性和 UI 区域性，由表示<xref:System.Threading.Thread.CurrentUICulture%2A>属性。  当前区域性支持分析和格式设置，字符串比较和排序，诸如区分区域性的操作，还控制书写系统和线程使用的日历。 当前 UI 区域性提供的资源文件中的资源的区分区域性的检索。  
  
 实例化一个新线程时，其区域性和 UI 区域性定义由的当前系统区域性和 UI 区域性，而不是区域性和 UI 区域性从中创建新线程的线程。 这意味着，例如，如果当前系统区域性为英语 （美国），主应用程序线程的当前区域性为法语 （法国），通过调用创建一个新线程的区域性<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>从主线程的构造函数是英语 （美国） 和不是法语 （法国）。 有关详细信息，请参阅的"区域性和线程"部分<xref:System.Globalization.CultureInfo>类主题。  
  
> [!IMPORTANT]
>  这是不正确的执行该目标的应用的异步操作的线程[!INCLUDE[net_v46](~/includes/net-v46-md.md)]并且更高版本，在这种情况下，区域性和 UI 区域性中的属于的异步操作的上下文; 的线程上异步操作通过执行默认继承的区域性和 UI 区域性从中启动异步操作的线程。 有关详细信息，请参阅 <xref:System.Globalization.CultureInfo> 类主题中的“区域性和基于任务的异步操作”一节。  
  
 你可以执行以下操作以确保的所有线程执行应用程序中共享相同的区域性和 UI 区域性：  
  
-   你可以将传递<xref:System.Globalization.CultureInfo>对象，表示该区域性<xref:System.Threading.ParameterizedThreadStart>委托或<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType>方法。  
  
-   在上运行的应用程序[!INCLUDE[net_v45](~/includes/net-v45-md.md)]和更高版本，你可以定义的区域性和 UI 区域性要分配给通过设置的值创建应用程序域中的所有线程<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType>和<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType>属性。 请注意这是每个应用程序域的设置。  
  
 有关详细信息和示例，请参阅的"区域性和线程"部分<xref:System.Globalization.CultureInfo>类主题。  
  
<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>获取相关信息和控制线程  
 你可以检索提供有关线程的信息的属性值的数目。 在某些情况下，你还可以设置这些属性值可控制的操作的线程。 这些线程属性包括：  
  
-   名称。 <xref:System.Threading.Thread.Name%2A> 是可写的一次可用于标识线程的属性。  其默认值是`null`。  
  
-   一个哈希代码，它可以通过调用检索<xref:System.Threading.Thread.GetHashCode%2A>方法。 哈希代码可以用于唯一标识线程;在线程的生存期内，其哈希代码不会与来自其他线程，而不考虑从中获取值的应用程序域的值。  
  
-   线程 id。 只读的值<xref:System.Threading.Thread.ManagedThreadId%2A>属性由运行时分配，并唯一地标识其进程中的线程。  
  
    > [!NOTE]
    >  因为非托管主机可以控制托管线程和非托管线程之间的关系，所以操作系统 [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) 与托管线程之间没有固定的关系。 具体而言，一个复杂的主机可以使用[CLR 托管 API](https://msdn.microsoft.com/library/ms404385.aspx)调度多个托管的线程针对同一操作系统线程，或不同的操作系统线程之间移动托管的线程。  
  
-   线程的当前状态。 其是否存在的持续时间内，线程是始终在一个或多个定义的状态<xref:System.Threading.ThreadState>属性。  
  
-   计划的优先级别，通过定义<xref:System.Threading.ThreadPriority>属性。 虽然你可以设置此值，以请求线程的优先级，但它不被保证遵循所操作系统。  
  
-   只读<xref:System.Threading.Thread.IsThreadPoolThread%2A>属性，它指示线程是否是一个线程池线程。  
  
-   <xref:System.Threading.Thread.IsBackground%2A> 属性。 有关详细信息，请参阅[前台和后台线程](#Foreground)部分。  
  
## Examples  
 下面的示例演示了简单的线程处理功能。  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 此代码生成类似于下面的输出：  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.Thread" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">一个委托，它表示此线程开始执行时要调用的方法。</param>
        <summary>初始化 <see cref="T:System.Threading.Thread" /> 类的新实例，指定允许对象在线程启动时传递给线程的委托。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 线程不会开始执行时创建它。 若要安排执行的线程，请调用<xref:System.Threading.Thread.Start%2A>方法。 若要将数据对象传递给该线程，使用<xref:System.Threading.Thread.Start%28System.Object%29>方法重载。  
  
> [!NOTE]
>  Visual Basic 用户可以省略<xref:System.Threading.ThreadStart>构造函数创建线程时。 使用`AddressOf`运算符传递你的方法，例如时`Dim t As New Thread(AddressOf ThreadProc)`。 Visual Basic 将自动调用<xref:System.Threading.ThreadStart>构造函数。  
  
   
  
## Examples  
 下面的示例演示了创建和使用的语法<xref:System.Threading.ParameterizedThreadStart>委托，它具有一个静态方法和实例方法。  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">表示开始执行此线程时要调用的方法的 <see cref="T:System.Threading.ThreadStart" /> 委托。</param>
        <summary>初始化 <see cref="T:System.Threading.Thread" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 线程不会开始执行时创建它。 若要安排执行的线程，请调用<xref:System.Threading.Thread.Start%2A>方法。  
  
> [!NOTE]
>  Visual Basic 用户可以省略<xref:System.Threading.ThreadStart>构造函数创建线程时。 使用`AddressOf`运算符，例如传递你的方法时`Dim t As New Thread(AddressOf ThreadProc)`。 Visual Basic 将自动调用<xref:System.Threading.ThreadStart>构造函数。  
  
   
  
## Examples  
 下面的代码示例演示如何创建线程执行的静态方法。  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 下面的代码示例演示如何创建执行的实例方法的线程。  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> 参数为 <see langword="null" />。</exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">表示开始执行此线程时要调用的方法的 <see cref="T:System.Threading.ParameterizedThreadStart" /> 委托。</param>
        <param name="maxStackSize">线程要使用的最大堆栈大小（以字节为单位）；如果为 0，则使用可执行文件的文件头中指定的默认最大堆栈大小。  
  
 重要事项   对于部分受信任的代码，如果 <c>maxStackSize</c> 大于默认堆栈大小，则将其忽略。 不引发异常。</param>
        <summary>初始化 <see cref="T:System.Threading.Thread" /> 类的新实例，指定允许对象在线程启动时传递给线程的委托，并指定线程的最大堆栈大小。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 避免使用此构造函数重载。 使用的默认堆栈大小<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>构造函数重载是线程的建议的堆栈大小。 如果一个线程出现内存问题，最可能的原因编程错误，例如无限递归。  
  
> [!IMPORTANT]
>  开头[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、 完全受信任的代码可以设置只`maxStackSize`为大于默认堆栈大小 （1 兆字节） 的值。 如果为指定更大的值`maxStackSize`时使用部分信任，运行代码`maxStackSize`将被忽略，并且默认堆栈大小适用。 不引发异常。 在任何信任级别的代码可以设置`maxStackSize`为小于默认堆栈大小的值。  
  
> [!NOTE]
>  如果你正在开发的完全受信任的库，将由部分受信任的代码，并且你需要启动线程需要大量堆栈，则必须在创建线程之前, 声明完全信任或将使用默认堆栈大小。 除非你完全控制的线程运行的代码，则请执行此操作。  
  
 如果`maxStackSize`小于比最小的堆栈大小，使用的最小的堆栈大小。 如果`maxStackSize`不是倍数的页大小，将其舍入到的页大小的下一个更大倍数。 例如，如果在 Windows Vista 上使用.NET Framework 2.0 版，256 KB （262144 字节） 是最小的堆栈大小，和的页大小为 64 KB （65536 字节为单位）。  
  
> [!NOTE]
>  在版本的 Windows XP 和 Windows Server 2003 之前的 Microsoft Windows`maxStackSize`将被忽略，并使用可执行文件的标头中指定的堆栈大小。  
  
 如果指定非常小的堆栈大小，你可能需要禁用堆栈溢出探测。 当堆栈受到严重约束时，探测可以本身导致堆栈溢出。 若要禁用堆栈溢出探测，到应用程序配置文件添加以下内容。  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">表示开始执行此线程时要调用的方法的 <see cref="T:System.Threading.ThreadStart" /> 委托。</param>
        <param name="maxStackSize">线程要使用的最大堆栈大小（以字节为单位）；如果为 0，则使用可执行文件的文件头中指定的默认最大堆栈大小。  
  
 重要事项   对于部分受信任的代码，如果 <c>maxStackSize</c> 大于默认堆栈大小，则将其忽略。 不引发异常。</param>
        <summary>初始化 <see cref="T:System.Threading.Thread" /> 类的新实例，指定线程的最大堆栈大小。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 避免使用此构造函数重载。 使用的默认堆栈大小<xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>构造函数重载是线程的建议的堆栈大小。 如果一个线程出现内存问题，最可能的原因编程错误，例如无限递归。  
  
> [!IMPORTANT]
>  开头[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、 完全受信任的代码可以设置只`maxStackSize`为大于默认堆栈大小 （1 兆字节） 的值。 如果为指定更大的值`maxStackSize`时使用部分信任，运行代码`maxStackSize`将被忽略，并且默认堆栈大小适用。 不引发异常。 在任何信任级别的代码可以设置`maxStackSize`为小于默认堆栈大小的值。  
  
> [!NOTE]
>  如果你正在开发的完全受信任的库，将由部分受信任的代码，并且你需要启动线程需要大量堆栈，则必须在创建线程之前, 声明完全信任或将使用默认堆栈大小。 除非你完全控制的线程运行的代码，则请执行此操作。  
  
 如果`maxStackSize`小于比最小的堆栈大小，使用的最小的堆栈大小。 如果`maxStackSize`不是倍数的页大小，将其舍入到的页大小的下一个更大倍数。 例如，如果在 Windows Vista 上使用.NET Framework 2.0 版，256 KB （262144 字节） 是最小的堆栈大小，和的页大小为 64 KB （65536 字节为单位）。  
  
> [!NOTE]
>  在版本的 Windows XP 和 Windows Server 2003 之前的 Microsoft Windows`maxStackSize`将被忽略，并使用可执行文件的标头中指定的堆栈大小。  
  
 如果指定非常小的堆栈大小，你可能需要禁用堆栈溢出探测。 当堆栈受到严重约束时，探测可以本身导致堆栈溢出。 若要禁用堆栈溢出探测，到应用程序配置文件添加以下内容。  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> 小于零。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在调用此方法的线程上引发 <see cref="T:System.Threading.ThreadAbortException" />，以开始终止此线程的过程。 调用此方法通常会终止线程。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在调用此方法的线程上引发 <see cref="T:System.Threading.ThreadAbortException" />，以开始终止此线程的过程。 调用此方法通常会终止线程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在线程上调用此方法时，系统将引发<xref:System.Threading.ThreadAbortException>在中止的线程中。 `ThreadAbortException` 是可由应用程序代码中，捕获特殊异常但被重新引发末尾`catch`除非阻止<xref:System.Threading.Thread.ResetAbort%2A>调用。 `ResetAbort` 取消请求中止，并防止`ThreadAbortException`从终止此线程。 快进`finally`块执行之前在线程终止。  
  
> [!NOTE]
>  当线程调用`Abort`自身，结果类似于引发异常;<xref:System.Threading.ThreadAbortException>立即，并且结果为可预测。 但是，如果一个线程调用`Abort`上另一线程，则将中断运行的任何代码。 此外，还有可能无法中止静态构造函数。 在极少数情况下，这可能会阻止在该应用程序域中创建该类的实例。 在.NET framework 1.0 和 1.1 版中，则的可能无法中止线程时`finally`运行块，在这种情况下`finally`中止块。  
  
 线程不能保证中止立即，要么根本。 如果一个线程非常的大量的计算中可以出现这种情况`finally`作为终止过程，从而无限期延迟中止中调用的块。 若要等待，直到线程已中止，你可以调用<xref:System.Threading.Thread.Join%2A>方法在调用线程上的<xref:System.Threading.Thread.Abort%2A>方法，但不能保证，等待将结束。  
  
> [!NOTE]
>  调用的线程<xref:System.Threading.Thread.Abort%2A>如果正在中止的线程处于受保护的代码区域，如可能会阻止`catch`块，`finally`块或受约束的执行区域。 如果调用线程<xref:System.Threading.Thread.Abort%2A>持有中止的线程需要，会出现死锁的锁。  
  
 如果`Abort`称为上尚未启动的线程，该线程将中止时<xref:System.Threading.Thread.Start%2A>调用。 如果`Abort`调用上被阻止或正在休眠的线程，该线程中断，然后中止。  
  
 如果`Abort`已挂起的线程上调用<xref:System.Threading.ThreadStateException>调用线程中引发<xref:System.Threading.Thread.Abort%2A>，和<xref:System.Threading.ThreadState.AbortRequested>添加到<xref:System.Threading.Thread.ThreadState%2A>正在中止的线程的属性。 A<xref:System.Threading.ThreadAbortException>不会在之前已挂起的线程中引发<xref:System.Threading.Thread.Resume%2A>调用。  
  
 如果`Abort`执行非托管的代码时在托管线程上调用`ThreadAbortException`直到返回到托管代码的线程不会引发。  
  
 如果两次调用`Abort`出现在同一时间，它是用于设置的状态信息的一个调用和执行的其他调用`Abort`。 但是，应用程序无法检测到这种情况。  
  
 后`Abort`调用线程的状态在一个线程上包括<xref:System.Threading.ThreadState.AbortRequested>。 线程已终止由于成功调用后`Abort`，线程的状态更改为<xref:System.Threading.ThreadState.Stopped>。 使用具有足够权限，线程，是目标的`Abort`可以取消中止使用`ResetAbort`方法。 有关示例，演示如何调用`ResetAbort`方法，请参阅`ThreadAbortException`类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">仅限 .NET Core：不支持此成员。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.Threading.ThreadStateException">正在中止的线程当前已挂起。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">有关线程的高级操作。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">一个对象，它包含应用程序特定的信息（如状态），该信息可供正被中止的线程使用。</param>
        <summary>引发在其上调用的线程中的 <see cref="T:System.Threading.ThreadAbortException" /> 以开始处理终止线程，同时提供有关线程终止的异常信息。 调用此方法通常会终止线程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在线程上调用此方法时，系统将引发<xref:System.Threading.ThreadAbortException>在中止的线程中。 `ThreadAbortException` 是可由应用程序代码中，捕获特殊异常但被重新引发末尾`catch`除非阻止<xref:System.Threading.Thread.ResetAbort%2A>调用。 `ResetAbort` 取消请求中止，并防止`ThreadAbortException`从终止此线程。 快进`finally`块执行之前在线程终止。  
  
> [!NOTE]
>  当线程调用`Abort`自身，结果类似于引发异常;<xref:System.Threading.ThreadAbortException>立即，并且结果为可预测。 但是，如果一个线程调用`Abort`上另一线程，则将中断运行的任何代码。 没有静态构造函数可能被中止的机会。 在极少数情况下，这可能会阻止在该应用程序域中创建该类的实例。 在.NET framework 1.0 和 1.1 版中，则的可能无法中止线程时`finally`运行块，在这种情况下`finally`中止块。  
  
 线程不能保证中止立即，要么根本。 如果一个线程非常的大量的计算中可以出现这种情况`finally`作为终止过程，从而无限期延迟中止中调用的块。 若要等待，直到线程已中止，你可以调用<xref:System.Threading.Thread.Join%2A>方法在调用线程上的<xref:System.Threading.Thread.Abort%2A>方法，但不能保证在等待将结束。  
  
> [!NOTE]
>  调用的线程<xref:System.Threading.Thread.Abort%2A>如果正在中止的线程处于受保护的代码区域，如可能会阻止`catch`块，`finally`块或受约束的执行区域。 如果调用线程<xref:System.Threading.Thread.Abort%2A>持有中止的线程需要，会出现死锁的锁。  
  
 如果`Abort`称为上尚未启动的线程，该线程将中止时<xref:System.Threading.Thread.Start%2A>调用。 如果`Abort`调用上被阻止或正在休眠的线程，该线程中断，然后中止。  
  
 如果`Abort`已挂起的线程上调用<xref:System.Threading.ThreadStateException>调用线程中引发<xref:System.Threading.Thread.Abort%2A>，和<xref:System.Threading.ThreadState.AbortRequested>添加到<xref:System.Threading.Thread.ThreadState%2A>正在中止的线程的属性。 A<xref:System.Threading.ThreadAbortException>不会在之前已挂起的线程中引发<xref:System.Threading.Thread.Resume%2A>调用。  
  
 如果`Abort`执行非托管的代码时在托管线程上调用`ThreadAbortException`直到返回到托管代码的线程不会引发。  
  
 如果两次调用`Abort`出现在同一时间，它是用于设置的状态信息的一个调用和执行的其他调用`Abort`。 但是，应用程序无法检测到这种情况。  
  
 后`Abort`调用线程的状态在一个线程上包括<xref:System.Threading.ThreadState.AbortRequested>。 线程已终止由于成功调用后`Abort`，线程的状态更改为<xref:System.Threading.ThreadState.Stopped>。 使用具有足够权限，线程，是目标的`Abort`可以取消中止使用`ResetAbort`方法。 有关示例，演示如何调用`ResetAbort`方法，请参阅`ThreadAbortException`类。  
  
   
  
## Examples  
 下面的代码示例演示如何将信息传递给正在中止的线程。  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">仅限 .NET Core：不支持此成员。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.Threading.ThreadStateException">正在中止的线程当前已挂起。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">有关线程的高级操作。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在所有线程上分配未命名的数据槽。 为了获得更好的性能，请改用以 <see cref="T:System.ThreadStaticAttribute" /> 特性标记的字段。</summary>
        <returns>所有线程上已分配的命名数据槽。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework 提供了有关使用线程本地存储区 (TLS) 的两种机制： 线程相关的静态字段 (即，使用标记的字段<xref:System.ThreadStaticAttribute>属性) 和数据槽。 线程相关的静态字段提供更好的性能比数据槽，编译时类型检查。 有关使用 TLS 的详细信息，请参阅[线程本地存储区： 线程相关的静态字段和数据槽](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。  
  
 所有线程上分配槽。  
  
 线程使用本地存储内存机制来存储线程特定的数据。 创建时，公共语言运行时分配给每个进程的多插槽数据存储数组。 线程可以分配数据存储区中的数据槽、 存储和检索数据的槽中值和线程过期后释放槽以供重用。 数据槽是每个线程的唯一的。 没有其他线程 （甚至不是子线程） 可以获取该数据。  
  
   
  
## Examples  
 本部分包含两个代码示例。 第一个示例演示如何使用字段将标有<xref:System.ThreadStaticAttribute>特性来保存线程特定的信息。 第二个示例演示如何使用数据槽执行相同的操作。  
  
 **第一个示例**  
  
 下面的示例演示如何使用字段将标有<xref:System.ThreadStaticAttribute>来保存线程特定的信息。 此方法提供更好的性能比第二个示例所示的技术。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **第二个示例**  
  
 下面的代码示例演示如何使用的数据槽存储线程特定的信息。  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要分配的数据槽的名称。</param>
        <summary>在所有线程上分配已命名的数据槽。 为了获得更好的性能，请改用以 <see cref="T:System.ThreadStaticAttribute" /> 特性标记的字段。</summary>
        <returns>所有线程上已分配的命名数据槽。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework 提供了有关使用线程本地存储区 (TLS) 的两种机制： 线程相关的静态字段 (即，使用标记的字段<xref:System.ThreadStaticAttribute>属性) 和数据槽。 线程相关的静态字段提供更好的性能比数据槽，编译时类型检查。 有关使用 TLS 的详细信息，请参阅[线程本地存储区： 线程相关的静态字段和数据槽](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。  
  
 线程使用本地存储内存机制来存储线程特定的数据。 创建时，公共语言运行时分配给每个进程的多插槽数据存储数组。 线程可以分配数据存储区中的数据槽、 存储和检索数据的槽中值和线程过期后释放槽以供重用。 数据槽是每个线程的唯一的。 没有其他线程 （甚至不是子线程） 可以获取该数据。  
  
 不需要使用<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>方法，以分配的命名的数据槽，因为<xref:System.Threading.Thread.GetNamedDataSlot%2A>方法分配槽，如果尚未分配。  
  
> [!NOTE]
>  如果<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>使用方法，因为它将引发异常，如果具有指定名称的槽已分配应该在程序启动时，主线程中调用它。 没有方法来测试是否已分配一个槽。  
  
 使用此方法分配的槽必须释放与<xref:System.Threading.Thread.FreeNamedDataSlot%2A>。  
  
   
  
## Examples  
 本部分包含两个代码示例。 第一个示例演示如何使用字段将标有<xref:System.ThreadStaticAttribute>特性来保存线程特定的信息。 第二个示例演示如何使用数据槽执行相同的操作。  
  
 **第一个示例**  
  
 下面的示例演示如何使用字段将标有<xref:System.ThreadStaticAttribute>来保存线程特定的信息。 此方法提供更好的性能比第二个示例所示的技术。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **第二个示例**  
  
 下面的示例演示如何使用命名的数据槽以存储线程特定的信息。  
  
> [!NOTE]
>  此代码示例不使用<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>方法，因为<xref:System.Threading.Thread.GetNamedDataSlot%2A>方法分配槽，如果尚未分配。 如果<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>方法时，应在程序启动主线程中调用它。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">已存在具有指定名称的命名的数据槽。</exception>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此线程的单元状态。</summary>
        <value>
          <see cref="T:System.Threading.ApartmentState" /> 值之一。 初始值为 <see langword="Unknown" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **<xref:System.Threading.Thread.ApartmentState%2A>属性已过时。**  未过时的替代项为<xref:System.Threading.Thread.GetApartmentState%2A>方法来检索其中的单元状态和<xref:System.Threading.Thread.SetApartmentState%2A>方法以设置单元状态。  
  
 在.NET framework 1.0 和 1.1 中，`ApartmentState`属性标记的线程以指示它将在单线程还是多线程单元中执行。 可以设置此属性，当线程处于`Unstarted`或`Running`线程状态; 但是，它可以只能设置一次一个线程。 如果尚未设置属性，它将返回`Unknown`。  
  
 尝试使用<xref:System.Threading.Thread.ApartmentState%2A>忽略属性设置已设置其单元状态的线程的单元状态。 但是，<xref:System.Threading.Thread.SetApartmentState%2A>方法抛出异常<xref:System.InvalidOperationException>在这种情况下。  
  
> [!IMPORTANT]
>  在.NET Framework 2.0 版中，新的线程将初始化为<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>如果它们启动之前尚未设置其单元状态。 主应用程序线程被初始化为<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>默认情况下。 你无法再设置的主应用程序线程<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>通过设置<xref:System.Threading.ApartmentState?displayProperty=nameWithType>代码的第一行上的属性。 使用<xref:System.STAThreadAttribute>相反。  
  
 在.NET Framework 2.0 版中，你可以指定的 COM 线程模型为 c + + 应用程序使用[/CLRTHREADATTRIBUTE （设置 CLR 线程特性）](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8)链接器选项。  
  
   
  
## Examples  
 下面的代码示例演示如何设置线程的单元状态。  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">尝试将此属性设置为不是有效单元状态的状态 （单线程单元 (<see langword="STA" />) 或多线程单元 (<see langword="MTA" />) 以外的状态）。</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通知宿主执行将要进入一个代码区域，在该代码区域内线程中止或未经处理异常的影响可能会危害应用程序域中的其他任务。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 公共语言运行时 (CLR)，如 Microsoft SQL Server 2005，主机可以建立不同的策略中的代码的关键和非关键区域的故障。 关键区域是一个线程中止或未经处理的异常的影响可能会不限于当前任务。 与此相反，中止或非关键区域的代码中的失败会影响仅在其中出错的任务。  
  
 例如，考虑一个尝试持有的锁时分配内存的任务。 如果内存分配失败，正在中止当前任务不能确保稳定性<xref:System.AppDomain>，因为在等待相同的锁的域可以是其他任务。 如果当前任务将被终止，则其他任务无法死锁。  
  
 在关键区域中发生故障，主机可能会决定是否要卸载整个<xref:System.AppDomain>而不是在可能不稳定状态中继续执行的风险。 若要通知宿主代码正在进入关键区域，调用<xref:System.Threading.Thread.BeginCriticalRegion%2A>。 调用<xref:System.Threading.Thread.EndCriticalRegion%2A>当执行返回到代码的非关键区域。  
  
 在 SQL Server 2005 下运行的代码中使用此方法需要要在最高的主机保护级别运行的代码。  
  
   
  
## Examples  
 下面的示例演示了利用<xref:System.Threading.Thread.BeginCriticalRegion%2A>和<xref:System.Threading.Thread.EndCriticalRegion%2A>方法将划分为关键和非关键区域的代码块。  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通知主机托管代码将要执行依赖于当前物理操作系统线程的标识的指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 公共语言运行时，如 Microsoft SQL Server 2005，某些主机提供其自己的线程管理。 提供其自己的线程管理的主机可以正在执行的任务在一个物理操作系统线程之间移动在任何时间。 大多数任务不受这种切换。 但是，某些任务具有线程关联 — 也就是说，它们依赖于物理操作系统线程的标识。 这些任务必须通知宿主在其执行不会切换的代码。  
  
 例如，如果应用程序调用一个系统 API 来获取操作系统锁定具有线程关联，例如 Win32 CRITICAL_SECTION 中，必须调用<xref:System.Threading.Thread.BeginThreadAffinity%2A>之前获取锁，和<xref:System.Threading.Thread.EndThreadAffinity%2A>后释放锁。  
  
 在 SQL Server 2005 下运行的代码中使用此方法需要要在最高的主机保护级别运行的代码。  
  
   
  
## Examples  
 下面的示例演示了利用<xref:System.Threading.Thread.BeginThreadAffinity%2A>和<xref:System.Threading.Thread.EndThreadAffinity%2A>方法用于通知的代码块取决于物理操作系统线程的标识的主机。  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取线程正在其中执行的当前上下文。</summary>
        <value>表示当前线程上下文的 <see cref="T:System.Runtime.Remoting.Contexts.Context" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前线程的区域性。</summary>
        <value>表示当前线程的区域性的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo>以及其关联的对象，此属性所返回的对象确定的日期的默认格式、 时间、 数字、 货币值，排序顺序的文本、 大小写约定，和的字符串比较。 请参阅<xref:System.Globalization.CultureInfo>类若要了解有关区域性名称和标识符，固定，非特定，和特定区域性之间的差异和区域性信息的方式会影响线程和应用程序域。 请参阅<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>属性以了解如何确定线程的默认区域性，以及用户如何设置其计算机的区域性信息。  
  
 开头[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，你可以设置<xref:System.Threading.Thread.CurrentCulture%2A>属性设置为非特定区域性。 这是因为的行为<xref:System.Globalization.CultureInfo>类已更改： 时，它表示非特定区域性，其属性值 (具体而言， <xref:System.Globalization.CultureInfo.Calendar%2A>， <xref:System.Globalization.CultureInfo.CompareInfo%2A>， <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>， <xref:System.Globalization.CultureInfo.NumberFormat%2A>，和<xref:System.Globalization.CultureInfo.TextInfo%2A>属性) 现在反映与非特定区域性关联的特定区域性。 在早期版本的.NET Framework 中，<xref:System.Threading.Thread.CurrentCulture%2A>属性引发<xref:System.NotSupportedException>异常时分配的非特定区域性。  
  
   
  
## Examples  
 下面的代码示例显示允许 Windows 窗体，以显示在控制面板中设置的区域性中的用户界面的线程处理语句。 需要附加代码。  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">属性设置为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">有关设置的属性。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置线程的当前负责人（对基于角色的安全性而言）。</summary>
        <value>表示安全上下文的 <see cref="T:System.Security.Principal.IPrincipal" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何设置和检索线程的主体。  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有设置该主体所需的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要操作的主体对象。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前正在运行的线程。</summary>
        <value>
          <see cref="T:System.Threading.Thread" />，表示当前正在运行的线程。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建反过来创建 20 个的子任务的任务。 在应用程序本身，作为很好地为每个任务中，调用`ShowThreadInformation`方法，它使用<xref:System.Threading.Thread.CurrentThread%2A>属性来显示有关在其运行的线程的信息。  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 每个子任务生成 1 亿个随机数字，介于 1 和 100 万个，并返回其平均值。 父任务调用<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>方法，以确保子任务已完成之前显示每个任务返回的平均值和计算平均值的平均值。  
  
 请注意，当应用程序运行在前台线程上时，每个任务运行在线程池线程上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置资源管理器使用的当前区域性以便在运行时查找区域性特定的资源。</summary>
        <value>表示当前区域性的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 UI 区域性指定应用程序需要支持用户输入和输出，以及默认情况下与操作系统区域性相同的资源。 请参阅<xref:System.Globalization.CultureInfo>类若要了解有关区域性名称和标识符，固定，非特定，和特定区域性之间的差异和区域性信息的方式会影响线程和应用程序域。 请参阅<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>属性若要了解如何确定线程的默认 UI 区域性。  
  
 <xref:System.Globalization.CultureInfo>返回此属性可以是一个非特定区域性。 非特定区域性不应与等格式设置方法<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>， <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>，和<xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>。 使用<xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>方法以获取特定区域性，或者使用<xref:System.Threading.Thread.CurrentCulture%2A>属性。  
  
> [!NOTE]
>  <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>方法抛出异常<xref:System.ArgumentException>非特定区域性"此不同 ("ZH-CHT") 和"中文-Hans"("ZH-CHS")。  
  
   
  
## Examples  
 下面的示例确定是否当前线程的 UI 区域性的语言为法语。 如果不是这样，它会将当前线程的 UI 区域性设置为英语 （美国）。  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 下面的代码示例显示允许 Windows 窗体，以显示在控制面板中设置的区域性中的用户界面的线程处理语句。 需要附加代码。  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">属性设置为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">该属性设置为不能用于定位资源文件的区域性名称。 资源文件名必须仅包含字母、数字、连字符或下划线。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>对于当前线程关闭运行时可调用包装 (RCW) 的自动清理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，公共语言运行时 (CLR) 运行时可调用包装器会自动清理。 在清除，这可能会导致某些应用程序的可重入性问题的过程的 CLR 泵消息满足以下异常条件：  
  
-   应用程序执行自己消息泵处理。  
  
-   应用程序需要精确地控制何时消息泵处理时发生。  
  
 此类应用程序可以使用<xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A>方法，以防止 CLR 执行自动回收的运行时可调用包装器。  
  
 当已在一个线程上调用此方法时，自动清理无法重新启用该线程。 准备好清理运行时可调用包装你的应用程序时，请使用<xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType>方法，以指示运行时清理当前上下文中的所有运行时可调用包装。 该方法将执行时发生消息泵处理。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通知宿主执行将要进入一个代码区域，在该代码区域内线程中止或未经处理异常的影响限于当前任务。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 公共语言运行时 (CLR)，如 Microsoft SQL Server 2005，主机可以建立不同的策略中的代码的关键和非关键区域的故障。 关键区域是一个线程中止或未经处理的异常的影响可能会不限于当前任务。 与此相反，中止或非关键区域的代码中的失败会影响仅在其中出错的任务。  
  
 例如，考虑一个尝试持有的锁时分配内存的任务。 如果内存分配失败，正在中止当前任务不能确保稳定性<xref:System.AppDomain>，因为在等待相同的锁的域可以是其他任务。 如果当前任务将被终止，则其他任务无法死锁。  
  
 在关键区域中发生故障，主机可能会决定是否要卸载整个<xref:System.AppDomain>而不是在可能不稳定状态中继续执行的风险。 若要通知宿主代码正在进入关键区域，调用<xref:System.Threading.Thread.BeginCriticalRegion%2A>。 调用<xref:System.Threading.Thread.EndCriticalRegion%2A>当执行返回到代码的非关键区域。  
  
 在 SQL Server 2005 下运行的代码中使用此方法需要要在最高的主机保护级别运行的代码。  
  
   
  
## Examples  
 下面的示例演示了利用<xref:System.Threading.Thread.BeginCriticalRegion%2A>和<xref:System.Threading.Thread.EndCriticalRegion%2A>方法将划分为关键和非关键区域的代码块。  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通知宿主托管代码已执行完依赖于当前物理操作系统线程的标识的指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 公共语言运行时，如 Microsoft SQL Server 2005，某些主机提供其自己的线程管理。 提供其自己的线程管理的主机可以正在执行的任务在一个物理操作系统线程之间移动在任何时间。 大多数任务不受这种切换。 但是，某些任务具有线程关联 — 也就是说，它们依赖于物理操作系统线程的标识。 这些任务必须通知宿主在其执行不会切换的代码。  
  
 例如，如果应用程序调用一个系统 API 来获取操作系统锁定具有线程关联，例如 Win32 CRITICAL_SECTION 中，必须调用<xref:System.Threading.Thread.BeginThreadAffinity%2A>之前获取锁，和<xref:System.Threading.Thread.EndThreadAffinity%2A>后释放锁。  
  
 在 SQL Server 2005 下运行的代码中使用此方法需要要在最高的主机保护级别运行的代码。  
  
   
  
## Examples  
 下面的示例演示了利用<xref:System.Threading.Thread.BeginThreadAffinity%2A>和<xref:System.Threading.Thread.EndThreadAffinity%2A>方法用于通知的代码块取决于物理操作系统线程的标识的主机。  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Threading.ExecutionContext" /> 对象，该对象包含有关当前线程的各种上下文的信息。</summary>
        <value>一个 <see cref="T:System.Threading.ExecutionContext" /> 对象，包含当前线程的上下文信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ExecutionContext>类提供了单个容器的执行逻辑线程相关的所有信息。 这包括安全上下文，调用上下文、 同步上下文，本地化上下文和事务上下文。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>确保垃圾回收器回收 <see cref="T:System.Threading.Thread" /> 对象时释放资源并执行其他清理操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 垃圾回收器调用<xref:System.Threading.Thread.Finalize%2A>何时准备好完成当前的对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要释放的数据槽的名称。</param>
        <summary>为进程中的所有线程消除名称与槽之间的关联。 为了获得更好的性能，请改用以 <see cref="T:System.ThreadStaticAttribute" /> 特性标记的字段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework 提供了有关使用线程本地存储区 (TLS) 的两种机制： 线程相关的静态字段 (即，使用标记的字段<xref:System.ThreadStaticAttribute>属性) 和数据槽。 线程相关的静态字段提供更好的性能比数据槽，编译时类型检查。 有关使用 TLS 的详细信息，请参阅[线程本地存储区： 线程相关的静态字段和数据槽](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。  
  
 任何线程调用后`FreeNamedDataSlot`，调用的其他任何线程<xref:System.Threading.Thread.GetNamedDataSlot%2A>具有相同名称将分配一个与名称关联的新槽。 后续调用`GetNamedDataSlot`任何线程将返回新的槽。 但是，任何线程仍具有<xref:System.LocalDataStoreSlot?displayProperty=nameWithType>返回到以前通过调用`GetNamedDataSlot`可以继续使用旧的槽。  
  
 发布已与名称关联的槽仅当每个`LocalDataStoreSlot`之前对的调用获得的`FreeNamedDataSlot`已被释放并垃圾回收。  
  
 线程使用本地存储内存机制来存储线程特定的数据。 创建时，公共语言运行时分配给每个进程的多插槽数据存储数组。 线程可以分配数据存储区中的数据槽、 存储和检索数据的槽中值和线程过期后释放槽以供重用。 数据槽是每个线程的唯一的。 没有其他线程 （甚至不是子线程） 可以获取该数据。  
  
   
  
## Examples  
 本部分包含两个代码示例。 第一个示例演示如何使用字段将标有<xref:System.ThreadStaticAttribute>特性来保存线程特定的信息。 第二个示例演示如何使用数据槽执行相同的操作。  
  
 **第一个示例**  
  
 下面的示例演示如何使用字段将标有<xref:System.ThreadStaticAttribute>来保存线程特定的信息。 此方法提供更好的性能比第二个示例所示的技术。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **第二个示例**  
  
 下面的示例演示如何使用命名的数据槽以存储线程特定的信息。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示单元状态的 <see cref="T:System.Threading.ApartmentState" /> 值。</summary>
        <returns>其中一个表示托管线程的单元状态的 <see cref="T:System.Threading.ApartmentState" /> 值。 默认值为 <see cref="F:System.Threading.ApartmentState.Unknown" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法，以及<xref:System.Threading.Thread.SetApartmentState%2A>方法和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法，将替换<xref:System.Threading.Thread.ApartmentState%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Threading.Thread.GetApartmentState%2A>， <xref:System.Threading.Thread.SetApartmentState%2A>，和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法。 代码示例创建一个线程。 在线程启动之前，<xref:System.Threading.Thread.GetApartmentState%2A>显示初始<xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>状态和<xref:System.Threading.Thread.SetApartmentState%2A>将状态更改为<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。 <xref:System.Threading.Thread.TrySetApartmentState%2A>方法然后返回`false`时尝试的状态更改为<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>因为已经设置了单元状态。 如果相同的操作已尝试使用<xref:System.Threading.Thread.SetApartmentState%2A>，<xref:System.InvalidOperationException>将引发。  
  
 在线程启动后，<xref:System.Threading.Thread.TrySetApartmentState%2A>方法会再次使用。 这次将引发<xref:System.Threading.ThreadStateException>因为线程已启动。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Threading.CompressedStack" /> 对象，此对象可用于获取当前线程的堆栈。</summary>
        <returns>无。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不再支持此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在所有情况下。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">要从其获取值的 <see cref="T:System.LocalDataStoreSlot" />。</param>
        <summary>在当前线程的当前域中从当前线程上指定的槽中检索值。 为了获得更好的性能，请改用以 <see cref="T:System.ThreadStaticAttribute" /> 特性标记的字段。</summary>
        <returns>检索到的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework 提供了有关使用线程本地存储区 (TLS) 的两种机制： 线程相关的静态字段 (即，使用标记的字段<xref:System.ThreadStaticAttribute>属性) 和数据槽。 线程相关的静态字段提供更好的性能比数据槽，编译时类型检查。 有关使用 TLS 的详细信息，请参阅[线程本地存储区： 线程相关的静态字段和数据槽](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。  
  
 线程使用本地存储内存机制来存储线程特定的数据。 创建时，公共语言运行时分配给每个进程的多插槽数据存储数组。 线程可以分配数据存储区中的数据槽、 存储和检索数据的槽中值和线程过期后释放槽以供重用。 数据槽是每个线程的唯一的。 没有其他线程 （甚至不是子线程） 可以获取该数据。  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A> 是`Shared`始终将应用于当前正在执行的线程，即使你在调用它使用另一个线程是指变量的方法。 为了避免混淆，使用调用时`Shared`方法： `Dim test As Object = Thread.GetData(testSlot)`。  
  
   
  
## Examples  
 本部分包含两个代码示例。 第一个示例演示如何使用字段将标有<xref:System.ThreadStaticAttribute>特性来保存线程特定的信息。 第二个示例演示如何使用数据槽执行相同的操作。  
  
 **第一个示例**  
  
 下面的示例演示如何使用字段将标有<xref:System.ThreadStaticAttribute>来保存线程特定的信息。 此方法提供更好的性能比第二个示例所示的技术。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **第二个示例**  
  
 下面的示例演示如何使用的数据槽以存储线程特定的信息。  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前线程正在其中运行的当前域。</summary>
        <returns>表示正在运行的线程的当前应用程序域的 <see cref="T:System.AppDomain" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何检索的名称和 ID`AppDomain`中的线程运行。  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回唯一的应用程序域标识符。</summary>
        <returns>唯一标识应用程序域的 32 位有符号整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何检索的名称和 ID`AppDomain`中的线程运行。  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前线程的哈希代码。</summary>
        <returns>整数哈希代码值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不保证是唯一的哈希代码。 使用<xref:System.Threading.Thread.ManagedThreadId%2A>属性，如果你需要为托管线程的唯一标识符。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">本地数据槽的名称。</param>
        <summary>查找命名的数据槽。 为了获得更好的性能，请改用以 <see cref="T:System.ThreadStaticAttribute" /> 特性标记的字段。</summary>
        <returns>为此线程分配的 <see cref="T:System.LocalDataStoreSlot" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework 提供了有关使用线程本地存储区 (TLS) 的两种机制： 线程相关的静态字段 (即，使用标记的字段<xref:System.ThreadStaticAttribute>属性) 和数据槽。 线程相关的静态字段提供更好的性能比数据槽，编译时类型检查。 有关使用 TLS 的详细信息，请参阅[线程本地存储区： 线程相关的静态字段和数据槽](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。  
  
 线程使用本地存储内存机制来存储线程特定的数据。 创建时，公共语言运行时分配给每个进程的多插槽数据存储数组。 线程可以分配数据存储区中的数据槽、 存储和检索数据的槽中值和线程过期后释放槽以供重用。 数据槽是每个线程的唯一的。 没有其他线程 （甚至不是子线程） 可以获取该数据。  
  
 如果命名的槽不存在，将分配新的槽。 命名的数据槽都是公开的并可操作的任何人。  
  
   
  
## Examples  
 本部分包含两个代码示例。 第一个示例演示如何使用字段将标有<xref:System.ThreadStaticAttribute>特性来保存线程特定的信息。 第二个示例演示如何使用数据槽执行相同的操作。  
  
 **第一个示例**  
  
 下面的示例演示如何使用字段将标有<xref:System.ThreadStaticAttribute>来保存线程特定的信息。 此方法提供更好的性能比第二个示例所示的技术。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **第二个示例**  
  
 下面的示例演示如何使用命名的数据槽以存储线程特定的信息。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>中断处于 <see langword="WaitSleepJoin" /> 线程状态的线程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在等待、 休眠或联接状态，此线程不当前被阻塞，则下次开始阻止时它将被中断。  
  
 <xref:System.Threading.ThreadInterruptedException> 在已中断线程，但此线程受到阻止之后才引发。 如果线程永远不会阻止，永远不会引发异常，并因此线程可能完成而不被中断。  
  
   
  
## Examples  
 在中断并随后被阻止时，下面的代码示例将显示正在运行的线程的行为。  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有适当的 <see cref="T:System.Security.Permissions.SecurityPermission" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">有关线程的高级操作。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</permission>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示当前线程的执行状态的值。</summary>
        <value>
          如果此线程已启动并且尚未正常终止或中止，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示某个线程是否为后台线程。</summary>
        <value>
          如果此线程为或将成为后台线程，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 线程是后台线程或前台线程。 后台线程均与前台线程相同，只不过后台线程不会阻止进程终止。 属于某个进程的所有前台线程已都终止，公共语言运行时结束该进程。 任何剩余的后台线程已停止，并不会完成。  
  
 默认情况下，以下线程执行在前台 (即，其<xref:System.Threading.Thread.IsBackground%2A>属性返回`false`):  
  
-   主线程 （或主应用程序线程）。  
  
-   通过调用创建的所有线程<xref:System.Threading.Thread>类构造函数。  
  
 默认情况下，以下线程在后台执行 (即，其<xref:System.Threading.Thread.IsBackground%2A>属性返回`true`):  
  
-   线程池线程，是一个由运行时维护辅助线程池。 可以通过使用线程池线程上配置的线程池和计划工作<xref:System.Threading.ThreadPool>类。  
  
    > [!NOTE]
    >  在线程池线程上自动执行基于任务的异步操作。  
  
-   从非托管代码进入托管的执行环境的所有线程。  
  
   
  
## Examples  
 下面的示例对比前台和后台线程的行为。 它将创建一个前台线程和后台线程。 前台线程前让进程一直运行，直到完成其`for`循环并终止。 但是，如示例输出所示，因为前台线程已完成执行，后台线程完成执行之前，已终止进程。  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">线程终止。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示线程是否属于托管线程池的值。</summary>
        <value>
          如果此线程属于托管线程池，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息请参阅[托管线程池](~/docs/standard/threading/the-managed-thread-pool.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何确定线程是否是从线程池。  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在此实例表示的线程终止前，阻止调用线程。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在继续执行标准的 COM 和 <see langword="SendMessage" /> 消息泵处理期间，阻止调用线程，直到由该实例表示的线程终止。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A> 是一种同步方法，阻止调用线程 （即，调用的方法的线程），直到线程其<xref:System.Threading.Thread.Join%2A>方法调用已完成。 使用此方法以确保线程已终止。 如果线程不会终止，调用方将无限期阻止。 在下面的示例中，`Thread1`线程调用<xref:System.Threading.Thread.Join>方法`Thread2`，这将导致`Thread1`到之前的块`Thread2`已完成。  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 如果线程已终止时<xref:System.Threading.Thread.Join%2A>调用时，该方法将立即返回。  
  
> [!WARNING]
>  你应永远不会调用<xref:System.Threading.Thread.Join%2A>方法<xref:System.Threading.Thread>对象，表示来自当前线程的当前线程。 这将导致您的应用程序挂起，因为当前线程自身无限期等待  
  
 此方法要包括的调用线程的状态更改<xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>。 不能调用`Join`中的线程上<xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>状态。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">调用方尝试加入处于 <see cref="F:System.Threading.ThreadState.Unstarted" /> 状态的线程。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">线程在等待时中断。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">等待线程终止的毫秒数。</param>
        <summary>在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻止调用线程，直到由该实例表示的线程终止或经过了指定时间为止。</summary>
        <returns>
          如果线程已终止，则为 <see langword="true" />；如果 <see langword="false" /> 参数指定的时间量已过之后还未终止线程，则为 <paramref name="millisecondsTimeout" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29> 是一种同步方法，阻止调用线程 （即，调用的方法的线程），直到任一线程其<xref:System.Threading.Thread.Join%2A>方法调用已完成或超时间隔已过去。 在下面的示例中，`Thread1`线程调用<xref:System.Threading.Thread.Join>方法`Thread2`，这将导致`Thread1`阻止直到`Thread2`已完成或 2 秒。  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 如果<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>为指定`millisecondsTimeout`参数，此方法的行为相同与<xref:System.Threading.Thread.Join>方法重载，只是返回值。  
  
 如果线程已终止时<xref:System.Threading.Thread.Join%2A>调用时，该方法将立即返回。  
  
 此方法要包括的调用线程的状态更改<xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>。 不能调用`Join`中的线程上<xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>状态。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 的值为负数，且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（以毫秒为单位）。</exception>
        <exception cref="T:System.Threading.ThreadStateException">该线程尚未启动。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">设置等待线程终止的时间量的 <see cref="T:System.TimeSpan" />。</param>
        <summary>在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻止调用线程，直到由该实例表示的线程终止或经过了指定时间为止。</summary>
        <returns>
          如果线程已终止，则为 <see langword="true" />；如果 <see langword="false" /> 参数指定的时间量已过之后还未终止线程，则为 <paramref name="timeout" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29> 是一种同步方法，阻止调用线程 （即，调用的方法的线程），直到任一线程其<xref:System.Threading.Thread.Join%2A>方法调用已完成或超时间隔已过去。 在下面的示例中，`Thread1`线程调用<xref:System.Threading.Thread.Join>方法`Thread2`，这将导致`Thread1`阻止直到`Thread2`已完成或 2 秒。  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 如果<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>为指定`timeout`，此方法的行为相同与<xref:System.Threading.Thread.Join>方法重载，只是返回值。  
  
 如果线程已终止时<xref:System.Threading.Thread.Join%2A>调用时，该方法将立即返回。  
  
 此方法要包括的当前线程的状态更改<xref:System.Threading.ThreadState.WaitSleepJoin>。 不能调用`Join`中的线程上<xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>状态。  
  
   
  
## Examples  
 下面的代码示例演示如何使用`TimeSpan`值与`Join`方法。  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 的值为负数，且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（以毫秒为单位），或大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
        <exception cref="T:System.Threading.ThreadStateException">调用方尝试加入处于 <see cref="F:System.Threading.ThreadState.Unstarted" /> 状态的线程。</exception>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前托管线程的唯一标识符。</summary>
        <value>一个整数，表示此托管线程的唯一标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 线程的<xref:System.Threading.Thread.ManagedThreadId%2A>属性值用于唯一标识该线程在其进程中的。  
  
 值<xref:System.Threading.Thread.ManagedThreadId%2A>属性不发生改变随着时间推移，即使承载公共语言运行时的非托管的代码实现为纤程的线程。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>按如下方式同步内存访问：执行当前线程的处理器在对指令重新排序时，不能采用先执行 <see cref="M:System.Threading.Thread.MemoryBarrier" /> 调用之后的内存存取，再执行 <see cref="M:System.Threading.Thread.MemoryBarrier" /> 调用之前的内存存取的方式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A> 仅在多处理器系统上与弱排序 （例如，使用多个 Intel 的 Itanium 处理器的系统） 的内存要求。  
  
 大多数情况下，C#`lock`语句，Visual Basic`SyncLock`语句，或<xref:System.Threading.Monitor>类提供简单的方法，用于将数据同步。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置线程的名称。</summary>
        <value>包含线程名称的字符串或 <see langword="null" />（如果未设置名称）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是可写的后。 由于线程的默认值<xref:System.Threading.Thread.Name%2A>属性是`null`，你可以确定是否已被显式分配名称到线程通过比较其与`null`。  
  
 分配给字符串<xref:System.Threading.Thread.Name%2A>属性可以包含任何 Unicode 字符。  
  
   
  
## Examples  
 下面的示例演示如何命名一个线程。  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已请求集运算，但 <see langword="Name" /> 属性已设置。</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置指示线程的调度优先级的值。</summary>
        <value>
          <see cref="T:System.Threading.ThreadPriority" /> 值之一。 默认值为 <see cref="F:System.Threading.ThreadPriority.Normal" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以为线程分配任一以下优先级<xref:System.Threading.ThreadPriority>值：  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 操作系统不需要遵循的线程的优先级。  
  
   
  
## Examples  
 下面的示例演示由于更改线程的优先级。 创建三个线程，其中一个线程的优先级设置为<xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>，并且第二个的优先级设置为<xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>。 每个线程递增中的变量`while`循环和的设定时间运行。  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">线程已到达最终状态，例如 <see cref="F:System.Threading.ThreadState.Aborted" />。</exception>
        <exception cref="T:System.ArgumentException">为设置操作指定的值不是有效的 <see cref="T:System.Threading.ThreadPriority" /> 值。</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消当前线程所请求的 <see cref="M:System.Threading.Thread.Abort(System.Object)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅可以由具有适当权限的代码调用此方法。  
  
 当调用`Abort`终止线程，系统将引发<xref:System.Threading.ThreadAbortException>。 `ThreadAbortException` 是一个特殊的例外，可由应用程序代码中，捕获，但将被重新引发 catch 块的末尾除非`ResetAbort`调用。 `ResetAbort` 取消请求中止，并防止`ThreadAbortException`从终止此线程。  
  
 请参阅<xref:System.Threading.ThreadAbortException>有关的示例，演示如何调用`ResetAbort`方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">仅限 .NET Core：不支持此成员。</exception>
        <exception cref="T:System.Threading.ThreadStateException">
          未对当前线程调用 <see langword="Abort" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有当前线程要求的安全权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">有关线程的高级操作。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>继续已挂起的线程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  不要使用<xref:System.Threading.Thread.Suspend%2A>和<xref:System.Threading.Thread.Resume%2A>方法来同步线程活动。 具有无法知道哪些代码的线程正在执行挂起时。 如果您挂起线程，它在安全权限评估期间保持锁定中的其他线程<xref:System.AppDomain>可能被阻止。 如果您挂起线程执行类构造函数时中的其他线程<xref:System.AppDomain>中尝试使用类被阻止。 很容易发生死锁。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">仅限 .NET Core：不支持此成员。</exception>
        <exception cref="T:System.Threading.ThreadStateException">该线程尚未启动、 已死或未处于挂起状态。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有适当的 <see cref="T:System.Security.Permissions.SecurityPermission" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">有关线程的高级操作。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">新的单元状态。</param>
        <summary>在线程启动前设置其单元状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新线程将初始化为<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>如果它们启动之前尚未设置其单元状态。 启动线程之前，必须设置单元状态。  
  
> [!NOTE]
>  主应用程序线程被初始化为<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>默认情况下。 设置到的主应用程序线程的单元状态的唯一办法<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>，将应用<xref:System.STAThreadAttribute>属性设为入口点方法。  
  
 <xref:System.Threading.Thread.SetApartmentState%2A>方法，以及<xref:System.Threading.Thread.GetApartmentState%2A>方法和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法，将替换<xref:System.Threading.Thread.ApartmentState%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Threading.Thread.GetApartmentState%2A>， <xref:System.Threading.Thread.SetApartmentState%2A>，和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法。 代码示例创建一个线程。 在线程启动之前，<xref:System.Threading.Thread.GetApartmentState%2A>显示初始<xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>状态和<xref:System.Threading.Thread.SetApartmentState%2A>将状态更改为<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。 <xref:System.Threading.Thread.TrySetApartmentState%2A>方法然后返回`false`时尝试的状态更改为<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>因为已经设置了单元状态。 如果相同的操作已尝试使用<xref:System.Threading.Thread.SetApartmentState%2A>，<xref:System.InvalidOperationException>将引发。  
  
 在线程启动后，<xref:System.Threading.Thread.TrySetApartmentState%2A>方法会再次使用。 这次将引发<xref:System.Threading.ThreadStateException>因为线程已启动。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">仅限 .NET Core：macOS 和 Linux 平台上不支持此成员。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> 不是有效的单元状态。</exception>
        <exception cref="T:System.Threading.ThreadStateException">线程已启动。</exception>
        <exception cref="T:System.InvalidOperationException">已初始化单元状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">将被应用到当前线程的 <see cref="T:System.Threading.CompressedStack" /> 对象。</param>
        <summary>将捕获的 <see cref="T:System.Threading.CompressedStack" /> 应用到当前线程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不再支持此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在所有情况下。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">在其中设置值的 <see cref="T:System.LocalDataStoreSlot" />。</param>
        <param name="data">要设置的值。</param>
        <summary>在当前正在运行的线程上为此线程的当前域在指定槽中设置数据。 为了提高性能，请改用用 <see cref="T:System.ThreadStaticAttribute" /> 属性标记的字段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework 提供了有关使用线程本地存储区 (TLS) 的两种机制： 线程相关的静态字段 (即，使用标记的字段<xref:System.ThreadStaticAttribute>属性) 和数据槽。 线程相关的静态字段提供更好的性能比数据槽，编译时类型检查。 有关使用 TLS 的详细信息，请参阅[线程本地存储区： 线程相关的静态字段和数据槽](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。  
  
 线程使用本地存储内存机制来存储线程特定的数据。 创建时，公共语言运行时分配给每个进程的多插槽数据存储数组。 线程可以分配数据存储区中的数据槽、 存储和检索数据的槽中值和释放线程过程结束之后的槽以重用和<xref:System.Threading.Thread>垃圾回收功能回收对象。 数据槽是每个线程的唯一的。 没有其他线程 （甚至不是子线程） 可以获取该数据。  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A> 是`Shared`始终将应用于当前正在执行的线程，即使你在调用它使用另一个线程是指变量的方法。 为了避免混淆，使用调用时`Shared`方法： `Thread.SetData(testSlot, "test data")`。  
  
   
  
## Examples  
 本部分包含两个代码示例。 第一个示例演示如何使用字段将标有<xref:System.ThreadStaticAttribute>特性来保存线程特定的信息。 第二个示例演示如何使用数据槽执行相同的操作。  
  
 **第一个示例**  
  
 下面的示例演示如何使用字段将标有<xref:System.ThreadStaticAttribute>来保存线程特定的信息。 此方法提供更好的性能比第二个示例所示的技术。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **第二个示例**  
  
 下面的示例演示如何使用命名的数据槽以存储线程特定的信息。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将当前线程挂起指定的时间。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">挂起线程的毫秒数。 如果 <c>millisecondsTimeout</c> 参数的值为零，则该线程会将其时间片的剩余部分让给任何已经准备好运行的、具有同等优先级的线程。 如果没有其他已经准备好运行的、具有同等优先级的线程，则不会挂起当前线程的执行。</param>
        <summary>将当前线程挂起指定的毫秒数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该线程将不会计划执行由操作系统指定的时间。 此方法要包括的线程的状态更改<xref:System.Threading.ThreadState.WaitSleepJoin>。  
  
 你可以指定<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>为`millisecondsTimeout`无限期挂起线程的参数。 但是，我们建议你使用其他<xref:System.Threading?displayProperty=nameWithType>类，如<xref:System.Threading.Mutex>， <xref:System.Threading.Monitor>， <xref:System.Threading.EventWaitHandle>，或<xref:System.Threading.Semaphore>改为小心地同步线程或管理资源。  
  
 以特定速度系统时钟计时周期调用时钟分辨率。 实际超时可能不完全指定的超时，因为指定的超时将调整与时钟计时周期保持一致。 时钟分辨率和等待时间的详细信息，请参阅[睡眠函数](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)主题。 此方法调用[睡眠函数](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)从 Windows 系统 Api。  
  
 此方法不执行标准的 COM 和 sendmessage 消息泵处理。  
  
> [!NOTE]
>  如果你需要具有的线程上休眠<xref:System.STAThreadAttribute>，但你想要执行标准的 COM 和 sendmessage 消息泵处理，请考虑使用的重载之一<xref:System.Threading.Thread.Join%2A>方法，它指定超时间隔。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Threading.Thread.Sleep%2A>方法进行阻止，应用程序的主线程。  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">超时值为负且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">挂起线程的时间量。 如果 <c>millisecondsTimeout</c> 参数的值为 <see cref="F:System.TimeSpan.Zero" />，则该线程会将其时间片的剩余部分让给任何已经准备好运行的、具有同等优先级的线程。 如果没有其他已经准备好运行的、具有同等优先级的线程，则不会挂起当前线程的执行。</param>
        <summary>将当前线程挂起指定的时间。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该线程将不会计划执行由操作系统指定的时间。 此方法要包括的线程的状态更改<xref:System.Threading.ThreadState.WaitSleepJoin>。  
  
 你可以指定<xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType>为`timeout`无限期挂起线程的参数。 但是，我们建议你使用其他<xref:System.Threading?displayProperty=nameWithType>类，如<xref:System.Threading.Mutex>， <xref:System.Threading.Monitor>， <xref:System.Threading.EventWaitHandle>，或<xref:System.Threading.Semaphore>改为小心地同步线程或管理资源。  
  
 此重载<xref:System.Threading.Thread.Sleep%2A>使用中的整毫秒总数`timeout`。 毫秒的小数部分将被丢弃。  
  
 此方法不执行标准的 COM 和 sendmessage 消息泵处理。  
  
> [!NOTE]
>  如果你需要具有的线程上休眠<xref:System.STAThreadAttribute>，但你想要执行标准的 COM 和 sendmessage 消息泵处理，请考虑使用的重载之一<xref:System.Threading.Thread.Join%2A>方法，它指定超时间隔。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Threading.Thread.Sleep%28System.TimeSpan%29>方法重载将阻止应用程序的主线程五次，2 秒钟，每次。  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 的值为负数，且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（以毫秒为单位），或大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">定义线程等待的时间长短的 32 位有符号整数。</param>
        <summary>导致线程等待由 <paramref name="iterations" /> 参数定义的时间量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.SpinWait%2A>方法可用于实现锁。 类在.NET Framework 中，如<xref:System.Threading.Monitor>和<xref:System.Threading.ReaderWriterLock>，内部使用此方法。 <xref:System.Threading.Thread.SpinWait%2A> 实质上是将处理器放入非常紧凑循环中，使用指定的循环计数`iterations`参数。 因此，等待的持续时间取决于处理器的速度。  
  
 与此对比<xref:System.Threading.Thread.Sleep%2A>方法。 调用线程<xref:System.Threading.Thread.Sleep%2A>产生的处理器时间，其当前切片的其余部分，即使指定的时间间隔为零。 指定一个非零的间隔值<xref:System.Threading.Thread.Sleep%2A>从线程计划程序会不考虑中移除线程，直到经过的时间间隔。  
  
 <xref:System.Threading.Thread.SpinWait%2A> 不是普通的应用程序通常有用的。 在大多数情况下，应使用.NET Framework 中; 提供的同步类例如，调用<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>或包装语句<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>(`lock`在 C# 或`SyncLock`在 Visual Basic 中)。  
  
> [!CAUTION]
>  在的罕见情况下，它将非常有利，若要避免的上下文切换，例如，当已知状态更改即将发生时，请调用<xref:System.Threading.Thread.SpinWait%2A>在循环中的方法。 代码<xref:System.Threading.Thread.SpinWait%2A>执行旨在防止具有多个处理器的计算机可能会发生的问题。 例如，在具有多个使用超线程技术的 Intel 处理器的计算机上<xref:System.Threading.Thread.SpinWait%2A>可防止在某些情况下的处理器资源不足。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使线程得以按计划执行。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导致操作系统将当前实例的状态更改为 <see cref="F:System.Threading.ThreadState.Running" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一旦线程处于<xref:System.Threading.ThreadState.Running?displayProperty=nameWithType>状态时，操作系统可以计划它的执行。 线程开始执行时所表示的方法的第一行执行<xref:System.Threading.ThreadStart>或<xref:System.Threading.ParameterizedThreadStart>委托提供给线程构造函数。 请注意，调用<xref:System.Threading.Thread.Start%2A>不会阻止调用线程。  
  
> [!NOTE]
>  如果创建使用的线程，则使用此重载<xref:System.Threading.ParameterizedThreadStart>委托，`null`传递给由线程执行的方法。  
  
 一旦线程终止，它无法重启通过再次调用`Start`。  
  
   
  
## Examples  
 下面的示例创建并启动线程。  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">线程已启动。</exception>
        <exception cref="T:System.OutOfMemoryException">内存不足，无法启动此线程。</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">一个对象，包含线程执行的方法要使用的数据。</param>
        <summary>导致操作系统将当前实例的状态更改为 <see cref="F:System.Threading.ThreadState.Running" />，并选择提供包含线程执行的方法要使用的数据的对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一旦线程处于<xref:System.Threading.ThreadState.Running?displayProperty=nameWithType>状态时，操作系统可以计划它的执行。 线程开始执行时所表示的方法的第一行执行<xref:System.Threading.ThreadStart>或<xref:System.Threading.ParameterizedThreadStart>委托提供给线程构造函数。 请注意，调用<xref:System.Threading.Thread.Start%2A>不会阻止调用线程。  
  
 一旦线程终止，它无法重启通过再次调用`Start`。  
  
 此重载和<xref:System.Threading.ParameterizedThreadStart>委托进行轻松地将数据传递给一个线程的过程，但技术不是类型安全，因为可以将任何对象传递给此重载。 若要将数据传递给一个线程的过程更可靠方法是放入一个辅助对象的线程的过程和数据字段。 有关详细信息，请参阅[创建线程并在启动时传递数据](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Threading.ParameterizedThreadStart>委托，它具有一个静态方法和实例方法。  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">线程已启动。</exception>
        <exception cref="T:System.OutOfMemoryException">内存不足，无法启动此线程。</exception>
        <exception cref="T:System.InvalidOperationException">该线程是使用 <see cref="T:System.Threading.ThreadStart" /> 委托而不是 <see cref="T:System.Threading.ParameterizedThreadStart" /> 委托创建的。</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>挂起线程，或者如果线程已挂起，则不起作用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果线程已挂起，则此方法无效。  
  
> [!CAUTION]
>  不要使用<xref:System.Threading.Thread.Suspend%2A>和<xref:System.Threading.Thread.Resume%2A>方法来同步线程活动。 具有无法知道哪些代码的线程正在执行挂起时。 如果您挂起线程，它在安全权限评估期间保持锁定中的其他线程<xref:System.AppDomain>可能被阻止。 如果您挂起线程执行类构造函数时中的其他线程<xref:System.AppDomain>中尝试使用类被阻止。 很容易发生死锁。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">仅限 .NET Core：不支持此成员。</exception>
        <exception cref="T:System.Threading.ThreadStateException">线程尚未启动或已终止。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有适当的 <see cref="T:System.Security.Permissions.SecurityPermission" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">有关线程的高级操作。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">留待将来使用。 必须为 IID_NULL。</param>
        <param name="rgszNames">要映射的名称的传入数组。</param>
        <param name="cNames">要映射的名称的计数。</param>
        <param name="lcid">要在其中解释名称的区域设置上下文。</param>
        <param name="rgDispId">调用方分配的数组，用于接收与名称对应的 ID。</param>
        <summary>将一组名称映射为对应的一组调度标识符。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于访问托管类从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::GetIDsOfNames`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要返回的类型信息。</param>
        <param name="lcid">类型信息的区域设置标识符。</param>
        <param name="ppTInfo">接收一个指针，指向请求的类型信息对象。</param>
        <summary>检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于访问托管类从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::GetTypeInfo`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">指向一个位置，该位置接收对象提供的类型信息接口的数量。</param>
        <summary>检索对象提供的类型信息接口的数量（0 或 1）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于访问托管类从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::GetTypeInfoCount`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">标识成员。</param>
        <param name="riid">留待将来使用。 必须为 IID_NULL。</param>
        <param name="lcid">要在其中解释参数的区域设置上下文。</param>
        <param name="wFlags">描述调用的上下文的标志。</param>
        <param name="pDispParams">指向一个结构的指针，该结构包含一个自变量数组、一个命名自变量的 DISPID 自变量数组和数组中元素数的计数。</param>
        <param name="pVarResult">指向要存储结果的位置的指针。</param>
        <param name="pExcepInfo">指向一个包含异常信息的结构的指针。</param>
        <param name="puArgErr">第一个出错自变量的索引。</param>
        <summary>提供对某一对象公开的属性和方法的访问。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于访问托管类从非托管代码，不应从托管代码调用。 有关详细信息`IDispatch::Invoke`，请参阅 MSDN 库。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值包含当前线程的状态。</summary>
        <value>其中一个表示当前线程的状态的 <see cref="T:System.Threading.ThreadState" /> 值。 初始值为 <see langword="Unstarted" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.ThreadState%2A>属性提供的更具体信息多于<xref:System.Threading.Thread.IsAlive%2A>属性。  
  
> [!IMPORTANT]
>  线程状态才会涉及调试方案中。 因此，始终不应在代码中使用线程状态来同步线程活动。  
  
   
  
## Examples  
 下面的代码示例演示如何访问`ThreadState`的线程。  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">新的单元状态。</param>
        <summary>在线程启动前设置其单元状态。</summary>
        <returns>
          如果设置了单元状态，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新线程将初始化为<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>如果它们启动之前尚未设置其单元状态。 启动线程之前，必须设置单元状态。  
  
> [!NOTE]
>  主应用程序线程被初始化为<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>默认情况下。 设置到的主应用程序线程的单元状态的唯一办法<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>，将应用<xref:System.STAThreadAttribute>属性设为入口点方法。  
  
 <xref:System.Threading.Thread.TrySetApartmentState%2A>方法，以及<xref:System.Threading.Thread.GetApartmentState%2A>方法和<xref:System.Threading.Thread.SetApartmentState%2A>方法，将替换<xref:System.Threading.Thread.ApartmentState%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Threading.Thread.GetApartmentState%2A>， <xref:System.Threading.Thread.SetApartmentState%2A>，和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法。 代码示例创建一个线程。 在线程启动之前，<xref:System.Threading.Thread.GetApartmentState%2A>显示初始<xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>状态和<xref:System.Threading.Thread.SetApartmentState%2A>将状态更改为<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。 <xref:System.Threading.Thread.TrySetApartmentState%2A>方法然后返回`false`时尝试的状态更改为<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>因为已经设置了单元状态。 如果相同的操作已尝试使用<xref:System.Threading.Thread.SetApartmentState%2A>，<xref:System.InvalidOperationException>将引发。  
  
 在线程启动后，<xref:System.Threading.Thread.TrySetApartmentState%2A>方法会再次使用。 这次将引发<xref:System.Threading.ThreadStateException>因为线程已启动。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> 不是有效的单元状态。</exception>
        <exception cref="T:System.Threading.ThreadStateException">线程已启动。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>读取字段值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要读取的字段。</param>
        <summary>读取字段值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</summary>
        <returns>由任何处理器写入字段的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>获得由任何处理器写入的内存位置的最新值。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要读取的字段。</param>
        <summary>读取字段值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</summary>
        <returns>由任何处理器写入字段的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>获得由任何处理器写入的内存位置的最新值。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要读取的字段。</param>
        <summary>读取字段值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</summary>
        <returns>由任何处理器写入字段的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>获得由任何处理器写入的内存位置的最新值。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要读取的字段。</param>
        <summary>读取字段值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</summary>
        <returns>由任何处理器写入字段的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>获得由任何处理器写入的内存位置的最新值。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要读取的字段。</param>
        <summary>读取字段值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</summary>
        <returns>由任何处理器写入字段的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>获得由任何处理器写入的内存位置的最新值。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要读取的字段。</param>
        <summary>读取字段值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</summary>
        <returns>由任何处理器写入字段的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>获得由任何处理器写入的内存位置的最新值。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要读取的字段。</param>
        <summary>读取字段值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</summary>
        <returns>由任何处理器写入字段的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>获得由任何处理器写入的内存位置的最新值。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要读取的字段。</param>
        <summary>读取字段值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</summary>
        <returns>由任何处理器写入字段的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>获得由任何处理器写入的内存位置的最新值。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要读取的字段。</param>
        <summary>读取字段值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</summary>
        <returns>由任何处理器写入字段的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>获得由任何处理器写入的内存位置的最新值。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要读取的字段。</param>
        <summary>读取字段值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</summary>
        <returns>由任何处理器写入字段的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>获得由任何处理器写入的内存位置的最新值。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要读取的字段。</param>
        <summary>读取字段值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</summary>
        <returns>由任何处理器写入字段的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>获得由任何处理器写入的内存位置的最新值。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要读取的字段。</param>
        <summary>读取字段值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</summary>
        <returns>由任何处理器写入字段的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>获得由任何处理器写入的内存位置的最新值。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要读取的字段。</param>
        <summary>读取字段值。 无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</summary>
        <returns>由任何处理器写入字段的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>获得由任何处理器写入的内存位置的最新值。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">将向其中写入值的字段。</param>
        <param name="value">要写入的值。</param>
        <summary>立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileWrite%2A>可确保写入内存位置的值是立即可见的所有处理器。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">将向其中写入值的字段。</param>
        <param name="value">要写入的值。</param>
        <summary>立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileWrite%2A>可确保写入内存位置的值是立即可见的所有处理器。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">将向其中写入值的字段。</param>
        <param name="value">要写入的值。</param>
        <summary>立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileWrite%2A>可确保写入内存位置的值是立即可见的所有处理器。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">将向其中写入值的字段。</param>
        <param name="value">要写入的值。</param>
        <summary>立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileWrite%2A>可确保写入内存位置的值是立即可见的所有处理器。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">将向其中写入值的字段。</param>
        <param name="value">要写入的值。</param>
        <summary>立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileWrite%2A>可确保写入内存位置的值是立即可见的所有处理器。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">将向其中写入值的字段。</param>
        <param name="value">要写入的值。</param>
        <summary>立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileWrite%2A>可确保写入内存位置的值是立即可见的所有处理器。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">将向其中写入值的字段。</param>
        <param name="value">要写入的值。</param>
        <summary>立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileWrite%2A>可确保写入内存位置的值是立即可见的所有处理器。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">将向其中写入值的字段。</param>
        <param name="value">要写入的值。</param>
        <summary>立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileWrite%2A>可确保写入内存位置的值是立即可见的所有处理器。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">将向其中写入值的字段。</param>
        <param name="value">要写入的值。</param>
        <summary>立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileWrite%2A>可确保写入内存位置的值是立即可见的所有处理器。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">将向其中写入值的字段。</param>
        <param name="value">要写入的值。</param>
        <summary>立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileWrite%2A>可确保写入内存位置的值是立即可见的所有处理器。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">将向其中写入值的字段。</param>
        <param name="value">要写入的值。</param>
        <summary>立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileWrite%2A>可确保写入内存位置的值是立即可见的所有处理器。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">将向其中写入值的字段。</param>
        <param name="value">要写入的值。</param>
        <summary>立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileWrite%2A>可确保写入内存位置的值是立即可见的所有处理器。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">将向其中写入值的字段。</param>
        <param name="value">要写入的值。</param>
        <summary>立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>进行同步的特殊情况。 在正常情况下，C#`lock`语句，Visual Basic`SyncLock`语句，和<xref:System.Threading.Monitor>类提供更轻松的替代项。  
  
 在多处理器系统中，<xref:System.Threading.Thread.VolatileWrite%2A>可确保写入内存位置的值是立即可见的所有处理器。 这可能需要刷新处理器缓存。  
  
 即使在单处理器系统中，<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>确保值为读取或写入到内存，并不缓存 （例如，在处理器寄存器）。 因此，你可以使用它们可以由另一个线程或硬件更新的字段对访问进行同步。  
  
 调用此方法只影响单个内存访问。 若要提供字段的有效同步，对字段的所有访问必须都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`字段上的修饰符可保证对该字段的所有访问都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导致调用线程执行准备好在当前处理器上运行的另一个线程。 由操作系统选择要执行的线程。</summary>
        <returns>
          如果操作系统转而执行另一个线程，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此方法成功，生成了线程的当前时间片的其余部分。 操作系统调度调用线程的另一个时间段，根据其优先级和可用于运行其他线程的状态。  
  
 生成操作仅限于执行调用线程的处理器。 操作系统将不执行切换到另一个处理器，即使该处理器处于空闲状态或正在运行较低优先级的线程。 如果没有其他线程准备好在当前处理器上执行，操作系统不会生成执行，并且此方法返回`false`。  
  
 此方法相当于使用平台调用来调用本机 Win32`SwitchToThread`函数。 应调用<xref:System.Threading.Thread.Yield%2A>方法而不是使用平台调用，因为平台调用会跳过任何自定义的线程处理行为的主机已请求。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>