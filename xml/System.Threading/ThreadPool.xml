<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="68b7762e25c13529637c3ed6d542d63fee277f04" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911345" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供一个线程池，该线程池可用于执行任务、发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 许多应用程序创建花费大量时间处于睡眠状态，等待事件发生的线程。 其他线程可能会进入休眠状态，只是为了被唤醒，定期轮询更改或更新状态信息。 线程池，可通过提供一个受系统管理的辅助线程池上的应用程序更有效地使用线程。 使用线程池线程的操作的示例包括：  
  
-   当你创建<xref:System.Threading.Tasks.Task>或<xref:System.Threading.Tasks.Task%601>对象来执行某些任务以异步方式，默认情况下，计划任务在线程池线程上运行。  
  
-   异步计时器使用线程池。 线程池线程执行从回调<xref:System.Threading.Timer?displayProperty=nameWithType>类，并引发事件从<xref:System.Timers.Timer?displayProperty=nameWithType>类。  
  
-   当你使用已注册的等待句柄时，某个系统线程监视等待句柄的状态。 等待操作完成后，线程池中的工作线程将执行对应的回调函数。  
  
-   当调用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法进行排队以在线程池线程上执行的方法。 通过传递给该方法执行此操作<xref:System.Threading.WaitCallback>委托。   委托具有签名  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     其中`state`是一个对象，包含由委托使用的数据。 实际的数据可以通过调用传递给委托<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>方法。  
  
> [!NOTE]
>  在托管的线程池线程是后台线程。 即，其<xref:System.Threading.Thread.IsBackground%2A>属性`true`。 这意味着，<xref:System.Threading.ThreadPool>线程不会对所有前台线程均都退出之后运行的应用程序。  
  
> [!IMPORTANT]
>  如果线程池重用某个线程，它不会清除在线程本地存储或使用标记的字段中的数据<xref:System.ThreadStaticAttribute>属性。 因此，检查线程本地存储区或的字段的方法标记有<xref:System.ThreadStaticAttribute>属性，它找到的值可能会留下线程池线程更早版本使用过程中。  
  
 你可以排队到线程池等待操作不相关的工作项。 若要请求的工作项来处理线程池中线程，调用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。 此方法将对该方法或将由所选线程池中的线程调用的委托的引用作为参数。 没有方法来取消工作项之后它已在排队等候。  
  
 计时器队列中的计时器和已注册的等待操作也使用线程池。 它们的回调函数要排队发送至线程池。  
  
 没有每个进程的一个线程池。 从 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 开始，进程的线程池的默认大小取决于若干因素，例如虚拟地址空间的大小。 进程可以调用 <xref:System.Threading.ThreadPool.GetMaxThreads%2A> 方法，以确定线程数。 可以使用更改线程池中的线程数<xref:System.Threading.ThreadPool.SetMaxThreads%2A>方法。 每个线程使用的默认堆栈大小，并运行默认优先级。  
  
> [!NOTE]
>  承载.NET Framework 的非托管的代码可以更改通过使用线程池的大小`CorSetMaxThreads`mscoree.h 文件中定义的函数。  
  
 线程池按需提供新的辅助线程或 I/O 完成线程直到它达到每个类别的最低要求。 当达到最小值时，线程池可以在该类别中创建其他线程或等待，直到一些任务完成。 从 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 开始，线程池创建和销毁工作线程以优化吞吐量，吞吐量被定义为每个单位时间完成的任务数。 线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。  
  
> [!NOTE]
>  需求较低时，线程池线程的实际数量可以低于最小值。  
  
 可以使用 <xref:System.Threading.ThreadPool.GetMinThreads%2A> 方法来获取这些最小值。  
  
> [!CAUTION]
>  你可以使用<xref:System.Threading.ThreadPool.SetMinThreads%2A>方法来增加最小线程数。 但是，不必要地增加这些值可能导致性能问题。 如果在同一时间开始太多的任务，则所有任务均可能会很慢。 大多数情况下，使用自己的分配线程算法，线程池将更好地执行任务。  
  
   
  
## Examples  
 在下面的示例中，主应用程序线程方法排入队列名为`ThreadProc`在线程池线程，休眠 1 秒，然后退出上执行。 `ThreadProc`方法只需显示一条消息。  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 如果注释掉对的调用<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法，在主线程退出之前在线程池线程上运行的方法。  线程池使用后台线程，不保留应用程序的运行的所有前台线程已都终止。  （这是一个简单的示例的争用条件）。  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将操作系统句柄绑定到 <see cref="T:System.Threading.ThreadPool" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">持有句柄的 <see cref="T:System.IntPtr" />。 在非托管端必须为重叠 I/O 打开该句柄。</param>
        <summary>将操作系统句柄绑定到 <see cref="T:System.Threading.ThreadPool" />。</summary>
        <returns>
          如果绑定了句柄，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示调用非托管的代码的能力。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">保存操作系统句柄的 <see cref="T:System.Runtime.InteropServices.SafeHandle" />。 在非托管端必须为重叠 I/O 打开该句柄。</param>
        <summary>将操作系统句柄绑定到 <see cref="T:System.Threading.ThreadPool" />。</summary>
        <returns>
          如果绑定了句柄，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `osHandle`参数应为<xref:Microsoft.Win32.SafeHandles.SafeFileHandle>，它派生自抽象<xref:System.Runtime.InteropServices.SafeHandle>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="osHandle" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示调用非托管的代码的能力。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">可用辅助线程的数目。</param>
        <param name="completionPortThreads">可用异步 I/O 线程的数目。</param>
        <summary>检索由 <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> 方法返回的最大线程池线程数和当前活动线程数之间的差值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>返回时，指定的变量`workerThreads`包含可以启动的其他工作线程和指定的变量的数量`completionPortThreads`包含可以是其他异步 I/O 线程数启动。  
  
 如果没有可用的线程，其他线程池请求保持排队状态，直到线程池线程变为可用。  
  
   
  
## Examples  
 简单的应用启动时，下面的示例显示工作线程和可用的 I/O 线程的数。  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">线程池中辅助线程的最大数目。</param>
        <param name="completionPortThreads">线程池中异步 I/O 线程的最大数目。</param>
        <summary>检索可以同时处于活动状态的线程池请求的数目。 所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Threading.ThreadPool.GetMaxThreads%2A>返回时，指定的变量`workerThreads`包含在线程池中允许的工作线程和指定的变量的最大数目`completionPortThreads`包含异步 I/O 线程中允许的最大数目线程池。  
  
 你可以使用<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>方法来确定在任何给定时间在线程池中的线程的实际数量。  
  
 你可以使用<xref:System.Threading.ThreadPool.SetMaxThreads%2A>在线程池中设置的最大工作线程和异步 I/O 线程数。  
  
 你可以排队尽可能的系统内存允许线程池请求。 如果有更多的请求数多于线程池线程数，则其他请求保持排队状态，直到线程池线程变为可用。  
  
   
  
## Examples  
 下面的代码示例演示如何检索最大和可用线程池中的线程数的计数。 工作项已使用的排队`FileStream`以异步方式写入两个文件。 回叫方法超时重叠。 工作线程处理的工作项，并根据速度和计算机上的处理器数目，一个或两个完成端口线程处理写入操作。  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">当此方法返回时，将包含线程池根据需要创建的最少数量的辅助线程。</param>
        <param name="completionPortThreads">当此方法返回时，将包含线程池根据需要创建的最少数量的异步 I/O 线程。</param>
        <summary>发出新的请求时，在切换到管理线程创建和销毁的算法之前检索线程池按需创建的线程的最小数量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 线程池按需提供新的辅助线程或 I/O 完成线程直到它达到每个类别的最低要求。 默认情况下，最小线程数设置为在系统上的处理器数。 当达到最小值时，线程池可以在该类别中创建其他线程或等待，直到一些任务完成。 开头[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，线程池创建和销毁线程以优化吞吐量，吞吐量被定义为每个单位时间完成的任务数。 线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。  
  
> [!NOTE]
>  需求较低时，线程池线程的实际数量可以低于最小值。  
  
   
  
## Examples  
 下面的示例将最小工作线程数设置为 4，并保留的最小异步 I/O 完成线程数的原始值。  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将方法排入队列以便执行。 此方法在有线程池线程变得可用时执行。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">一个 <see cref="T:System.Threading.WaitCallback" />，表示要执行的方法。</param>
        <summary>将方法排入队列以便执行。 此方法在有线程池线程变得可用时执行。</summary>
        <returns>
          如果此方法成功排队，则为 <see langword="true" />；如果无法将该工作项排队，则引发 <see cref="T:System.NotSupportedException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以将数据排队方法的类定义方法，或可以使用的实例字段中所需的放置<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>重载接受一个包含所需数据的对象。  
  
> [!NOTE]
>  Visual Basic 用户可以省略<xref:System.Threading.WaitCallback>构造函数，并且只需使用`AddressOf`运算符传递到回调方法时<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>。 Visual Basic 会自动调用正确的委托构造函数。  
  
## <a name="version-information"></a>版本信息  
 在.NET Framework 2.0 版中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排队使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。 在早期版本，不会传播的主体的信息。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29>方法重载将任务排入队列，由`ThreadProc`方法，以在有线程变得可用时执行。 使用此重载不提供任何任务信息。 因此，可供信息`ThreadProc`方法仅限于该方法所属的对象。  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">承载公共语言运行时 (CLR) 的宿主不支持此操作。</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <see cref="T:System.Threading.WaitCallback" />，它表示要执行的方法。</param>
        <param name="state">包含方法所用数据的对象。</param>
        <summary>将方法排入队列以便执行，并指定包含该方法所用数据的对象。 此方法在有线程池线程变得可用时执行。</summary>
        <returns>
          如果此方法成功排队，则为 <see langword="true" />；如果无法将该工作项排队，则引发 <see cref="T:System.NotSupportedException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果回调方法需要复杂的数据，你可以定义一个类来包含的数据。  
  
> [!NOTE]
>  Visual Basic 用户可以省略<xref:System.Threading.WaitCallback>构造函数，并且只需使用`AddressOf`运算符传递到回调方法时<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>。 Visual Basic 会自动调用正确的委托构造函数。  
  
## <a name="version-information"></a>版本信息  
 在.NET Framework 2.0 版中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排队使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。 在早期版本，不会传播的主体的信息。  
  
   
  
## Examples  
 下面的示例演示如何创建包含任务信息的对象。 它还演示了如何在线程池将该对象传递给排队等待执行的任务。  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">承载公共语言运行时 (CLR) 的宿主不支持此操作。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册正在等待 <see cref="T:System.Threading.WaitHandle" /> 的委托。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <c>waitObject</c> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <c>millisecondsTimeOutInterval</c> 参数为 0（零），则函数将测试对象状态并立即返回。 如果 <c>millisecondsTimeOutInterval</c> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">
          如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 32 位有符号整数来表示超时值（以毫秒为单位）。</summary>
        <returns>封装本机句柄的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法来释放对等待句柄的引用。 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使你指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定的委托排队到线程池。 在下列情况之一发生时，工作线程将执行委托：  
  
-   指定的对象处于终止状态。  
  
-   达到超时间隔。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法检查指定的对象的当前状态<xref:System.Threading.WaitHandle>。 如果对象的状态为非终止状态，该方法将注册一个等待操作。 等待操作由线程池中的线程执行。 对象的状态将被发送信号或超时间隔结束时，将通过工作线程执行委托。 如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次该事件处于有信号状态或达到超时间隔重置计时器。  
  
> [!IMPORTANT]
>  使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>与的最大计数为 1。  
  
 若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。 因此，如果必须使用相同的本机操作系统句柄中多次调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，你必须使用 Win32 句柄复制`DuplicateHandle`函数。 请注意，不应传递到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，因为等待线程可能检测不到该事件已终止之前将重置。  
  
 再返回，该函数修改修改某些类型的同步对象的状态。 修改仅发生在其终止的状态导致等待条件得到满足的对象。 例如，信号量的计数减少 1。  
  
## <a name="version-information"></a>版本信息  
 从.NET Framework 2.0 版中，开始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排队使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。 在早期版本，不会传播的主体的信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <c>waitObject</c> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <c>millisecondsTimeOutInterval</c> 参数为 0（零），则函数将测试对象状态并立即返回。 如果 <c>millisecondsTimeOutInterval</c> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">
          如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 64 位有符号整数来表示超时值（以毫秒为单位）。</summary>
        <returns>封装本机句柄的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法来释放对等待句柄的引用。 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使你指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定的委托排队到线程池。 在下列情况之一发生时，工作线程将执行委托：  
  
-   指定的对象处于终止状态。  
  
-   达到超时间隔。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法检查指定的对象的当前状态<xref:System.Threading.WaitHandle>。 如果对象的状态为非终止状态，该方法将注册一个等待操作。 等待操作由线程池中的线程执行。 对象的状态将被发送信号或超时间隔结束时，将通过工作线程执行委托。 如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次该事件处于有信号状态或达到超时间隔重置计时器。  
  
> [!IMPORTANT]
>  使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>与的最大计数为 1。  
  
 若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。 因此，如果必须使用相同的本机操作系统句柄中多次调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，你必须使用 Win32 句柄复制`DuplicateHandle`函数。 请注意，不应传递到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，因为等待线程可能检测不到该事件已终止之前将重置。  
  
 再返回，该函数修改修改某些类型的同步对象的状态。 修改仅发生在其终止的状态导致等待条件得到满足的对象。 例如，信号量的计数减少 1。  
  
## <a name="version-information"></a>版本信息  
 从.NET Framework 2.0 版中，开始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排队使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。 在早期版本，不会传播的主体的信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <c>waitObject</c> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> 表示的超时时间。 如果 <c>timeout</c> 为 0（零），则函数将测试对象状态并立即返回。 如果 <c>timeout</c> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">
          如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 <see cref="T:System.TimeSpan" /> 值来表示超时时间。</summary>
        <returns>封装本机句柄的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法来释放对等待句柄的引用。 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使你指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定的委托排队到线程池。 在下列情况之一发生时，工作线程将执行委托：  
  
-   指定的对象处于终止状态。  
  
-   达到超时间隔。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法检查指定的对象的当前状态<xref:System.Threading.WaitHandle>。 如果对象的状态为非终止状态，该方法将注册一个等待操作。 等待操作由线程池中的线程执行。 对象的状态将被发送信号或超时间隔结束时，将通过工作线程执行委托。 如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次该事件处于有信号状态或达到超时间隔重置计时器。  
  
> [!IMPORTANT]
>  使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>与的最大计数为 1。  
  
 若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。 因此，如果必须使用相同的本机操作系统句柄中多次调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，你必须使用 Win32 句柄复制`DuplicateHandle`函数。 请注意，不应传递到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，因为等待线程可能检测不到该事件已终止之前将重置。  
  
 再返回，该函数修改修改某些类型的同步对象的状态。 修改仅发生在其终止的状态导致等待条件得到满足的对象。 例如，信号量的计数减少 1。  
  
## <a name="version-information"></a>版本信息  
 从.NET Framework 2.0 版中，开始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排队使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。 在早期版本，不会传播的主体的信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 参数小于 -1。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="timeout" /> 参数大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <c>waitObject</c> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <c>millisecondsTimeOutInterval</c> 参数为 0（零），则函数将测试对象状态并立即返回。 如果 <c>millisecondsTimeOutInterval</c> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">
          如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>指定表示超时（以毫秒为单位）的 32 位无符号整数，注册一个委托等待 <see cref="T:System.Threading.WaitHandle" />。</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" />，可用于取消已注册的等待操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法来释放对等待句柄的引用。 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使你指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定的委托排队到线程池。 在下列情况之一发生时，工作线程将执行委托：  
  
-   指定的对象处于终止状态。  
  
-   达到超时间隔。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法检查指定的对象的当前状态<xref:System.Threading.WaitHandle>。 如果对象的状态为非终止状态，该方法将注册一个等待操作。 等待操作由线程池中的线程执行。 对象的状态将被发送信号或超时间隔结束时，将通过工作线程执行委托。 如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次该事件处于有信号状态或达到超时间隔重置计时器。  
  
> [!IMPORTANT]
>  使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>与的最大计数为 1。  
  
 若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。 因此，如果必须使用相同的本机操作系统句柄中多次调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，你必须使用 Win32 句柄复制`DuplicateHandle`函数。 请注意，不应传递到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，因为等待线程可能检测不到该事件已终止之前将重置。  
  
 再返回，该函数修改修改某些类型的同步对象的状态。 修改仅发生在其终止的状态导致等待条件得到满足的对象。 例如，信号量的计数减少 1。  
  
## <a name="version-information"></a>版本信息  
 从.NET Framework 2.0 版中，开始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排队使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。 在早期版本，不会传播的主体的信息。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>时要执行方法指定的回调方法指定的等待句柄处于有信号状态。 在此示例中，回调方法是`WaitProc`，和等待句柄是<xref:System.Threading.AutoResetEvent>。  
  
 该示例定义了`TaskInfo`类来保存时它将执行传递给回调的信息。 该示例创建`TaskInfo`对象并将其分配某些字符串数据。 <xref:System.Threading.RegisteredWaitHandle>返回<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法分配给`Handle`字段`TaskInfo`对象，以便回调方法有权<xref:System.Threading.RegisteredWaitHandle>。  
  
 除了指定`TaskInfo`作为要传递给回调方法，调用的对象<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定<xref:System.Threading.AutoResetEvent>任务将等待，<xref:System.Threading.WaitOrTimerCallback>委托，表示`WaitProc`回调方法一秒的超时间隔和多个回调。  
  
 当主线程发出信号<xref:System.Threading.AutoResetEvent>通过调用其<xref:System.Threading.EventWaitHandle.Set%2A>方法，<xref:System.Threading.WaitOrTimerCallback>调用委托。 `WaitProc`方法测试<xref:System.Threading.RegisteredWaitHandle>以确定是否发生超时。 如果由于等待句柄已收到信号，而调用的回调`WaitProc`方法注销<xref:System.Threading.RegisteredWaitHandle>，从而停止其他回调。 对于超时，该任务将继续等待。 `WaitProc`方法结束时将消息输出到控制台。  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">线程池中辅助线程的最大数目。</param>
        <param name="completionPortThreads">线程池中异步 I/O 线程的最大数目。</param>
        <summary>设置可以同时处于活动状态的线程池的请求数目。 所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。</summary>
        <returns>
          如果更改成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能设置辅助线程或 I/O 完成线程的最大数量为一个数字小于的计算机上的处理器数。 若要确定存在多少处理器，检索的值<xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType>属性。 此外，你不能设置辅助线程或为一个小于最小相应工作线程数的数字的 I/O 完成线程或 I/O 完成线程的最大数目。 若要确定最小线程池大小，请调用<xref:System.Threading.ThreadPool.GetMinThreads%2A>方法。  
  
 如果承载公共语言运行时，例如通过 Internet 信息服务 (IIS) 或 SQL Server，主机可以限制或阻止更改到线程池大小。  
  
 更改的最大线程池中的线程数时要格外小心。 虽然你的代码中获益，所做的更改可能产生负面影响上使用的代码库。  
  
 设置线程池大小太大，则会导致性能问题。 如果在同一时间执行过多的线程，任务切换开销就成为一个重要的因素。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示控制线程的能力。 权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">要由线程池根据需要创建的新的最小工作程序线程数。</param>
        <param name="completionPortThreads">要由线程池根据需要创建的新的最小空闲异步 I/O 线程数。</param>
        <summary>发出新的请求时，在切换到管理线程创建和销毁的算法之前设置线程池按需创建的线程的最小数量。</summary>
        <returns>
          如果更改成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 线程池按需提供新的辅助线程或 I/O 完成线程直到它达到每个类别的最低要求。 当达到最小值时，线程池可以在该类别中创建其他线程或等待，直到一些任务完成。 开头[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，线程池创建和销毁线程以优化吞吐量，吞吐量被定义为每个单位时间完成的任务数。 线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。  
  
 需求较低时，线程池线程的实际数量可以低于最小值。  
  
 如果你指定为负数或大于最大活动线程池线程数的数字 (使用获取<xref:System.Threading.ThreadPool.GetMaxThreads%2A>)，<xref:System.Threading.ThreadPool.SetMinThreads%2A>返回`false`并不会更改两个最小值。  
  
> [!CAUTION]
>  默认情况下，最小线程数设置为在系统上的处理器数。 你可以使用<xref:System.Threading.ThreadPool.SetMinThreads%2A>方法来增加最小的数字 ofthreads。 但是，不必要地增加这些值可能导致性能问题。 如果在同一时间开始太多的任务，则所有任务均可能会很慢。 在大多数情况下，线程池将使用其自己的分配线程算法更好地执行。 减少到小于处理器数也会影响性能的最小值。  
  
   
  
## Examples  
 下面的示例将最小工作线程数设置为 4，并保留的最小异步 I/O 完成线程数的原始值。  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示控制线程的能力。 权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">要排队的 <see cref="T:System.Threading.NativeOverlapped" /> 结构。</param>
        <summary>将重叠的 I/O 操作排队以便执行。</summary>
        <returns>
          如果成功地将此操作排队到 I/O 完成端口，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关使用本机 Win32 信息重叠的 I/O，请参阅<xref:System.Threading.Overlapped>类，<xref:System.Threading.NativeOverlapped>结构，与`OVERLAPPED`Win32 平台 SDK 中的结构。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>方法可能会无意中打开安全漏洞。 代码访问安全性将基于堆栈的所有调用方的权限其权限检查。 工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>，线程池线程的堆栈不具有实际调用方的上下文。 恶意代码可能会利用这一点避开权限检查。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">一个 <see cref="T:System.Threading.WaitCallback" />，表示当线程池中的线程选择工作项时调用的委托。</param>
        <param name="state">在接受线程池服务时传递给委托的对象。</param>
        <summary>将指定的委托排队到线程池，但不会将调用堆栈传播到辅助线程。</summary>
        <returns>
          如果方法成功，则为 <see langword="true" />；如果未能将该工作项排队，则引发 <see cref="T:System.OutOfMemoryException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法，<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>则不会传播到辅助线程的调用堆栈。 这使得代码丢失所做的调用堆栈，从而提升其安全特权。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>可能无意中打开安全漏洞。 代码访问安全性将基于堆栈的所有调用方的权限其权限检查。 工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>，线程池线程的堆栈不会实际调用方的上下文。 恶意代码可能会利用这一点避开权限检查。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.ApplicationException">遇到了内存不足的情况。</exception>
        <exception cref="T:System.OutOfMemoryException">未能将该工作项排队。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册委托以等待 <see cref="T:System.Threading.WaitHandle" />，但不会将调用堆栈传播到辅助线程。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <c>waitObject</c> 参数发出信号时调用的委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <c>millisecondsTimeOutInterval</c> 参数为 0（零），则函数将测试对象状态并立即返回。 如果 <c>millisecondsTimeOutInterval</c> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">
          如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并使用一个 32 位带符号整数来表示超时时间（以毫秒为单位）。 此方法不将调用堆栈传播到辅助线程。</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>则不会传播到辅助线程的调用堆栈。 这使得代码丢失所做的调用堆栈，从而提升其安全特权。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能无意中打开安全漏洞。 代码访问安全性将基于堆栈的所有调用方的权限其权限检查。 工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，线程池线程的堆栈不会实际调用方的上下文。 恶意代码可能会利用这一点避开权限检查。  
  
 使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。  
  
 完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法来释放对等待句柄的引用。 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使你指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <c>waitObject</c> 参数发出信号时调用的委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <c>millisecondsTimeOutInterval</c> 参数为 0（零），则函数将测试对象状态并立即返回。 如果 <c>millisecondsTimeOutInterval</c> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">
          如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 64 位有符号整数来表示超时值（以毫秒为单位）。 此方法不将调用堆栈传播到辅助线程。</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>则不会传播到辅助线程的调用堆栈。 这使得代码丢失所做的调用堆栈，从而提升其安全特权。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能无意中打开安全漏洞。 代码访问安全性将基于堆栈的所有调用方的权限其权限检查。 工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，线程池线程的堆栈不会实际调用方的上下文。 恶意代码可能会利用这一点避开权限检查。  
  
 使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。  
  
 完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法来释放对等待句柄的引用。 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使你指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <c>waitObject</c> 参数发出信号时调用的委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> 表示的超时时间。 如果 <c>timeout</c> 为 0（零），则函数将测试对象状态并立即返回。 如果 <c>timeout</c> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">
          如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 <see cref="T:System.TimeSpan" /> 值来表示超时时间。此方法不将调用堆栈传播到辅助线程。</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>则不会传播到辅助线程的调用堆栈。 这使得代码丢失所做的调用堆栈，从而提升其安全特权。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能无意中打开安全漏洞。 代码访问安全性将基于堆栈的所有调用方的权限其权限检查。 工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，线程池线程的堆栈不会实际调用方的上下文。 恶意代码可能会利用这一点避开权限检查。  
  
 使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。  
  
 完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法来释放对等待句柄的引用。 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使你指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 参数小于 -1。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="timeout" /> 参数大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <c>waitObject</c> 参数发出信号时调用的委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <c>millisecondsTimeOutInterval</c> 参数为 0（零），则函数将测试对象状态并立即返回。 如果 <c>millisecondsTimeOutInterval</c> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">
          如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>指定表示超时（以毫秒为单位）的 32 位无符号整数，注册一个委托等待 <see cref="T:System.Threading.WaitHandle" />。 此方法不将调用堆栈传播到辅助线程。</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>则不会传播到辅助线程的调用堆栈。 这使得代码丢失所做的调用堆栈，从而提升其安全特权。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能无意中打开安全漏洞。 代码访问安全性将基于堆栈的所有调用方的权限其权限检查。 工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，线程池线程的堆栈不会实际调用方的上下文。 恶意代码可能会利用这一点避开权限检查。  
  
 使用<xref:System.Threading.Mutex>为`waitObject`不提供的回调的互相排斥，因为基础的 Win32 API 使用默认值`WT_EXECUTEDEFAULT`标志，以便在一个单独的线程池线程上调度每个回调。  
  
 完成之后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法来释放对等待句柄的引用。 我们建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使你指定`true`为`executeOnlyOnce`。 垃圾回收的工作的详细信息有效地如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
  </Members>
</Type>