<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9f9c9e42dff8e89feb11010c57e7d17bc9b44648" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48675411" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="22ade-101">提供一个线程池，该线程池可用于执行任务、发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器。</span>
      <span class="sxs-lookup">
        <span data-stu-id="22ade-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-102">许多应用程序创建大量花费的时间处于睡眠状态，等待要发生的事件的线程。</span><span class="sxs-lookup"><span data-stu-id="22ade-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="22ade-103">其他线程可能会进入休眠状态，只是为了被唤醒，定期轮询更改或更新的状态信息。</span><span class="sxs-lookup"><span data-stu-id="22ade-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="22ade-104">线程池，可通过提供应用程序提供的由系统管理的工作线程池来更有效地使用线程。</span><span class="sxs-lookup"><span data-stu-id="22ade-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="22ade-105">使用线程池线程的操作的示例包括：</span><span class="sxs-lookup"><span data-stu-id="22ade-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="22ade-106">当您创建<xref:System.Threading.Tasks.Task>或<xref:System.Threading.Tasks.Task%601>对象来计划任务在线程池线程上运行的默认情况下以异步方式执行某项任务。</span><span class="sxs-lookup"><span data-stu-id="22ade-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="22ade-107">异步计时器使用线程池。</span><span class="sxs-lookup"><span data-stu-id="22ade-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="22ade-108">线程池线程执行从回调<xref:System.Threading.Timer?displayProperty=nameWithType>类，并从引发事件<xref:System.Timers.Timer?displayProperty=nameWithType>类。</span><span class="sxs-lookup"><span data-stu-id="22ade-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="22ade-109">当使用已注册的等待句柄时，系统线程监视等待句柄的状态。</span><span class="sxs-lookup"><span data-stu-id="22ade-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="22ade-110">等待操作完成后，从线程池工作线程将执行相应的回调函数。</span><span class="sxs-lookup"><span data-stu-id="22ade-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="22ade-111">当您调用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法进行排队以在线程池线程上执行的方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="22ade-112">为此，可将该方法传递<xref:System.Threading.WaitCallback>委托。</span><span class="sxs-lookup"><span data-stu-id="22ade-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="22ade-113">委托的签名</span><span class="sxs-lookup"><span data-stu-id="22ade-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="22ade-114">其中`state`是一个对象，包含使用委托的数据。</span><span class="sxs-lookup"><span data-stu-id="22ade-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="22ade-115">实际的数据可以通过调用传递给委托<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="22ade-116">在托管的线程池线程是后台线程。</span><span class="sxs-lookup"><span data-stu-id="22ade-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="22ade-117">也就是说，其<xref:System.Threading.Thread.IsBackground%2A>属性是`true`。</span><span class="sxs-lookup"><span data-stu-id="22ade-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="22ade-118">这意味着，<xref:System.Threading.ThreadPool>线程不会对所有前台线程均已都退出后运行的应用程序。</span><span class="sxs-lookup"><span data-stu-id="22ade-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="22ade-119">如果线程池重用某个线程，它不会清除线程本地存储区中或使用标记的字段中的数据<xref:System.ThreadStaticAttribute>属性。</span><span class="sxs-lookup"><span data-stu-id="22ade-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="22ade-120">因此，使用标记的方法时检查线程本地存储区或字段的<xref:System.ThreadStaticAttribute>属性，它找到的值可能会保留从线程池线程更早版本使用。</span><span class="sxs-lookup"><span data-stu-id="22ade-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="22ade-121">您还可以排队到线程池等待操作不相关的工作项。</span><span class="sxs-lookup"><span data-stu-id="22ade-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="22ade-122">若要请求工作项通过在线程池中的线程处理，请调用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="22ade-123">此方法将对方法或将由所选从线程池线程调用的委托的引用作为参数。</span><span class="sxs-lookup"><span data-stu-id="22ade-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="22ade-124">没有方法来取消后已排队的工作项。</span><span class="sxs-lookup"><span data-stu-id="22ade-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="22ade-125">计时器队列中的计时器和已注册的等待操作也使用线程池。</span><span class="sxs-lookup"><span data-stu-id="22ade-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="22ade-126">它们的回调函数将排队到线程池。</span><span class="sxs-lookup"><span data-stu-id="22ade-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="22ade-127">没有一个线程池，每个进程。</span><span class="sxs-lookup"><span data-stu-id="22ade-127">There is one thread pool per process.</span></span> <span data-ttu-id="22ade-128">从 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 开始，进程的线程池的默认大小取决于若干因素，例如虚拟地址空间的大小。</span><span class="sxs-lookup"><span data-stu-id="22ade-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="22ade-129">进程可以调用 <xref:System.Threading.ThreadPool.GetMaxThreads%2A> 方法，以确定线程数。</span><span class="sxs-lookup"><span data-stu-id="22ade-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="22ade-130">可以使用更改线程池中的线程数<xref:System.Threading.ThreadPool.SetMaxThreads%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="22ade-131">每个线程使用的默认堆栈大小，并运行默认的优先级。</span><span class="sxs-lookup"><span data-stu-id="22ade-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="22ade-132">承载.NET Framework 的非托管的代码可以通过更改线程池的大小`CorSetMaxThreads`mscoree.h 文件中定义的函数。</span><span class="sxs-lookup"><span data-stu-id="22ade-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="22ade-133">线程池按需提供新的工作线程或 I/O 完成线程直到它达到每个类别的最小值。</span><span class="sxs-lookup"><span data-stu-id="22ade-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="22ade-134">当达到最小值时，线程池可以创建该类别中的其他线程或等待，直到一些任务完成。</span><span class="sxs-lookup"><span data-stu-id="22ade-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="22ade-135">从 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 开始，线程池创建和销毁工作线程以优化吞吐量，吞吐量被定义为每个单位时间完成的任务数。</span><span class="sxs-lookup"><span data-stu-id="22ade-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="22ade-136">线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。</span><span class="sxs-lookup"><span data-stu-id="22ade-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="22ade-137">需求较低时，线程池线程的实际数量可以低于最小值。</span><span class="sxs-lookup"><span data-stu-id="22ade-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="22ade-138">可以使用 <xref:System.Threading.ThreadPool.GetMinThreads%2A> 方法来获取这些最小值。</span><span class="sxs-lookup"><span data-stu-id="22ade-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="22ade-139">可以使用<xref:System.Threading.ThreadPool.SetMinThreads%2A>方法来增加最小线程数。</span><span class="sxs-lookup"><span data-stu-id="22ade-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="22ade-140">但是，不必要地增加这些值可能导致性能问题。</span><span class="sxs-lookup"><span data-stu-id="22ade-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="22ade-141">如果在同一时间开始太多的任务，则所有任务均可能会很慢。</span><span class="sxs-lookup"><span data-stu-id="22ade-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="22ade-142">大多数情况下，使用自己的分配线程算法，线程池将更好地执行任务。</span><span class="sxs-lookup"><span data-stu-id="22ade-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="22ade-143">在以下示例中，主应用程序线程方法排入队列名为`ThreadProc`休眠一秒，然后退出在线程池线程上执行。</span><span class="sxs-lookup"><span data-stu-id="22ade-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="22ade-144">`ThreadProc`方法只是显示一条消息。</span><span class="sxs-lookup"><span data-stu-id="22ade-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="22ade-145">如果注释掉对的调用<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法中，主线程退出之前方法在线程池线程上运行。</span><span class="sxs-lookup"><span data-stu-id="22ade-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="22ade-146">线程池使用后台线程，不保留应用程序的运行的所有前台线程已都终止。</span><span class="sxs-lookup"><span data-stu-id="22ade-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="22ade-147">（这是一个争用条件的简单示例。）</span><span class="sxs-lookup"><span data-stu-id="22ade-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="22ade-148">此类型是线程安全的。</span>
      <span class="sxs-lookup">
        <span data-stu-id="22ade-148">This type is thread safe.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
      <span data-ttu-id="22ade-149">线程与线程处理</span>
      <span class="sxs-lookup">
        <span data-stu-id="22ade-149">Threads and Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
      <span data-ttu-id="22ade-150">托管的线程池</span>
      <span class="sxs-lookup">
        <span data-stu-id="22ade-150">The Managed Thread Pooling</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="22ade-151">将操作系统句柄绑定到 <see cref="T:System.Threading.ThreadPool" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-151">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="22ade-152">持有句柄的 <see cref="T:System.IntPtr" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-152">An <see cref="T:System.IntPtr" /> that holds the handle.</span>
          </span>
          <span data-ttu-id="22ade-153">在非托管端必须为重叠 I/O 打开该句柄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-153">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-154">将操作系统句柄绑定到 <see cref="T:System.Threading.ThreadPool" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-154">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-155">如果绑定了句柄，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-155">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="22ade-156">调用方没有所要求的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-156">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="22ade-157">表示调用非托管的代码的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-157">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="22ade-158">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-158">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="22ade-159">保存操作系统句柄的 <see cref="T:System.Runtime.InteropServices.SafeHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-159">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span>
          </span>
          <span data-ttu-id="22ade-160">在非托管端必须为重叠 I/O 打开该句柄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-160">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-161">将操作系统句柄绑定到 <see cref="T:System.Threading.ThreadPool" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-161">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-162">如果绑定了句柄，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-162">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-163">`osHandle`参数应<xref:Microsoft.Win32.SafeHandles.SafeFileHandle>，又派生自抽象<xref:System.Runtime.InteropServices.SafeHandle>类。</span><span class="sxs-lookup"><span data-stu-id="22ade-163">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="22ade-164">
            <paramref name="osHandle" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-164">
              <paramref name="osHandle" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="22ade-165">表示调用非托管的代码的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-165">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="22ade-166">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-166">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="22ade-167">可用辅助线程的数目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-167">The number of available worker threads.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="22ade-168">可用异步 I/O 线程的数目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-168">The number of available asynchronous I/O threads.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-169">检索由 <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> 方法返回的最大线程池线程数和当前活动线程数之间的差值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-169">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-170">当<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>返回指定的变量`workerThreads`包含额外的工作线程可启动和指定的变量的数量`completionPortThreads`包含可以是其他异步 I/O 线程数已启动。</span><span class="sxs-lookup"><span data-stu-id="22ade-170">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="22ade-171">如果没有可用的线程，其他线程池请求保持排队状态，直到线程池线程变得可用。</span><span class="sxs-lookup"><span data-stu-id="22ade-171">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="22ade-172">下面的示例的简单应用程序启动时显示工作线程数和可用的 I/O 线程的数。</span><span class="sxs-lookup"><span data-stu-id="22ade-172">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="22ade-173">线程池中辅助线程的最大数目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-173">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="22ade-174">线程池中异步 I/O 线程的最大数目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-174">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-175">检索可以同时处于活动状态的线程池请求的数目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-175">Retrieves the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="22ade-176">所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-176">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-177">当<xref:System.Threading.ThreadPool.GetMaxThreads%2A>返回指定的变量`workerThreads`包含允许在线程池中的工作线程和指定的变量的最大数目`completionPortThreads`包含异步 I/O 线程中允许的最大数目线程池。</span><span class="sxs-lookup"><span data-stu-id="22ade-177">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="22ade-178">可以使用<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>方法来确定在任何给定时间的实际线程池中的线程数。</span><span class="sxs-lookup"><span data-stu-id="22ade-178">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="22ade-179">可以使用<xref:System.Threading.ThreadPool.SetMaxThreads%2A>设置线程池中的工作线程和异步 I/O 线程的最大数目。</span><span class="sxs-lookup"><span data-stu-id="22ade-179">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="22ade-180">您可以尽可能的系统内存允许线程池的请求进行排队。</span><span class="sxs-lookup"><span data-stu-id="22ade-180">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="22ade-181">如果有多个请求线程池线程数多于，其他请求保持排队状态，直到线程池线程变得可用。</span><span class="sxs-lookup"><span data-stu-id="22ade-181">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="22ade-182">下面的代码示例演示如何检索最大和可用的线程池中的线程数的计数。</span><span class="sxs-lookup"><span data-stu-id="22ade-182">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="22ade-183">工作项进行排队，使用`FileStream`将以异步方式写入两个文件。</span><span class="sxs-lookup"><span data-stu-id="22ade-183">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="22ade-184">回叫方法超时重叠。</span><span class="sxs-lookup"><span data-stu-id="22ade-184">The callback methods are timed to overlap.</span></span> <span data-ttu-id="22ade-185">工作线程处理的工作项，并根据速度和的计算机上的处理器数，一个或两个完成端口线程处理写入操作。</span><span class="sxs-lookup"><span data-stu-id="22ade-185">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="22ade-186">当此方法返回时，将包含线程池根据需要创建的最少数量的辅助线程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-186">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="22ade-187">当此方法返回时，将包含线程池根据需要创建的最少数量的异步 I/O 线程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-187">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-188">发出新的请求时，在切换到管理线程创建和销毁的算法之前检索线程池按需创建的线程的最小数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-188">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-189">线程池按需提供新的工作线程或 I/O 完成线程直到它达到每个类别的最小值。</span><span class="sxs-lookup"><span data-stu-id="22ade-189">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="22ade-190">默认情况下，最小线程数设置为在系统上的处理器数。</span><span class="sxs-lookup"><span data-stu-id="22ade-190">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="22ade-191">当达到最小值时，线程池可以创建该类别中的其他线程或等待，直到一些任务完成。</span><span class="sxs-lookup"><span data-stu-id="22ade-191">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="22ade-192">从[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，线程池创建和销毁线程以优化吞吐量，该常数定义为每个单位的时间完成的任务数。</span><span class="sxs-lookup"><span data-stu-id="22ade-192">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="22ade-193">线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。</span><span class="sxs-lookup"><span data-stu-id="22ade-193">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="22ade-194">需求较低时，线程池线程的实际数量可以低于最小值。</span><span class="sxs-lookup"><span data-stu-id="22ade-194">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="22ade-195">下面的示例将最小工作线程数设置为 4，并保留的最小异步 I/O 完成线程数的原始值。</span><span class="sxs-lookup"><span data-stu-id="22ade-195">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="22ade-196">将方法排入队列以便执行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-196">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="22ade-197">此方法在有线程池线程变得可用时执行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-197">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="22ade-198">一个 <see cref="T:System.Threading.WaitCallback" />，表示要执行的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-198">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-199">将方法排入队列以便执行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-199">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="22ade-200">此方法在有线程池线程变得可用时执行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-200">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-201">如果此方法成功排队，则为 <see langword="true" />；如果无法将该工作项排队，则引发 <see cref="T:System.NotSupportedException" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-201">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-202">可以将放置在其中定义该方法，也可以使用的类的实例字段中排队的方法所需的数据<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>重载接受一个包含所需的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="22ade-202">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="22ade-203">Visual Basic 用户可以省略<xref:System.Threading.WaitCallback>构造函数，并只需使用`AddressOf`运算符时将传递到回调方法<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>。</span><span class="sxs-lookup"><span data-stu-id="22ade-203">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="22ade-204">Visual Basic 会自动调用正确的委托构造函数。</span><span class="sxs-lookup"><span data-stu-id="22ade-204">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="22ade-205">版本信息</span><span class="sxs-lookup"><span data-stu-id="22ade-205">Version Information</span></span>  
 <span data-ttu-id="22ade-206">在.NET Framework 2.0 版中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排入队列使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-206">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="22ade-207">在早期版本中，不会传播主体的信息。</span><span class="sxs-lookup"><span data-stu-id="22ade-207">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="22ade-208">下面的示例使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29>方法重载将任务排入队列，由表示`ThreadProc`方法，以在线程变得可用时执行。</span><span class="sxs-lookup"><span data-stu-id="22ade-208">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="22ade-209">使用此重载不提供任何任务信息。</span><span class="sxs-lookup"><span data-stu-id="22ade-209">No task information is supplied with this overload.</span></span> <span data-ttu-id="22ade-210">因此，可供信息`ThreadProc`方法被限制为该方法所属的对象。</span><span class="sxs-lookup"><span data-stu-id="22ade-210">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="22ade-211">
            <paramref name="callBack" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-211">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="22ade-212">承载公共语言运行时 (CLR) 的宿主不支持此操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-212">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="22ade-213">托管线程池</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-213">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="22ade-214">
            <see cref="T:System.Threading.WaitCallback" />，它表示要执行的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-214">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="22ade-215">包含方法所用数据的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-215">An object containing data to be used by the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-216">将方法排入队列以便执行，并指定包含该方法所用数据的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-216">Queues a method for execution, and specifies an object containing data to be used by the method.</span>
          </span>
          <span data-ttu-id="22ade-217">此方法在有线程池线程变得可用时执行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-217">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-218">如果此方法成功排队，则为 <see langword="true" />；如果无法将该工作项排队，则引发 <see cref="T:System.NotSupportedException" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-218">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-219">如果回调方法需要复杂的数据，可以定义一个类来包含的数据。</span><span class="sxs-lookup"><span data-stu-id="22ade-219">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="22ade-220">Visual Basic 用户可以省略<xref:System.Threading.WaitCallback>构造函数，并只需使用`AddressOf`运算符时将传递到回调方法<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>。</span><span class="sxs-lookup"><span data-stu-id="22ade-220">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="22ade-221">Visual Basic 会自动调用正确的委托构造函数。</span><span class="sxs-lookup"><span data-stu-id="22ade-221">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="22ade-222">版本信息</span><span class="sxs-lookup"><span data-stu-id="22ade-222">Version Information</span></span>  
 <span data-ttu-id="22ade-223">在.NET Framework 2.0 版中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排入队列使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-223">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="22ade-224">在早期版本中，不会传播主体的信息。</span><span class="sxs-lookup"><span data-stu-id="22ade-224">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="22ade-225">下面的示例使用.NET 线程池来计算`Fibonacci`介于 20 和 40 之间的五个数字的结果。</span><span class="sxs-lookup"><span data-stu-id="22ade-225">The following example uses the .NET thread pool to calculate the `Fibonacci` result for five numbers between 20 and 40.</span></span> <span data-ttu-id="22ade-226">每个 `Fibonacci` 结果都由 `Fibonacci` 类表示，该类提供一个名为 `ThreadPoolCallback` 的方法，用于执行计算。</span><span class="sxs-lookup"><span data-stu-id="22ade-226">Each `Fibonacci` result is represented by the `Fibonacci` class, which provides a method named `ThreadPoolCallback` that performs the calculation.</span></span> <span data-ttu-id="22ade-227">创建表示每个 `Fibonacci` 值的对象，并将 `ThreadPoolCallback` 方法传递给 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>，它分配池中的一个可用线程来执行此方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-227">An object that represents each `Fibonacci` value is created, and the `ThreadPoolCallback` method is passed to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, which assigns an available thread in the pool to execute the method.</span></span>  
  
 <span data-ttu-id="22ade-228">因为每个`Fibonacci`对象指定一个半随机值来计算，和每个线程都将争用处理器时间，因为无法知道如何预先花费的时间计算的所有五个结果。</span><span class="sxs-lookup"><span data-stu-id="22ade-228">Because each `Fibonacci` object is given a semi-random value to compute, and because each thread will be competing for processor time, you cannot know in advance how long it will take for all five results to be calculated.</span></span> <span data-ttu-id="22ade-229">这就是在构造期间为每个 `Fibonacci` 对象传递 <xref:System.Threading.ManualResetEvent> 类的一个实例的原因。</span><span class="sxs-lookup"><span data-stu-id="22ade-229">That is why each `Fibonacci` object is passed an instance of the <xref:System.Threading.ManualResetEvent> class during construction.</span></span> <span data-ttu-id="22ade-230">每个对象都通知提供的事件对象其计算过程何时完成，它允许使用的块执行主线程<xref:System.Threading.WaitHandle.WaitAll%2A>直到所有五个`Fibonacci`对象全部计算出结果。</span><span class="sxs-lookup"><span data-stu-id="22ade-230">Each object signals the provided event object when its calculation is complete, which allows the primary thread to block execution with <xref:System.Threading.WaitHandle.WaitAll%2A> until all five `Fibonacci` objects have calculated a result.</span></span> <span data-ttu-id="22ade-231">然后 `Main` 方法会显示每个 `Fibonacci` 结果。</span><span class="sxs-lookup"><span data-stu-id="22ade-231">The `Main` method then displays each `Fibonacci` result.</span></span>
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="22ade-232">承载公共语言运行时 (CLR) 的宿主不支持此操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-232">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="22ade-233">
            <paramref name="callBack" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-233">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="22ade-234">托管线程池</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-234">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="22ade-235">注册正在等待 <see cref="T:System.Threading.WaitHandle" /> 的委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-235">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="22ade-236">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-236">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="22ade-237">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-237">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="22ade-238">向 <c>waitObject</c> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-238">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="22ade-239">传递给委托的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-239">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="22ade-240">以毫秒为单位的超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-240">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="22ade-241">如果 <c>millisecondsTimeOutInterval</c> 参数为 0（零），则函数将测试对象状态并立即返回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-241">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="22ade-242">如果 <c>millisecondsTimeOutInterval</c> 为 -1，则函数的超时间隔永远不过期。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-242">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="22ade-243">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-243">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-244">注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 32 位有符号整数来表示超时值（以毫秒为单位）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-244">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-245">封装本机句柄的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-245">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-246">完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="22ade-246">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="22ade-247">我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="22ade-247">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="22ade-248">垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。</span><span class="sxs-lookup"><span data-stu-id="22ade-248">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="22ade-249"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定的委托排队到线程池。</span><span class="sxs-lookup"><span data-stu-id="22ade-249">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="22ade-250">发生以下情况之一时，工作线程将执行委托：</span><span class="sxs-lookup"><span data-stu-id="22ade-250">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="22ade-251">指定的对象处于已发出信号状态。</span><span class="sxs-lookup"><span data-stu-id="22ade-251">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="22ade-252">超时间隔过期。</span><span class="sxs-lookup"><span data-stu-id="22ade-252">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="22ade-253"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法检查指定的对象的当前状态<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="22ade-253">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="22ade-254">如果对象的状态为非终止状态，该方法注册一个等待操作。</span><span class="sxs-lookup"><span data-stu-id="22ade-254">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="22ade-255">由线程池中的线程执行等待操作。</span><span class="sxs-lookup"><span data-stu-id="22ade-255">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="22ade-256">对象的状态将被发送信号或超时间隔结束时，将由工作线程执行委托。</span><span class="sxs-lookup"><span data-stu-id="22ade-256">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="22ade-257">如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次发出事件信号或超时间隔结束时重置计时器。</span><span class="sxs-lookup"><span data-stu-id="22ade-257">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="22ade-258">使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。</span><span class="sxs-lookup"><span data-stu-id="22ade-258">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="22ade-259">而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>，最大计数为 1。</span><span class="sxs-lookup"><span data-stu-id="22ade-259">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="22ade-260">若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-260">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="22ade-261">等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。</span><span class="sxs-lookup"><span data-stu-id="22ade-261">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="22ade-262">因此，如果必须使用相同的本机操作系统句柄中多次调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，必须重复使用 Win32 句柄`DuplicateHandle`函数。</span><span class="sxs-lookup"><span data-stu-id="22ade-262">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="22ade-263">请注意，不应传递到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，这是因为等待线程可能检测不到该事件重置之前发出信号。</span><span class="sxs-lookup"><span data-stu-id="22ade-263">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="22ade-264">再返回，该函数修改某些类型的同步对象的状态。</span><span class="sxs-lookup"><span data-stu-id="22ade-264">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="22ade-265">仅对其发出信号的状态引起的等待条件得到满足的对象的进行修改。</span><span class="sxs-lookup"><span data-stu-id="22ade-265">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="22ade-266">例如，一个信号量计数被减少 1。</span><span class="sxs-lookup"><span data-stu-id="22ade-266">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="22ade-267">版本信息</span><span class="sxs-lookup"><span data-stu-id="22ade-267">Version Information</span></span>  
 <span data-ttu-id="22ade-268">从.NET Framework 2.0 版中，开始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排入队列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-268">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="22ade-269">在早期版本中，不会传播主体的信息。</span><span class="sxs-lookup"><span data-stu-id="22ade-269">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="22ade-270">
            <paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-270">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="22ade-271">托管线程池</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-271">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="22ade-272">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-272">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="22ade-273">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-273">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="22ade-274">向 <c>waitObject</c> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-274">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="22ade-275">传递给委托的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-275">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="22ade-276">以毫秒为单位的超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-276">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="22ade-277">如果 <c>millisecondsTimeOutInterval</c> 参数为 0（零），则函数将测试对象状态并立即返回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-277">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="22ade-278">如果 <c>millisecondsTimeOutInterval</c> 为 -1，则函数的超时间隔永远不过期。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-278">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="22ade-279">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-279">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-280">注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 64 位有符号整数来表示超时值（以毫秒为单位）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-280">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-281">封装本机句柄的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-281">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-282">完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="22ade-282">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="22ade-283">我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="22ade-283">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="22ade-284">垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。</span><span class="sxs-lookup"><span data-stu-id="22ade-284">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="22ade-285"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定的委托排队到线程池。</span><span class="sxs-lookup"><span data-stu-id="22ade-285">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="22ade-286">发生以下情况之一时，工作线程将执行委托：</span><span class="sxs-lookup"><span data-stu-id="22ade-286">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="22ade-287">指定的对象处于已发出信号状态。</span><span class="sxs-lookup"><span data-stu-id="22ade-287">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="22ade-288">超时间隔过期。</span><span class="sxs-lookup"><span data-stu-id="22ade-288">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="22ade-289"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法检查指定的对象的当前状态<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="22ade-289">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="22ade-290">如果对象的状态为非终止状态，该方法注册一个等待操作。</span><span class="sxs-lookup"><span data-stu-id="22ade-290">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="22ade-291">由线程池中的线程执行等待操作。</span><span class="sxs-lookup"><span data-stu-id="22ade-291">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="22ade-292">对象的状态将被发送信号或超时间隔结束时，将由工作线程执行委托。</span><span class="sxs-lookup"><span data-stu-id="22ade-292">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="22ade-293">如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次发出事件信号或超时间隔结束时重置计时器。</span><span class="sxs-lookup"><span data-stu-id="22ade-293">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="22ade-294">使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。</span><span class="sxs-lookup"><span data-stu-id="22ade-294">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="22ade-295">而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>，最大计数为 1。</span><span class="sxs-lookup"><span data-stu-id="22ade-295">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="22ade-296">若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-296">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="22ade-297">等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。</span><span class="sxs-lookup"><span data-stu-id="22ade-297">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="22ade-298">因此，如果必须使用相同的本机操作系统句柄中多次调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，必须重复使用 Win32 句柄`DuplicateHandle`函数。</span><span class="sxs-lookup"><span data-stu-id="22ade-298">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="22ade-299">请注意，不应传递到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，这是因为等待线程可能检测不到该事件重置之前发出信号。</span><span class="sxs-lookup"><span data-stu-id="22ade-299">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="22ade-300">再返回，该函数修改某些类型的同步对象的状态。</span><span class="sxs-lookup"><span data-stu-id="22ade-300">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="22ade-301">仅对其发出信号的状态引起的等待条件得到满足的对象的进行修改。</span><span class="sxs-lookup"><span data-stu-id="22ade-301">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="22ade-302">例如，一个信号量计数被减少 1。</span><span class="sxs-lookup"><span data-stu-id="22ade-302">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="22ade-303">版本信息</span><span class="sxs-lookup"><span data-stu-id="22ade-303">Version Information</span></span>  
 <span data-ttu-id="22ade-304">从.NET Framework 2.0 版中，开始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排入队列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-304">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="22ade-305">在早期版本中，不会传播主体的信息。</span><span class="sxs-lookup"><span data-stu-id="22ade-305">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="22ade-306">
            <paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-306">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="22ade-307">托管线程池</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-307">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="22ade-308">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-308">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="22ade-309">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-309">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="22ade-310">向 <c>waitObject</c> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-310">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="22ade-311">传递给委托的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-311">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="22ade-312">
            <see cref="T:System.TimeSpan" /> 表示的超时时间。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-312">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="22ade-313">如果 <c>timeout</c> 为 0（零），则函数将测试对象状态并立即返回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-313">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="22ade-314">如果 <c>timeout</c> 为 -1，则函数的超时间隔永远不过期。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-314">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="22ade-315">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-315">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-316">注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 <see cref="T:System.TimeSpan" /> 值来表示超时时间。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-316">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-317">封装本机句柄的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-317">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-318">完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="22ade-318">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="22ade-319">我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="22ade-319">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="22ade-320">垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。</span><span class="sxs-lookup"><span data-stu-id="22ade-320">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="22ade-321"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定的委托排队到线程池。</span><span class="sxs-lookup"><span data-stu-id="22ade-321">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="22ade-322">发生以下情况之一时，工作线程将执行委托：</span><span class="sxs-lookup"><span data-stu-id="22ade-322">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="22ade-323">指定的对象处于已发出信号状态。</span><span class="sxs-lookup"><span data-stu-id="22ade-323">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="22ade-324">超时间隔过期。</span><span class="sxs-lookup"><span data-stu-id="22ade-324">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="22ade-325"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法检查指定的对象的当前状态<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="22ade-325">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="22ade-326">如果对象的状态为非终止状态，该方法注册一个等待操作。</span><span class="sxs-lookup"><span data-stu-id="22ade-326">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="22ade-327">由线程池中的线程执行等待操作。</span><span class="sxs-lookup"><span data-stu-id="22ade-327">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="22ade-328">对象的状态将被发送信号或超时间隔结束时，将由工作线程执行委托。</span><span class="sxs-lookup"><span data-stu-id="22ade-328">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="22ade-329">如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次发出事件信号或超时间隔结束时重置计时器。</span><span class="sxs-lookup"><span data-stu-id="22ade-329">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="22ade-330">使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。</span><span class="sxs-lookup"><span data-stu-id="22ade-330">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="22ade-331">而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>，最大计数为 1。</span><span class="sxs-lookup"><span data-stu-id="22ade-331">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="22ade-332">若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-332">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="22ade-333">等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。</span><span class="sxs-lookup"><span data-stu-id="22ade-333">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="22ade-334">因此，如果必须使用相同的本机操作系统句柄中多次调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，必须重复使用 Win32 句柄`DuplicateHandle`函数。</span><span class="sxs-lookup"><span data-stu-id="22ade-334">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="22ade-335">请注意，不应传递到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，这是因为等待线程可能检测不到该事件重置之前发出信号。</span><span class="sxs-lookup"><span data-stu-id="22ade-335">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="22ade-336">再返回，该函数修改某些类型的同步对象的状态。</span><span class="sxs-lookup"><span data-stu-id="22ade-336">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="22ade-337">仅对其发出信号的状态引起的等待条件得到满足的对象的进行修改。</span><span class="sxs-lookup"><span data-stu-id="22ade-337">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="22ade-338">例如，一个信号量计数被减少 1。</span><span class="sxs-lookup"><span data-stu-id="22ade-338">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="22ade-339">版本信息</span><span class="sxs-lookup"><span data-stu-id="22ade-339">Version Information</span></span>  
 <span data-ttu-id="22ade-340">从.NET Framework 2.0 版中，开始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排入队列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-340">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="22ade-341">在早期版本中，不会传播主体的信息。</span><span class="sxs-lookup"><span data-stu-id="22ade-341">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="22ade-342">
            <paramref name="timeout" /> 参数小于 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-342">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="22ade-343">
            <paramref name="timeout" /> 参数大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-343">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="22ade-344">托管线程池</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-344">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="22ade-345">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-345">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="22ade-346">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-346">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="22ade-347">向 <c>waitObject</c> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-347">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="22ade-348">传递给委托的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-348">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="22ade-349">以毫秒为单位的超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-349">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="22ade-350">如果 <c>millisecondsTimeOutInterval</c> 参数为 0（零），则函数将测试对象状态并立即返回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-350">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="22ade-351">如果 <c>millisecondsTimeOutInterval</c> 为 -1，则函数的超时间隔永远不过期。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-351">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="22ade-352">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-352">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-353">指定表示超时（以毫秒为单位）的 32 位无符号整数，注册一个委托等待 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-353">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-354">
            <see cref="T:System.Threading.RegisteredWaitHandle" />，可用于取消已注册的等待操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-354">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-355">完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="22ade-355">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="22ade-356">我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="22ade-356">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="22ade-357">垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。</span><span class="sxs-lookup"><span data-stu-id="22ade-357">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="22ade-358"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定的委托排队到线程池。</span><span class="sxs-lookup"><span data-stu-id="22ade-358">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="22ade-359">发生以下情况之一时，工作线程将执行委托：</span><span class="sxs-lookup"><span data-stu-id="22ade-359">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="22ade-360">指定的对象处于已发出信号状态。</span><span class="sxs-lookup"><span data-stu-id="22ade-360">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="22ade-361">超时间隔过期。</span><span class="sxs-lookup"><span data-stu-id="22ade-361">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="22ade-362"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法检查指定的对象的当前状态<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="22ade-362">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="22ade-363">如果对象的状态为非终止状态，该方法注册一个等待操作。</span><span class="sxs-lookup"><span data-stu-id="22ade-363">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="22ade-364">由线程池中的线程执行等待操作。</span><span class="sxs-lookup"><span data-stu-id="22ade-364">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="22ade-365">对象的状态将被发送信号或超时间隔结束时，将由工作线程执行委托。</span><span class="sxs-lookup"><span data-stu-id="22ade-365">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="22ade-366">如果`timeOutInterval`参数不是 0 （零） 和`executeOnlyOnce`参数是`false`，每次发出事件信号或超时间隔结束时重置计时器。</span><span class="sxs-lookup"><span data-stu-id="22ade-366">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="22ade-367">使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。</span><span class="sxs-lookup"><span data-stu-id="22ade-367">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="22ade-368">而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>，最大计数为 1。</span><span class="sxs-lookup"><span data-stu-id="22ade-368">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="22ade-369">若要取消等待操作，请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-369">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="22ade-370">等待线程使用 Win32`WaitForMultipleObjects`函数来监视已注册的等待操作。</span><span class="sxs-lookup"><span data-stu-id="22ade-370">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="22ade-371">因此，如果必须使用相同的本机操作系统句柄中多次调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，必须重复使用 Win32 句柄`DuplicateHandle`函数。</span><span class="sxs-lookup"><span data-stu-id="22ade-371">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="22ade-372">请注意，不应传递到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，这是因为等待线程可能检测不到该事件重置之前发出信号。</span><span class="sxs-lookup"><span data-stu-id="22ade-372">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="22ade-373">再返回，该函数修改某些类型的同步对象的状态。</span><span class="sxs-lookup"><span data-stu-id="22ade-373">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="22ade-374">仅对其发出信号的状态引起的等待条件得到满足的对象的进行修改。</span><span class="sxs-lookup"><span data-stu-id="22ade-374">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="22ade-375">例如，一个信号量计数被减少 1。</span><span class="sxs-lookup"><span data-stu-id="22ade-375">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="22ade-376">版本信息</span><span class="sxs-lookup"><span data-stu-id="22ade-376">Version Information</span></span>  
 <span data-ttu-id="22ade-377">从.NET Framework 2.0 版中，开始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性值将传播到辅助线程排入队列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-377">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="22ade-378">在早期版本中，不会传播主体的信息。</span><span class="sxs-lookup"><span data-stu-id="22ade-378">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="22ade-379">下面的示例演示如何使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>要指定的等待句柄发出信号时执行指定的回调方法的方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-379">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="22ade-380">在此示例中，回调方法是`WaitProc`，并等待句柄是<xref:System.Threading.AutoResetEvent>。</span><span class="sxs-lookup"><span data-stu-id="22ade-380">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="22ade-381">该示例定义了`TaskInfo`类来保存时它将执行传递给回调的信息。</span><span class="sxs-lookup"><span data-stu-id="22ade-381">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="22ade-382">此示例将创建`TaskInfo`对象，并将其分配一些字符串数据。</span><span class="sxs-lookup"><span data-stu-id="22ade-382">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="22ade-383"><xref:System.Threading.RegisteredWaitHandle>返回的<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定给`Handle`字段`TaskInfo`对象，以便回调方法有权访问<xref:System.Threading.RegisteredWaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="22ade-383">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="22ade-384">除了指定`TaskInfo`作为要传递给回调方法调用的对象<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指定<xref:System.Threading.AutoResetEvent>任务将等待<xref:System.Threading.WaitOrTimerCallback>委托，表示`WaitProc`回调方法一个第二个超时时间间隔和多个回调。</span><span class="sxs-lookup"><span data-stu-id="22ade-384">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="22ade-385">当主线程发出信号<xref:System.Threading.AutoResetEvent>通过调用其<xref:System.Threading.EventWaitHandle.Set%2A>方法，<xref:System.Threading.WaitOrTimerCallback>调用委托。</span><span class="sxs-lookup"><span data-stu-id="22ade-385">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="22ade-386">`WaitProc`方法测试<xref:System.Threading.RegisteredWaitHandle>以确定是否发生了超时值。</span><span class="sxs-lookup"><span data-stu-id="22ade-386">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="22ade-387">如果由于等待句柄已收到信号，而调用的回调`WaitProc`方法将注销<xref:System.Threading.RegisteredWaitHandle>，从而停止其他回调。</span><span class="sxs-lookup"><span data-stu-id="22ade-387">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="22ade-388">在超时的情况下该任务将继续等待。</span><span class="sxs-lookup"><span data-stu-id="22ade-388">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="22ade-389">`WaitProc`方法结束通过将消息输出到控制台。</span><span class="sxs-lookup"><span data-stu-id="22ade-389">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="22ade-390">
            <paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-390">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="22ade-391">托管线程池</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-391">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="22ade-392">线程池中辅助线程的最大数目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-392">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="22ade-393">线程池中异步 I/O 线程的最大数目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-393">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-394">设置可以同时处于活动状态的线程池的请求数目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-394">Sets the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="22ade-395">所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-395">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-396">如果更改成功，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-396">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-397">您不能设置工作线程或 I/O 完成线程的最大数目为一个数字小于的计算机上的处理器数。</span><span class="sxs-lookup"><span data-stu-id="22ade-397">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="22ade-398">若要确定存在有多少处理器，检索的值<xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType>属性。</span><span class="sxs-lookup"><span data-stu-id="22ade-398">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="22ade-399">此外，不能设置工作线程或 I/O 完成线程数小于最小相应工作线程数或 I/O 完成线程的最大数目。</span><span class="sxs-lookup"><span data-stu-id="22ade-399">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="22ade-400">若要确定最小线程池的大小，请调用<xref:System.Threading.ThreadPool.GetMinThreads%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="22ade-400">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="22ade-401">如果托管公共语言运行时，例如通过 Internet 信息服务 (IIS) 或 SQL Server，主机可以限制或阻止更改到线程池大小。</span><span class="sxs-lookup"><span data-stu-id="22ade-401">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="22ade-402">更改最大数量的线程池中的线程时要格外小心。</span><span class="sxs-lookup"><span data-stu-id="22ade-402">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="22ade-403">虽然你的代码可能受益，所做的更改可能产生负面影响您使用的代码库。</span><span class="sxs-lookup"><span data-stu-id="22ade-403">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="22ade-404">设置线程池大小太大，可能会导致性能问题。</span><span class="sxs-lookup"><span data-stu-id="22ade-404">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="22ade-405">如果在同一时间执行过多的线程，任务切换开销就成为一个重要的因素。</span><span class="sxs-lookup"><span data-stu-id="22ade-405">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="22ade-406">用于控制线程的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-406">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="22ade-407">权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-407">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="22ade-408">要由线程池根据需要创建的新的最小工作程序线程数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-408">The minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="22ade-409">要由线程池根据需要创建的新的最小空闲异步 I/O 线程数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-409">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-410">发出新的请求时，在切换到管理线程创建和销毁的算法之前设置线程池按需创建的线程的最小数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-410">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-411">如果更改成功，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-411">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-412">线程池按需提供新的工作线程或 I/O 完成线程直到它达到每个类别的最小值。</span><span class="sxs-lookup"><span data-stu-id="22ade-412">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="22ade-413">当达到最小值时，线程池可以创建该类别中的其他线程或等待，直到一些任务完成。</span><span class="sxs-lookup"><span data-stu-id="22ade-413">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="22ade-414">从[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，线程池创建和销毁线程以优化吞吐量，该常数定义为每个单位的时间完成的任务数。</span><span class="sxs-lookup"><span data-stu-id="22ade-414">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="22ade-415">线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。</span><span class="sxs-lookup"><span data-stu-id="22ade-415">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="22ade-416">需求较低时，线程池线程的实际数量可以低于最小值。</span><span class="sxs-lookup"><span data-stu-id="22ade-416">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="22ade-417">如果指定为负数或大于最大活动线程池线程数的数字 (使用获得<xref:System.Threading.ThreadPool.GetMaxThreads%2A>)，<xref:System.Threading.ThreadPool.SetMinThreads%2A>返回`false`和也最小值不会更改。</span><span class="sxs-lookup"><span data-stu-id="22ade-417">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="22ade-418">默认情况下，最小线程数设置为在系统上的处理器数。</span><span class="sxs-lookup"><span data-stu-id="22ade-418">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="22ade-419">可以使用<xref:System.Threading.ThreadPool.SetMinThreads%2A>方法来增加最小数字 ofthreads。</span><span class="sxs-lookup"><span data-stu-id="22ade-419">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number ofthreads.</span></span> <span data-ttu-id="22ade-420">但是，不必要地增加这些值可能导致性能问题。</span><span class="sxs-lookup"><span data-stu-id="22ade-420">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="22ade-421">如果在同一时间开始太多的任务，则所有任务均可能会很慢。</span><span class="sxs-lookup"><span data-stu-id="22ade-421">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="22ade-422">在大多数情况下，线程池将使用其自己的分配线程算法更好地执行。</span><span class="sxs-lookup"><span data-stu-id="22ade-422">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="22ade-423">减少到小于处理器的数量也会影响性能的最小值。</span><span class="sxs-lookup"><span data-stu-id="22ade-423">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="22ade-424">下面的示例将最小工作线程数设置为 4，并保留的最小异步 I/O 完成线程数的原始值。</span><span class="sxs-lookup"><span data-stu-id="22ade-424">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="22ade-425">用于控制线程的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-425">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="22ade-426">权限值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-426">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">
          <span data-ttu-id="22ade-427">要排队的 <see cref="T:System.Threading.NativeOverlapped" /> 结构。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-427">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-428">将重叠的 I/O 操作排队以便执行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-428">Queues an overlapped I/O operation for execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-429">如果成功地将此操作排队到 I/O 完成端口，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-429">
              <see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-430">有关使用本机 Win32 信息重叠 I/O，请参阅<xref:System.Threading.Overlapped>类，<xref:System.Threading.NativeOverlapped>结构，和`OVERLAPPED`Win32 平台 SDK 中的结构。</span><span class="sxs-lookup"><span data-stu-id="22ade-430">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="22ade-431">使用<xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>方法可能会无意中打开安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="22ade-431">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="22ade-432">代码访问安全性基础在堆栈上的所有调用方的权限及其权限检查。</span><span class="sxs-lookup"><span data-stu-id="22ade-432">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="22ade-433">工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>，线程池线程的堆栈不具有实际调用方的上下文。</span><span class="sxs-lookup"><span data-stu-id="22ade-433">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="22ade-434">恶意代码可能会利用这一点以避免权限检查。</span><span class="sxs-lookup"><span data-stu-id="22ade-434">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="22ade-435">直接调用方需要完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-435">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="22ade-436">不能由部分受信任的或透明的代码使用此成员。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-436">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="22ade-437">一个 <see cref="T:System.Threading.WaitCallback" />，表示当线程池中的线程选择工作项时调用的委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-437">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="22ade-438">在接受线程池服务时传递给委托的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-438">The object that is passed to the delegate when serviced from the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-439">将指定的委托排队到线程池，但不会将调用堆栈传播到辅助线程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-439">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-440">如果方法成功，则为 <see langword="true" />；如果未能将该工作项排队，则引发 <see cref="T:System.OutOfMemoryException" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-440">
              <see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-441">与不同<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法，<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>不会传播到辅助线程的调用堆栈。</span><span class="sxs-lookup"><span data-stu-id="22ade-441">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="22ade-442">这允许丢失的调用堆栈，从而提升其安全特权的代码。</span><span class="sxs-lookup"><span data-stu-id="22ade-442">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="22ade-443">使用<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>可能会无意中打开安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="22ade-443">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="22ade-444">代码访问安全性基础在堆栈上的所有调用方的权限及其权限检查。</span><span class="sxs-lookup"><span data-stu-id="22ade-444">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="22ade-445">工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>，线程池线程的堆栈不会实际调用方的上下文。</span><span class="sxs-lookup"><span data-stu-id="22ade-445">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="22ade-446">恶意代码可能会利用这一点以避免权限检查。</span><span class="sxs-lookup"><span data-stu-id="22ade-446">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="22ade-447">调用方没有所要求的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-447">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="22ade-448">遇到了内存不足的情况。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-448">An out-of-memory condition was encountered.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="22ade-449">未能将该工作项排队。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-449">The work item could not be queued.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="22ade-450">
            <paramref name="callBack" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-450">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="22ade-451">直接调用方需要完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-451">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="22ade-452">不能由部分受信任的或透明的代码使用此成员。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-452">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="22ade-453">托管线程池</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-453">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="22ade-454">注册委托以等待 <see cref="T:System.Threading.WaitHandle" />，但不会将调用堆栈传播到辅助线程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-454">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="22ade-455">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-455">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="22ade-456">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-456">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="22ade-457">向 <c>waitObject</c> 参数发出信号时调用的委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-457">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="22ade-458">传递给委托的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-458">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="22ade-459">以毫秒为单位的超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-459">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="22ade-460">如果 <c>millisecondsTimeOutInterval</c> 参数为 0（零），则函数将测试对象状态并立即返回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-460">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="22ade-461">如果 <c>millisecondsTimeOutInterval</c> 为 -1，则函数的超时间隔永远不过期。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-461">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="22ade-462">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-462">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-463">注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并使用一个 32 位带符号整数来表示超时时间（以毫秒为单位）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-463">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="22ade-464">此方法不将调用堆栈传播到辅助线程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-464">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-465">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-465">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-466">与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不会传播到辅助线程的调用堆栈。</span><span class="sxs-lookup"><span data-stu-id="22ade-466">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="22ade-467">这允许丢失的调用堆栈，从而提升其安全特权的代码。</span><span class="sxs-lookup"><span data-stu-id="22ade-467">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="22ade-468">使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能会无意中打开安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="22ade-468">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="22ade-469">代码访问安全性基础在堆栈上的所有调用方的权限及其权限检查。</span><span class="sxs-lookup"><span data-stu-id="22ade-469">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="22ade-470">工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，线程池线程的堆栈不会实际调用方的上下文。</span><span class="sxs-lookup"><span data-stu-id="22ade-470">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="22ade-471">恶意代码可能会利用这一点以避免权限检查。</span><span class="sxs-lookup"><span data-stu-id="22ade-471">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="22ade-472">使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。</span><span class="sxs-lookup"><span data-stu-id="22ade-472">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="22ade-473">完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="22ade-473">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="22ade-474">我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="22ade-474">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="22ade-475">垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。</span><span class="sxs-lookup"><span data-stu-id="22ade-475">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="22ade-476">
            <paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-476">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="22ade-477">调用方没有所要求的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-477">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="22ade-478">直接调用方需要完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-478">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="22ade-479">不能由部分受信任的或透明的代码使用此成员。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-479">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="22ade-480">托管线程池</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-480">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="22ade-481">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-481">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="22ade-482">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-482">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="22ade-483">向 <c>waitObject</c> 参数发出信号时调用的委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-483">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="22ade-484">传递给委托的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-484">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="22ade-485">以毫秒为单位的超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-485">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="22ade-486">如果 <c>millisecondsTimeOutInterval</c> 参数为 0（零），则函数将测试对象状态并立即返回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-486">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="22ade-487">如果 <c>millisecondsTimeOutInterval</c> 为 -1，则函数的超时间隔永远不过期。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-487">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="22ade-488">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-488">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-489">注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 64 位有符号整数来表示超时值（以毫秒为单位）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-489">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="22ade-490">此方法不将调用堆栈传播到辅助线程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-490">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-491">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-491">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-492">与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不会传播到辅助线程的调用堆栈。</span><span class="sxs-lookup"><span data-stu-id="22ade-492">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="22ade-493">这允许丢失的调用堆栈，从而提升其安全特权的代码。</span><span class="sxs-lookup"><span data-stu-id="22ade-493">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="22ade-494">使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能会无意中打开安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="22ade-494">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="22ade-495">代码访问安全性基础在堆栈上的所有调用方的权限及其权限检查。</span><span class="sxs-lookup"><span data-stu-id="22ade-495">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="22ade-496">工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，线程池线程的堆栈不会实际调用方的上下文。</span><span class="sxs-lookup"><span data-stu-id="22ade-496">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="22ade-497">恶意代码可能会利用这一点以避免权限检查。</span><span class="sxs-lookup"><span data-stu-id="22ade-497">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="22ade-498">使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。</span><span class="sxs-lookup"><span data-stu-id="22ade-498">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="22ade-499">完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="22ade-499">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="22ade-500">我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="22ade-500">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="22ade-501">垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。</span><span class="sxs-lookup"><span data-stu-id="22ade-501">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="22ade-502">
            <paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-502">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="22ade-503">调用方没有所要求的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-503">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="22ade-504">直接调用方需要完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-504">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="22ade-505">不能由部分受信任的或透明的代码使用此成员。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-505">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="22ade-506">托管线程池</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-506">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="22ade-507">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-507">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="22ade-508">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-508">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="22ade-509">向 <c>waitObject</c> 参数发出信号时调用的委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-509">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="22ade-510">传递给委托的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-510">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="22ade-511">
            <see cref="T:System.TimeSpan" /> 表示的超时时间。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-511">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="22ade-512">如果 <c>timeout</c> 为 0（零），则函数将测试对象状态并立即返回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-512">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="22ade-513">如果 <c>timeout</c> 为 -1，则函数的超时间隔永远不过期。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-513">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="22ade-514">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-514">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-515">注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 <see cref="T:System.TimeSpan" /> 值来表示超时时间。此方法不将调用堆栈传播到辅助线程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-515">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-516">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-516">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-517">与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不会传播到辅助线程的调用堆栈。</span><span class="sxs-lookup"><span data-stu-id="22ade-517">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="22ade-518">这允许丢失的调用堆栈，从而提升其安全特权的代码。</span><span class="sxs-lookup"><span data-stu-id="22ade-518">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="22ade-519">使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能会无意中打开安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="22ade-519">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="22ade-520">代码访问安全性基础在堆栈上的所有调用方的权限及其权限检查。</span><span class="sxs-lookup"><span data-stu-id="22ade-520">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="22ade-521">工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，线程池线程的堆栈不会实际调用方的上下文。</span><span class="sxs-lookup"><span data-stu-id="22ade-521">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="22ade-522">恶意代码可能会利用这一点以避免权限检查。</span><span class="sxs-lookup"><span data-stu-id="22ade-522">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="22ade-523">使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。</span><span class="sxs-lookup"><span data-stu-id="22ade-523">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="22ade-524">完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="22ade-524">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="22ade-525">我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="22ade-525">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="22ade-526">垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。</span><span class="sxs-lookup"><span data-stu-id="22ade-526">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="22ade-527">
            <paramref name="timeout" /> 参数小于 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-527">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="22ade-528">
            <paramref name="timeout" /> 参数大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-528">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="22ade-529">调用方没有所要求的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-529">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="22ade-530">直接调用方需要完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-530">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="22ade-531">不能由部分受信任的或透明的代码使用此成员。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-531">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="22ade-532">托管线程池</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-532">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="22ade-533">要注册的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-533">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="22ade-534">使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-534">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="22ade-535">向 <c>waitObject</c> 参数发出信号时调用的委托。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-535">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="22ade-536">传递给委托的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-536">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="22ade-537">以毫秒为单位的超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-537">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="22ade-538">如果 <c>millisecondsTimeOutInterval</c> 参数为 0（零），则函数将测试对象状态并立即返回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-538">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="22ade-539">如果 <c>millisecondsTimeOutInterval</c> 为 -1，则函数的超时间隔永远不过期。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-539">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="22ade-540">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <c>waitObject</c> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-540">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="22ade-541">指定表示超时（以毫秒为单位）的 32 位无符号整数，注册一个委托等待 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-541">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="22ade-542">此方法不将调用堆栈传播到辅助线程。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-542">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="22ade-543">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-543">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="22ade-544">与不同<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不会传播到辅助线程的调用堆栈。</span><span class="sxs-lookup"><span data-stu-id="22ade-544">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="22ade-545">这允许丢失的调用堆栈，从而提升其安全特权的代码。</span><span class="sxs-lookup"><span data-stu-id="22ade-545">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="22ade-546">使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能会无意中打开安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="22ade-546">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="22ade-547">代码访问安全性基础在堆栈上的所有调用方的权限及其权限检查。</span><span class="sxs-lookup"><span data-stu-id="22ade-547">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="22ade-548">工作线程池线程使用的排队时<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，线程池线程的堆栈不会实际调用方的上下文。</span><span class="sxs-lookup"><span data-stu-id="22ade-548">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="22ade-549">恶意代码可能会利用这一点以避免权限检查。</span><span class="sxs-lookup"><span data-stu-id="22ade-549">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="22ade-550">使用<xref:System.Threading.Mutex>有关`waitObject`不提供用于回调的互相排斥，因为基础 Win32 API 使用默认`WT_EXECUTEDEFAULT`标志，因此在单独的线程池线程上调度每个回调。</span><span class="sxs-lookup"><span data-stu-id="22ade-550">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="22ade-551">完成后使用<xref:System.Threading.RegisteredWaitHandle>此方法返回时，请调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，以释放对等待句柄的引用。</span><span class="sxs-lookup"><span data-stu-id="22ade-551">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="22ade-552">我们建议，始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`为`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="22ade-552">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="22ade-553">垃圾回收的工作的详细信息有效地调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法而不是具体取决于已注册的等待句柄的终结器。</span><span class="sxs-lookup"><span data-stu-id="22ade-553">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="22ade-554">调用方没有所要求的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-554">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="22ade-555">直接调用方需要完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-555">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="22ade-556">不能由部分受信任的或透明的代码使用此成员。</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-556">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="22ade-557">托管线程池</span>
          <span class="sxs-lookup">
            <span data-stu-id="22ade-557">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
  </Members>
</Type>