<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2ff770bb9446d6ebe71649784ebe115f60734cc0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531351" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>表示用于管理资源访问的锁定状态，可实现多线程读取或进行独占式写入访问。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Threading.ReaderWriterLockSlim>来保护是由多个线程读取，并一次通过某个线程写入到的资源。 <xref:System.Threading.ReaderWriterLockSlim> 允许多个线程能够在读取模式下，允许一个线程必须处于与独占所有权的锁写模式并允许具有读取访问权限要升级的读取模式，线程可以升级为写入模式，而无需放弃它的一个线程s 读取资源的访问权限。  
  
> [!NOTE]
>  虽然 <xref:System.Threading.ReaderWriterLockSlim> 类似于 <xref:System.Threading.ReaderWriterLock>，但不同之处在于，前者简化了递归规则以及锁状态的升级和降级规则。 <xref:System.Threading.ReaderWriterLockSlim> 避免了许多潜在的死锁情况。 另外，<xref:System.Threading.ReaderWriterLockSlim> 的性能显著优于 <xref:System.Threading.ReaderWriterLock>。 建议对所有新开发的项目使用 <xref:System.Threading.ReaderWriterLockSlim>。  
  
 默认情况下的新实例<xref:System.Threading.ReaderWriterLockSlim>使用创建<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>标志，并不允许递归。 对于所有新开发，建议，此默认策略，因为递归带来不必要的复杂情况，从而使代码更容易出现死锁。 若要简化从现有项目使用<xref:System.Threading.Monitor>或<xref:System.Threading.ReaderWriterLock>，你可以使用<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>标志来创建的实例<xref:System.Threading.ReaderWriterLockSlim>，允许使用递归。  
  
 线程可以在三种模式中输入该锁： 读取模式、 写入模式和升级的读取的模式。 (在本主题的其余部分，"读取进入可升级模式"称为"可升级模式"，并且短语"输入`x`模式"较长的短语优先使用"输入中的锁定`x`模式"。)  
  
 无论递归策略只有一个线程可以在任何时间是在写入模式下。 当线程在写入模式下，没有其他线程可以在任何模式下输入该锁。 在任何时候，只有一个线程可以在进入可升级模式。 在读取模式下，可以具有任意数量的线程和中可以有一个线程进入可升级模式时其他线程处于读取模式。  
  
> [!IMPORTANT]
>  此类型实现<xref:System.IDisposable>接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，调用其<xref:System.IDisposable.Dispose%2A>中的方法`try` / `catch`块。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅中的"使用实现 IDisposable 的对象"部分<xref:System.IDisposable>接口主题。  
  
 <xref:System.Threading.ReaderWriterLockSlim> 具有托管线程关联;也就是说，每个<xref:System.Threading.Thread>对象必须使其自己的方法调用进入和退出的锁模式。 无需对线程可以更改另一个线程的模式。  
  
 如果<xref:System.Threading.ReaderWriterLockSlim>不允许使用递归，线程尝试输入锁可以阻止的原因：  
  
-   尝试进入读取的模式块，如果有多个线程等待进入写入模式或写入模式中是否存在单个线程的线程。  
  
    > [!NOTE]
    >  阻止新的读取器时编写器将排队等待的锁的公平性策略时，倾向于编写器。 当前的公平策略均衡的公平性到读取器和编写器，提升中最常见的方案的吞吐量。 未来版本[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]可能引入新的公平策略。  
  
-   尝试进入可升级模式块是否存在一个线程正在进入可升级模式，如果有多个线程等待进入写入模式，或如果在写入模式下没有单个线程的线程。  
  
-   尝试进入写入模式块，如果没有任何的三种模式中的线程的线程。  
  
## <a name="upgrading-and-downgrading-locks"></a>升级和降级锁定  
 进入可升级模式适用于在其中一个线程通常读取从受保护的资源，但可能需要向其写入，如果满足某个条件。 线程已进入<xref:System.Threading.ReaderWriterLockSlim>在进入可升级模式具有读取访问受保护的资源，并可以升级为通过调用写入模式<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>或<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法。 中可能存在只有一个线程进入可升级模式一次，因为升级为写入模式不能发生死锁时不允许递归，这是默认策略。  
  
> [!IMPORTANT]
>  无论递归策略，最初输入线程读取模式下不允许升级到进入可升级模式或写入模式，因为这种方式导致的死锁的概率较强。 例如，如果两个线程在读取模式下都尝试进入写入模式，它们将死锁。 进入可升级模式旨在来避免这类死锁。  
  
 如果在读取模式下，升级块的线程有其他线程。 当线程被阻止时, 尝试进入读取的模式的其他线程被阻止。 当所有线程均都退出读取模式时，被阻止进入可升级线程进入写入模式。 如果没有其他线程等待进入写入模式，则它们保持被阻止，因为处于可升级模式的单一线程将阻止它们获取对该资源独占访问权。  
  
 在进入可升级模式中的线程时退出写入模式，因此除非有线程正等待进入写入模式，可以执行其他线程等待进入读取的模式。 进入可升级模式中的线程可以升级和降级无限期，只要它是将写入到受保护资源的唯一线程。  
  
> [!IMPORTANT]
>  如果允许多个线程进入写入模式或进入可升级模式，则不能允许一个线程独占进入可升级模式。 否则，尝试输入的线程写入模式直接将被阻止无限期，其他线程时其阻止，将不能进入读取的模式。  
  
 进入可升级模式中的线程可以降级为通过首先调用读取模式<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法，然后再调用<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法。 此降级模式可用于所有的锁定递归策略，即使<xref:System.Threading.LockRecursionPolicy.NoRecursion>。  
  
 在将降级为读取模式之后, 线程将不能重新进入可升级模式直到它已退出读取模式。  
  
## <a name="entering-the-lock-recursively"></a>输入锁以递归方式  
 你可以创建<xref:System.Threading.ReaderWriterLockSlim>通过使用支持递归锁定项<xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29>构造函数来指定锁定策略，并指定<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>。  
  
> [!NOTE]
>  对于新开发，不建议使用递归的因为它带来不必要的复杂情况，从而使代码更容易出现死锁。  
  
 有关<xref:System.Threading.ReaderWriterLockSlim>，允许使用递归，以下可以认为线程可以输入的模式：  
  
-   处于读取模式的线程可以输入以递归方式读取的模式，但不能进入写入模式或进入可升级模式。 如果它尝试这样做，请<xref:System.Threading.LockRecursionException>引发。 进入读取模式后再进入写入模式，或进入可升级模式是带的死锁，概率较强的模式，因此不允许。 如前面所述，需升级锁的情况提供进入可升级模式。  
  
-   进入可升级模式中的线程可以进入写入模式和/或读取的模式，并且可以输入任何以下三种模式以递归方式。 但是，尝试进入写入模式块读取模式中是否有其他线程。  
  
-   写入模式中的线程可以进入读取的模式和/或进入可升级模式，并且可以输入任何以下三种模式以递归方式。  
  
-   不进入锁定状态的线程可以输入任何模式。 出于相同原因，因为尝试输入非递归锁可以阻止此尝试。  
  
 线程可以退出其已进入按任意顺序模式，只要它退出它进入该模式的次数完全相同的每种模式。 如果线程尝试退出模式的次数过多，或者尝试退出它并未进入，模式<xref:System.Threading.SynchronizationLockException>引发。  
  
## <a name="lock-states"></a>锁定状态  
 你可能会发现其状态的锁将很有用。 A<xref:System.Threading.ReaderWriterLockSlim>可以是四种状态之一： 不进入、 读取、 升级和写入。  
  
-   未输入： 在此状态下，没有线程进入锁定 （或所有线程均已都退出锁）。  
  
-   阅读： 在此状态下，一个或多个线程进入锁定用于读访问到受保护的资源。  
  
    > [!NOTE]
    >  线程可以通过使用在读取模式中输入该锁<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>或<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法，或通过进入可升级模式从其降级。  
  
-   升级： 在此状态下，一个线程已进入锁定用于读访问升级的写权限的选项 （即，在进入可升级模式下），和零个或多个线程已进入锁定用于读访问。 一次不能超过一个线程可以进入并可以升级; 锁尝试进入可升级模式的其他线程被阻止。  
  
-   写入： 在此状态下，一个线程已进入锁定以进行写访问到受保护的资源。 该线程拥有独占锁。 尝试进入锁定状态出于任何原因的其他任何线程被阻止。  
  
 下表描述了锁定状态，不允许递归，当一个线程的锁之间的转换`t`采用最左边的列中所述的操作。 在时它不执行操作，`t`具有无模式。 (的特殊情况下其中`t`处于表批注中介绍了可升级模式。)最上面一行描述锁的起始状态。 单元格描述线程，会发生什么情况，并在括号中显示的锁定状态的更改。  
  
||未输入 (N)|Read (R)|升级 (U)|写入 (W)|  
|-|-----------------------|----------------|-------------------|-----------------|  
|`t` 进入读取的模式|`t` 进入 (R)。|`t` 如果多个线程正在等待写入模式，则，阻塞否则为`t`进入。|`t` 如果多个线程正在等待写入模式，则，阻塞否则为`t`进入。<sup>1</sup>|`t` 块。|  
|`t` 进入可升级模式|`t` 进入 (U)。|`t` 如果多个线程正在等待阻塞进入写入模式或升级模式;否则为`t`进入 (U)。|`t` 块。|`t` 块。|  
|`t` 进入写入模式|`t` 进入 (W)。|`t` 块。|`t` 块。<sup>2</sup>|`t` 块。|  
  
 <sup>1</sup>如果`t`启动注销进入可升级模式，在进入读取的模式。 此操作永远不会阻止。 锁定状态不会更改。 （在线程可以完成降级为通过退出可升级模式来读取模式）。  
  
 <sup>2</sup>如果`t`初始进入可升级模式，它会阻止如果多个线程处于读取模式。 否则它将升级为写入模式。 锁定状态更改为写入 (W)。 如果`t`块中，在多个线程处于读取模式，因为最后一个线程时退出读取的模式时，就会立即进入写入模式，即使有线程正等待进入写入模式。  
  
 因为线程退出锁状态更改时下, 一个线程被唤醒，选择，如下所示：  
  
-   首先，正在等待的线程写入模式，并已在进入可升级模式 （可以有最多一个此类线程）。  
  
-   失败，正在等待写入模式的线程。  
  
-   失败，正在等待进入可升级模式的线程。  
  
-   如果没有，正在等待读取模式的所有线程。  
  
 后续状态的锁始终是写入 (W) 中的第一个的两种情况下和升级 (U) 在第三个情况下，而无论锁定正在退出的线程触发状态更改时的状态。 在最后一种情况，锁定状态是升级 (U)，如果一个线程中没有进入可升级模式后的状态更改和 Read (R) 否则，而不考虑以前的状态。  
  
   
  
## Examples  
 下面的示例演示了简单的同步的缓存包含具有整数键的字符串。 实例<xref:System.Threading.ReaderWriterLockSlim>使用对访问进行同步<xref:System.Collections.Generic.Dictionary%602>用作内部缓存。  
  
 该示例包括简单的方法，用于向缓存中添加、 删除从缓存中，和从缓存中读取。 为了演示超时，该示例包括仅当它可以在指定的超时时间内执行此操作将添加到缓存的方法。  
  
 为了演示可升级模式，该示例包括检索与键关联的值的方法，并将其替换为新值进行比较。 如果值保持不变，该方法将返回状态指示无更改。 它没有值找不到键，插入的键/值对。 如果值已更改，将它更新。 进入可升级模式允许线程从读取访问权限，根据需要而没有死锁的风险的写权限升级。  
  
 该示例包括指定演示进入可升级模式的方法的返回值的嵌套的枚举。  
  
 该示例使用默认构造函数创建锁，因此不允许递归。 编程<xref:System.Threading.ReaderWriterLockSlim>当锁不允许递归是更简单且更不易出错。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 下面的代码然后使用`SynchronizedCache`要存储蔬菜名称的字典对象。 它将创建三个任务。 第一个写入的名称数组中存储的蔬菜`SynchronizedCache`实例。 第二个和第三个任务显示蔬菜中 （从低到高的索引的索引） 以降序顺序的第二个升序排序, 的第一个的名称。 最后一项任务搜索字符串"黄瓜"，并当它找到它，将调用<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法要替换的字符串"绿色 bean"。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>使用默认属性值初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Threading.ReaderWriterLockSlim>初始化与此构造函数不允许使用递归。 也就是说，<xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> 属性将返回 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>。  
  
 关于递归策略和其效果的详细信息，请参阅<xref:System.Threading.LockRecursionPolicy>枚举和<xref:System.Threading.ReaderWriterLockSlim>类。  
  
   
  
## Examples  
 下面的示例演示了简单的同步的缓存包含具有整数键的字符串。 实例<xref:System.Threading.ReaderWriterLockSlim>使用对访问进行同步<xref:System.Collections.Generic.Dictionary%602>用作内部缓存。 无参数构造函数用于创建该锁。  
  
 该示例包括简单的方法，用于向缓存中添加、 删除从缓存中，和从缓存中读取。 为了演示超时，该示例包括仅当它可以在指定的超时时间内执行此操作将添加到缓存的方法。  
  
 为了演示可升级模式，该示例包括检索与键关联的值的方法，并将其替换为新值进行比较。 如果值保持不变，该方法将返回状态指示无更改。 它没有值找不到键，插入的键/值对。 如果值已更改，将它更新。 进入可升级模式允许线程从读取访问权限，根据需要而没有死锁的风险的写权限升级。  
  
 该示例包括指定演示进入可升级模式的方法的返回值的嵌套的枚举。  
  
 该示例使用默认构造函数创建锁，因此不允许递归。 编程<xref:System.Threading.ReaderWriterLockSlim>当锁不允许递归是更简单且更不易出错。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 下面的代码然后使用`SynchronizedCache`要存储蔬菜名称的字典对象。 它将创建三个任务。 第一个写入的名称数组中存储的蔬菜`SynchronizedCache`实例。 第二个和第三个任务显示蔬菜中 （从低到高的索引的索引） 以降序顺序的第二个升序排序, 的第一个的名称。 最后一项任务搜索字符串"黄瓜"，并当它找到它，将调用<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法要替换的字符串"绿色 bean"。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">枚举值之一，用于指定锁定递归策略。</param>
        <summary>在指定锁定递归策略的情况下初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 递归策略将确定在多次输入锁的线程上的限制。 例如，如果使用锁创建了<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>和线程已进入读取模式锁定<xref:System.Threading.LockRecursionException>如果线程尝试重新输入中读取模式锁定，则引发。 同样，如果线程已进入写入模式锁定<xref:System.Threading.LockRecursionException>如果线程尝试重新输入在任何模式下锁定，则引发。  
  
> [!NOTE]
>  进入可升级模式中的线程可以升级为写入模式，或降级为读取而不考虑锁定递归策略设置的模式。  
  
 无论递归策略，最初输入线程读取模式下不允许升级到进入可升级模式或写入模式，因为这种方式导致的死锁的概率较强。  
  
 关于递归策略和其效果的详细信息，请参阅<xref:System.Threading.LockRecursionPolicy>枚举和<xref:System.Threading.ReaderWriterLockSlim>类。  
  
   
  
## Examples  
 下面的示例演示两个异常情况，一种依赖于<xref:System.Threading.LockRecursionPolicy>设置，另一个没有。  
  
 在第一个方案中，线程进入读取的模式，并尝试以递归方式进入读取的模式。 如果<xref:System.Threading.ReaderWriterLockSlim>使用默认构造函数，它将递归策略设置为创建<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>，将引发异常。 如果<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>用于创建<xref:System.Threading.ReaderWriterLockSlim>，不会引发异常。  
  
 在第二个方案中，则线程进入读取的模式，然后尝试进入写入模式。 <xref:System.Threading.LockRecursionException> 是引发而不考虑锁定递归策略。  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 下面的代码然后使用`SynchronizedCache`要存储蔬菜名称的字典对象。 它将创建三个任务。 第一个写入的名称数组中存储的蔬菜`SynchronizedCache`实例。 第二个和第三个任务显示蔬菜中 （从低到高的索引的索引） 以降序顺序的第二个升序排序, 的第一个的名称。 最后一项任务搜索字符串"黄瓜"，并当它找到它，将调用<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法要替换的字符串"绿色 bean"。  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已进入读取模式锁定状态的独有线程的总数。</summary>
        <value>已进入读取模式锁定状态的独有线程的数量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 线程只计算一次，即使锁定允许使用递归和线程已进入读取的模式多次。  
  
 仅用于调试、 分析和记录等目的，而不适用于控制算法的行为，请使用此属性。 只要在已计算，可以更改结果。 因此，它是不安全决定根据此属性。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A>属性中读取模式的线程数超过阈值会生成一个事件日志条目。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的当前实例所使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完成使用 <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 后，应调用 <xref:System.Threading.ReaderWriterLockSlim>。 <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 方法使 <xref:System.Threading.ReaderWriterLockSlim> 处于不可用状态。 在调用<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>，必须释放对所有引用<xref:System.Threading.ReaderWriterLockSlim>以便垃圾回收器才能回收的内存，<xref:System.Threading.ReaderWriterLockSlim>占用。 有关详细信息，请参阅[清洗向上非托管资源](~/docs/standard/garbage-collection/unmanaged.md)和[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
> [!NOTE]
>  始终调用<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>在发布到最后一个引用之前<xref:System.Threading.ReaderWriterLockSlim>对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> 大于零。  
  
 或  
  
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> 大于零。  
  
 或  
  
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> 大于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试进入读取模式锁定状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法受到阻止，直到调用线程进入锁定，并因此可能永远不会返回。 使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法指定的间隔时间，阻止，然后返回调用线程不具有已进入读取模式，在此间隔期间。  
  
 多个线程可以在同一时间进入读取的模式。  
  
 如果一个或多个线程在等待进入写入模式，线程的调用<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法受到阻止，直到这些线程操作已超时或已进入写入模式和从它然后退出。  
  
> [!NOTE]
>  如果锁定允许使用递归，线程已进入读取模式锁定可以递归方式进入读取的模式，即使其他线程等待进入写入模式。  
  
 当其他线程处于读取模式时，最多一个线程可以处于进入可升级模式。 如果其他线程正在等待进入可升级模式，且没有等待进入写入模式的线程，线程该调用<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法立即进入读取的模式，不会阻止。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法进入读取模式锁定。 在示例中所示的方法检索与键关联的值。 如果未找到键，由内部引发的异常<xref:System.Collections.Generic.Dictionary%602>允许 terminate 方法。 A`finally`块用于执行<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>方法，从而确保调用方退出读取的模式。  
  
 此代码摘自更大的示例为提供<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">当前线程持有读取锁时将无法获取写入锁。  
  
 或  
  
 <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，并且当前线程在已持有读取锁时已尝试获取读取锁。  
  
 或  
  
 <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，并且当前线程在已持有写入锁时已尝试获取读取锁。  
  
 或  
  
 递归数将超出该计数器的容量。 此限值很大，因此应用程序永远不会遇到此异常。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试进入可升级模式锁定状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法受到阻止，直到调用线程进入锁定，并因此可能永远不会返回。 使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>方法指定的间隔时间，阻止，然后返回如果调用线程在此间隔期间未进入可升级模式。  
  
 当一个线程通常访问受保护的资源时使用进入可升级模式<xref:System.Threading.ReaderWriterLockSlim>在读取模式，但可能需要等待进入写入模式，如果符合特定的条件。 进入可升级模式中的线程可以降级为读取模式，或升级为写入模式。  
  
 只有一个线程可以在任何给定时间进入可升级模式。 如果某个线程处于进入可升级模式，并且有没有线程在等待进入写入模式，任意数量的其他线程可以进入读取的模式，即使有线程在等待进入可升级模式。  
  
 如果一个或多个线程在等待进入写入模式，线程的调用<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法受到阻止，直到这些线程操作已超时或已进入写入模式和从它然后退出。  
  
> [!NOTE]
>  如果锁定允许使用递归，已进入可升级模式锁定的线程可以输入以递归方式进入可升级模式，即使其他线程等待进入写入模式。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法进入可升级模式锁定。 A`finally`块用于执行<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法，从而确保调用方退出可升级模式。  
  
 在示例中所示的方法检索与键关联的值，并将其替换为新值进行比较。 如果值保持不变，该方法将返回状态指示无更改。 它没有值找不到键，插入的键/值对。 如果值已更改，将它更新。 进入可升级模式允许根据需要在不死锁风险的情况下升级读取的锁定的线程。  
  
 该示例使用默认构造函数创建锁，因此不允许递归。 编程<xref:System.Threading.ReaderWriterLockSlim>当锁不允许递归是更简单且更不易出错。  
  
 此代码摘自更大的示例为提供<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入任意模式的锁定状态。  
  
 或  
  
 当前线程已进入读取模式，因此尝试进入可升级模式将有可能导致死锁。  
  
 或  
  
 递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试进入写入模式锁定状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法受到阻止，直到调用线程进入锁定，并因此可能永远不会返回。 使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法指定的间隔时间，阻止，然后返回如果调用线程在此间隔期间未进入写入模式。  
  
 如果其他线程已进入读取模式锁定调用线程<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法受到阻止，直到这些线程均已退出读取模式。 当线程在等待进入写入模式，尝试之前等待进入写入模式的所有线程进入读取的模式或进入可升级模式块的更多线程操作已超时或已进入写入模式和从它然后退出。  
  
> [!NOTE]
>  如果锁定允许使用递归，线程已进入写入模式锁定可以写入递归方式进入模式，即使其他线程等待进入写入模式。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法进入写入模式锁定。 在示例中所示的方法将新的键/值对添加到同步的缓存。 如果密钥已在缓存中，由内部引发的异常<xref:System.Collections.Generic.Dictionary%602>允许 terminate 方法。 A`finally`块用于执行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，从而确保调用方退出写入模式。  
  
 此代码摘自更大的示例为提供<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入任意模式的锁定状态。  
  
 或  
  
 当前线程已进入读取模式，因此尝试进入写入模式锁定状态将有可能导致死锁。  
  
 或  
  
 递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>减少读取模式的递归计数，并在生成的计数为 0（零）时退出读取模式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不是递归顺序对敏感的。 例如，如果一个线程进入可升级模式锁定，然后进入读取模式锁定顺序在线程退出两种模式下的顺序并不重要。 如果锁定允许使用递归，线程可以进入写入模式锁定状态，然后输入密码以递归方式以读取模式;在线程退出在其中的顺序读取模式，写入模式并不重要。  
  
 退出锁可能向其他正在等待的线程的信号。  
  
   
  
## Examples  
 下面的示例演示如何使用`finally`块执行<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>方法，从而确保调用方退出读取的模式。 在示例中所示的方法检索与键关联的值。 如果未找到键，由内部引发的异常<xref:System.Collections.Generic.Dictionary%602>允许 terminate 方法。 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法用于进入读取的模式。  
  
 此代码摘自更大的示例为提供<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">当前线程未进入读取模式锁定状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>减少可升级模式的递归计数，并在生成的计数为 0（零）时退出可升级模式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不是递归顺序对敏感的。 例如，如果一个线程进入可升级模式锁定，然后进入写入模式锁定顺序在线程退出两种模式下的顺序并不重要。 如果锁定允许使用递归，线程可以进入写入模式锁定，然后输入密码以递归方式进入可升级模式; 中在其中在线程退出可升级模式和写入模式的顺序并不重要。  
  
 退出锁可能向其他正在等待的线程的信号。  
  
   
  
## Examples  
 下面的示例演示如何使用`finally`块执行<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法，从而确保调用方退出可升级模式。  
  
 在示例中所示的方法检索与键关联的值，并将其替换为新值进行比较。 如果值保持不变，该方法将返回状态指示无更改。 它没有值找不到键，插入的键/值对。 如果值已更改，将它更新。 进入可升级模式允许根据需要在不死锁风险的情况下升级读取的锁定的线程。  
  
 该示例使用默认构造函数创建锁，因此不允许递归。 编程<xref:System.Threading.ReaderWriterLockSlim>当锁不允许递归是更简单且更不易出错。  
  
 此代码摘自更大的示例为提供<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">当前线程未进入可升级模式锁定状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>减少写入模式的递归计数，并在生成的计数为 0（零）时退出写入模式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不是递归顺序对敏感的。 例如，如果一个线程进入可升级模式锁定，然后进入写入模式锁定顺序在线程退出两种模式下的顺序并不重要。 如果锁定允许使用递归，线程可以进入写入模式锁定状态，然后输入密码以递归方式以读取模式;在线程退出在其中的顺序读取模式，写入模式并不重要。  
  
 退出锁可能向其他正在等待的线程的信号。  
  
   
  
## Examples  
 下面的示例演示如何使用`finally`块执行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，从而确保调用方退出写入模式。 在示例中所示的方法将新的键/值对添加到同步的缓存。 如果密钥已在缓存中，由内部引发的异常<xref:System.Collections.Generic.Dictionary%602>允许 terminate 方法。 <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法用于进入写入模式锁定。  
  
 此代码摘自更大的示例为提供<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">当前线程未进入写入模式锁定状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前线程是否已进入读取模式的锁定状态。</summary>
        <value>
          如果当前线程已进入读取模式，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性被旨在用于断言或其他调试目的。 不要使用它来控制控制程序执行流程。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A>属性生成断言，如果当前线程已进入读取模式意外。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前线程是否已进入可升级模式的锁定状态。</summary>
        <value>
          如果当前线程已进入可升级模式，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性被旨在用于断言或其他调试目的。 不要使用它来控制控制程序执行流程。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A>生成断言，如果当前线程已进入可升级模式意外的属性。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前线程是否已进入写入模式的锁定状态。</summary>
        <value>
          如果当前线程已进入写入模式，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性被旨在用于断言或其他调试目的。 不要使用它来控制控制程序执行流程。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A>生成断言，如果当前线程已进入写入模式意外的属性。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象的递归策略。</summary>
        <value>枚举值之一，用于指定锁定递归策略。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 递归策略将确定在多次输入锁的线程上的限制。 例如，如果使用锁创建了<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>和线程已进入读取模式锁定<xref:System.Threading.LockRecursionException>如果线程尝试重新输入中读取模式锁定，则引发。  
  
> [!NOTE]
>  进入可升级模式中的线程可以升级为写入模式，或降级为读取而不考虑锁定递归策略设置的模式。  
  
 无论递归策略，最初输入线程读取模式下不允许升级到进入可升级模式或写入模式，因为这种方式导致的死锁的概率较强。  
  
 关于递归策略和其效果的详细信息，请参阅<xref:System.Threading.LockRecursionPolicy>枚举和<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前线程进入读取模式锁定状态的次数，用于指示递归。</summary>
        <value>0 （零），如果当前线程没有进入读取模式，它以递归方式，1，如果线程已进入读取的模式但却不进入或*n*如果线程已进入锁定以递归方式*n* -1 次。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅用于调试、 分析和记录等目的，而不适用于控制算法的行为，请使用此属性。 只要在已计算，可以更改结果。 因此，它是不安全决定根据此属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前线程进入可升级模式锁定状态的次数，用于指示递归。</summary>
        <value>如果当前线程没有进入可升级模式，如果线程已进入可升级模式，但没有进入它以递归方式，则为 1 的 0 或*n*如果线程已进入可升级模式以递归方式*n* -1时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅用于调试、 分析和记录等目的，而不适用于控制算法的行为，请使用此属性。 只要在已计算，可以更改结果。 因此，它是不安全决定根据此属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前线程进入写入模式锁定状态的次数，用于指示递归。</summary>
        <value>如果当前线程没有进入写入模式 0，1 如果线程已进入写入模式却不它以递归方式进入，或*n*如果线程已进入写入模式下以递归方式*n* -1 次。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅用于调试、 分析和记录等目的，而不适用于控制算法的行为，请使用此属性。 只要在已计算，可以更改结果。 因此，它是不安全决定根据此属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>尝试进入读取模式锁定状态，可以选择超时时间。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">等待的毫秒数，或为 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)，表示无限期等待。</param>
        <summary>尝试进入读取模式锁定状态，可以选择整数超时时间。</summary>
        <returns>
          如果调用线程已进入读取模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`为 0 （零），此方法检查的锁定状态，并返回`false`立即如果所需的状态不可用。  
  
 多个线程可以在同一时间进入读取的模式。  
  
 如果一个或多个线程在等待进入写入模式，线程的调用<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法阻止，直到这些线程具有是操作已超时或已进入写入模式和从它，然后退出，或直到调用线程的自己的超时间隔过期。  
  
> [!NOTE]
>  如果锁定允许使用递归，线程已进入读取模式锁定可以递归方式进入读取的模式，即使其他线程等待进入写入模式。  
  
 当其他线程处于读取模式时，一个线程可以处于进入可升级模式。 如果其他线程正在等待进入可升级模式，且没有等待进入写入模式的线程，线程该调用<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法立即进入读取的模式，不会阻止。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
 或  
  
 递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 的值为负，但不等于 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，这是唯一允许使用的负值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">等待的间隔；或为 -1 毫秒，表示无限期等待。</param>
        <summary>尝试进入读取模式锁定状态，可以选择超时时间。</summary>
        <returns>
          如果调用线程已进入读取模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`为 0 （零），此方法检查的锁定状态，并返回`false`立即如果所需的状态不可用。  
  
 多个线程可以进入读取模式锁定在同一时间。  
  
 如果一个或多个线程排队等待进入写入模式，线程的调用<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法阻止，直到这些线程具有是操作已超时或已进入写入模式和从它，然后退出，或直到调用线程的自己的超时间隔过期。  
  
> [!NOTE]
>  如果锁定允许使用递归，线程已进入读取模式锁定可以递归方式进入读取的模式，即使其他线程等待进入写入模式。  
  
 当其他线程处于读取模式时，一个线程可以处于进入可升级模式。 如果其他线程正在等待进入可升级模式，且没有等待进入写入模式的线程，线程该调用<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法立即进入读取的模式，不会阻止。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
 或  
  
 递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 的值为负，但不等于 -1 毫秒，这是唯一允许使用的负值。  
  
 或  
  
 <paramref name="timeout" /> 的值大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>尝试进入可升级模式锁定状态，可以选择超时时间。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">等待的毫秒数，或为 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)，表示无限期等待。</param>
        <summary>尝试进入可升级模式锁定状态，可以选择超时时间。</summary>
        <returns>
          如果调用线程已进入可升级模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`为 0 （零），此方法检查的锁定状态，并返回`false`立即如果所需的状态不可用。  
  
 当一个线程通常访问受保护的资源时使用进入可升级模式<xref:System.Threading.ReaderWriterLockSlim>在读取模式，但可能需要等待进入写入模式，如果符合特定的条件。 进入可升级模式中的线程可以升级为写入模式，或降级为读取模式。  
  
 在任何给定时间，只有一个线程可以在进入可升级模式中输入锁。 如果某个线程处于进入可升级模式，并且有没有线程在等待进入写入模式，任意数量的其他线程可以进入读取的模式，即使有线程在等待进入可升级模式。  
  
 如果一个或多个线程在等待进入写入模式，线程的调用<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>方法阻止，直到这些线程具有是操作已超时或已进入写入模式和从它，然后退出，或直到调用线程的自己的超时间隔过期。  
  
> [!NOTE]
>  如果锁定允许使用递归，已进入可升级模式锁定的线程可以输入以递归方式进入可升级模式，即使其他线程等待进入写入模式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
 或  
  
 初始状态下，当前线程进入读取模式锁定状态，因此尝试进入可升级模式将有可能导致死锁。  
  
 或  
  
 递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 的值为负，但不等于 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，这是唯一允许使用的负值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">等待的间隔；或为 -1 毫秒，表示无限期等待。</param>
        <summary>尝试进入可升级模式锁定状态，可以选择超时时间。</summary>
        <returns>
          如果调用线程已进入可升级模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`为 0 （零），此方法检查的锁定状态，并返回`false`立即如果所需的状态不可用。  
  
 当一个线程通常访问保护的资源时使用进入可升级模式<xref:System.Threading.ReaderWriterLockSlim>在读取模式，但可能需要等待进入写入模式，如果符合特定的条件。 进入可升级模式中的线程可以升级为写入模式，或降级为读取模式。  
  
 在任何给定时间，只有一个线程可以在进入可升级模式中输入锁。 如果某个线程处于进入可升级模式，并且有没有线程在等待进入写入模式，任意数量的其他线程可以进入读取的模式，即使有线程在等待进入可升级模式。  
  
 如果一个或多个线程在等待进入写入模式，线程的调用<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>方法阻止，直到这些线程具有是操作已超时或已进入写入模式和从它，然后退出，或直到调用线程的自己的超时间隔过期。  
  
> [!NOTE]
>  如果锁定允许使用递归，已进入可升级模式锁定的线程可以输入以递归方式进入可升级模式，即使其他线程等待进入写入模式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
 或  
  
 初始状态下，当前线程进入读取模式锁定状态，因此尝试进入可升级模式将有可能导致死锁。  
  
 或  
  
 递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 的值为负，但不等于 -1 毫秒，这是唯一允许使用的负值。  
  
 或  
  
 <paramref name="timeout" /> 的值大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>尝试进入写入模式锁定状态，可以选择超时时间。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">等待的毫秒数，或为 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)，表示无限期等待。</param>
        <summary>尝试进入写入模式锁定状态，可以选择超时时间。</summary>
        <returns>
          如果调用线程已进入写入模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`为 0 （零），此方法检查的锁定状态，并返回`false`立即如果所需的状态不可用。  
  
 如果其他线程已进入读取模式锁定调用线程<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法将一直阻塞直到这些线程均已退出读取的模式或超时间隔已过去。 而线程被阻止等待进入写入模式，尝试进入读取的模式或进入可升级模式的其他线程阻塞，直到所有线程正等待进入都写入模式，具有可以操作已超时或已进入都写入模式，然后又从中退出。  
  
> [!NOTE]
>  如果锁定允许使用递归，线程已进入写入模式锁定可以写入递归方式进入模式，即使其他线程等待进入写入模式。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法进入锁定状态在写入模式下，超时时间。在示例中所示的方法将新的键/值对添加到同步的缓存。 如果指定的超时间隔过后线程进入锁之前，该方法返回`false`。 该方法返回`true`如果添加的键/值对。  
  
 如果密钥已在缓存中，由内部引发的异常<xref:System.Collections.Generic.Dictionary%602>允许 terminate 方法。 A`finally`块用于执行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，从而确保调用方退出锁。  
  
 此代码摘自更大的示例为提供<xref:System.Threading.ReaderWriterLockSlim>类。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
 或  
  
 初始状态下，当前线程进入读取模式锁定状态，因此尝试进入写入模式将有可能导致死锁。  
  
 或  
  
 递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 的值为负，但不等于 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，这是唯一允许使用的负值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">等待的间隔；或为 -1 毫秒，表示无限期等待。</param>
        <summary>尝试进入写入模式锁定状态，可以选择超时时间。</summary>
        <returns>
          如果调用线程已进入写入模式，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`为 0 （零），此方法检查的锁定状态，并返回`false`立即如果所需的状态不可用。  
  
 如果其他线程已进入读取模式锁定调用线程<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法将一直阻塞直到这些线程均已退出读取的模式或超时间隔已过去。 而线程被阻止等待进入写入模式，尝试进入读取的模式或进入可升级模式的其他线程阻塞，直到所有线程正等待进入都写入模式，具有可以操作已超时或已进入都写入模式，然后又从中退出。  
  
> [!NOTE]
>  如果锁定允许使用递归，线程已进入写入模式锁定可以写入递归方式进入模式，即使其他线程等待进入写入模式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，而且当前线程已进入锁定状态。  
  
 或  
  
 初始状态下，当前线程进入读取模式锁定状态，因此尝试进入写入模式将有可能导致死锁。  
  
 或  
  
 递归数将超出该计数器的容量。 此限制数值很大，因此任何情况下应用程序都不应遇到此情况。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 的值为负，但不等于 -1 毫秒，这是唯一允许使用的负值。  
  
 或  
  
 <paramref name="timeout" /> 的值大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取等待进入读取模式锁定状态的线程总数。</summary>
        <value>等待进入读取模式的线程总数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅用于调试、 分析和记录等目的，而不适用于控制算法的行为，请使用此属性。 只要在已计算，可以更改结果。 因此，它是不安全决定根据此属性。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A>属性生成一个事件日志条目，如果被阻止，等待进入读取的模式的线程数超过阈值。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取等待进入可升级模式锁定状态的线程总数。</summary>
        <value>等待进入可升级模式的线程总数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅用于调试、 分析和记录等目的，而不适用于控制算法的行为，请使用此属性。 只要在已计算，可以更改结果。 因此，它是不安全决定根据此属性。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A>属性生成一个事件日志条目，如果被阻止，等待进入可升级模式的线程数超过阈值。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取等待进入写入模式锁定状态的线程总数。</summary>
        <value>等待进入写入模式的线程总数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅用于调试、 分析和记录等目的，而不适用于控制算法的行为，请使用此属性。 只要在已计算，可以更改结果。 因此，它是不安全决定根据此属性。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A>属性生成一个事件日志条目，如果被阻止，等待进入写入模式的线程数超过阈值。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>