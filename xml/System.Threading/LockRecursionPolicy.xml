<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="LockRecursionPolicy.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac52aaae222fcf2f023007bf6b87e2bf7c7bb83adaa.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2aaae222fcf2f023007bf6b87e2bf7c7bb83adaa</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.LockRecursionPolicy">
          <source>Specifies whether a lock can be entered multiple times by the same thread.</source>
          <target state="translated">指定同一个线程是否可以多次进入一个锁定状态。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>The default recursion policy depends on the type of lock.</source>
          <target state="translated">默认的递归策略依赖于的锁的类型。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>For the default policy and the precise behavior of lock recursion for any given lock type, see the documentation for the type.</source>
          <target state="translated">默认策略和任何给定的锁类型的锁定递归的确切行为，请参阅该类型的文档。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>For example, the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class does not allow a thread to enter the lock in write mode if it already entered the lock in read mode, regardless of the lock policy setting, in order to reduce the chance of deadlocks.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>类不允许线程进入写入模式的锁定，如果它已进入读取模式锁定，而不考虑锁定策略设置，以减少死锁的机会。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>Currently only one lock uses this enumeration:</source>
          <target state="translated">当前仅一个锁定状态使用此枚举：</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> property.</source>
          <target state="translated">有关更多信息，请参见 <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>The following example shows two exception scenarios, one that depends on the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> setting and one that does not.</source>
          <target state="translated">下面的示例演示两个异常情况，一种依赖于<ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph>设置，另一个没有。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>In the first scenario, the thread enters the lock in read mode and then tries to enter read mode recursively.</source>
          <target state="translated">在第一个方案中，线程进入读取模式锁定并尝试以递归方式进入读取的模式。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is created by using the default constructor, which sets recursion policy to NoRecursion, an exception is thrown.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>创建通过使用默认构造函数，它将递归策略设置为 NoRecursion，会引发异常。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>If SupportsRecursion is used to create the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, no exception is thrown.</source>
          <target state="translated">如果 SupportsRecursion 用于创建<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>，不会引发异常。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>In the second scenario, the thread enters the lock in read mode and then tries to enter the lock in write mode.</source>
          <target state="translated">在第二个方案中，则线程进入读取模式锁定，然后尝试进入写入模式锁定。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown regardless of the lock recursion policy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> 是引发而不考虑锁定递归策略。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.NoRecursion">
          <source>If a thread tries to enter a lock recursively, an exception is thrown.</source>
          <target state="translated">如果线程尝试以递归方式进入锁定状态，将引发异常。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.NoRecursion">
          <source>Some classes may allow certain recursions when this setting is in effect.</source>
          <target state="translated">某些类可能会在此设置生效时允许使用特定的递归方式。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
          <source>A thread can enter a lock recursively.</source>
          <target state="translated">线程可以采用递归方式进入锁定状态。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
          <source>Some classes may restrict this capability.</source>
          <target state="translated">某些类可能会限制此功能。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>