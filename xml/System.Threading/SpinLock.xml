<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="SpinLock.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b857fe3" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2eccf4de-4b1c-4706-8cb3-f46682ccfb72f5bcd330020fac61054fec09791305e50bf0a619.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f5bcd330020fac61054fec09791305e50bf0a619</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b15b8cf0f6dbc1504057c88969d9ef4b790891fe</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/11/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.SpinLock">
          <source>Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.</source>
          <target state="translated">提供一个相互排斥锁基元，在该基元中，尝试获取锁的线程将在重复检查的循环中等待，直至该锁变为可用为止。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>For an example of how to use a Spin Lock, see <bpt id="p1">[</bpt>How to: Use SpinLock for Low-Level Synchronization<ept id="p1">](~/docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)</ept>.</source>
          <target state="translated">有关如何使用旋转锁的示例，请参阅<bpt id="p1">[</bpt>如何： 使用 SpinLock 进行低级别同步<ept id="p1">](~/docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)</ept>。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>Spin locks can be used for leaf-level locks where the object allocation implied by using a <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph>, in size or due to garbage collection pressure, is overly expensive.</source>
          <target state="translated">自旋锁可用于叶级别的锁使用隐含的对象分配<ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph>、 大小或由于垃圾回收压力，消耗过多。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>A spin lock can be useful in to avoid blocking; however, if you expect a significant amount of blocking, you should probably not use spin locks due to excessive spinning.</source>
          <target state="translated">自旋锁可以在若要避免妨碍;但是，如果你预计占用大量的阻止，你可能不应使用自旋锁由于过多的旋转。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>Spinning can be beneficial when locks are fine-grained and large in number (for example, a lock per node in a linked list) and also when lock hold-times are always extremely short.</source>
          <target state="translated">当锁是细粒度的并且大数量 （例如，每个节点在链接列表中的锁） 以及锁保持时间都很短，旋转可能很有利。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>In general, while holding a spin lock, one should avoid any of these actions:</source>
          <target state="translated">一般情况下，同时保留自旋锁，应避免任何这些操作：</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>blocking,</source>
          <target state="translated">阻止，</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>calling anything that itself may block,</source>
          <target state="translated">调用的任何内容本身可能会阻止，</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>holding more than one spin lock at once,</source>
          <target state="translated">同时，保持多个数值调节钮锁</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>making dynamically dispatched calls (interface and virtuals),</source>
          <target state="translated">动态进行调度的调用 （接口和虚方法）</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>making statically dispatched calls into any code one doesn't own, or</source>
          <target state="translated">以静态方式进行调度到一个不拥有任何代码的调用或</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>allocating memory.</source>
          <target state="translated">分配内存。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source><ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> should only be used after you have been determined that doing so will improve an application's performance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> 应仅用于你，这样做可以改进应用程序的性能确定后。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>It is also important to note that <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> is a value type, for performance reasons.</source>
          <target state="translated">还有一点需要注意<ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph>是值类型，出于性能原因。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>For this reason, you must be very careful not to accidentally copy a <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> instance, as the two instances (the original and the copy) would then be completely independent of one another, which would likely lead to erroneous behavior of the application.</source>
          <target state="translated">为此，你必须非常小心，以免意外复制<ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph>实例，如两个实例 （原始和复制），若要完全相互独立的这可能会导致应用程序的错误行为。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> instance must be passed around, it should be passed by reference rather than by value.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph>必须围绕传递实例时，它应按引用而不是按值传递。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>Do not store <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> instances in readonly fields.</source>
          <target state="translated">将不会存储<ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph>readonly 字段中的实例。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>The following example shows how to use a <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph>:</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.SpinLock">
          <source>All members of <ph id="ph1">&lt;see cref="T:System.Threading.SpinLock" /&gt;</ph> are thread-safe and may be used from multiple threads concurrently.</source>
          <target state="translated">所有成员<ph id="ph1">&lt;see cref="T:System.Threading.SpinLock" /&gt;</ph>是线程安全的可从多个线程同时使用。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.#ctor(System.Boolean)">
          <source>Whether to capture and use thread IDs for debugging purposes.</source>
          <target state="translated">是否捕获线程 ID 并将其用于调试目的。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.#ctor(System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.SpinLock" /&gt;</ph> structure with the option to track thread IDs to improve debugging.</source>
          <target state="translated">使用用于跟踪线程 ID 以改善调试的选项初始化 <ph id="ph1">&lt;see cref="T:System.Threading.SpinLock" /&gt;</ph> 结构的新实例。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.#ctor(System.Boolean)">
          <source>The default constructor for <ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> tracks thread ownership.</source>
          <target state="translated">默认构造函数<ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph>跟踪线程所有权。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.#ctor(System.Boolean)">
          <source>The following example demonstrates how a SpinLock may be used.</source>
          <target state="translated">下面的示例演示如何可能使用旋转锁。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source>True if the lock is acquired; otherwise, false.</source>
          <target state="translated">如果已获取锁，则为 true，否则为 false。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source><bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> must be initialized to false prior to calling this method.</source>
          <target state="translated">调用此方法前，必须将 <bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> 初始化为 false。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source>Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> can be examined reliably to determine whether the lock was acquired.</source>
          <target state="translated">采用可靠的方式获取锁，这样，即使在方法调用中发生异常的情况下，都能采用可靠的方式检查 <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> 以确定是否已获取锁。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source><ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> is a non-reentrant lock, meaning that if a thread holds the lock, it is not allowed to enter the lock again.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.SpinLock&gt;</ph> 是一个非可重入锁，这意味着，如果一个线程保持锁定，它不允许重新进入锁定。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source>If thread ownership tracking is enabled (whether it's enabled is available through <ph id="ph1">&lt;xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A&gt;</ph>), an exception will be thrown when a thread tries to re-enter a lock it already holds.</source>
          <target state="translated">如果启用了跟踪的线程所有权 (是否启用它是可通过<ph id="ph1">&lt;xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A&gt;</ph>)，当一个线程尝试重新输入已持有的锁时，将引发异常。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source>However, if thread ownership tracking is disabled, attempting to enter a lock already held will result in deadlock.</source>
          <target state="translated">但是，如果禁用跟踪的线程所有权，则尝试输入已持有的锁将导致死锁。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source>If you call <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> without having first called <ph id="ph2">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph> the internal state of the <ph id="ph3">&lt;xref:System.Threading.SpinLock&gt;</ph> can become corrupted.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph>没有首先调用<ph id="ph2">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>的内部状态<ph id="ph3">&lt;xref:System.Threading.SpinLock&gt;</ph>可能会损坏。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> argument must be initialized to false prior to calling Enter.</source>
          <target state="translated">在调用 Enter 之前，<ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> 参数必须初始化为 false。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Enter(System.Boolean@)">
          <source>Thread ownership tracking is enabled, and the current thread has already acquired this lock.</source>
          <target state="translated">线程所有权跟踪已启用，当前线程已获取此锁定。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="T:System.Threading.SpinLock">
          <source>Releases the lock.</source>
          <target state="translated">释放锁。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Exit">
          <source>Releases the lock.</source>
          <target state="translated">释放锁。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Exit">
          <source>The default overload of <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> provides the same behavior as if calling <ph id="ph2">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> using true as the argument.</source>
          <target state="translated">默认重载<ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph>提供相同的行为就像调用<ph id="ph2">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph>true 使用作为参数。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Exit">
          <source>If you call <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> without having first called <ph id="ph2">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph> the internal state of the <ph id="ph3">&lt;xref:System.Threading.SpinLock&gt;</ph> can become corrupted.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph>没有首先调用<ph id="ph2">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>的内部状态<ph id="ph3">&lt;xref:System.Threading.SpinLock&gt;</ph>可能会损坏。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Exit">
          <source>Thread ownership tracking is enabled, and the current thread is not the owner of this lock.</source>
          <target state="translated">启用线程所有权跟踪，当前线程不是此锁的所有者。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Exit(System.Boolean)">
          <source>A Boolean value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads.</source>
          <target state="translated">一个布尔值，该值指示是否应发出内存界定，以便将退出操作立即发布到其他线程。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Exit(System.Boolean)">
          <source>Releases the lock.</source>
          <target state="translated">释放锁。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Exit(System.Boolean)">
          <source>Calling <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> with the <ph id="ph2">`useMemoryBarrier`</ph> argument set to true will improve the fairness of the lock at the expense of some performance.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph>与<ph id="ph2">`useMemoryBarrier`</ph>设置为 true 将提高这会降低某些性能的锁公平性的自变量。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Exit(System.Boolean)">
          <source>The default <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> overload behaves as if specifying true for <ph id="ph2">`useMemoryBarrier`</ph>.</source>
          <target state="translated">默认值<ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph>重载的行为方式好像指定时为 true， <ph id="ph2">`useMemoryBarrier`</ph>。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.Exit(System.Boolean)">
          <source>If you call <ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> without having first called <ph id="ph2">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph> the internal state of the <ph id="ph3">&lt;xref:System.Threading.SpinLock&gt;</ph> can become corrupted.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph>没有首先调用<ph id="ph2">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>的内部状态<ph id="ph3">&lt;xref:System.Threading.SpinLock&gt;</ph>可能会损坏。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.Exit(System.Boolean)">
          <source>Thread ownership tracking is enabled, and the current thread is not the owner of this lock.</source>
          <target state="translated">启用线程所有权跟踪，当前线程不是此锁的所有者。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="P:System.Threading.SpinLock.IsHeld">
          <source>Gets whether the lock is currently held by any thread.</source>
          <target state="translated">获取锁当前是否已由任何线程占用。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.SpinLock.IsHeld">
          <source>true if the lock is currently held by any thread; otherwise false.</source>
          <target state="translated">如果锁当前已由任何线程占用，则为 true；否则为 false。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="P:System.Threading.SpinLock.IsHeldByCurrentThread">
          <source>Gets whether the lock is held by the current thread.</source>
          <target state="translated">获取锁是否已由当前线程占用。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.SpinLock.IsHeldByCurrentThread">
          <source>true if the lock is held by the current thread; otherwise false.</source>
          <target state="translated">如果锁已由当前线程占用，则为 true；否则为 false。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.SpinLock.IsHeldByCurrentThread">
          <source>If the lock was initialized to track owner threads, this will return whether the lock is acquired by the current thread.</source>
          <target state="translated">如果锁被初始化，以跟踪所有者线程，这将返回当前线程是否已获取锁。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.SpinLock.IsHeldByCurrentThread">
          <source>It is invalid to use this property when the lock was initialized to not track thread ownership.</source>
          <target state="translated">要锁定初始化不跟踪线程所有权时使用此属性无效。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="P:System.Threading.SpinLock.IsHeldByCurrentThread">
          <source>Thread ownership tracking is disabled.</source>
          <target state="translated">禁用线程所有权跟踪。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
          <source>Gets whether thread ownership tracking is enabled for this instance.</source>
          <target state="translated">获取是否已为此实例启用了线程所有权跟踪。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
          <source>true if thread ownership tracking is enabled for this instance; otherwise false.</source>
          <target state="translated">如果已为此实例启用了线程所有权跟踪，则为 true；否则为 false。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="T:System.Threading.SpinLock">
          <source>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> can be examined reliably to determine whether the lock was acquired.</source>
          <target state="translated">尝试采用可靠的方式获取锁，这样，即使在方法调用中发生异常的情况下，都能采用可靠的方式检查  <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> 以确定是否已获取锁。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
          <source>True if the lock is acquired; otherwise, false.</source>
          <target state="translated">如果已获取锁，则为 true，否则为 false。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
          <source><bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> must be initialized to false prior to calling this method.</source>
          <target state="translated">调用此方法前，必须将 <bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> 初始化为 false。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
          <source>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> can be examined reliably to determine whether the lock was acquired.</source>
          <target state="translated">尝试采用可靠的方式获取锁，这样，即使在方法调用中发生异常的情况下，都能采用可靠的方式检查  <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> 以确定是否已获取锁。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
          <source>Unlike <ph id="ph1">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>, TryEnter will not block waiting for the lock to be available.</source>
          <target state="translated">与不同<ph id="ph1">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>，TryEnter 不会阻止等待可用的锁。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
          <source>If the lock is not available when TryEnter is called, it will return immediately without any further spinning.</source>
          <target state="translated">如果在调用 tryenter 时，锁定不可用，则会立即返回而无需任何进一步旋转。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> argument must be initialized to false prior to calling TryEnter.</source>
          <target state="translated">在调用 TryEnter 之前，<ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> 参数必须在初始化为 false。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
          <source>Thread ownership tracking is enabled, and the current thread has already acquired this lock.</source>
          <target state="translated">线程所有权跟踪已启用，当前线程已获取此锁定。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">等待的毫秒数，或为 <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1)，表示无限期等待。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source>True if the lock is acquired; otherwise, false.</source>
          <target state="translated">如果已获取锁，则为 true，否则为 false。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source><bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> must be initialized to false prior to calling this method.</source>
          <target state="translated">调用此方法前，必须将 <bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> 初始化为 false。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> can be examined reliably to determine whether the lock was acquired.</source>
          <target state="translated">尝试采用可靠的方式获取锁，这样，即使在方法调用中发生异常的情况下，都能采用可靠的方式检查  <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> 以确定是否已获取锁。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source>Unlike <ph id="ph1">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>, TryEnter will not block indefinitely waiting for the lock to be available.</source>
          <target state="translated">与不同<ph id="ph1">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>，TryEnter 不会阻止无限期地等待锁可用。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source>It will block until either the lock is available or until the <ph id="ph1">`millisecondsTimeout`</ph> has expired.</source>
          <target state="translated">它将阻止任一锁可用之前，或者直到<ph id="ph1">`millisecondsTimeout`</ph>已过期。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> 是一个非 -1 的负数，而 -1 表示无限期超时。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> argument must be initialized to false prior to calling TryEnter.</source>
          <target state="translated">在调用 TryEnter 之前，<ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> 参数必须在初始化为 false。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
          <source>Thread ownership tracking is enabled, and the current thread has already acquired this lock.</source>
          <target state="translated">线程所有权跟踪已启用，当前线程已获取此锁定。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">表示等待毫秒数的 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph>，或表示 -1 毫秒（无限期等待）的 <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source>True if the lock is acquired; otherwise, false.</source>
          <target state="translated">如果已获取锁，则为 true，否则为 false。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source><bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> must be initialized to false prior to calling this method.</source>
          <target state="translated">调用此方法前，必须将 <bpt id="p1">&lt;c&gt;</bpt>lockTaken<ept id="p1">&lt;/c&gt;</ept> 初始化为 false。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> can be examined reliably to determine whether the lock was acquired.</source>
          <target state="translated">尝试采用可靠的方式获取锁，这样，即使在方法调用中发生异常的情况下，都能采用可靠的方式检查  <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> 以确定是否已获取锁。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source>Unlike <ph id="ph1">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>, TryEnter will not block indefinitely waiting for the lock to be available.</source>
          <target state="translated">与不同<ph id="ph1">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>，TryEnter 不会阻止无限期地等待锁可用。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source>It will block until either the lock is available or until the <ph id="ph1">`timeout`</ph> has expired.</source>
          <target state="translated">它将阻止任一锁可用之前，或者直到<ph id="ph1">`timeout`</ph>已过期。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 是 -1 毫秒之外的负数，表示无限超时或者超时大于 <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> 毫秒。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> argument must be initialized to false prior to calling TryEnter.</source>
          <target state="translated">在调用 TryEnter 之前，<ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> 参数必须在初始化为 false。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
          <source>Thread ownership tracking is enabled, and the current thread has already acquired this lock.</source>
          <target state="translated">线程所有权跟踪已启用，当前线程已获取此锁定。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>