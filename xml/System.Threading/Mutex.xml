<Type Name="Mutex" FullName="System.Threading.Mutex">
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="98e7d-101">一个同步基元，也可用于进程间同步。</span><span class="sxs-lookup"><span data-stu-id="98e7d-101">A synchronization primitive that can also be used for interprocess synchronization.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98e7d-102">当两个或多个线程需要进行在同一时间访问共享的资源时，系统将需要使用同步机制来确保一次只有一个线程使用的资源。</span><span class="sxs-lookup"><span data-stu-id="98e7d-102">When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.</span></span> <span data-ttu-id="98e7d-103"><xref:System.Threading.Mutex> 是一个同步基元，授予对共享资源只有一个线程的独占访问权。</span><span class="sxs-lookup"><span data-stu-id="98e7d-103"><xref:System.Threading.Mutex> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.</span></span> <span data-ttu-id="98e7d-104">如果线程获取互斥体，想要获取该互斥体的第二个线程则挂起，直到第一个线程释放互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-104">If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="98e7d-105">此类型实现<xref:System.IDisposable>接口。</span><span class="sxs-lookup"><span data-stu-id="98e7d-105">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="98e7d-106">在使用完类型后，您应直接或间接释放类型。</span><span class="sxs-lookup"><span data-stu-id="98e7d-106">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="98e7d-107">若要直接释放类型，调用其<xref:System.IDisposable.Dispose%2A>中的方法`try` / `catch`块。</span><span class="sxs-lookup"><span data-stu-id="98e7d-107">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="98e7d-108">若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。</span><span class="sxs-lookup"><span data-stu-id="98e7d-108">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="98e7d-109">有关详细信息，请参阅中的"使用实现 IDisposable 的对象"部分<xref:System.IDisposable>接口主题。</span><span class="sxs-lookup"><span data-stu-id="98e7d-109">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="98e7d-110">你可以使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>请求所有权的互斥体的方法。</span><span class="sxs-lookup"><span data-stu-id="98e7d-110">You can use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method to request ownership of a mutex.</span></span> <span data-ttu-id="98e7d-111">调用线程受到阻止，直到出现以下之一：</span><span class="sxs-lookup"><span data-stu-id="98e7d-111">The calling thread blocks until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="98e7d-112">互斥体处于有信号状态，以指示它不拥有。</span><span class="sxs-lookup"><span data-stu-id="98e7d-112">The mutex is signaled to indicate that it is not owned.</span></span> <span data-ttu-id="98e7d-113">在此情况下，<xref:System.Threading.WaitHandle.WaitOne%2A>方法返回`true`，调用线程互斥体的所有权，并访问受互斥体的资源。</span><span class="sxs-lookup"><span data-stu-id="98e7d-113">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true`, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.</span></span> <span data-ttu-id="98e7d-114">线程完成后访问资源，必须调用<xref:System.Threading.Mutex.ReleaseMutex%2A>方法来释放互斥体的所有权。</span><span class="sxs-lookup"><span data-stu-id="98e7d-114">When it has finished accessing the resource, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the mutex.</span></span> <span data-ttu-id="98e7d-115">示例部分中的第一个示例说明了此模式。</span><span class="sxs-lookup"><span data-stu-id="98e7d-115">The first example in the Examples section illustrates this pattern.</span></span>  
  
-   <span data-ttu-id="98e7d-116">对的调用中指定的超时间隔<xref:System.Threading.WaitHandle.WaitOne%2A>方法具有`millisecondsTimeout`或`timeout`参数已过。</span><span class="sxs-lookup"><span data-stu-id="98e7d-116">The time-out interval specified in the call to a <xref:System.Threading.WaitHandle.WaitOne%2A> method that has a `millisecondsTimeout` or `timeout` parameter has elapsed.</span></span> <span data-ttu-id="98e7d-117">在此情况下，<xref:System.Threading.WaitHandle.WaitOne%2A>方法返回`false`，并调用线程进行任何进一步尝试获取互斥体的所有权。</span><span class="sxs-lookup"><span data-stu-id="98e7d-117">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `false`, and the calling thread makes no further attempt to acquire ownership of the mutex.</span></span> <span data-ttu-id="98e7d-118">在这种情况下，应构建代码，以便对调用线程由 mutex 保护的资源的访问被拒绝。</span><span class="sxs-lookup"><span data-stu-id="98e7d-118">In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.</span></span> <span data-ttu-id="98e7d-119">线程永远不会获取互斥体的所有权，因为它不能调用<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="98e7d-119">Because the thread never acquired ownership of the mutex, it must not call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span> <span data-ttu-id="98e7d-120">示例部分中的第二个示例说明了此模式。</span><span class="sxs-lookup"><span data-stu-id="98e7d-120">The second example in the Examples section illustrates this pattern.</span></span>  
  
 <span data-ttu-id="98e7d-121"><xref:System.Threading.Mutex>类强制线程标识，因此只能由获得它的线程可以释放互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-121">The <xref:System.Threading.Mutex> class enforces thread identity, so a mutex can be released only by the thread that acquired it.</span></span> <span data-ttu-id="98e7d-122">与此相反，<xref:System.Threading.Semaphore>类不会强制线程标识。</span><span class="sxs-lookup"><span data-stu-id="98e7d-122">By contrast, the <xref:System.Threading.Semaphore> class does not enforce thread identity.</span></span> <span data-ttu-id="98e7d-123">此外可以跨应用程序域边界传递互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-123">A mutex can also be passed across application domain boundaries.</span></span>  
  
 <span data-ttu-id="98e7d-124">拥有互斥体的线程可以请求中重复调用相同的互斥体<xref:System.Threading.WaitHandle.WaitOne%2A>而不会阻止其执行。</span><span class="sxs-lookup"><span data-stu-id="98e7d-124">The thread that owns a mutex can request the same mutex in repeated calls to <xref:System.Threading.WaitHandle.WaitOne%2A> without blocking its execution.</span></span> <span data-ttu-id="98e7d-125">但是，调用线程必须<xref:System.Threading.Mutex.ReleaseMutex%2A>方法相同数量的次数以释放互斥体的所有权。</span><span class="sxs-lookup"><span data-stu-id="98e7d-125">However, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="98e7d-126">因为<xref:System.Threading.Mutex>类继承自<xref:System.Threading.WaitHandle>，你还可以调用静态<xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>和<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>方法对受保护资源的访问进行同步。</span><span class="sxs-lookup"><span data-stu-id="98e7d-126">Because the <xref:System.Threading.Mutex> class inherits from <xref:System.Threading.WaitHandle>, you can also call the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods to synchronize access to a protected resource.</span></span>  
  
 <span data-ttu-id="98e7d-127">如果某个线程终止时拥有互斥体，则认为该 mutex 来放弃。</span><span class="sxs-lookup"><span data-stu-id="98e7d-127">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="98e7d-128">互斥体的状态设置为终止状态，并且下一步正在等待的线程获取所有权。</span><span class="sxs-lookup"><span data-stu-id="98e7d-128">The state of the mutex is set to signaled, and the next waiting thread gets ownership.</span></span> <span data-ttu-id="98e7d-129">从 2.0 版.NET Framework 中，开始<xref:System.Threading.AbandonedMutexException>获取放弃的 mutex 的下一个线程中引发。</span><span class="sxs-lookup"><span data-stu-id="98e7d-129">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the abandoned mutex.</span></span> <span data-ttu-id="98e7d-130">在.NET Framework 2.0 版中之前, 没有引发异常。</span><span class="sxs-lookup"><span data-stu-id="98e7d-130">Before version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="98e7d-131">放弃的 mutex 通常表明代码中的存在严重错误。</span><span class="sxs-lookup"><span data-stu-id="98e7d-131">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="98e7d-132">如果一个线程退出时不释放互斥体，由 mutex 保护的数据结构可能不处于一致状态。</span><span class="sxs-lookup"><span data-stu-id="98e7d-132">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="98e7d-133">下一个请求 mutex 所有权的线程可以处理此异常并继续操作，如果可以验证这些数据结构的完整性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-133">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="98e7d-134">对于系统范围的 mutex，放弃的 mutex 可能指示应用程序已突然终止（例如，通过使用 Windows 任务管理器终止）。</span><span class="sxs-lookup"><span data-stu-id="98e7d-134">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
 <span data-ttu-id="98e7d-135">互斥体，有两种类型： 局部互斥，是未命名的且名为系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-135">Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.</span></span> <span data-ttu-id="98e7d-136">本地 mutex 仅存在于进程中。</span><span class="sxs-lookup"><span data-stu-id="98e7d-136">A local mutex exists only within your process.</span></span> <span data-ttu-id="98e7d-137">它可供你具有对引用的过程中的任何线程<xref:System.Threading.Mutex>表示互斥体的对象。</span><span class="sxs-lookup"><span data-stu-id="98e7d-137">It can be used by any thread in your process that has a reference to the <xref:System.Threading.Mutex> object that represents the mutex.</span></span> <span data-ttu-id="98e7d-138">每个未命名<xref:System.Threading.Mutex>对象表示单独的局部互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-138">Each unnamed <xref:System.Threading.Mutex> object represents a separate local mutex.</span></span>  
  
 <span data-ttu-id="98e7d-139">已命名的系统互斥体，可以看到在整个操作系统，也可用于同步进程的活动。</span><span class="sxs-lookup"><span data-stu-id="98e7d-139">Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="98e7d-140">你可以创建<xref:System.Threading.Mutex>表示已命名的系统互斥体通过接受的名称的构造函数的对象。</span><span class="sxs-lookup"><span data-stu-id="98e7d-140">You can create a <xref:System.Threading.Mutex> object that represents a named system mutex by using a constructor that accepts a name.</span></span> <span data-ttu-id="98e7d-141">可以在同一时间，创建该操作系统对象，或它可以在创建之前存在<xref:System.Threading.Mutex>对象。</span><span class="sxs-lookup"><span data-stu-id="98e7d-141">The operating-system object can be created at the same time, or it can exist before the creation of the <xref:System.Threading.Mutex> object.</span></span> <span data-ttu-id="98e7d-142">可以创建多个表示同一命名系统 mutex 的 <xref:System.Threading.Mutex> 对象，还能使用 <xref:System.Threading.Mutex.OpenExisting%2A> 方法打开现有的命名系统 mutex。</span><span class="sxs-lookup"><span data-stu-id="98e7d-142">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex, and you can use the <xref:System.Threading.Mutex.OpenExisting%2A> method to open an existing named system mutex.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="98e7d-143">运行终端服务的服务器，请在已命名的系统互斥体可以包含两个级别的可见性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-143">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="98e7d-144">如果其名称以前缀"全局\\"，互斥体是在所有终端服务器会话中可见。</span><span class="sxs-lookup"><span data-stu-id="98e7d-144">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="98e7d-145">如果其名称以前缀"本地\\"，互斥体是仅在终端服务器会话中可见则创建它。</span><span class="sxs-lookup"><span data-stu-id="98e7d-145">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="98e7d-146">在这种情况下，具有相同名称的单独 mutex 可以存在于每个服务器上的其他终端服务器会话。</span><span class="sxs-lookup"><span data-stu-id="98e7d-146">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="98e7d-147">如果你创建命名互斥体时，你不会指定前缀，它将前缀"本地\\"。</span><span class="sxs-lookup"><span data-stu-id="98e7d-147">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="98e7d-148">终端服务器会话中，其名称只是其前缀不同的两个互斥体是单独的互斥体，且都是可见的所有进程在终端服务器会话中。</span><span class="sxs-lookup"><span data-stu-id="98e7d-148">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="98e7d-149">也就是说，前缀名称"全局\\"和"本地\\"描述相对于终端服务器会话、 不相对于进程的互斥体名称的作用域。</span><span class="sxs-lookup"><span data-stu-id="98e7d-149">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 <span data-ttu-id="98e7d-150">此示例演示如何本地<xref:System.Threading.Mutex>对象用于对受保护资源的访问进行同步。</span><span class="sxs-lookup"><span data-stu-id="98e7d-150">This example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="98e7d-151">因为每个调用线程已被阻止，直到它将获取互斥体的所有权，则必须调用<xref:System.Threading.Mutex.ReleaseMutex%2A>方法来释放线程的所有权。</span><span class="sxs-lookup"><span data-stu-id="98e7d-151">Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the thread.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="98e7d-152">在以下示例中，每个线程调用<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29>方法以获取互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-152">In the following example, each thread calls the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> method to acquire the mutex.</span></span> <span data-ttu-id="98e7d-153">如果达到超时间隔，该方法返回`false`，和线程既不获取互斥体也不获取互斥锁保护的资源的访问权限。</span><span class="sxs-lookup"><span data-stu-id="98e7d-153">If the time-out interval elapses, the method returns `false`, and the thread neither acquires the mutex nor gains access to the resource the mutex protects.</span></span> <span data-ttu-id="98e7d-154"><xref:System.Threading.Mutex.ReleaseMutex%2A>只能由获取互斥体的线程调用方法。</span><span class="sxs-lookup"><span data-stu-id="98e7d-154">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is called only by the thread that acquires the mutex.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="98e7d-155">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="98e7d-155">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="98e7d-156">初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="98e7d-156">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="98e7d-157">使用默认属性初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="98e7d-157">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with default properties.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98e7d-158">调用此构造函数重载是调用相同<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>构造函数重载并指定`false`的互斥体的初始所有权。</span><span class="sxs-lookup"><span data-stu-id="98e7d-158">Calling this constructor overload is the same as calling the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor overload and specifying `false` for initial ownership of the mutex.</span></span> <span data-ttu-id="98e7d-159">也就是说，调用线程不拥有互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-159">That is, the calling thread does not own the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98e7d-160">下面的代码示例演示如何本地<xref:System.Threading.Mutex>对象用于对受保护资源的访问进行同步。</span><span class="sxs-lookup"><span data-stu-id="98e7d-160">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="98e7d-161">创建互斥体的线程不最初拥有其信息。</span><span class="sxs-lookup"><span data-stu-id="98e7d-161">The thread that creates the mutex does not own it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="98e7d-162">如果给调用线程赋予互斥体的初始所属权，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-162"><see langword="true" /> to give the calling thread initial ownership of the mutex; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="98e7d-163">使用 Boolean 值（指示调用线程是否应具有互斥体的初始所有权）初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="98e7d-163">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="98e7d-164">下面的代码示例演示如何本地<xref:System.Threading.Mutex>对象用于对受保护资源的访问进行同步。</span><span class="sxs-lookup"><span data-stu-id="98e7d-164">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="98e7d-165">创建的线程<xref:System.Threading.Mutex>最初拥有它。</span><span class="sxs-lookup"><span data-stu-id="98e7d-165">The thread that creates the <xref:System.Threading.Mutex> owns it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="98e7d-166">如果为 <see langword="true" />，则给予调用线程已命名的系统互斥体的初始所属权（如果已命名的系统互斥体是通过此调用创建的）；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-166"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="98e7d-167"><see cref="T:System.Threading.Mutex" /> 的名称。</span><span class="sxs-lookup"><span data-stu-id="98e7d-167">The name of the <see cref="T:System.Threading.Mutex" />.</span></span> <span data-ttu-id="98e7d-168">如果值为 <see langword="null" />，则 <see cref="T:System.Threading.Mutex" /> 是未命名的。</span><span class="sxs-lookup"><span data-stu-id="98e7d-168">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span></span></param>
        <summary><span data-ttu-id="98e7d-169">使用 Boolean 值（指示调用线程是否应具有互斥体的初始所有权以及字符串是否为互斥体的名称）初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="98e7d-169">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98e7d-170">如果`name`不`null`和`initiallyOwned`是`true`，调用线程拥有互斥体，仅当已命名的系统互斥体通过此调用创建。</span><span class="sxs-lookup"><span data-stu-id="98e7d-170">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the mutex only if the named system mutex was created as a result of this call.</span></span> <span data-ttu-id="98e7d-171">由于没有任何机制可确定是否已创建的已命名的系统互斥体，它是更好的做法指定`false`为`initiallyOwned`时调用此构造函数重载。</span><span class="sxs-lookup"><span data-stu-id="98e7d-171">Since there is no mechanism for determining whether the named system mutex was created, it is better to specify `false` for `initiallyOwned` when calling this constructor overload.</span></span> <span data-ttu-id="98e7d-172">你可以使用<xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29>构造函数，如果你需要确定初始所属权。</span><span class="sxs-lookup"><span data-stu-id="98e7d-172">You can use the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor if you need to determine initial ownership.</span></span>  
  
 <span data-ttu-id="98e7d-173">此构造函数初始化<xref:System.Threading.Mutex>对象，表示已命名的系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-173">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="98e7d-174">你可以创建多个<xref:System.Threading.Mutex>对象来表示同一个已命名系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-174">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="98e7d-175">如果命名互斥体已创建具有访问控制安全性，并且调用方没有<xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="98e7d-175">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="98e7d-176">若要打开现有的已命名互斥体，具有所需的同步线程活动，这些权限，请参阅<xref:System.Threading.Mutex.OpenExisting%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="98e7d-176">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="98e7d-177">如果指定`null`或为空字符串`name`，创建了局部互斥体，就像已调用<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>构造函数。</span><span class="sxs-lookup"><span data-stu-id="98e7d-177">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="98e7d-178">在这种情况下，`createdNew`始终`true`。</span><span class="sxs-lookup"><span data-stu-id="98e7d-178">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="98e7d-179">因为它们是系统范围内，则可以使用已命名的互斥来协调跨进程边界资源使用。</span><span class="sxs-lookup"><span data-stu-id="98e7d-179">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="98e7d-180">运行终端服务的服务器，请在已命名的系统互斥体可以包含两个级别的可见性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-180">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="98e7d-181">如果其名称以前缀"全局\\"，互斥体是在所有终端服务器会话中可见。</span><span class="sxs-lookup"><span data-stu-id="98e7d-181">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="98e7d-182">如果其名称以前缀"本地\\"，互斥体是仅在终端服务器会话中可见则创建它。</span><span class="sxs-lookup"><span data-stu-id="98e7d-182">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="98e7d-183">在这种情况下，具有相同名称的单独 mutex 可以存在于每个服务器上的其他终端服务器会话。</span><span class="sxs-lookup"><span data-stu-id="98e7d-183">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="98e7d-184">如果你创建命名互斥体时，你不会指定前缀，它将前缀"本地\\"。</span><span class="sxs-lookup"><span data-stu-id="98e7d-184">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="98e7d-185">终端服务器会话中，其名称只是其前缀不同的两个互斥体是单独的互斥体，且都是可见的所有进程在终端服务器会话中。</span><span class="sxs-lookup"><span data-stu-id="98e7d-185">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="98e7d-186">也就是说，前缀名称"全局\\"和"本地\\"描述相对于终端服务器会话、 不相对于进程的互斥体名称的作用域。</span><span class="sxs-lookup"><span data-stu-id="98e7d-186">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 <span data-ttu-id="98e7d-187">下面的示例演示如何使用命名的互斥体之间在两个单独的进程中运行的线程发出信号。</span><span class="sxs-lookup"><span data-stu-id="98e7d-187">The following example shows how a named mutex is used to signal between threads running in two separate processes.</span></span>  
  
 <span data-ttu-id="98e7d-188">从两个或多个命令窗口中运行此程序。</span><span class="sxs-lookup"><span data-stu-id="98e7d-188">Run this program from two or more command windows.</span></span> <span data-ttu-id="98e7d-189">每个进程创建<xref:System.Threading.Mutex>对象，表示已命名的互斥体`MyMutex`。</span><span class="sxs-lookup"><span data-stu-id="98e7d-189">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex `MyMutex`.</span></span> <span data-ttu-id="98e7d-190">命名的互斥体是系统对象的生存期受限制其生存期<xref:System.Threading.Mutex>其表示的对象。</span><span class="sxs-lookup"><span data-stu-id="98e7d-190">The named mutex is a system object whose lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="98e7d-191">第一个过程将创建时创建命名互斥体其<xref:System.Threading.Mutex>对象; 在此示例中，命名的互斥体拥有的第一个运行该程序的进程。</span><span class="sxs-lookup"><span data-stu-id="98e7d-191">The named mutex is created when the first process creates its <xref:System.Threading.Mutex> object; in this example, the named mutex is owned by the first process that runs the program.</span></span> <span data-ttu-id="98e7d-192">销毁命名互斥体时所有<xref:System.Threading.Mutex>已发布其表示的对象。</span><span class="sxs-lookup"><span data-stu-id="98e7d-192">The named mutex is destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span>  
  
 <span data-ttu-id="98e7d-193">此示例中使用的构造函数重载无法告知调用线程已命名的互斥体的初始所属权是否已授予。</span><span class="sxs-lookup"><span data-stu-id="98e7d-193">The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted.</span></span> <span data-ttu-id="98e7d-194">不应使用此构造函数来请求初始所属权，除非可以确保线程将创建命名互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-194">You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="98e7d-195">命名互斥体存在且具有访问控制安全性，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-195">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="98e7d-196">出现 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="98e7d-196">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="98e7d-197">无法创建命名互斥体，可能是由于其他类型的等待句柄具有相同名称。</span><span class="sxs-lookup"><span data-stu-id="98e7d-197">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98e7d-198"><paramref name="name" /> 超过 260 个字符。</span><span class="sxs-lookup"><span data-stu-id="98e7d-198"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="98e7d-199">需要完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="98e7d-199">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="98e7d-200">此成员不能由部分受信任或不透明的代码。</span><span class="sxs-lookup"><span data-stu-id="98e7d-200">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="98e7d-201">如果为 <see langword="true" />，则给予调用线程已命名的系统互斥体的初始所属权（如果已命名的系统互斥体是通过此调用创建的）；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-201"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="98e7d-202"><see cref="T:System.Threading.Mutex" /> 的名称。</span><span class="sxs-lookup"><span data-stu-id="98e7d-202">The name of the <see cref="T:System.Threading.Mutex" />.</span></span> <span data-ttu-id="98e7d-203">如果值为 <see langword="null" />，则 <see cref="T:System.Threading.Mutex" /> 是未命名的。</span><span class="sxs-lookup"><span data-stu-id="98e7d-203">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span></span></param>
        <param name="createdNew"><span data-ttu-id="98e7d-204">在此方法返回时，如果创建了本地互斥体（即，如果 <c>name</c> 为 <see langword="null" /> 或空字符串）或指定的已命名系统互斥体，则包含布尔值 <see langword="true" />；如果指定的已命名系统互斥体已存在，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-204">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span></span> <span data-ttu-id="98e7d-205">此参数未经初始化即被传递。</span><span class="sxs-lookup"><span data-stu-id="98e7d-205">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="98e7d-206">使用可指示调用线程是否应具有互斥体的初始所有权以及字符串是否为互斥体的名称的 Boolean 值和当线程返回时可指示调用线程是否已赋予互斥体的初始所有权的 Boolean 值初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="98e7d-206">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98e7d-207">如果`name`不`null`和`initiallyOwned`是`true`，调用线程拥有命名互斥体才`createdNew`是`true`后调用。</span><span class="sxs-lookup"><span data-stu-id="98e7d-207">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="98e7d-208">否则，线程可以通过调用请求互斥体<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="98e7d-208">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="98e7d-209">此构造函数初始化<xref:System.Threading.Mutex>对象，表示已命名的系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-209">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="98e7d-210">你可以创建多个<xref:System.Threading.Mutex>对象来表示同一个已命名系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-210">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="98e7d-211">如果命名互斥体已创建具有访问控制安全性，并且调用方没有<xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>权限，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="98e7d-211">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> rights, an exception is thrown.</span></span> <span data-ttu-id="98e7d-212">若要打开现有的已命名互斥体，具有所需的同步线程活动，这些权限，请参阅<xref:System.Threading.Mutex.OpenExisting%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="98e7d-212">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="98e7d-213">如果指定`null`或为空字符串`name`，创建了局部互斥体，就像已调用<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>构造函数。</span><span class="sxs-lookup"><span data-stu-id="98e7d-213">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="98e7d-214">在这种情况下，`createdNew`始终`true`。</span><span class="sxs-lookup"><span data-stu-id="98e7d-214">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="98e7d-215">因为它们是系统范围内，则可以使用已命名的互斥来协调跨进程边界资源使用。</span><span class="sxs-lookup"><span data-stu-id="98e7d-215">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="98e7d-216">运行终端服务的服务器，请在已命名的系统互斥体可以包含两个级别的可见性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-216">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="98e7d-217">如果其名称以前缀"全局\\"，互斥体是在所有终端服务器会话中可见。</span><span class="sxs-lookup"><span data-stu-id="98e7d-217">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="98e7d-218">如果其名称以前缀"本地\\"，互斥体是仅在终端服务器会话中可见则创建它。</span><span class="sxs-lookup"><span data-stu-id="98e7d-218">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="98e7d-219">在这种情况下，具有相同名称的单独 mutex 可以存在于每个服务器上的其他终端服务器会话。</span><span class="sxs-lookup"><span data-stu-id="98e7d-219">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="98e7d-220">如果你创建命名互斥体时，你不会指定前缀，它将前缀"本地\\"。</span><span class="sxs-lookup"><span data-stu-id="98e7d-220">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="98e7d-221">终端服务器会话中，其名称只是其前缀不同的两个互斥体是单独的互斥体，且都是可见的所有进程在终端服务器会话中。</span><span class="sxs-lookup"><span data-stu-id="98e7d-221">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="98e7d-222">也就是说，前缀名称"全局\\"和"本地\\"描述相对于终端服务器会话、 不相对于进程的互斥体名称的作用域。</span><span class="sxs-lookup"><span data-stu-id="98e7d-222">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 <span data-ttu-id="98e7d-223">下面的代码示例演示如何使用命名的互斥体之间进程或线程发出信号。</span><span class="sxs-lookup"><span data-stu-id="98e7d-223">The following code example shows how a named mutex is used to signal between processes or threads.</span></span> <span data-ttu-id="98e7d-224">从两个或多个命令窗口中运行此程序。</span><span class="sxs-lookup"><span data-stu-id="98e7d-224">Run this program from two or more command windows.</span></span> <span data-ttu-id="98e7d-225">每个进程创建<xref:System.Threading.Mutex>表示命名互斥体"MyMutex"的对象。</span><span class="sxs-lookup"><span data-stu-id="98e7d-225">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex "MyMutex".</span></span> <span data-ttu-id="98e7d-226">命名的互斥体是系统对象。</span><span class="sxs-lookup"><span data-stu-id="98e7d-226">The named mutex is a system object.</span></span> <span data-ttu-id="98e7d-227">在此示例中，其生存期由的生存期<xref:System.Threading.Mutex>其表示的对象。</span><span class="sxs-lookup"><span data-stu-id="98e7d-227">In this example, its lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="98e7d-228">第一个过程将创建其局部变量时创建命名互斥体<xref:System.Threading.Mutex>对象，并销毁时所有<xref:System.Threading.Mutex>已发布其表示的对象。</span><span class="sxs-lookup"><span data-stu-id="98e7d-228">The named mutex is created when the first process creates its local <xref:System.Threading.Mutex> object, and destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span> <span data-ttu-id="98e7d-229">命名的互斥体最初属于第一个过程。</span><span class="sxs-lookup"><span data-stu-id="98e7d-229">The named mutex is initially owned by the first process.</span></span> <span data-ttu-id="98e7d-230">第二个过程和任何后续进程等待前面的进程释放命名的互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-230">The second process and any subsequent processes wait for earlier processes to release the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="98e7d-231">命名互斥体存在且具有访问控制安全性，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-231">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="98e7d-232">出现 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="98e7d-232">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="98e7d-233">无法创建命名互斥体，可能是由于其他类型的等待句柄具有相同名称。</span><span class="sxs-lookup"><span data-stu-id="98e7d-233">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98e7d-234"><paramref name="name" /> 超过 260 个字符。</span><span class="sxs-lookup"><span data-stu-id="98e7d-234"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="98e7d-235">需要完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="98e7d-235">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="98e7d-236">此成员不能由部分受信任或不透明的代码。</span><span class="sxs-lookup"><span data-stu-id="98e7d-236">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="98e7d-237">如果为 <see langword="true" />，则给予调用线程已命名的系统互斥体的初始所属权（如果已命名的系统互斥体是通过此调用创建的）；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-237"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="98e7d-238">系统互斥体的名称。</span><span class="sxs-lookup"><span data-stu-id="98e7d-238">The name of the system mutex.</span></span> <span data-ttu-id="98e7d-239">如果值为 <see langword="null" />，则 <see cref="T:System.Threading.Mutex" /> 是未命名的。</span><span class="sxs-lookup"><span data-stu-id="98e7d-239">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span></span></param>
        <param name="createdNew"><span data-ttu-id="98e7d-240">在此方法返回时，如果创建了本地互斥体（即，如果 <c>name</c> 为 <see langword="null" /> 或空字符串）或指定的已命名系统互斥体，则包含布尔值 <see langword="true" />；如果指定的已命名系统互斥体已存在，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-240">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span></span> <span data-ttu-id="98e7d-241">此参数未经初始化即被传递。</span><span class="sxs-lookup"><span data-stu-id="98e7d-241">This parameter is passed uninitialized.</span></span></param>
        <param name="mutexSecurity"><span data-ttu-id="98e7d-242">一个 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 对象，表示应用于已命名的系统互斥体的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-242">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span></span></param>
        <summary><span data-ttu-id="98e7d-243">使用可指示调用线程是否应具有互斥体的初始所有权以及字符串是否为互斥体的名称的 Boolean 值和当线程返回时可指示调用线程是否已赋予互斥体的初始所有权以及访问控制安全是否已应用到命名互斥体的 Boolean 变量初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="98e7d-243">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98e7d-244">如果`name`不`null`和`initiallyOwned`是`true`，调用线程拥有命名互斥体才`createdNew`是`true`后调用。</span><span class="sxs-lookup"><span data-stu-id="98e7d-244">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="98e7d-245">否则，线程可以通过调用请求互斥体<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="98e7d-245">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="98e7d-246">使用此构造函数要应用于已命名的系统互斥体的访问控制安全性，创建时，阻止其他代码的互斥体的控制。</span><span class="sxs-lookup"><span data-stu-id="98e7d-246">Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.</span></span>  
  
 <span data-ttu-id="98e7d-247">此构造函数初始化<xref:System.Threading.Mutex>对象，表示已命名的系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-247">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="98e7d-248">你可以创建多个<xref:System.Threading.Mutex>对象来表示同一个已命名系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-248">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="98e7d-249">如果已命名的系统互斥体不存在，它被创建具有指定的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-249">If the named system mutex does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="98e7d-250">如果命名互斥体存在，则忽略指定的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-250">If the named mutex exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="98e7d-251">调用方具有对新创建的完全控制<xref:System.Threading.Mutex>对象即使`mutexSecurity`拒绝或无法授予当前用户某些访问权限。</span><span class="sxs-lookup"><span data-stu-id="98e7d-251">The caller has full control over the newly created <xref:System.Threading.Mutex> object even if `mutexSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="98e7d-252">但是，如果当前的用户尝试获取另一个<xref:System.Threading.Mutex>对象以表示同一个已命名互斥体，使用构造函数或<xref:System.Threading.Mutex.OpenExisting%2A>方法，Windows 应用访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-252">However, if the current user attempts to get another <xref:System.Threading.Mutex> object to represent the same named mutex, using either a constructor or the <xref:System.Threading.Mutex.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="98e7d-253">如果命名互斥体已创建具有访问控制安全性，并且调用方没有<xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="98e7d-253">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="98e7d-254">若要打开现有的已命名互斥体，具有所需的同步线程活动，这些权限，请参阅<xref:System.Threading.Mutex.OpenExisting%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="98e7d-254">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="98e7d-255">如果指定`null`或为空字符串`name`，创建了局部互斥体，就像已调用<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>构造函数。</span><span class="sxs-lookup"><span data-stu-id="98e7d-255">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="98e7d-256">在这种情况下，`createdNew`始终`true`。</span><span class="sxs-lookup"><span data-stu-id="98e7d-256">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="98e7d-257">因为它们是系统范围内，则可以使用已命名的互斥来协调跨进程边界资源使用。</span><span class="sxs-lookup"><span data-stu-id="98e7d-257">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="98e7d-258">运行终端服务的服务器，请在已命名的系统互斥体可以包含两个级别的可见性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-258">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="98e7d-259">如果其名称以前缀"全局\\"，互斥体是在所有终端服务器会话中可见。</span><span class="sxs-lookup"><span data-stu-id="98e7d-259">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="98e7d-260">如果其名称以前缀"本地\\"，互斥体是仅在终端服务器会话中可见则创建它。</span><span class="sxs-lookup"><span data-stu-id="98e7d-260">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="98e7d-261">在这种情况下，具有相同名称的单独 mutex 可以存在于每个服务器上的其他终端服务器会话。</span><span class="sxs-lookup"><span data-stu-id="98e7d-261">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="98e7d-262">如果你创建命名互斥体时，你不会指定前缀，它将前缀"本地\\"。</span><span class="sxs-lookup"><span data-stu-id="98e7d-262">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="98e7d-263">终端服务器会话中，其名称只是其前缀不同的两个互斥体是单独的互斥体，且都是可见的所有进程在终端服务器会话中。</span><span class="sxs-lookup"><span data-stu-id="98e7d-263">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="98e7d-264">也就是说，前缀名称"全局\\"和"本地\\"描述相对于终端服务器会话、 不相对于进程的互斥体名称的作用域。</span><span class="sxs-lookup"><span data-stu-id="98e7d-264">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 <span data-ttu-id="98e7d-265">下面的代码示例演示通过访问控制安全性的已命名的互斥体的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="98e7d-265">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="98e7d-266">该示例使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法重载来测试是否存在的已命名的互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-266">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="98e7d-267">如果互斥体不存在，它是初始所属权和创建将拒绝使用互斥体的权限的当前用户，但授予的权限读取和更改权限互斥体的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-267">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="98e7d-268">如果从两个命令窗口中运行已编译的示例，第二个副本将在调用引发访问冲突异常<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="98e7d-268">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="98e7d-269">捕获了异常，并且该示例使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法重载，以读取和更改的权限所需的权限打开互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-269">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="98e7d-270">更改权限后，输入并释放它所需的权限打开互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-270">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="98e7d-271">如果从第三个命令窗口中运行已编译的示例，它将运行使用新的权限。</span><span class="sxs-lookup"><span data-stu-id="98e7d-271">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="98e7d-272">出现 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="98e7d-272">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="98e7d-273">命名互斥体存在且具有访问控制安全性，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-273">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="98e7d-274">无法创建命名互斥体，可能是由于其他类型的等待句柄具有相同名称。</span><span class="sxs-lookup"><span data-stu-id="98e7d-274">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98e7d-275"><paramref name="name" /> 超过 260 个字符。</span><span class="sxs-lookup"><span data-stu-id="98e7d-275"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="98e7d-276">需要完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="98e7d-276">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="98e7d-277">此成员不能由部分受信任或不透明的代码。</span><span class="sxs-lookup"><span data-stu-id="98e7d-277">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="98e7d-278">获取表示已命名的互斥体的访问控制安全性的 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="98e7d-278">Gets a <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span></span></summary>
        <returns><span data-ttu-id="98e7d-279">表示已命名的互斥体的访问控制安全性的 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="98e7d-279">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98e7d-280"><xref:System.Threading.Mutex.GetAccessControl%2A>方法使用以下标志 （使用按位或运算组合） 的组合来搜索权限： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>， <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>，和<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="98e7d-280">The <xref:System.Threading.Mutex.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="98e7d-281">用户必须具有<xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>才能调用此方法，而且互斥体必须打开与<xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="98e7d-281">The user must have <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98e7d-282">下面的代码示例演示通过访问控制安全性的已命名的互斥体的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="98e7d-282">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="98e7d-283">该示例使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法重载来测试是否存在的已命名的互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-283">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="98e7d-284">如果互斥体不存在，它是初始所属权和创建将拒绝使用互斥体的权限的当前用户，但授予的权限读取和更改权限互斥体的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-284">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="98e7d-285">如果从两个命令窗口中运行已编译的示例，第二个副本将在调用引发访问冲突异常<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="98e7d-285">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="98e7d-286">捕获了异常，并且该示例使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法重载，以读取和更改权限，使用所需的权限打开互斥体<xref:System.Threading.Mutex.GetAccessControl%2A>和<xref:System.Threading.Mutex.SetAccessControl%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="98e7d-286">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="98e7d-287">更改权限后，输入并释放它所需的权限打开互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-287">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="98e7d-288">如果从第三个命令窗口中运行已编译的示例，它将运行使用新的权限。</span><span class="sxs-lookup"><span data-stu-id="98e7d-288">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="98e7d-289">当前 <see cref="T:System.Threading.Mutex" /> 对象表示一个已命名的系统互斥体，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-289">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span></span>  
  
 <span data-ttu-id="98e7d-290">或</span><span class="sxs-lookup"><span data-stu-id="98e7d-290">-or-</span></span>  
  
 <span data-ttu-id="98e7d-291">当前 <see cref="T:System.Threading.Mutex" /> 对象表示一个已命名的系统互斥体，但它未用 <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /> 打开。</span><span class="sxs-lookup"><span data-stu-id="98e7d-291">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, and was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="98e7d-292">不支持 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="98e7d-292">Not supported for Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="98e7d-293">打开指定的已命名的互斥体（如果已经存在）。</span><span class="sxs-lookup"><span data-stu-id="98e7d-293">Opens a specified named mutex, if it already exists.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="98e7d-294">要打开的系统互斥体的名称。</span><span class="sxs-lookup"><span data-stu-id="98e7d-294">The name of the system mutex to open.</span></span></param>
        <summary><span data-ttu-id="98e7d-295">打开指定的已命名的互斥体（如果已经存在）。</span><span class="sxs-lookup"><span data-stu-id="98e7d-295">Opens the specified named mutex, if it already exists.</span></span></summary>
        <returns><span data-ttu-id="98e7d-296">表示已命名的系统互斥体的对象。</span><span class="sxs-lookup"><span data-stu-id="98e7d-296">An object that represents the named system mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98e7d-297"><xref:System.Threading.Mutex.OpenExisting%2A>方法尝试打开指定已命名系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-297">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open the specified named system mutex.</span></span> <span data-ttu-id="98e7d-298">如果不存在的系统互斥体，则此方法将引发异常而不是创建系统对象。</span><span class="sxs-lookup"><span data-stu-id="98e7d-298">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="98e7d-299">若要创建的系统互斥体时不存在，请使用之一<xref:System.Threading.Mutex.%23ctor%2A>构造函数具有`name`参数。</span><span class="sxs-lookup"><span data-stu-id="98e7d-299">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="98e7d-300">多次调用此方法使用相同的值的`name`不一定返回相同<xref:System.Threading.Mutex>对象，即使返回这些对象表示相同的已命名的系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-300">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="98e7d-301">此方法重载是等效于调用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法重载并指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>权限，使用按位或运算组合在一起。</span><span class="sxs-lookup"><span data-stu-id="98e7d-301">This method overload is equivalent to calling the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="98e7d-302">指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>标志将允许线程等待互斥体，并指定<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>标志将允许线程调用<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="98e7d-302">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="98e7d-303">此方法不会请求 mutex 所有权。</span><span class="sxs-lookup"><span data-stu-id="98e7d-303">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98e7d-304">下面的代码示例演示通过访问控制安全性的已命名的互斥体的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="98e7d-304">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="98e7d-305">该示例使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法重载来测试是否存在的已命名的互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-305">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="98e7d-306">如果互斥体不存在，它是初始所属权和创建将拒绝使用互斥体的权限的当前用户，但授予的权限读取和更改权限互斥体的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-306">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="98e7d-307">如果从两个命令窗口中运行已编译的示例，第二个副本将在调用引发访问冲突异常<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="98e7d-307">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="98e7d-308">捕获了异常，并且该示例使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法重载，以读取和更改的权限所需的权限打开互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-308">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="98e7d-309">更改权限后，输入并释放它所需的权限打开互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-309">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="98e7d-310">如果从第三个命令窗口中运行已编译的示例，它将运行使用新的权限。</span><span class="sxs-lookup"><span data-stu-id="98e7d-310">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98e7d-311"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="98e7d-311"><paramref name="name" /> is an empty string.</span></span>  
  
 <span data-ttu-id="98e7d-312">或</span><span class="sxs-lookup"><span data-stu-id="98e7d-312">-or-</span></span>  
  
 <span data-ttu-id="98e7d-313"><paramref name="name" /> 超过 260 个字符。</span><span class="sxs-lookup"><span data-stu-id="98e7d-313"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="98e7d-314"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-314"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="98e7d-315">命名的 mutex 不存在。</span><span class="sxs-lookup"><span data-stu-id="98e7d-315">The named mutex does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="98e7d-316">出现 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="98e7d-316">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="98e7d-317">存在命名的互斥，但用户没有使用它时所需的安全访问权限。</span><span class="sxs-lookup"><span data-stu-id="98e7d-317">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="98e7d-318">需要完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="98e7d-318">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="98e7d-319">此成员不能由部分受信任或不透明的代码。</span><span class="sxs-lookup"><span data-stu-id="98e7d-319">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="98e7d-320">要打开的系统互斥体的名称。</span><span class="sxs-lookup"><span data-stu-id="98e7d-320">The name of the system mutex to open.</span></span></param>
        <param name="rights"><span data-ttu-id="98e7d-321">表示所需的安全访问权限的枚举值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="98e7d-321">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <summary><span data-ttu-id="98e7d-322">利用所需的安全访问权限，打开指定的已命名的互斥体（如果已经存在）。</span><span class="sxs-lookup"><span data-stu-id="98e7d-322">Opens the specified named mutex, if it already exists, with the desired security access.</span></span></summary>
        <returns><span data-ttu-id="98e7d-323">表示已命名的系统互斥体的对象。</span><span class="sxs-lookup"><span data-stu-id="98e7d-323">An object that represents the named system mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98e7d-324">`rights`参数必须包含<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>标志以允许线程等待互斥体和<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>标志以允许线程调用<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="98e7d-324">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="98e7d-325"><xref:System.Threading.Mutex.OpenExisting%2A>方法尝试打开现有的已命名互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-325">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open an existing named mutex.</span></span> <span data-ttu-id="98e7d-326">如果不存在的系统互斥体，则此方法将引发异常而不是创建系统对象。</span><span class="sxs-lookup"><span data-stu-id="98e7d-326">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="98e7d-327">若要创建的系统互斥体时不存在，请使用之一<xref:System.Threading.Mutex.%23ctor%2A>构造函数具有`name`参数。</span><span class="sxs-lookup"><span data-stu-id="98e7d-327">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="98e7d-328">多次调用此方法使用相同的值的`name`不一定返回相同<xref:System.Threading.Mutex>对象，即使返回这些对象表示相同的已命名的系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-328">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="98e7d-329">此方法不会请求 mutex 所有权。</span><span class="sxs-lookup"><span data-stu-id="98e7d-329">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98e7d-330">下面的代码示例演示通过访问控制安全性的已命名的互斥体的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="98e7d-330">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="98e7d-331">该示例使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法重载来测试是否存在的已命名的互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-331">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="98e7d-332">如果互斥体不存在，它是初始所属权和创建将拒绝使用互斥体的权限的当前用户，但授予的权限读取和更改权限互斥体的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-332">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="98e7d-333">如果从两个命令窗口中运行已编译的示例，第二个副本将在调用引发访问冲突异常<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="98e7d-333">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="98e7d-334">捕获了异常，并且该示例使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法重载，以读取和更改的权限所需的权限打开互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-334">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="98e7d-335">更改权限后，输入并释放它所需的权限打开互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-335">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="98e7d-336">如果从第三个命令窗口中运行已编译的示例，它将运行使用新的权限。</span><span class="sxs-lookup"><span data-stu-id="98e7d-336">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98e7d-337"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="98e7d-337"><paramref name="name" /> is an empty string.</span></span>  
  
 <span data-ttu-id="98e7d-338">或</span><span class="sxs-lookup"><span data-stu-id="98e7d-338">-or-</span></span>  
  
 <span data-ttu-id="98e7d-339"><paramref name="name" /> 超过 260 个字符。</span><span class="sxs-lookup"><span data-stu-id="98e7d-339"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="98e7d-340"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-340"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="98e7d-341">命名的 mutex 不存在。</span><span class="sxs-lookup"><span data-stu-id="98e7d-341">The named mutex does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="98e7d-342">出现 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="98e7d-342">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="98e7d-343">已命名的 mutex 存在，但是用户不具备所需的安全访问权。</span><span class="sxs-lookup"><span data-stu-id="98e7d-343">The named mutex exists, but the user does not have the desired security access.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="98e7d-344">需要完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="98e7d-344">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="98e7d-345">此成员不能由部分受信任或不透明的代码。</span><span class="sxs-lookup"><span data-stu-id="98e7d-345">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="98e7d-346">释放 <see cref="T:System.Threading.Mutex" /> 一次。</span><span class="sxs-lookup"><span data-stu-id="98e7d-346">Releases the <see cref="T:System.Threading.Mutex" /> once.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98e7d-347">每当线程获取互斥体 (例如，通过调用其<xref:System.Threading.WaitHandle.WaitOne%2A>方法)，它随后必须调用<xref:System.Threading.Mutex.ReleaseMutex%2A>为放弃互斥体的所有权并解除阻止尝试获得所有权的互斥体的其他线程。</span><span class="sxs-lookup"><span data-stu-id="98e7d-347">Whenever a thread acquires a mutex (for example, by calling its <xref:System.Threading.WaitHandle.WaitOne%2A> method), it must subsequently call <xref:System.Threading.Mutex.ReleaseMutex%2A> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.</span></span> <span data-ttu-id="98e7d-348">如果尝试获取互斥体的所有权会失败 (例如，当调用<xref:System.Threading.WaitHandle.WaitOne%2A>方法替换`millisecondsTimeout`或`timeout`参数返回`false`因为在请求超时时)，不应在调用线程<xref:System.Threading.Mutex.ReleaseMutex%2A>，在此情况下，线程应也不允许访问受互斥体，如以下示例所示的资源。</span><span class="sxs-lookup"><span data-stu-id="98e7d-348">If the attempt to get ownership of the mutex fails (for example, when a call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method with a `millisecondsTimeout` or a `timeout` parameter returns `false` because the request times out), the thread shouldn't call <xref:System.Threading.Mutex.ReleaseMutex%2A>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 <span data-ttu-id="98e7d-349">拥有互斥体的线程可以在函数调用中重复的等待指定相同的互斥体，而不会阻止其执行。</span><span class="sxs-lookup"><span data-stu-id="98e7d-349">A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.</span></span> <span data-ttu-id="98e7d-350">由公共语言运行时保留的调用数。</span><span class="sxs-lookup"><span data-stu-id="98e7d-350">The number of calls is kept by the common language runtime.</span></span> <span data-ttu-id="98e7d-351">必须在调用线程<xref:System.Threading.Mutex.ReleaseMutex%2A>相同数量的次数以释放互斥体的所有权。</span><span class="sxs-lookup"><span data-stu-id="98e7d-351">The thread must call <xref:System.Threading.Mutex.ReleaseMutex%2A> the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="98e7d-352">如果某个线程终止时拥有互斥体，则认为该 mutex 来放弃。</span><span class="sxs-lookup"><span data-stu-id="98e7d-352">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="98e7d-353">互斥体的状态设置为终止，并在下一个等待线程获取所有权。</span><span class="sxs-lookup"><span data-stu-id="98e7d-353">The state of the mutex is set to signaled and the next waiting thread gets ownership.</span></span> <span data-ttu-id="98e7d-354">如果没有人拥有互斥体，互斥体的状态处于有信号状态。</span><span class="sxs-lookup"><span data-stu-id="98e7d-354">If no one owns the mutex, the state of the mutex is signaled.</span></span> <span data-ttu-id="98e7d-355">从 2.0 版.NET Framework 中，开始<xref:System.Threading.AbandonedMutexException>获取互斥体的下一个线程中引发。</span><span class="sxs-lookup"><span data-stu-id="98e7d-355">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the mutex.</span></span> <span data-ttu-id="98e7d-356">在.NET Framework 2.0 版中之前, 没有引发异常。</span><span class="sxs-lookup"><span data-stu-id="98e7d-356">Prior to version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="98e7d-357">放弃的 mutex 通常表明代码中的存在严重错误。</span><span class="sxs-lookup"><span data-stu-id="98e7d-357">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="98e7d-358">如果一个线程退出时不释放互斥体，由 mutex 保护的数据结构可能不处于一致状态。</span><span class="sxs-lookup"><span data-stu-id="98e7d-358">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="98e7d-359">下一个请求 mutex 所有权的线程可以处理此异常并继续操作，如果可以验证这些数据结构的完整性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-359">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="98e7d-360">对于系统范围的 mutex，放弃的 mutex 可能指示应用程序已突然终止（例如，通过使用 Windows 任务管理器终止）。</span><span class="sxs-lookup"><span data-stu-id="98e7d-360">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98e7d-361">下面的示例显示如何本地<xref:System.Threading.Mutex>对象用于对受保护资源的访问进行同步。</span><span class="sxs-lookup"><span data-stu-id="98e7d-361">The following example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="98e7d-362">创建互斥体的线程不最初拥有其信息。</span><span class="sxs-lookup"><span data-stu-id="98e7d-362">The thread that creates the mutex does not own it initially.</span></span> <span data-ttu-id="98e7d-363"><xref:System.Threading.Mutex.ReleaseMutex%2A>方法用于当不再需要时，释放互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-363">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is used to release the mutex when it is no longer needed.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="98e7d-364">调用线程不拥有互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-364">The calling thread does not own the mutex.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="98e7d-365">已释放当前实例。</span><span class="sxs-lookup"><span data-stu-id="98e7d-365">The current instance has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity"><span data-ttu-id="98e7d-366">一个 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 对象，表示应用于已命名的系统互斥体的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-366">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span></span></param>
        <summary><span data-ttu-id="98e7d-367">设置已命名的系统互斥体的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-367">Sets the access control security for a named system mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98e7d-368">用户必须具有<xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>权限才能调用此方法，而且互斥体必须使用打开<xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="98e7d-368">The user must have <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98e7d-369">下面的代码示例演示通过访问控制安全性的已命名的互斥体的跨进程行为。</span><span class="sxs-lookup"><span data-stu-id="98e7d-369">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="98e7d-370">该示例使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法重载来测试是否存在的已命名的互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-370">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="98e7d-371">如果互斥体不存在，它是初始所属权和创建将拒绝使用互斥体的权限的当前用户，但授予的权限读取和更改权限互斥体的访问控制安全性。</span><span class="sxs-lookup"><span data-stu-id="98e7d-371">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="98e7d-372">如果从两个命令窗口中运行已编译的示例，第二个副本将在调用引发访问冲突异常<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="98e7d-372">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="98e7d-373">捕获了异常，并且该示例使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法重载，以读取和更改权限，使用所需的权限打开互斥体<xref:System.Threading.Mutex.GetAccessControl%2A>和<xref:System.Threading.Mutex.SetAccessControl%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="98e7d-373">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="98e7d-374">更改权限后，输入并释放它所需的权限打开互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-374">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="98e7d-375">如果从第三个命令窗口中运行已编译的示例，它将运行使用新的权限。</span><span class="sxs-lookup"><span data-stu-id="98e7d-375">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="98e7d-376"><paramref name="mutexSecurity" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-376"><paramref name="mutexSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="98e7d-377">用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-377">The user does not have <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span></span>  
  
 <span data-ttu-id="98e7d-378">或</span><span class="sxs-lookup"><span data-stu-id="98e7d-378">-or-</span></span>  
  
 <span data-ttu-id="98e7d-379">互斥体未用 <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /> 打开。</span><span class="sxs-lookup"><span data-stu-id="98e7d-379">The mutex was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="98e7d-380">当前 <see cref="T:System.Threading.Mutex" /> 对象不表示已命名的系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-380">The current <see cref="T:System.Threading.Mutex" /> object does not represent a named system mutex.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="98e7d-381">打开指定的已命名的互斥体（如果已经存在），并返回指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="98e7d-381">Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="98e7d-382">要打开的系统互斥体的名称。</span><span class="sxs-lookup"><span data-stu-id="98e7d-382">The name of the system mutex to open.</span></span></param>
        <param name="result"><span data-ttu-id="98e7d-383">当此方法返回时，如果调用成功，则包含表示命名互斥体的 <see cref="T:System.Threading.Mutex" /> 对象；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-383">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="98e7d-384">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="98e7d-384">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="98e7d-385">打开指定的已命名的互斥体（如果已经存在），并返回指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="98e7d-385">Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns>
          <span data-ttu-id="98e7d-386">如果命名互斥体成功打开，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-386"><see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98e7d-387">如果命名互斥体不存在，则此方法不创建它。</span><span class="sxs-lookup"><span data-stu-id="98e7d-387">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="98e7d-388">若要创建的系统互斥体时不存在，请使用之一<xref:System.Threading.Mutex.%23ctor%2A>构造函数具有`name`参数。</span><span class="sxs-lookup"><span data-stu-id="98e7d-388">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="98e7d-389">如果你不确定是否已命名的互斥体存在，请使用而不是此方法重载<xref:System.Threading.Mutex.OpenExisting%28System.String%29>互斥体不存在时引发异常的方法重载。</span><span class="sxs-lookup"><span data-stu-id="98e7d-389">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="98e7d-390">多次调用此方法使用相同的值的`name`不一定返回相同<xref:System.Threading.Mutex>对象，即使返回这些对象表示相同的已命名的系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-390">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="98e7d-391">此方法重载是等效于调用<xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29>方法重载并指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>权限，使用按位或运算组合在一起。</span><span class="sxs-lookup"><span data-stu-id="98e7d-391">This method overload is equivalent to calling the <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="98e7d-392">指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>标志将允许线程等待互斥体，并指定<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>标志将允许线程调用<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="98e7d-392">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="98e7d-393">此方法不会请求 mutex 所有权。</span><span class="sxs-lookup"><span data-stu-id="98e7d-393">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98e7d-394"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="98e7d-394"><paramref name="name" /> is an empty string.</span></span>  
  
 <span data-ttu-id="98e7d-395">或</span><span class="sxs-lookup"><span data-stu-id="98e7d-395">-or-</span></span>  
  
 <span data-ttu-id="98e7d-396"><paramref name="name" /> 超过 260 个字符。</span><span class="sxs-lookup"><span data-stu-id="98e7d-396"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="98e7d-397"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-397"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="98e7d-398">出现 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="98e7d-398">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="98e7d-399">存在命名的互斥，但用户没有使用它时所需的安全访问权限。</span><span class="sxs-lookup"><span data-stu-id="98e7d-399">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="98e7d-400">需要完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="98e7d-400">requires full trust for the immediate caller.</span></span> <span data-ttu-id="98e7d-401">此成员不能由部分受信任或不透明的代码。</span><span class="sxs-lookup"><span data-stu-id="98e7d-401">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="98e7d-402">要打开的系统互斥体的名称。</span><span class="sxs-lookup"><span data-stu-id="98e7d-402">The name of the system mutex to open.</span></span></param>
        <param name="rights"><span data-ttu-id="98e7d-403">表示所需的安全访问权限的枚举值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="98e7d-403">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <param name="result"><span data-ttu-id="98e7d-404">当此方法返回时，如果调用成功，则包含表示命名互斥体的 <see cref="T:System.Threading.Mutex" /> 对象；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-404">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="98e7d-405">该参数未经初始化即被处理。</span><span class="sxs-lookup"><span data-stu-id="98e7d-405">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="98e7d-406">利用所需的安全访问权限，打开指定的已命名的互斥体（如果已经存在），并返回指示操作是否成功的值。</span><span class="sxs-lookup"><span data-stu-id="98e7d-406">Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns>
          <span data-ttu-id="98e7d-407">如果命名互斥体成功打开，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-407"><see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98e7d-408">如果命名互斥体不存在，则此方法不创建它。</span><span class="sxs-lookup"><span data-stu-id="98e7d-408">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="98e7d-409">若要创建的系统互斥体时不存在，请使用之一<xref:System.Threading.Mutex.%23ctor%2A>构造函数具有`name`参数。</span><span class="sxs-lookup"><span data-stu-id="98e7d-409">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="98e7d-410">如果你不确定是否已命名的互斥体存在，请使用而不是此方法重载<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>互斥体不存在时引发异常的方法重载。</span><span class="sxs-lookup"><span data-stu-id="98e7d-410">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="98e7d-411">`rights`参数必须包含<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>标志以允许线程等待互斥体和<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>标志以允许线程调用<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="98e7d-411">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="98e7d-412">多次调用此方法使用相同的值的`name`不一定返回相同<xref:System.Threading.Mutex>对象，即使返回这些对象表示相同的已命名的系统互斥体。</span><span class="sxs-lookup"><span data-stu-id="98e7d-412">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="98e7d-413">此方法不会请求 mutex 所有权。</span><span class="sxs-lookup"><span data-stu-id="98e7d-413">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98e7d-414"><paramref name="name" /> 是一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="98e7d-414"><paramref name="name" /> is an empty string.</span></span>  
  
 <span data-ttu-id="98e7d-415">或</span><span class="sxs-lookup"><span data-stu-id="98e7d-415">-or-</span></span>  
  
 <span data-ttu-id="98e7d-416"><paramref name="name" /> 超过 260 个字符。</span><span class="sxs-lookup"><span data-stu-id="98e7d-416"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="98e7d-417"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="98e7d-417"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="98e7d-418">出现 Win32 错误。</span><span class="sxs-lookup"><span data-stu-id="98e7d-418">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="98e7d-419">存在命名的互斥，但用户没有使用它时所需的安全访问权限。</span><span class="sxs-lookup"><span data-stu-id="98e7d-419">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="98e7d-420">需要完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="98e7d-420">requires full trust for the immediate caller.</span></span> <span data-ttu-id="98e7d-421">此成员不能由部分受信任或不透明的代码。</span><span class="sxs-lookup"><span data-stu-id="98e7d-421">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>