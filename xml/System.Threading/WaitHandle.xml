<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b0743bee28025334f71604c9b2d0c45160aa6bc8" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52608543" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="bc64f-101">封装等待对共享资源的独占访问的操作系统特定的对象。</span>
      <span class="sxs-lookup">
        <span data-stu-id="bc64f-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-102"><xref:System.Threading.WaitHandle>类封装本机操作系统同步句柄，用于表示在运行时允许多个等待操作的所有同步对象。</span><span class="sxs-lookup"><span data-stu-id="bc64f-102">The <xref:System.Threading.WaitHandle> class encapsulates a native operating system synchronization handle and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="bc64f-103">与其他同步对象的等待句柄的比较，请参阅[同步基元概述](~/docs/standard/threading/overview-of-synchronization-primitives.md)。</span><span class="sxs-lookup"><span data-stu-id="bc64f-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="bc64f-104"><xref:System.Threading.WaitHandle>类本身是抽象的。</span><span class="sxs-lookup"><span data-stu-id="bc64f-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="bc64f-105">类派生自<xref:System.Threading.WaitHandle>定义了一个信号机制，以指示获取或释放访问共享资源，但它们使用继承<xref:System.Threading.WaitHandle>方法，若要在等待访问共享资源。</span><span class="sxs-lookup"><span data-stu-id="bc64f-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="bc64f-106">类派生自<xref:System.Threading.WaitHandle>包括：</span><span class="sxs-lookup"><span data-stu-id="bc64f-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="bc64f-107"><xref:System.Threading.Mutex> 类。</span><span class="sxs-lookup"><span data-stu-id="bc64f-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="bc64f-108">请参阅[Mutex](~/docs/standard/threading/mutexes.md)。</span><span class="sxs-lookup"><span data-stu-id="bc64f-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="bc64f-109"><xref:System.Threading.EventWaitHandle>类和其派生的类，<xref:System.Threading.AutoResetEvent>和<xref:System.Threading.ManualResetEvent>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="bc64f-110">请参阅 [EventWaitHandle、AutoResetEvent、CountdownEvent、ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)。</span><span class="sxs-lookup"><span data-stu-id="bc64f-110">See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
-   <span data-ttu-id="bc64f-111"><xref:System.Threading.Semaphore> 类。</span><span class="sxs-lookup"><span data-stu-id="bc64f-111">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="bc64f-112">请参阅[Semaphore 和 SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md)。</span><span class="sxs-lookup"><span data-stu-id="bc64f-112">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="bc64f-113">线程可以通过将阻止各个等待句柄上调用实例方法<xref:System.Threading.WaitHandle.WaitOne%2A>，由派生的类继承<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-113">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="bc64f-114">派生的类<xref:System.Threading.WaitHandle>的区别在于其线程关联。</span><span class="sxs-lookup"><span data-stu-id="bc64f-114">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="bc64f-115">事件等待句柄 (<xref:System.Threading.EventWaitHandle>， <xref:System.Threading.AutoResetEvent>，和<xref:System.Threading.ManualResetEvent>) 和信号量不具有线程关联; 任何线程都可以发送事件等待句柄或信号量。</span><span class="sxs-lookup"><span data-stu-id="bc64f-115">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="bc64f-116">互斥锁，但是，具有线程关联;拥有 mutex 的线程必须释放它，并且如果某个线程调用引发异常<xref:System.Threading.Mutex.ReleaseMutex%2A>上不拥有互斥体的方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-116">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="bc64f-117">因为<xref:System.Threading.WaitHandle>类派生自<xref:System.MarshalByRefObject>，这些类可用于跨应用程序域边界同步线程的活动。</span><span class="sxs-lookup"><span data-stu-id="bc64f-117">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="bc64f-118">及其派生类，除了<xref:System.Threading.WaitHandle>类包含静态方法，直到一个阻塞线程的数量，或者更多的同步对象收到信号。</span><span class="sxs-lookup"><span data-stu-id="bc64f-118">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.</span></span> <span data-ttu-id="bc64f-119">这些方法包括：</span><span class="sxs-lookup"><span data-stu-id="bc64f-119">These include:</span></span>  
  
-   <span data-ttu-id="bc64f-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>它允许线程发出信号一个等待句柄并立即等待另一个。</span><span class="sxs-lookup"><span data-stu-id="bc64f-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="bc64f-121"><xref:System.Threading.WaitHandle.WaitAll%2A>它允许一个线程等待，直到所有等待句柄数组中的都接收信号。</span><span class="sxs-lookup"><span data-stu-id="bc64f-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="bc64f-122"><xref:System.Threading.WaitHandle.WaitAny%2A>它允许一个线程等待，直到任一一组指定的等待句柄发送信号。</span><span class="sxs-lookup"><span data-stu-id="bc64f-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</span></span>  
  
 <span data-ttu-id="bc64f-123">这些方法的重载提供超时间隔后，将放弃等待，并输入允许使用同步上下文的其他线程在等待之前退出同步上下文的机会。</span><span class="sxs-lookup"><span data-stu-id="bc64f-123">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="bc64f-124">此类型实现<xref:System.IDisposable>接口。</span><span class="sxs-lookup"><span data-stu-id="bc64f-124">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="bc64f-125">完成后使用的类型或从其派生的类型的操作后，您应释放它直接或间接。</span><span class="sxs-lookup"><span data-stu-id="bc64f-125">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="bc64f-126">若要直接释放类型，调用其<xref:System.Threading.WaitHandle.Close%2A>中的方法`try` / `catch`块。</span><span class="sxs-lookup"><span data-stu-id="bc64f-126">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="bc64f-127">若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。</span><span class="sxs-lookup"><span data-stu-id="bc64f-127">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="bc64f-128">有关详细信息，请参阅中的"使用对象实现 IDisposable"一节<xref:System.IDisposable>接口主题。</span><span class="sxs-lookup"><span data-stu-id="bc64f-128">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="bc64f-129"><xref:System.Threading.WaitHandle> 实现<xref:System.IDisposable.Dispose%2A>模式。</span><span class="sxs-lookup"><span data-stu-id="bc64f-129"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="bc64f-130">请参阅[释放模式](~/docs/standard/design-guidelines/dispose-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="bc64f-130">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="bc64f-131">派生自<xref:System.Threading.WaitHandle>，使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>属性来存储本机操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="bc64f-131">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native operating system handle.</span></span> <span data-ttu-id="bc64f-132">不需要重写受保护<xref:System.Threading.WaitHandle.Dispose%2A>方法除非你使用其他非托管的资源。</span><span class="sxs-lookup"><span data-stu-id="bc64f-132">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc64f-133">下面的代码示例演示如何在两个线程可以执行后台任务，同时主线程等待任务完成使用静态<xref:System.Threading.WaitHandle.WaitAny%2A>并<xref:System.Threading.WaitHandle.WaitAll%2A>方法的<xref:System.Threading.WaitHandle>类。</span><span class="sxs-lookup"><span data-stu-id="bc64f-133">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="bc64f-134">此类型是线程安全的。</span>
      <span class="sxs-lookup">
        <span data-stu-id="bc64f-134">This type is thread safe.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="bc64f-135">线程</span>
      <span class="sxs-lookup">
        <span data-stu-id="bc64f-135">Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">
      <span data-ttu-id="bc64f-136">线程处理对象和功能</span>
      <span class="sxs-lookup">
        <span data-stu-id="bc64f-136">Threading Objects and Features</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">
      <span data-ttu-id="bc64f-137">Mutexes</span>
      <span class="sxs-lookup">
        <span data-stu-id="bc64f-137">Mutexes</span>
      </span>
    </related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
      <span data-ttu-id="bc64f-138">EventWaitHandle、AutoResetEvent 和 anualResetEvent</span>
      <span class="sxs-lookup">
        <span data-stu-id="bc64f-138">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
      <span data-ttu-id="bc64f-139">信号量</span>
      <span class="sxs-lookup">
        <span data-stu-id="bc64f-139">Semaphores</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bc64f-140">初始化 <see cref="T:System.Threading.WaitHandle" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-140">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bc64f-141">释放由当前 <see cref="T:System.Threading.WaitHandle" /> 占用的所有资源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-141">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-142">此方法是公共实现<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>方法<xref:System.Threading.WaitHandle>类和其派生的类。</span><span class="sxs-lookup"><span data-stu-id="bc64f-142">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="bc64f-143">它提供了一种标准的实现，调用`Dispose(Boolean)`重载，并`true`自变量，然后调用<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-143">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="bc64f-144">调用此方法来释放由的实例占用的所有资源`WaitHandle`或派生的类。</span><span class="sxs-lookup"><span data-stu-id="bc64f-144">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="bc64f-145">调用此方法后，对当前实例的引用会导致未定义的行为。</span><span class="sxs-lookup"><span data-stu-id="bc64f-145">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc64f-146">始终调用<xref:System.Threading.WaitHandle.Close%2A>或<xref:System.Threading.WaitHandle.Dispose>发布到最后一个引用之前<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-146">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="bc64f-147">否则，不会释放它所使用的资源。</span><span class="sxs-lookup"><span data-stu-id="bc64f-147">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="bc64f-148">应重写<see langword="Dispose(Boolean)" />方法来释放资源分配中派生的类。</span>
            <span class="sxs-lookup">
              <span data-stu-id="bc64f-148">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
          </para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">
          <span data-ttu-id="bc64f-149">实现 Dispose 方法</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-149">Implementing a Dispose Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc64f-150">释放 <see cref="T:System.Threading.WaitHandle" /> 类的当前实例所使用的所有资源</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-150">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bc64f-151">释放 <see cref="T:System.Threading.WaitHandle" /> 类的当前实例所使用的所有资源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-151">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-152">此方法等效于<xref:System.Threading.WaitHandle.Close%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-152">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc64f-153">始终调用<xref:System.Threading.WaitHandle.Close%2A>或<xref:System.Threading.WaitHandle.Dispose>发布到最后一个引用之前<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-153">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="bc64f-154">否则，不会释放它所使用的资源。</span><span class="sxs-lookup"><span data-stu-id="bc64f-154">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">
          <span data-ttu-id="bc64f-155">清理非托管资源</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-155">Cleaning Up Unmanaged Resources</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <span data-ttu-id="bc64f-156">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-156">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-157">当在派生类中重写时，释放 <see cref="T:System.Threading.WaitHandle" /> 使用的非托管资源，并且可选择释放托管资源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-157">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-158">调用此方法<xref:System.Threading.WaitHandle.Close%2A>并<xref:System.Threading.WaitHandle.Dispose>方法使用`explicitDisposing`参数设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="bc64f-158">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="bc64f-159">当`explicitDisposing`参数是`true`，此方法释放任何托管对象所持有的所有资源，此<xref:System.Threading.WaitHandle>对象引用。</span><span class="sxs-lookup"><span data-stu-id="bc64f-159">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="bc64f-160">应重写<see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />方法来释放资源分配中派生的类。</span>
            <span class="sxs-lookup">
              <span data-stu-id="bc64f-160">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
            <span data-ttu-id="bc64f-161">
              <see cref="M:System.Threading.WaitHandle.Close" />或<see cref="M:System.Threading.WaitHandle.Dispose" />方法可以由其他对象调用多次。</span>
            <span class="sxs-lookup">
              <span data-stu-id="bc64f-161">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="bc64f-162">重写此方法时, 请小心不要引用已释放到的早期调用中的对象<see langword="Dispose" />或<see langword="Close" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="bc64f-162">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span>
            </span>
          </para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">
          <span data-ttu-id="bc64f-163">实现 Dispose 方法</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-163">Implementing a Dispose Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bc64f-164">释放由当前实例所持有的资源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-164">Releases the resources held by the current instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> <span data-ttu-id="bc64f-165">此成员已从.NET Framework 2.0 版和后续版本。</span><span class="sxs-lookup"><span data-stu-id="bc64f-165">This member has been removed from the .NET Framework version 2.0 and subsequent versions.</span></span> <span data-ttu-id="bc64f-166">本主题仅适用于本主题后面的"版本信息"中列出的版本。</span><span class="sxs-lookup"><span data-stu-id="bc64f-166">This topic applies only to the versions listed in "Version Information" later in this topic.</span></span>


<span data-ttu-id="bc64f-167">应用程序代码不调用此方法。调用此操作会自动在垃圾回收期间除非终止由垃圾回收器已被禁用。</span><span class="sxs-lookup"><span data-stu-id="bc64f-167">Application code does not call this method; it is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled.</span></span> <span data-ttu-id="bc64f-168">有关详细信息，请参阅 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 和 <xref:System.Object.Finalize>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-168">For more information, see <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> and <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="bc64f-169">此方法重写 <xref:System.Object.Finalize>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-169">This method overrides <xref:System.Object.Finalize>.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc64f-170">获取或设置本机操作系统句柄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-170">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc64f-171">
            <see langword="IntPtr" />，它表示本机操作系统句柄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-171">An <see langword="IntPtr" /> representing the native operating system handle.</span>
          </span>
          <span data-ttu-id="bc64f-172">默认为 <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> 字段的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-172">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-173">分配到一个新值<xref:System.Threading.WaitHandle.Handle%2A>属性不会关闭上一个句柄。</span><span class="sxs-lookup"><span data-stu-id="bc64f-173">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="bc64f-174">这可能导致句柄泄漏。</span><span class="sxs-lookup"><span data-stu-id="bc64f-174">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="bc64f-175">在.NET Framework 版本 2.0 或更高版本; 不使用此属性使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>属性改为。</span><span class="sxs-lookup"><span data-stu-id="bc64f-175">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="bc64f-176">此属性设置为有效的句柄还设置<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>属性，但将其设置为<xref:System.Threading.WaitHandle.InvalidHandle>可能会导致句柄泄漏。</span><span class="sxs-lookup"><span data-stu-id="bc64f-176">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="bc64f-177">需要完全信任立即呼叫者设置属性值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-177">Requires full trust for the immediate caller to set the property value.</span>
          </span>
          <span data-ttu-id="bc64f-178">此成员不能由部分受信任的或透明代码设置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-178">This member cannot be set by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="bc64f-179">派生的类型必须具有<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />设置属性值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-179">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc64f-180">表示无效的本机操作系统句柄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-180">Represents an invalid native operating system handle.</span>
          </span>
          <span data-ttu-id="bc64f-181">此字段为只读。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-181">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-182">在内部用于初始化<xref:System.Threading.WaitHandle.Handle%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="bc64f-182">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="bc64f-183">可以使用此值以确定是否<see cref="P:System.Threading.WaitHandle.Handle" />属性包含有效的本机操作系统句柄。</span>
            <span class="sxs-lookup">
              <span data-stu-id="bc64f-183">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc64f-184">获取或设置本机操作系统句柄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-184">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bc64f-185">
            <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />，它表示本机操作系统句柄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-185">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-186">当将新值赋给<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>属性上, 一个句柄将关闭时的上一个<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>对象被收集。</span><span class="sxs-lookup"><span data-stu-id="bc64f-186">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="bc64f-187">请勿手动关闭句柄，因为这会导致<xref:System.ObjectDisposedException>时<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>尝试关闭句柄。</span><span class="sxs-lookup"><span data-stu-id="bc64f-187">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="bc64f-188"><xref:System.Threading.WaitHandle> 实现<xref:System.IDisposable.Dispose%2A>模式。</span><span class="sxs-lookup"><span data-stu-id="bc64f-188"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="bc64f-189">请参阅[释放模式](~/docs/standard/design-guidelines/dispose-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="bc64f-189">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="bc64f-190">派生自<xref:System.Threading.WaitHandle>，使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>属性来存储你的本机句柄操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="bc64f-190">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="bc64f-191">不需要重写受保护<xref:System.Threading.WaitHandle.Dispose%2A>方法除非你使用其他非托管的资源。</span><span class="sxs-lookup"><span data-stu-id="bc64f-191">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="bc64f-192">直接调用方需要完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-192">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="bc64f-193">不能由部分受信任的或透明的代码使用此成员。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-193">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="bc64f-194">派生的类型必须具有<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />若要调用此成员。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-194">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc64f-195">向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-195">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="bc64f-196">要发出信号的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-196">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="bc64f-197">要等待的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-197">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-198">向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-198">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-199">如果信号和等待都成功完成，则为 <see langword="true" />；如果等待没有完成，则此方法不返回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-199">
              <see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-200">此操作不能保证才能成为原子性。</span><span class="sxs-lookup"><span data-stu-id="bc64f-200">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="bc64f-201">当前线程发出信号后`toSignal`但在等待之前`toWaitOn`，在另一个处理器运行的线程可能会发出信号`toWaitOn`或在其上等待。</span><span class="sxs-lookup"><span data-stu-id="bc64f-201">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc64f-202">下面的代码示例使用<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>方法重载来允许主线程发出信号已阻塞的线程并然后等待，直到线程完成任务。</span><span class="sxs-lookup"><span data-stu-id="bc64f-202">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="bc64f-203">该示例启动五个线程时，允许其上阻止<xref:System.Threading.EventWaitHandle>使用创建<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>标志，然后一个线程一次时释放用户按下 ENTER 键。</span><span class="sxs-lookup"><span data-stu-id="bc64f-203">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="bc64f-204">该示例然后另外五个线程并释放所有使用<xref:System.Threading.EventWaitHandle>使用创建<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>标志。</span><span class="sxs-lookup"><span data-stu-id="bc64f-204">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc64f-205">
            <paramref name="toSignal" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-205">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-206">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-206">-or-</span>
          </span>
          <span data-ttu-id="bc64f-207">
            <paramref name="toWaitOn" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-207">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc64f-208">在一个具有 <see cref="T:System.STAThreadAttribute" /> 的线程上调用了该方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-208">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="bc64f-209">Windows 98 或 Windows Millennium Edition 不支持此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-209">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-210">
            <paramref name="toSignal" /> 是信号量，已达到最大计数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-210">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-211">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-211">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-212">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-212">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="bc64f-213">要发出信号的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-213">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="bc64f-214">要等待的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-214">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="bc64f-215">一个整数，表示要等待的间隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-215">An integer that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="bc64f-216">如果值是 <see cref="F:System.Threading.Timeout.Infinite" />，即 -1，则等待是无限期的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-216">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="bc64f-217">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-217">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-218">向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个，指定超时间隔为 32 位有符号整数，并指定在进入等待前是否退出上下文的同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-218">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-219">如果信号发送和等待均成功完成，则为 <see langword="true" />；如果信号发送完成，但等待超时，则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-219">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-220">此操作不能保证才能成为原子性。</span><span class="sxs-lookup"><span data-stu-id="bc64f-220">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="bc64f-221">当前线程发出信号后`toSignal`但在等待之前`toWaitOn`，在另一个处理器运行的线程可能会发出信号`toWaitOn`或在其上等待。</span><span class="sxs-lookup"><span data-stu-id="bc64f-221">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="bc64f-222">如果`millisecondsTimeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="bc64f-222">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="bc64f-223">测试的状态`toWaitOn`并立即返回。</span><span class="sxs-lookup"><span data-stu-id="bc64f-223">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bc64f-224">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="bc64f-224">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bc64f-225">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.SignalAndWait%2A>从非默认托管上下文中调用方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-225">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bc64f-226">如果你的线程是派生自的类的实例的调用内部发生这种情况<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-226">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bc64f-227">即使当前正在执行一种方法不是派生的类上<xref:System.ContextBoundObject>，例如<xref:System.String>，可以在非默认上下文中是如果<xref:System.ContextBoundObject>是当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="bc64f-227">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bc64f-228">时在非默认上下文中执行代码时，指定`true`有关`exitContext`会导致线程退出非默认托管的上下文 (即，转换到默认上下文) 执行前<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-228">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="bc64f-229">线程在调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="bc64f-229">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="bc64f-230">在上下文绑定类时这很有用<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-230">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="bc64f-231">在这种情况下，所有调用的类的成员将自动都同步，并同步域是为类代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="bc64f-231">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bc64f-232">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法，并指定`true`为`exitContext`，在线程退出同步域，这样在调用对象的任何成员以继续操作被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="bc64f-232">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bc64f-233">当<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法返回时，调用线程必须等待以重新输入同步域。</span><span class="sxs-lookup"><span data-stu-id="bc64f-233">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc64f-234">
            <paramref name="toSignal" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-234">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-235">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-235">-or-</span>
          </span>
          <span data-ttu-id="bc64f-236">
            <paramref name="toWaitOn" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-236">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc64f-237">对具有 <see cref="T:System.STAThreadAttribute" /> 的线程调用了此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-237">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="bc64f-238">Windows 98 或 Windows Millennium Edition 不支持此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-238">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-239">无法终止 <see cref="T:System.Threading.WaitHandle" />，因为它将超过其最大计数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-239">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc64f-240">
            <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-240">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-241">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-241">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-242">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-242">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="bc64f-243">要发出信号的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-243">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="bc64f-244">要等待的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-244">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="bc64f-245">一个 <see cref="T:System.TimeSpan" />，表示要等待的间隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-245">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="bc64f-246">如果值是 -1，则等待是无限期的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-246">If the value is -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="bc64f-247">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-247">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-248">向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个，指定超时间隔为 <see cref="T:System.TimeSpan" />，并指定在进入等待前是否退出上下文的同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-248">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-249">如果信号发送和等待均成功完成，则为 <see langword="true" />；如果信号发送完成，但等待超时，则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-249">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-250">此操作不能保证才能成为原子性。</span><span class="sxs-lookup"><span data-stu-id="bc64f-250">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="bc64f-251">当前线程发出信号后`toSignal`但在等待之前`toWaitOn`，在另一个处理器运行的线程可能会发出信号`toWaitOn`或在其上等待。</span><span class="sxs-lookup"><span data-stu-id="bc64f-251">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="bc64f-252">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-252">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bc64f-253">如果`timeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="bc64f-253">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="bc64f-254">测试的状态`toWaitOn`并立即返回。</span><span class="sxs-lookup"><span data-stu-id="bc64f-254">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bc64f-255">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="bc64f-255">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bc64f-256">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.SignalAndWait%2A>从非默认托管上下文中调用方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-256">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bc64f-257">如果你的线程是派生自的类的实例的调用内部发生这种情况<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-257">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bc64f-258">即使当前正在执行一种方法不是派生的类上<xref:System.ContextBoundObject>，例如<xref:System.String>，可以在非默认上下文中是如果<xref:System.ContextBoundObject>是当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="bc64f-258">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bc64f-259">时在非默认上下文中执行代码时，指定`true`有关`exitContext`会导致线程退出非默认托管的上下文 (即，转换到默认上下文) 执行前<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-259">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="bc64f-260">线程在调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="bc64f-260">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="bc64f-261">在上下文绑定类时这很有用<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-261">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="bc64f-262">在这种情况下，所有调用的类的成员将自动都同步，并同步域是为类代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="bc64f-262">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bc64f-263">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法，并指定`true`为`exitContext`，在线程退出同步域，这样在调用对象的任何成员以继续操作被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="bc64f-263">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bc64f-264">当<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法返回时，调用线程必须等待以重新输入同步域。</span><span class="sxs-lookup"><span data-stu-id="bc64f-264">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc64f-265">
            <paramref name="toSignal" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-265">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-266">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-266">-or-</span>
          </span>
          <span data-ttu-id="bc64f-267">
            <paramref name="toWaitOn" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-267">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc64f-268">在一个具有 <see cref="T:System.STAThreadAttribute" /> 的线程上调用了该方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-268">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="bc64f-269">Windows 98 或 Windows Millennium Edition 不支持此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-269">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-270">
            <paramref name="toSignal" /> 是信号量，已达到最大计数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-270">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc64f-271">
            <paramref name="timeout" /> 计算为 -1 以外的负毫秒数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-271">
              <paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span>
          </span>
          <span data-ttu-id="bc64f-272">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-272">-or-</span>
          </span>
          <span data-ttu-id="bc64f-273">
            <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-273">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-274">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-274">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-275">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-275">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bc64f-276">释放由 <see cref="T:System.Threading.WaitHandle" /> 使用的所有资源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-276">Releases all resources used by the <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="bc64f-277">调用`Dispose`允许使用的资源<xref:System.Threading.WaitHandle>重新分配用于其他目的。</span><span class="sxs-lookup"><span data-stu-id="bc64f-277">Calling `Dispose` allows the resources used by the <xref:System.Threading.WaitHandle> to be reallocated for other purposes.</span></span> <span data-ttu-id="bc64f-278">有关详细信息`Dispose`，请参阅[清理了非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</span><span class="sxs-lookup"><span data-stu-id="bc64f-278">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc64f-279">等待指定数组中的所有元素都收到信号。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-279">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="bc64f-280">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-280">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="bc64f-281">此数组不能包含对同一对象的多个引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-281">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-282">等待指定数组中的所有元素都收到信号。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-282">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-283">如果 <see langword="true" /> 中的每个元素都收到信号，则返回 <paramref name="waitHandles" />；否则该方法永不返回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-283">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-284"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新增功能。</span><span class="sxs-lookup"><span data-stu-id="bc64f-284"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bc64f-285">在上一版本中，<xref:System.Threading.WaitHandle.WaitAll%2A>方法将返回`true`时放弃的互斥体。</span><span class="sxs-lookup"><span data-stu-id="bc64f-285">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="bc64f-286">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="bc64f-286">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bc64f-287">在系统范围的情况下它可能指示，已突然终止应用程序 （例如，通过使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="bc64f-287">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bc64f-288">该异常包含有关调试的有用信息。</span><span class="sxs-lookup"><span data-stu-id="bc64f-288">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bc64f-289"><xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时都收到信号的句柄。</span><span class="sxs-lookup"><span data-stu-id="bc64f-289">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="bc64f-290">在某些实现中，如果传递的 64 个以上的句柄，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="bc64f-290">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="bc64f-291">如果数组包含重复项，调用将失败<xref:System.DuplicateWaitObjectException>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-291">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc64f-292"><xref:System.Threading.WaitHandle.WaitAll%2A>方法不支持在具有的线程上<xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-292">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="bc64f-293">调用此方法重载是等效于调用<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>方法重载并指定-1 (或<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) 用于`millisecondsTimeout`并`true`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="bc64f-293">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc64f-294">下面的代码示例演示如何使用线程池以异步方式创建和写入的文件组。</span><span class="sxs-lookup"><span data-stu-id="bc64f-294">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="bc64f-295">完成后，每个写入操作排队作为工作项和信号。</span><span class="sxs-lookup"><span data-stu-id="bc64f-295">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="bc64f-296">主线程等待发出信号的所有项，然后退出。</span><span class="sxs-lookup"><span data-stu-id="bc64f-296">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc64f-297">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-297">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-298">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-298">-or-</span>
          </span>
          <span data-ttu-id="bc64f-299">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-299">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-300">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-300">-or-</span>
          </span>
          <span data-ttu-id="bc64f-301">
            <paramref name="waitHandles" /> 为不具有元素的数组且 .NET Framework 版本为 2.0 或更高版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-301">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="bc64f-302">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.ArgumentException" />。</span>
              <span class="sxs-lookup">
                <span data-stu-id="bc64f-302">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="bc64f-303">
            <paramref name="waitHandles" /> 数组包含重复的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-303">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc64f-304">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-304">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="bc64f-305">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-305">-or-</span>
          </span>
          <span data-ttu-id="bc64f-306">
            <see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-306">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="bc64f-307">
            <paramref name="waitHandles" /> 数组不含任何元素，并且 .NET Framework 版本为 1.0 或 1.1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-307">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-308">等待终止，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-308">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-309">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-309">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-310">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-310">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="bc64f-311">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-311">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="bc64f-312">此数组不能包含对同一对象的多个引用（重复的元素）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-312">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="bc64f-313">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-313">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-314">等待指定数组中的所有元素接收信号，同时使用 <see cref="T:System.Int32" /> 值指定时间间隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-314">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-315">如果 <paramref name="waitHandles" /> 中的每个元素都已收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-315">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-316">如果`millisecondsTimeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="bc64f-316">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="bc64f-317">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="bc64f-317">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bc64f-318"><xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时，等待将终止，这意味着所有句柄都已终止或出现超时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-318">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="bc64f-319">在某些实现中，如果传递的 64 个以上的句柄，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="bc64f-319">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="bc64f-320">如果数组中有重复项，调用将失败<xref:System.DuplicateWaitObjectException>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-320">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc64f-321"><xref:System.Threading.WaitHandle.WaitAll%2A>方法不支持在具有的线程上<xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-321">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="bc64f-322">调用此方法的重载相当于调用<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="bc64f-322">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc64f-323">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-323">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-324">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-324">-or-</span>
          </span>
          <span data-ttu-id="bc64f-325">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-325">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-326">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-326">-or-</span>
          </span>
          <span data-ttu-id="bc64f-327">
            <paramref name="waitHandles" /> 是一个不含任何元素的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-327">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="bc64f-328">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.ArgumentException" />。</span>
              <span class="sxs-lookup">
                <span data-stu-id="bc64f-328">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="bc64f-329">
            <paramref name="waitHandles" /> 数组包含重复的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-329">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc64f-330">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-330">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="bc64f-331">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-331">-or-</span>
          </span>
          <span data-ttu-id="bc64f-332">
            <see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-332">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc64f-333">
            <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-333">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-334">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-334">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-335">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-335">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-336">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-336">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="bc64f-337">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-337">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="bc64f-338">此数组不能包含对同一对象的多个引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-338">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="bc64f-339">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-339">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-340">等待指定数组中的所有元素接收信号，同时使用 <see cref="T:System.TimeSpan" /> 值指定时间间隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-340">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-341">如果 <paramref name="waitHandles" /> 中的每个元素都已收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-341">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-342">如果`timeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="bc64f-342">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="bc64f-343">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="bc64f-343">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bc64f-344"><xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时，等待将终止，这意味着所有句柄都已终止或发生超时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-344">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="bc64f-345">在某些实现中，如果传递的 64 个以上的句柄，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="bc64f-345">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="bc64f-346">如果数组包含重复项，则调用将失败。</span><span class="sxs-lookup"><span data-stu-id="bc64f-346">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc64f-347"><xref:System.Threading.WaitHandle.WaitAll%2A>方法不支持在具有的线程上<xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-347">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="bc64f-348">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-348">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bc64f-349">调用此方法的重载相当于调用<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="bc64f-349">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc64f-350">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-350">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-351">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-351">-or-</span>
          </span>
          <span data-ttu-id="bc64f-352">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-352">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-353">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-353">-or-</span>
          </span>
          <span data-ttu-id="bc64f-354">
            <paramref name="waitHandles" /> 是一个不含任何元素的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-354">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="bc64f-355">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.ArgumentException" />。</span>
              <span class="sxs-lookup">
                <span data-stu-id="bc64f-355">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="bc64f-356">
            <paramref name="waitHandles" /> 数组包含重复的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-356">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc64f-357">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-357">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="bc64f-358">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-358">-or-</span>
          </span>
          <span data-ttu-id="bc64f-359">
            <see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-359">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc64f-360">
            <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-360">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="bc64f-361">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-361">-or-</span>
          </span>
          <span data-ttu-id="bc64f-362">
            <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-362">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-363">等待终止，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-363">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-364">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-364">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-365">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-365">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="bc64f-366">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-366">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="bc64f-367">此数组不能包含对同一对象的多个引用（重复的元素）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-367">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="bc64f-368">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-368">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="bc64f-369">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-369">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-370">等待指定数组中的所有元素收到信号，使用 <see cref="T:System.Int32" /> 值指定时间间隔，并指定是否在等待之前退出同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-370">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-371">如果 <paramref name="waitHandles" /> 中的每个元素都已收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-371">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-372">如果`millisecondsTimeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="bc64f-372">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="bc64f-373">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="bc64f-373">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bc64f-374"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新增功能。</span><span class="sxs-lookup"><span data-stu-id="bc64f-374"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bc64f-375">在上一版本中，<xref:System.Threading.WaitHandle.WaitAll%2A>方法将返回`true`时放弃的互斥体。</span><span class="sxs-lookup"><span data-stu-id="bc64f-375">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="bc64f-376">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="bc64f-376">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bc64f-377">在系统范围的情况下它可能指示，已突然终止应用程序 （例如，通过使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="bc64f-377">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bc64f-378">该异常包含有关调试的有用信息。</span><span class="sxs-lookup"><span data-stu-id="bc64f-378">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bc64f-379"><xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时，等待将终止，这意味着所有句柄都已终止或出现超时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-379">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="bc64f-380">在某些实现中，如果传递的 64 个以上的句柄，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="bc64f-380">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="bc64f-381">如果数组中有重复项，调用将失败<xref:System.DuplicateWaitObjectException>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-381">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc64f-382"><xref:System.Threading.WaitHandle.WaitAll%2A>方法不支持在具有的线程上<xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-382">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bc64f-383">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="bc64f-383">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bc64f-384">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitAll%2A>从非默认托管上下文中调用方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-384">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bc64f-385">如果你的线程是派生自的类的实例的调用内部发生这种情况<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-385">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bc64f-386">即使当前正在执行一种方法不派生自的类上<xref:System.ContextBoundObject>，例如<xref:System.String>，可以在非默认上下文中是如果<xref:System.ContextBoundObject>是当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="bc64f-386">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bc64f-387">时在非默认上下文中执行代码时，指定`true`有关`exitContext`会导致线程退出非默认托管的上下文 (即，转换到默认上下文) 执行前<xref:System.Threading.WaitHandle.WaitAll%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-387">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="bc64f-388">线程在调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitAll%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="bc64f-388">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="bc64f-389">在上下文绑定类时这很有用<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>属性。</span><span class="sxs-lookup"><span data-stu-id="bc64f-389">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="bc64f-390">在这种情况下，所有调用的类的成员将自动都同步，并同步域是为类代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="bc64f-390">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bc64f-391">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitAll%2A>方法，并指定`true`为`exitContext`，在线程退出同步域，这样在调用对象的任何成员以继续操作被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="bc64f-391">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bc64f-392">当<xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时，调用线程必须等待以重新输入同步域。</span><span class="sxs-lookup"><span data-stu-id="bc64f-392">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc64f-393">下面的代码示例演示如何使用线程池以异步方式创建和写入的文件组。</span><span class="sxs-lookup"><span data-stu-id="bc64f-393">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="bc64f-394">完成后，每个写入操作排队作为工作项和信号。</span><span class="sxs-lookup"><span data-stu-id="bc64f-394">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="bc64f-395">主线程等待发出信号的所有项，然后退出。</span><span class="sxs-lookup"><span data-stu-id="bc64f-395">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc64f-396">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-396">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-397">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-397">-or-</span>
          </span>
          <span data-ttu-id="bc64f-398">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-398">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-399">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-399">-or-</span>
          </span>
          <span data-ttu-id="bc64f-400">
            <paramref name="waitHandles" /> 为不具有元素的数组且 .NET Framework 版本为 2.0 或更高版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-400">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="bc64f-401">
            <paramref name="waitHandles" /> 数组包含重复的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-401">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc64f-402">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-402">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="bc64f-403">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-403">-or-</span>
          </span>
          <span data-ttu-id="bc64f-404">
            <see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-404">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="bc64f-405">
            <paramref name="waitHandles" /> 数组不含任何元素，并且 .NET Framework 版本为 1.0 或 1.1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-405">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc64f-406">
            <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-406">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-407">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-407">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-408">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-408">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-409">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-409">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="bc64f-410">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-410">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="bc64f-411">此数组不能包含对同一对象的多个引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-411">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="bc64f-412">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-412">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="bc64f-413">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-413">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-414">等待指定数组中的所有元素收到信号，使用 <see cref="T:System.TimeSpan" /> 值指定时间间隔，并指定是否在等待之前退出同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-414">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-415">如果 <paramref name="waitHandles" /> 中的每个元素都收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-415">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-416">如果`timeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="bc64f-416">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="bc64f-417">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="bc64f-417">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bc64f-418"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新增功能。</span><span class="sxs-lookup"><span data-stu-id="bc64f-418"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bc64f-419">在上一版本中，<xref:System.Threading.WaitHandle.WaitAll%2A>方法将返回`true`时放弃的互斥体。</span><span class="sxs-lookup"><span data-stu-id="bc64f-419">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="bc64f-420">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="bc64f-420">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bc64f-421">在系统范围的情况下它可能指示，已突然终止应用程序 （例如，通过使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="bc64f-421">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bc64f-422">该异常包含有关调试的有用信息。</span><span class="sxs-lookup"><span data-stu-id="bc64f-422">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bc64f-423"><xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时，等待将终止，这意味着所有句柄都已终止或发生超时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-423">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="bc64f-424">在某些实现中，如果传递的 64 个以上的句柄，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="bc64f-424">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="bc64f-425">如果数组包含重复项，则调用将失败。</span><span class="sxs-lookup"><span data-stu-id="bc64f-425">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc64f-426"><xref:System.Threading.WaitHandle.WaitAll%2A>方法不支持在具有的线程上<xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-426">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="bc64f-427">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-427">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bc64f-428">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="bc64f-428">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bc64f-429">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitAll%2A>从非默认托管上下文中调用方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-429">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bc64f-430">如果你的线程是派生自的类的实例的调用内部发生这种情况<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-430">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bc64f-431">即使当前正在执行一种方法不派生自的类上<xref:System.ContextBoundObject>，例如<xref:System.String>，可以在非默认上下文中是如果<xref:System.ContextBoundObject>是当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="bc64f-431">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bc64f-432">时在非默认上下文中执行代码时，指定`true`有关`exitContext`会导致线程退出非默认托管的上下文 (即，转换到默认上下文) 执行前<xref:System.Threading.WaitHandle.WaitAll%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-432">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="bc64f-433">在调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitAll%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="bc64f-433">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="bc64f-434">在上下文绑定类时这很有用<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-434">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="bc64f-435">在这种情况下，所有调用的类的成员将自动都同步，并同步域是为类代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="bc64f-435">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bc64f-436">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitAll%2A>方法，并指定`true`为`exitContext`，在线程退出同步域，这样在调用对象的任何成员以继续操作被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="bc64f-436">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bc64f-437">当<xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时，调用线程必须等待以重新输入同步域。</span><span class="sxs-lookup"><span data-stu-id="bc64f-437">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc64f-438">下面的代码示例演示如何使用线程池以异步方式创建和写入的文件组。</span><span class="sxs-lookup"><span data-stu-id="bc64f-438">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="bc64f-439">完成后，每个写入操作排队作为工作项和信号。</span><span class="sxs-lookup"><span data-stu-id="bc64f-439">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="bc64f-440">主线程等待发出信号的所有项，然后退出。</span><span class="sxs-lookup"><span data-stu-id="bc64f-440">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc64f-441">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-441">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-442">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-442">-or-</span>
          </span>
          <span data-ttu-id="bc64f-443">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-443">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-444">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-444">-or-</span>
          </span>
          <span data-ttu-id="bc64f-445">
            <paramref name="waitHandles" /> 为不具有元素的数组且 .NET Framework 版本为 2.0 或更高版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-445">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="bc64f-446">
            <paramref name="waitHandles" /> 数组包含重复的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-446">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc64f-447">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-447">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="bc64f-448">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-448">-or-</span>
          </span>
          <span data-ttu-id="bc64f-449">
            <see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-449">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="bc64f-450">
            <paramref name="waitHandles" /> 数组不含任何元素，并且 .NET Framework 版本为 1.0 或 1.1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-450">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc64f-451">
            <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-451">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="bc64f-452">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-452">-or-</span>
          </span>
          <span data-ttu-id="bc64f-453">
            <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-453">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-454">等待终止，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-454">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-455">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-455">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-456">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-456">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc64f-457">等待指定数组中的任一元素收到信号。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-457">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="bc64f-458">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-458">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-459">等待指定数组中的任一元素收到信号。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-459">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-460">满足等待的对象的数组索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-460">The array index of the object that satisfied the wait.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-461"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新增功能。</span><span class="sxs-lookup"><span data-stu-id="bc64f-461"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bc64f-462">在上一版本中，<xref:System.Threading.WaitHandle.WaitAny%2A>方法将返回`true`如果等待完成，因为已放弃的互斥体。</span><span class="sxs-lookup"><span data-stu-id="bc64f-462">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="bc64f-463">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="bc64f-463">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bc64f-464">在系统范围的情况下它可能指示，已突然终止应用程序 （例如，通过使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="bc64f-464">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bc64f-465">该异常包含有关调试的有用信息。</span><span class="sxs-lookup"><span data-stu-id="bc64f-465">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bc64f-466"><xref:System.Threading.WaitHandle.WaitAny%2A>方法会抛出<xref:System.Threading.AbandonedMutexException>仅等待完成由于已放弃的互斥体。</span><span class="sxs-lookup"><span data-stu-id="bc64f-466">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="bc64f-467">如果`waitHandles`包含具有较低的索引号比放弃的互斥体，释放的互斥体<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="bc64f-467">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc64f-468">在版本的.NET Framework 版本 2.0 中，如果一个线程退出或中止，且不显式地释放低于<xref:System.Threading.Mutex>，并且`Mutex`中位于索引 0 （零）`WaitAny`上另一个线程，返回的索引数组`WaitAny`是而不是 0 128。</span><span class="sxs-lookup"><span data-stu-id="bc64f-468">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="bc64f-469">此方法返回时任何句柄发出信号。</span><span class="sxs-lookup"><span data-stu-id="bc64f-469">This method returns when any handle is signaled.</span></span> <span data-ttu-id="bc64f-470">如果多个对象在调用期间将被发送信号，则返回值是对象的具有所有终止的对象的最小索引值终止的数组索引。</span><span class="sxs-lookup"><span data-stu-id="bc64f-470">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="bc64f-471">在某些实现中，如果多个传递的句柄 64，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="bc64f-471">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="bc64f-472">调用此方法重载是等效于调用<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>方法重载并指定-1 (或<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) 用于`millisecondsTimeout`并`true`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="bc64f-472">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc64f-473">下面的代码示例演示如何调用<xref:System.Threading.WaitHandle.WaitAny%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-473">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc64f-474">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-474">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-475">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-475">-or-</span>
          </span>
          <span data-ttu-id="bc64f-476">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-476">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc64f-477">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-477">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="bc64f-478">
            <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 1.0 或 1.1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-478">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-479">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-479">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-480">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-480">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc64f-481">
            <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 2.0 或更高。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-481">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-482">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-482">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="bc64f-483">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-483">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="bc64f-484">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-484">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-485">等待指定数组中的任意元素接收信号，同时使用 32 位有符号整数指定时间间隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-485">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-486">满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <paramref name="millisecondsTimeout" /> 的时间间隔已过，则为 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-486">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-487">如果`millisecondsTimeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="bc64f-487">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="bc64f-488">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="bc64f-488">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bc64f-489"><xref:System.Threading.WaitHandle.WaitAny%2A>方法会抛出<xref:System.Threading.AbandonedMutexException>仅等待完成由于已放弃的互斥体。</span><span class="sxs-lookup"><span data-stu-id="bc64f-489">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="bc64f-490">如果`waitHandles`包含具有较低的索引号比放弃的互斥体，释放的互斥体<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="bc64f-490">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="bc64f-491">此方法返回时，等待将终止，任何句柄发出信号或超时发生时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-491">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="bc64f-492">如果多个对象在调用期间将被发送信号，则返回值是对象的具有所有终止的对象的最小索引值终止的数组索引。</span><span class="sxs-lookup"><span data-stu-id="bc64f-492">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="bc64f-493">在某些实现中，如果多个传递的句柄 64，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="bc64f-493">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="bc64f-494">调用此方法的重载相当于调用<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="bc64f-494">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc64f-495">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-495">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-496">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-496">-or-</span>
          </span>
          <span data-ttu-id="bc64f-497">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-497">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc64f-498">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-498">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc64f-499">
            <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-499">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-500">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-500">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-501">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-501">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc64f-502">
            <paramref name="waitHandles" /> 是一个不含任何元素的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-502">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-503">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-503">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="bc64f-504">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-504">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="bc64f-505">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-505">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-506">等待指定数组中的任意元素接收信号，同时使用 <see cref="T:System.TimeSpan" /> 指定时间间隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-506">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-507">满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <paramref name="timeout" /> 的时间间隔已过，则为 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-507">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-508">如果`timeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="bc64f-508">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="bc64f-509">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="bc64f-509">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bc64f-510"><xref:System.Threading.WaitHandle.WaitAny%2A>方法会抛出<xref:System.Threading.AbandonedMutexException>仅等待完成由于已放弃的互斥体。</span><span class="sxs-lookup"><span data-stu-id="bc64f-510">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="bc64f-511">如果`waitHandles`包含具有较低的索引号比放弃的互斥体，释放的互斥体<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="bc64f-511">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="bc64f-512">此方法返回时，等待将终止，任何句柄发出信号时或发生超时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-512">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="bc64f-513">如果多个对象在调用期间将被发送信号，则返回值是对象的具有所有终止的对象的最小索引值终止的数组索引。</span><span class="sxs-lookup"><span data-stu-id="bc64f-513">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="bc64f-514">在某些实现中，如果多个传递的句柄 64，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="bc64f-514">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="bc64f-515">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-515">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bc64f-516">调用此方法的重载相当于调用<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="bc64f-516">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc64f-517">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-517">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-518">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-518">-or-</span>
          </span>
          <span data-ttu-id="bc64f-519">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-519">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc64f-520">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-520">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc64f-521">
            <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-521">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="bc64f-522">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-522">-or-</span>
          </span>
          <span data-ttu-id="bc64f-523">
            <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-523">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-524">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-524">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-525">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-525">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc64f-526">
            <paramref name="waitHandles" /> 是一个不含任何元素的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-526">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-527">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-527">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="bc64f-528">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-528">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="bc64f-529">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-529">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="bc64f-530">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-530">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-531">等待指定数组中的任一元素收到信号，使用 32 位带符号整数指定时间间隔并指定是否在等待之前退出同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-531">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-532">满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <paramref name="millisecondsTimeout" /> 的时间间隔已过，则为 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-532">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-533">如果`millisecondsTimeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="bc64f-533">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="bc64f-534">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="bc64f-534">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bc64f-535"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新增功能。</span><span class="sxs-lookup"><span data-stu-id="bc64f-535"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bc64f-536">在上一版本中，<xref:System.Threading.WaitHandle.WaitAny%2A>方法将返回`true`如果等待完成，因为已放弃的互斥体。</span><span class="sxs-lookup"><span data-stu-id="bc64f-536">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="bc64f-537">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="bc64f-537">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bc64f-538">在系统范围的情况下它可能指示，已突然终止应用程序 （例如，通过使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="bc64f-538">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bc64f-539">该异常包含有关调试的有用信息。</span><span class="sxs-lookup"><span data-stu-id="bc64f-539">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bc64f-540"><xref:System.Threading.WaitHandle.WaitAny%2A>方法会抛出<xref:System.Threading.AbandonedMutexException>仅等待完成由于已放弃的互斥体。</span><span class="sxs-lookup"><span data-stu-id="bc64f-540">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="bc64f-541">如果`waitHandles`包含具有较低的索引号比放弃的互斥体，释放的互斥体<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="bc64f-541">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc64f-542">在版本的.NET Framework 版本 2.0 中，如果一个线程退出或中止，且不显式地释放低于<xref:System.Threading.Mutex>，并且`Mutex`中位于索引 0 （零）`WaitAny`上另一个线程，返回的索引数组`WaitAny`是而不是 0 128。</span><span class="sxs-lookup"><span data-stu-id="bc64f-542">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="bc64f-543">此方法返回时，等待将终止，任何句柄发出信号或超时发生时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-543">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="bc64f-544">如果多个对象在调用期间将被发送信号，则返回值是对象的具有所有终止的对象的最小索引值终止的数组索引。</span><span class="sxs-lookup"><span data-stu-id="bc64f-544">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="bc64f-545">在某些实现中，如果多个传递的句柄 64，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="bc64f-545">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bc64f-546">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="bc64f-546">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bc64f-547">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitAny%2A>从非默认托管上下文中调用方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-547">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bc64f-548">如果你的线程是派生自的类的实例的调用内部发生这种情况<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-548">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bc64f-549">即使当前正在执行一种方法不是派生的类上<xref:System.ContextBoundObject>，例如<xref:System.String>，可以在非默认上下文中是如果<xref:System.ContextBoundObject>是当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="bc64f-549">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bc64f-550">时在非默认上下文中执行代码时，指定`true`有关`exitContext`会导致线程退出非默认托管的上下文 (即，转换到默认上下文) 执行前<xref:System.Threading.WaitHandle.WaitAny%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-550">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="bc64f-551">线程在调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitAny%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="bc64f-551">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="bc64f-552">在上下文绑定类时这很有用<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-552">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="bc64f-553">在这种情况下，所有调用的类的成员将自动都同步，并同步域是为类代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="bc64f-553">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bc64f-554">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitAny%2A>方法，并指定`true`为`exitContext`，在线程退出同步域，这样在调用对象的任何成员以继续操作被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="bc64f-554">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bc64f-555">当<xref:System.Threading.WaitHandle.WaitAny%2A>方法返回时，调用线程必须等待以重新输入同步域。</span><span class="sxs-lookup"><span data-stu-id="bc64f-555">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc64f-556">下面的代码示例演示如何使用线程池来同时搜索多个磁盘上的文件。</span><span class="sxs-lookup"><span data-stu-id="bc64f-556">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="bc64f-557">有关空间注意事项，搜索每个磁盘的根目录。</span><span class="sxs-lookup"><span data-stu-id="bc64f-557">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc64f-558">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-558">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-559">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-559">-or-</span>
          </span>
          <span data-ttu-id="bc64f-560">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-560">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc64f-561">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-561">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="bc64f-562">
            <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 1.0 或 1.1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-562">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc64f-563">
            <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-563">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-564">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-564">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-565">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-565">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc64f-566">
            <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 2.0 或更高。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-566">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-567">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-567">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="bc64f-568">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-568">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="bc64f-569">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-569">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="bc64f-570">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-570">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-571">等待指定数组中的任一元素收到信号，使用 <see cref="T:System.TimeSpan" /> 指定时间间隔并指定是否在等待之前退出同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-571">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-572">满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <paramref name="timeout" /> 的时间间隔已过，则为 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-572">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-573">如果`timeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="bc64f-573">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="bc64f-574">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="bc64f-574">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="bc64f-575"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新增功能。</span><span class="sxs-lookup"><span data-stu-id="bc64f-575"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bc64f-576">在上一版本中，<xref:System.Threading.WaitHandle.WaitAny%2A>方法将返回`true`如果等待完成，因为已放弃的互斥体。</span><span class="sxs-lookup"><span data-stu-id="bc64f-576">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="bc64f-577">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="bc64f-577">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bc64f-578">在系统范围的情况下它可能指示，已突然终止应用程序 （例如，通过使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="bc64f-578">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bc64f-579">该异常包含有关调试的有用信息。</span><span class="sxs-lookup"><span data-stu-id="bc64f-579">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bc64f-580"><xref:System.Threading.WaitHandle.WaitAny%2A>方法会抛出<xref:System.Threading.AbandonedMutexException>仅等待完成由于已放弃的互斥体。</span><span class="sxs-lookup"><span data-stu-id="bc64f-580">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="bc64f-581">如果`waitHandles`包含具有较低的索引号比放弃的互斥体，释放的互斥体<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="bc64f-581">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bc64f-582">在版本的.NET Framework 版本 2.0 中，如果一个线程退出或中止，且不显式地释放低于<xref:System.Threading.Mutex>，并且`Mutex`中位于索引 0 （零）`WaitAny`上另一个线程，返回的索引数组`WaitAny`是而不是 0 128。</span><span class="sxs-lookup"><span data-stu-id="bc64f-582">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="bc64f-583">此方法返回时，等待将终止，任何句柄发出信号时或发生超时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-583">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="bc64f-584">如果多个对象在调用期间将被发送信号，则返回值是对象的具有所有终止的对象的最小索引值终止的数组索引。</span><span class="sxs-lookup"><span data-stu-id="bc64f-584">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="bc64f-585">在某些实现中，如果多个传递的句柄 64，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="bc64f-585">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="bc64f-586">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-586">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bc64f-587">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="bc64f-587">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bc64f-588">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitAny%2A>从非默认托管上下文中调用方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-588">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bc64f-589">如果你的线程是派生自的类的实例的调用内部发生这种情况<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-589">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bc64f-590">即使当前正在执行一种方法不是派生的类上<xref:System.ContextBoundObject>，例如<xref:System.String>，可以在非默认上下文中是如果<xref:System.ContextBoundObject>是当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="bc64f-590">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bc64f-591">时在非默认上下文中执行代码时，指定`true`有关`exitContext`会导致线程退出非默认托管的上下文 (即，转换到默认上下文) 执行前<xref:System.Threading.WaitHandle.WaitAny%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-591">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="bc64f-592">线程在调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitAny%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="bc64f-592">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="bc64f-593">在上下文绑定类时这很有用<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-593">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="bc64f-594">在这种情况下，所有调用的类的成员将自动都同步，并同步域是为类代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="bc64f-594">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bc64f-595">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitAny%2A>方法，并指定`true`为`exitContext`，在线程退出同步域，这样在调用对象的任何成员以继续操作被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="bc64f-595">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bc64f-596">当<xref:System.Threading.WaitHandle.WaitAny%2A>方法返回时，调用线程必须等待以重新输入同步域。</span><span class="sxs-lookup"><span data-stu-id="bc64f-596">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc64f-597">下面的代码示例演示如何使用线程池来同时搜索多个磁盘上的文件。</span><span class="sxs-lookup"><span data-stu-id="bc64f-597">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="bc64f-598">有关空间注意事项，搜索每个磁盘的根目录。</span><span class="sxs-lookup"><span data-stu-id="bc64f-598">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="bc64f-599">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-599">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="bc64f-600">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-600">-or-</span>
          </span>
          <span data-ttu-id="bc64f-601">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-601">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="bc64f-602">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-602">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="bc64f-603">
            <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 1.0 或 1.1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-603">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc64f-604">
            <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-604">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="bc64f-605">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-605">-or-</span>
          </span>
          <span data-ttu-id="bc64f-606">
            <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-606">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-607">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-607">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-608">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-608">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="bc64f-609">
            <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 2.0 或更高。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-609">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-610">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-610">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bc64f-611">阻止当前线程，直到当前 <see cref="T:System.Threading.WaitHandle" /> 收到信号。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-611">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bc64f-612">阻止当前线程，直到当前 <see cref="T:System.Threading.WaitHandle" /> 收到信号。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-612">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-613">如果当前实例收到信号，则为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-613">
              <see langword="true" /> if the current instance receives a signal.</span>
          </span>
          <span data-ttu-id="bc64f-614">如果当前实例永不发出信号，则 <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> 永不返回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-614">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-615"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新增功能。</span><span class="sxs-lookup"><span data-stu-id="bc64f-615"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bc64f-616">在上一版本中，<xref:System.Threading.WaitHandle.WaitOne%2A>方法将返回`true`时放弃的互斥体。</span><span class="sxs-lookup"><span data-stu-id="bc64f-616">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="bc64f-617">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="bc64f-617">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bc64f-618">在系统范围的情况下它可能指示，已突然终止应用程序 （例如，通过使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="bc64f-618">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bc64f-619">该异常包含有关调试的有用信息。</span><span class="sxs-lookup"><span data-stu-id="bc64f-619">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bc64f-620">此方法进行阻止，直到当前实例无限期的调用方收到信号。</span><span class="sxs-lookup"><span data-stu-id="bc64f-620">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="bc64f-621">使用此方法进行阻止，直至<xref:System.Threading.WaitHandle>从另一个线程收到信号，例如则会生成异步操作完成时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-621">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="bc64f-622">有关详细信息，请参阅<xref:System.IAsyncResult>接口。</span><span class="sxs-lookup"><span data-stu-id="bc64f-622">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="bc64f-623">调用此方法重载是等效于调用<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>方法重载并指定-1 或<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>第一个参数和`false`为第二个参数。</span><span class="sxs-lookup"><span data-stu-id="bc64f-623">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="bc64f-624">重写此方法以自定义派生类的行为。</span><span class="sxs-lookup"><span data-stu-id="bc64f-624">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc64f-625">下面的代码示例演示如何使用等待句柄以防止进程终止等待后台线程完成执行时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-625">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc64f-626">已释放当前实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-626">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-627">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-627">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-628">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-628">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-629">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-629">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="bc64f-630">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-630">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-631">阻止当前线程，直到当前 <see cref="T:System.Threading.WaitHandle" /> 收到信号，同时使用 32 位带符号整数指定时间间隔（以毫秒为单位）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-631">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-632">如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-632">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-633">如果`millisecondsTimeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="bc64f-633">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="bc64f-634">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="bc64f-634">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="bc64f-635">此方法受到阻止，直到当前实例收到信号或超时的调用方会发生。</span><span class="sxs-lookup"><span data-stu-id="bc64f-635">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="bc64f-636">使用此方法进行阻止，直至<xref:System.Threading.WaitHandle>从另一个线程收到信号，例如则会生成异步操作完成时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-636">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="bc64f-637">有关详细信息，请参阅<xref:System.IAsyncResult>接口。</span><span class="sxs-lookup"><span data-stu-id="bc64f-637">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="bc64f-638">重写此方法以自定义派生类的行为。</span><span class="sxs-lookup"><span data-stu-id="bc64f-638">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="bc64f-639">调用此方法的重载相当于调用<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="bc64f-639">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc64f-640">下面的代码示例演示如何使用等待句柄以防止进程终止等待后台线程完成执行时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-640">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc64f-641">已释放当前实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-641">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc64f-642">
            <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-642">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-643">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-643">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-644">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-644">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-645">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-645">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="bc64f-646">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-646">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-647">阻止当前线程，直到当前实例收到信号，同时使用 <see cref="T:System.TimeSpan" /> 指定时间间隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-647">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-648">如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-648">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-649">如果`timeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="bc64f-649">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="bc64f-650">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="bc64f-650">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="bc64f-651">此方法受到阻止，直到当前实例收到信号或超时的调用方会发生。</span><span class="sxs-lookup"><span data-stu-id="bc64f-651">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="bc64f-652">使用此方法进行阻止，直至<xref:System.Threading.WaitHandle>从另一个线程收到信号，例如则会生成异步操作完成时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-652">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="bc64f-653">有关详细信息，请参阅<xref:System.IAsyncResult>接口。</span><span class="sxs-lookup"><span data-stu-id="bc64f-653">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="bc64f-654">重写此方法以自定义派生类的行为。</span><span class="sxs-lookup"><span data-stu-id="bc64f-654">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="bc64f-655">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-655">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="bc64f-656">调用此方法的重载相当于调用<xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="bc64f-656">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc64f-657">已释放当前实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-657">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc64f-658">
            <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-658">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="bc64f-659">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-659">-or-</span>
          </span>
          <span data-ttu-id="bc64f-660">
            <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-660">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-661">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-661">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-662">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-662">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-663">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-663">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="bc64f-664">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-664">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="bc64f-665">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-665">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-666">阻止当前线程，直到当前的 <see cref="T:System.Threading.WaitHandle" /> 收到信号为止，同时使用 32 位带符号整数指定时间间隔，并指定是否在等待之前退出同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-666">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-667">如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-667">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-668">如果`millisecondsTimeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="bc64f-668">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="bc64f-669">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="bc64f-669">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="bc64f-670"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新增功能。</span><span class="sxs-lookup"><span data-stu-id="bc64f-670"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bc64f-671">在上一版本中，<xref:System.Threading.WaitHandle.WaitOne%2A>方法将返回`true`时放弃的互斥体。</span><span class="sxs-lookup"><span data-stu-id="bc64f-671">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="bc64f-672">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="bc64f-672">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bc64f-673">在系统范围的情况下它可能指示，已突然终止应用程序 （例如，通过使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="bc64f-673">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bc64f-674">该异常包含有关调试的有用信息。</span><span class="sxs-lookup"><span data-stu-id="bc64f-674">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bc64f-675">此方法受到阻止，直到当前实例收到信号或超时的调用方会发生。</span><span class="sxs-lookup"><span data-stu-id="bc64f-675">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="bc64f-676">使用此方法进行阻止，直至<xref:System.Threading.WaitHandle>从另一个线程收到信号，例如则会生成异步操作完成时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-676">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="bc64f-677">有关详细信息，请参阅<xref:System.IAsyncResult>接口。</span><span class="sxs-lookup"><span data-stu-id="bc64f-677">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="bc64f-678">重写此方法以自定义派生类的行为。</span><span class="sxs-lookup"><span data-stu-id="bc64f-678">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bc64f-679">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="bc64f-679">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bc64f-680">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitOne%2A>从非默认托管上下文中调用方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-680">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bc64f-681">如果你的线程是派生自的类的实例的调用内部发生这种情况<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-681">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bc64f-682">即使当前正在执行一种方法不是派生的类上<xref:System.ContextBoundObject>，例如<xref:System.String>，可以在非默认上下文中是如果<xref:System.ContextBoundObject>是当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="bc64f-682">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bc64f-683">时在非默认上下文中执行代码时，指定`true`有关`exitContext`会导致线程退出非默认托管的上下文 (即，转换到默认上下文) 执行前<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-683">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="bc64f-684">线程在调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitOne%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="bc64f-684">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="bc64f-685">在上下文绑定类时这很有用<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-685">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="bc64f-686">在这种情况下，所有调用的类的成员将自动都同步，并同步域是为类代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="bc64f-686">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bc64f-687">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitOne%2A>方法，并指定`true`为`exitContext`，在线程退出同步域，这样在调用对象的任何成员以继续操作被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="bc64f-687">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bc64f-688">当<xref:System.Threading.WaitHandle.WaitOne%2A>方法返回时，调用线程必须等待以重新输入同步域。</span><span class="sxs-lookup"><span data-stu-id="bc64f-688">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc64f-689">下面的示例演示如何将<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>方法重载的行为与在一个域中同步调用时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-689">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="bc64f-690">首先的线程在等待`exitContext`设置为`false`并阻止，直到等待超时过期。</span><span class="sxs-lookup"><span data-stu-id="bc64f-690">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="bc64f-691">第二个线程执行后的第一个线程终止，并使用在等待`exitContext`设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="bc64f-691">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="bc64f-692">此第二个线程的等待句柄发送信号的调用未被阻止，并在线程等待超时前完成。</span><span class="sxs-lookup"><span data-stu-id="bc64f-692">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc64f-693">已释放当前实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-693">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc64f-694">
            <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-694">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-695">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-695">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-696">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-696">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-697">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-697">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="bc64f-698">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-698">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="bc64f-699">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-699">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bc64f-700">阻止当前线程，直到当前实例收到信号为止，同时使用 <see cref="T:System.TimeSpan" /> 指定时间间隔，并指定是否在等待之前退出同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-700">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bc64f-701">如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-701">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-702">如果`timeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="bc64f-702">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="bc64f-703">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="bc64f-703">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="bc64f-704"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新增功能。</span><span class="sxs-lookup"><span data-stu-id="bc64f-704"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="bc64f-705">在上一版本中，<xref:System.Threading.WaitHandle.WaitOne%2A>方法将返回`true`时放弃的互斥体。</span><span class="sxs-lookup"><span data-stu-id="bc64f-705">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="bc64f-706">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="bc64f-706">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="bc64f-707">在系统范围的情况下它可能指示，已突然终止应用程序 （例如，通过使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="bc64f-707">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="bc64f-708">该异常包含有关调试的有用信息。</span><span class="sxs-lookup"><span data-stu-id="bc64f-708">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="bc64f-709">此方法受到阻止，直到当前实例收到信号或超时的调用方会发生。</span><span class="sxs-lookup"><span data-stu-id="bc64f-709">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="bc64f-710">使用此方法进行阻止，直至<xref:System.Threading.WaitHandle>从另一个线程收到信号，例如则会生成异步操作完成时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-710">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="bc64f-711">有关详细信息，请参阅<xref:System.IAsyncResult>接口。</span><span class="sxs-lookup"><span data-stu-id="bc64f-711">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="bc64f-712">重写此方法以自定义派生类的行为。</span><span class="sxs-lookup"><span data-stu-id="bc64f-712">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="bc64f-713">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-713">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="bc64f-714">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="bc64f-714">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="bc64f-715">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitOne%2A>从非默认托管上下文中调用方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-715">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="bc64f-716">如果你的线程是派生自的类的实例的调用内部发生这种情况<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-716">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="bc64f-717">即使当前正在执行一种方法不是派生的类上<xref:System.ContextBoundObject>，例如<xref:System.String>，可以在非默认上下文中是如果<xref:System.ContextBoundObject>是当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="bc64f-717">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="bc64f-718">时在非默认上下文中执行代码时，指定`true`有关`exitContext`会导致线程退出非默认托管的上下文 (即，转换到默认上下文) 执行前<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="bc64f-718">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="bc64f-719">线程在调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitOne%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="bc64f-719">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="bc64f-720">在上下文绑定类时这很有用<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="bc64f-720">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="bc64f-721">在这种情况下，所有调用的类的成员将自动都同步，并同步域是为类代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="bc64f-721">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="bc64f-722">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitOne%2A>方法，并指定`true`为`exitContext`，在线程退出同步域，这样在调用对象的任何成员以继续操作被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="bc64f-722">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="bc64f-723">当<xref:System.Threading.WaitHandle.WaitOne%2A>方法返回时，调用线程必须等待以重新输入同步域。</span><span class="sxs-lookup"><span data-stu-id="bc64f-723">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc64f-724">下面的代码示例演示如何使用等待句柄以防止进程终止等待后台线程完成执行时。</span><span class="sxs-lookup"><span data-stu-id="bc64f-724">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="bc64f-725">已释放当前实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-725">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="bc64f-726">
            <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-726">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="bc64f-727">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-727">-or-</span>
          </span>
          <span data-ttu-id="bc64f-728">
            <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-728">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="bc64f-729">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-729">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="bc64f-730">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-730">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bc64f-731">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-731">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="bc64f-732">指示在任何等待句柄终止之前 <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> 操作已超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-732">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span>
          </span>
          <span data-ttu-id="bc64f-733">此字段为常数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="bc64f-733">This field is constant.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bc64f-734">此字段是一个可能的返回值的`WaitAny`。</span><span class="sxs-lookup"><span data-stu-id="bc64f-734">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bc64f-735">下面的代码示例演示如何使用线程池来同时搜索多个磁盘上的文件。</span><span class="sxs-lookup"><span data-stu-id="bc64f-735">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="bc64f-736">有关空间注意事项，搜索每个磁盘的根目录。</span><span class="sxs-lookup"><span data-stu-id="bc64f-736">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>