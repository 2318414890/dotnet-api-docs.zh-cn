<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9c30c9bf2d271da2afe9d173213a99d04fceefda" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531501" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>封装等待对共享资源的独占访问的操作系统特定的对象。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.WaitHandle>类封装 Win32 同步句柄，并且用于表示在运行时允许多个等待操作的所有同步对象。 与其他同步对象的等待句柄的比较，请参阅[同步基元概述](~/docs/standard/threading/overview-of-synchronization-primitives.md)。  
  
 <xref:System.Threading.WaitHandle>本身的类为抽象类。 类派生自<xref:System.Threading.WaitHandle>定义信号机制，以指示获取或释放访问共享资源，但它们使用继承<xref:System.Threading.WaitHandle>方法若要在等待访问共享资源。 类派生自<xref:System.Threading.WaitHandle>包括：  
  
-   <xref:System.Threading.Mutex> 类。 请参阅[互斥体](~/docs/standard/threading/mutexes.md)。  
  
-   <xref:System.Threading.EventWaitHandle>类和派生的类，<xref:System.Threading.AutoResetEvent>和<xref:System.Threading.ManualResetEvent>。 请参阅 [EventWaitHandle、AutoResetEvent、CountdownEvent、ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)。  
  
-   <xref:System.Threading.Semaphore> 类。 请参阅[Semaphore 和 SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md)。  
  
 线程在一个单独的等待句柄可以阻止通过调用实例方法<xref:System.Threading.WaitHandle.WaitOne%2A>，由派生自的类继承<xref:System.Threading.WaitHandle>。  
  
 派生的类<xref:System.Threading.WaitHandle>其线程关联的行为有所不同。 事件等待句柄 (<xref:System.Threading.EventWaitHandle>， <xref:System.Threading.AutoResetEvent>，和<xref:System.Threading.ManualResetEvent>) 和信号量不具有线程关联; 任何线程都可以发送的事件等待句柄或信号量。 互斥锁，另一方面，具有线程关联;拥有互斥体的线程必须释放它，并且会引发异常，如果一个线程调用<xref:System.Threading.Mutex.ReleaseMutex%2A>上不拥有互斥体的方法。  
  
 因为<xref:System.Threading.WaitHandle>类派生自<xref:System.MarshalByRefObject>，这些类可以用于跨应用程序域边界同步线程活动。  
  
 及其派生类，除了<xref:System.Threading.WaitHandle>类具有多种直到一个阻塞线程的静态方法或更多的同步对象接收到信号... 这些方法包括：  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>它允许发出信号一个等待句柄并立即等待另一个线程。  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>它允许线程等待直到数组中的所有等待句柄都接收到信号。  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>它允许线程等待，直到已终止的一组指定等待句柄的任何一个。  
  
 这些方法的重载提供放弃等待，并有机会输入允许使用的同步上下文其他线程在等待之前退出同步上下文的超时间隔。  
  
> [!IMPORTANT]
>  此类型实现<xref:System.IDisposable>接口。 完成后使用的类型或其派生的类型的操作后，你应释放类型直接或间接。 若要直接释放类型，调用其<xref:System.Threading.WaitHandle.Close%2A>中的方法`try` / `catch`块。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅中的"使用实现 IDisposable 的对象"部分<xref:System.IDisposable>接口主题。  
  
 <xref:System.Threading.WaitHandle> 实现<xref:System.IDisposable.Dispose%2A>模式。 请参阅[释放模式](~/docs/standard/design-guidelines/dispose-pattern.md)。 派生自<xref:System.Threading.WaitHandle>，使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>属性来存储你的本机句柄操作系统句柄。 不需要重写受保护<xref:System.Threading.WaitHandle.Dispose%2A>方法除非使用更多的非托管的资源。  
  
   
  
## Examples  
 下面的代码示例演示如何两个线程可以执行后台任务时主线程等待任务完成使用静态<xref:System.Threading.WaitHandle.WaitAny%2A>和<xref:System.Threading.WaitHandle.WaitAll%2A>方法<xref:System.Threading.WaitHandle>类。  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.WaitHandle" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放由当前 <see cref="T:System.Threading.WaitHandle" /> 占用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是的公共实现<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>方法<xref:System.Threading.WaitHandle>类和派生的类。 它提供调用的标准实现`Dispose(Boolean)`重载`true`自变量，然后调用<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。 调用此方法以释放由的实例所持有的所有资源`WaitHandle`或某个派生的类。  
  
 调用此方法后，对当前实例的引用会导致未定义的行为。  
  
> [!NOTE]
>  始终调用<xref:System.Threading.WaitHandle.Close%2A>或<xref:System.Threading.WaitHandle.Dispose>在发布到最后一个引用之前<xref:System.Threading.WaitHandle>。 否则，不会释放它所使用的资源。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>应重写<see langword="Dispose(Boolean)" />方法来释放资源分配中派生类。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>释放 <see cref="T:System.Threading.WaitHandle" /> 类的当前实例所使用的所有资源</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Threading.WaitHandle" /> 类的当前实例所使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法相当于<xref:System.Threading.WaitHandle.Close%2A>方法。  
  
> [!NOTE]
>  始终调用<xref:System.Threading.WaitHandle.Close%2A>或<xref:System.Threading.WaitHandle.Dispose>在发布到最后一个引用之前<xref:System.Threading.WaitHandle>。 否则，不会释放它所使用的资源。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>当在派生类中重写时，释放 <see cref="T:System.Threading.WaitHandle" /> 使用的非托管资源，并且可选择释放托管资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法<xref:System.Threading.WaitHandle.Close%2A>和<xref:System.Threading.WaitHandle.Dispose>方法`explicitDisposing`参数设置为`true`。  当`explicitDisposing`参数是`true`，此方法释放由任何托管对象持有的全部资源此<xref:System.Threading.WaitHandle>对象引用。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>应重写<see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />方法来释放资源分配中派生类。  
  
 <see cref="M:System.Threading.WaitHandle.Close" />或<see cref="M:System.Threading.WaitHandle.Dispose" />方法可以由其他对象调用多次。 在重写此方法，请注意不要引用在以前调用之前释放对象<see langword="Dispose" />或<see langword="Close" />。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置本机操作系统句柄。</summary>
        <value>
          <see langword="IntPtr" />，它表示本机操作系统句柄。 默认为 <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> 字段的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 分配新值赋给<xref:System.Threading.WaitHandle.Handle%2A>属性不会关闭上一个句柄。 这可能导致句柄泄漏。  
  
 在.NET Framework 版本 2.0 或更高版本; 不使用此属性使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>属性改为。 此属性设置为有效句柄还集<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>属性，但将其设置为<xref:System.Threading.WaitHandle.InvalidHandle>可能会导致句柄泄漏。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方中，设置属性值。 此成员不能通过部分受信任的或透明的代码中设置。</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">派生的类型都必须具有<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />设置属性值。</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示无效的本机操作系统句柄。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在内部用于初始化<xref:System.Threading.WaitHandle.Handle%2A>属性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>你可以使用此值以确定是否<see cref="P:System.Threading.WaitHandle.Handle" />属性包含有效的本机操作系统句柄。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置本机操作系统句柄。</summary>
        <value>
          <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />，它表示本机操作系统句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你将新值赋给<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>属性上, 一个句柄将被关闭时的上一个<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>收集对象。 请勿手动关闭该句柄，因为这会导致<xref:System.ObjectDisposedException>时<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>尝试关闭该句柄。  
  
 <xref:System.Threading.WaitHandle> 实现<xref:System.IDisposable.Dispose%2A>模式。 请参阅[释放模式](~/docs/standard/design-guidelines/dispose-pattern.md)。 派生自<xref:System.Threading.WaitHandle>，使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>属性来存储你的本机句柄操作系统句柄。 不需要重写受保护<xref:System.Threading.WaitHandle.Dispose%2A>方法除非使用更多的非托管的资源。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">派生的类型都必须具有<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />若要调用此成员。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">要发出信号的 <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="toWaitOn">要等待的 <see cref="T:System.Threading.WaitHandle" />。</param>
        <summary>向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个。</summary>
        <returns>
          如果信号和等待都成功完成，则为 <see langword="true" />；如果等待没有完成，则此方法不返回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此操作不能保证以保证不可分割。 当前线程的信号后`toSignal`，但在等待之前`toWaitOn`，在另一个处理器运行的线程可能指示`toWaitOn`或在其上等待。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>方法重载，以允许主线程发出信号被阻塞的线程并然后等待，直到线程完成任务。  
  
 上面的示例启动五个线程，使其上阻止<xref:System.Threading.EventWaitHandle>使用创建<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>标志和用户按下 ENTER 键的然后释放一个线程时间。 该示例然后另外五个线程并释放所有使用<xref:System.Threading.EventWaitHandle>使用创建<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>标志。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="toWaitOn" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">在一个具有 <see cref="T:System.STAThreadAttribute" /> 的线程上调用了该方法。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 或 Windows Millennium Edition 不支持此方法。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> 是信号量，已达到最大计数。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待结束，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">要发出信号的 <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="toWaitOn">要等待的 <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="millisecondsTimeout">一个整数，表示要等待的间隔。 如果值是 <see cref="F:System.Threading.Timeout.Infinite" />，即 -1，则等待是无限期的。</param>
        <param name="exitContext">
          如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个，指定超时间隔为 32 位有符号整数，并指定在进入等待前是否退出上下文的同步域。</summary>
        <returns>
          如果信号发送和等待均成功完成，则为 <see langword="true" />；如果信号发送完成，但等待超时，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此操作不能保证以保证不可分割。 当前线程的信号后`toSignal`，但在等待之前`toWaitOn`，在另一个处理器运行的线程可能指示`toWaitOn`或在其上等待。  
  
 如果`millisecondsTimeout`为零，该方法不会阻止。 它测试的状态`toWaitOn`并立即返回。  
  
## <a name="notes-on-exiting-the-context"></a>在退出上下文的说明  
 `exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.SignalAndWait%2A>从非默认托管上下文内部调用方法。 如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。 即使你当前正在执行一个方法不是派生的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。  
  
 你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法。 线程的调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法完成。  
  
 这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。 在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。 如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。 当<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法返回时，调用线程必须等待重新进入的同步域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="toWaitOn" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">对具有 <see cref="T:System.STAThreadAttribute" /> 的线程调用了此方法。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 或 Windows Millennium Edition 不支持此方法。</exception>
        <exception cref="T:System.InvalidOperationException">无法终止 <see cref="T:System.Threading.WaitHandle" />，因为它将超过其最大计数。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待结束，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">要发出信号的 <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="toWaitOn">要等待的 <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="timeout">一个 <see cref="T:System.TimeSpan" />，表示要等待的间隔。 如果值是 -1，则等待是无限期的。</param>
        <param name="exitContext">
          如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个，指定超时间隔为 <see cref="T:System.TimeSpan" />，并指定在进入等待前是否退出上下文的同步域。</summary>
        <returns>
          如果信号发送和等待均成功完成，则为 <see langword="true" />；如果信号发送完成，但等待超时，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此操作不能保证以保证不可分割。 当前线程的信号后`toSignal`，但在等待之前`toWaitOn`，在另一个处理器运行的线程可能指示`toWaitOn`或在其上等待。  
  
 最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
 如果`timeout`为零，该方法不会阻止。 它测试的状态`toWaitOn`并立即返回。  
  
## <a name="notes-on-exiting-the-context"></a>在退出上下文的说明  
 `exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.SignalAndWait%2A>从非默认托管上下文内部调用方法。 如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。 即使你当前正在执行一个方法不是派生的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。  
  
 你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法。 线程的调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法完成。  
  
 这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。 在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。 如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。 当<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法返回时，调用线程必须等待重新进入的同步域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="toWaitOn" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">在一个具有 <see cref="T:System.STAThreadAttribute" /> 的线程上调用了该方法。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 或 Windows Millennium Edition 不支持此方法。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> 是信号量，已达到最大计数。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 计算为 -1 以外的负毫秒数。  
  
 或  
  
 <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待结束，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>等待指定数组中的所有元素都收到信号。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。 此数组不能包含对同一对象的多个引用。</param>
        <summary>等待指定数组中的所有元素都收到信号。</summary>
        <returns>
          如果 <see langword="true" /> 中的每个元素都收到信号，则返回 <paramref name="waitHandles" />；否则该方法永不返回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。 在以前版本，<xref:System.Threading.WaitHandle.WaitAll%2A>方法返回`true`时放弃互斥体。 放弃的 mutex 通常表明存在严重的编码错误。 对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。 异常将包含信息对于调试很有用。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时所有句柄都已终止。 在某些实现中，如果传递的 64 个以上的句柄，<xref:System.NotSupportedException>引发。 如果数组包含重复项，调用将失败并<xref:System.DuplicateWaitObjectException>。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>方法不支持在具有的线程上<xref:System.STAThreadAttribute>。  
  
 调用此方法重载是等效于调用<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>方法重载并指定-1 (或<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) 为`millisecondsTimeout`和`true`为`exitContext`。  
  
   
  
## Examples  
 下面的代码示例演示如何使用线程池来以异步方式创建和写入到一组文件。 完成后，每个写入操作进行排队作为工作项和信号。 主线程等待所有项发出信号，然后退出。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 参数为 <see langword="null" />。 或  
  
 <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。  
  
 或  
  
 <paramref name="waitHandles" /> 为不具有元素的数组且 .NET Framework 版本为 2.0 或更高版本。</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 在[适用于 Windows 应用商店应用的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或[可移植类库](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改为捕获基类异常 <see cref="T:System.ArgumentException" />。  
  
</para>
          </block>
          <paramref name="waitHandles" /> 数组包含重复的元素。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。  
  
 或  
  
 <see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> 数组不含任何元素，并且 .NET Framework 版本为 1.0 或 1.1。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待终止，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。 此数组不能包含对同一对象的多个引用（重复的元素）。</param>
        <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
        <summary>等待指定数组中的所有元素接收信号，同时使用 <see cref="T:System.Int32" /> 值指定时间间隔。</summary>
        <returns>
          如果 <paramref name="waitHandles" /> 中的每个元素都已收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`为零，该方法不会阻止。 它测试等待句柄的状态并立即返回。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时，等待将终止，这意味着所有句柄都终止或超时发生时。 在某些实现中，如果传递的 64 个以上的句柄，<xref:System.NotSupportedException>引发。 如果数组中存在重复项，调用将失败并<xref:System.DuplicateWaitObjectException>。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>方法不支持在具有的线程上<xref:System.STAThreadAttribute>。  
  
 调用此方法重载是调用相同<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 参数为 <see langword="null" />。  
  
 或  
  
 <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。  
  
 或  
  
 <paramref name="waitHandles" /> 是一个不含任何元素的数组。</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 在[适用于 Windows 应用商店应用的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或[可移植类库](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改为捕获基类异常 <see cref="T:System.ArgumentException" />。  
  
</para>
          </block>
          <paramref name="waitHandles" /> 数组包含重复的元素。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。  
  
 或  
  
 <see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待结束，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。 此数组不能包含对同一对象的多个引用。</param>
        <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
        <summary>等待指定数组中的所有元素接收信号，同时使用 <see cref="T:System.TimeSpan" /> 值指定时间间隔。</summary>
        <returns>
          如果 <paramref name="waitHandles" /> 中的每个元素都已收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`为零，该方法不会阻止。 它测试等待句柄的状态并立即返回。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时等待将终止，这意味着所有句柄都已终止或发生超时。 在某些实现中，如果传递的 64 个以上的句柄，<xref:System.NotSupportedException>引发。 如果数组包含重复项，则调用将失败。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>方法不支持在具有的线程上<xref:System.STAThreadAttribute>。  
  
 最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
 调用此方法重载是调用相同<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 参数为 <see langword="null" />。  
  
 或  
  
 <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。  
  
 或  
  
 <paramref name="waitHandles" /> 是一个不含任何元素的数组。</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 在[适用于 Windows 应用商店应用的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或[可移植类库](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改为捕获基类异常 <see cref="T:System.ArgumentException" />。  
  
</para>
          </block>
          <paramref name="waitHandles" /> 数组包含重复的元素。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。  
  
 或  
  
 <see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。  
  
 或  
  
 <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待终止，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。 此数组不能包含对同一对象的多个引用（重复的元素）。</param>
        <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
        <param name="exitContext">
          如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>等待指定数组中的所有元素收到信号，使用 <see cref="T:System.Int32" /> 值指定时间间隔，并指定是否在等待之前退出同步域。</summary>
        <returns>
          如果 <paramref name="waitHandles" /> 中的每个元素都已收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`为零，该方法不会阻止。 它测试等待句柄的状态并立即返回。  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。 在以前版本，<xref:System.Threading.WaitHandle.WaitAll%2A>方法返回`true`时放弃互斥体。 放弃的 mutex 通常表明存在严重的编码错误。 对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。 异常将包含信息对于调试很有用。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时，等待将终止，这意味着所有句柄都终止或超时发生时。 在某些实现中，如果传递的 64 个以上的句柄，<xref:System.NotSupportedException>引发。 如果数组中存在重复项，调用将失败并<xref:System.DuplicateWaitObjectException>。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>方法不支持在具有的线程上<xref:System.STAThreadAttribute>。  
  
## <a name="notes-on-exiting-the-context"></a>在退出上下文的说明  
 `exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitAll%2A>从非默认托管上下文内部调用方法。 如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。 即使你当前正在执行一个方法不派生自的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。  
  
 你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.WaitAll%2A>方法。 线程的调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitAll%2A>方法完成。  
  
 这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>属性。 在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。 如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitAll%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。 当<xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时，调用线程必须等待重新进入的同步域。  
  
   
  
## Examples  
 下面的代码示例演示如何使用线程池来以异步方式创建和写入到一组文件。 完成后，每个写入操作进行排队作为工作项和信号。 主线程等待所有项发出信号，然后退出。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 参数为 <see langword="null" />。  
  
 或  
  
 <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。  
  
 或  
  
 <paramref name="waitHandles" /> 为不具有元素的数组且 .NET Framework 版本为 2.0 或更高版本。</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <paramref name="waitHandles" /> 数组包含重复的元素。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。  
  
 或  
  
 <see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> 数组不含任何元素，并且 .NET Framework 版本为 1.0 或 1.1。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待结束，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。 此数组不能包含对同一对象的多个引用。</param>
        <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">
          如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>等待指定数组中的所有元素收到信号，使用 <see cref="T:System.TimeSpan" /> 值指定时间间隔，并指定是否在等待之前退出同步域。</summary>
        <returns>
          如果 <paramref name="waitHandles" /> 中的每个元素都收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`为零，该方法不会阻止。 它测试等待句柄的状态并立即返回。  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。 在以前版本，<xref:System.Threading.WaitHandle.WaitAll%2A>方法返回`true`时放弃互斥体。 放弃的 mutex 通常表明存在严重的编码错误。 对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。 异常将包含信息对于调试很有用。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时等待将终止，这意味着所有句柄都已终止或发生超时。 在某些实现中，如果传递的 64 个以上的句柄，<xref:System.NotSupportedException>引发。 如果数组包含重复项，则调用将失败。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>方法不支持在具有的线程上<xref:System.STAThreadAttribute>。  
  
 最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
## <a name="notes-on-exiting-the-context"></a>在退出上下文的说明  
 `exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitAll%2A>从非默认托管上下文内部调用方法。 如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。 即使你当前正在执行一个方法不派生自的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。  
  
 你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.WaitAll%2A>方法。 它的调用后将返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitAll%2A>方法完成。  
  
 这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。 在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。 如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitAll%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。 当<xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时，调用线程必须等待重新进入的同步域。  
  
   
  
## Examples  
 下面的代码示例演示如何使用线程池来以异步方式创建和写入到一组文件。 完成后，每个写入操作进行排队作为工作项和信号。 主线程等待所有项发出信号，然后退出。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 参数为 <see langword="null" />。  
  
 或  
  
 <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。  
  
 或  
  
 <paramref name="waitHandles" /> 为不具有元素的数组且 .NET Framework 版本为 2.0 或更高版本。</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <paramref name="waitHandles" /> 数组包含重复的元素。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。  
  
 或  
  
 <see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> 数组不含任何元素，并且 .NET Framework 版本为 1.0 或 1.1。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。  
  
 或  
  
 <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待终止，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>等待指定数组中的任一元素收到信号。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</param>
        <summary>等待指定数组中的任一元素收到信号。</summary>
        <returns>满足等待的对象的数组索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。 在以前版本，<xref:System.Threading.WaitHandle.WaitAny%2A>方法返回`true`如果等待完成因为放弃互斥体。 放弃的 mutex 通常表明存在严重的编码错误。 对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。 异常将包含信息对于调试很有用。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>方法抛出异常<xref:System.Threading.AbandonedMutexException>仅等待完成由于放弃的 mutex。 如果`waitHandles`包含使用较低的索引号比放弃的 mutex，释放的互斥体<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成且不会引发异常。  
  
> [!NOTE]
>  在版本的.NET Framework 早于 2.0 版中，如果线程退出或中止，且不显式释放<xref:System.Threading.Mutex>，且`Mutex`中位于索引 0 （零）`WaitAny`上另一线程，返回的索引的数组`WaitAny`是而不是 0 128。  
  
 此方法返回时任何句柄处于有信号状态。 如果多个对象将被发送信号呼叫期间，返回值将为所有终止的对象的最小索引值中具有终止对象的数组索引。 在某些实现中，如果多个传递的 64 句柄，<xref:System.NotSupportedException>引发。  
  
 调用此方法重载是等效于调用<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>方法重载并指定-1 (或<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) 为`millisecondsTimeout`和`true`为`exitContext`。  
  
   
  
## Examples  
 下面的代码示例演示如何调用<xref:System.Threading.WaitHandle.WaitAny%2A>方法。  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 参数为 <see langword="null" />。  
  
 或  
  
 <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 1.0 或 1.1。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待结束，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 2.0 或更高。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</param>
        <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
        <summary>等待指定数组中的任意元素接收信号，同时使用 32 位有符号整数指定时间间隔。</summary>
        <returns>满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <paramref name="millisecondsTimeout" /> 的时间间隔已过，则为 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`为零，该方法不会阻止。 它测试等待句柄的状态并立即返回。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>方法抛出异常<xref:System.Threading.AbandonedMutexException>仅等待完成由于放弃的 mutex。 如果`waitHandles`包含使用较低的索引号比放弃的 mutex，释放的互斥体<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成且不会引发异常。  
  
 此方法返回时，等待将终止，会向任何句柄发出信号或发生超时时。 如果多个对象将被发送信号呼叫期间，返回值将为所有终止的对象的最小索引值中具有终止对象的数组索引。 在某些实现中，如果多个传递的 64 句柄，<xref:System.NotSupportedException>引发。  
  
 调用此方法重载是调用相同<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 参数为 <see langword="null" />。  
  
 或  
  
 <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待结束，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> 是一个不含任何元素的数组。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</param>
        <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
        <summary>等待指定数组中的任意元素接收信号，同时使用 <see cref="T:System.TimeSpan" /> 指定时间间隔。</summary>
        <returns>满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <paramref name="timeout" /> 的时间间隔已过，则为 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`为零，该方法不会阻止。 它测试等待句柄的状态并立即返回。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>方法抛出异常<xref:System.Threading.AbandonedMutexException>仅等待完成由于放弃的 mutex。 如果`waitHandles`包含使用较低的索引号比放弃的 mutex，释放的互斥体<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成且不会引发异常。  
  
 此方法返回时，等待将终止，会向任何句柄发出信号或超时发生时。 如果多个对象将被发送信号呼叫期间，返回值将为所有终止的对象的最小索引值中具有终止对象的数组索引。 在某些实现中，如果多个传递的 64 句柄，<xref:System.NotSupportedException>引发。  
  
 最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
 调用此方法重载是调用相同<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 参数为 <see langword="null" />。  
  
 或  
  
 <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。  
  
 或  
  
 <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待结束，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> 是一个不含任何元素的数组。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</param>
        <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
        <param name="exitContext">
          如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>等待指定数组中的任一元素收到信号，使用 32 位带符号整数指定时间间隔并指定是否在等待之前退出同步域。</summary>
        <returns>满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <paramref name="millisecondsTimeout" /> 的时间间隔已过，则为 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`为零，该方法不会阻止。 它测试等待句柄的状态并立即返回。  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。 在以前版本，<xref:System.Threading.WaitHandle.WaitAny%2A>方法返回`true`如果等待完成因为放弃互斥体。 放弃的 mutex 通常表明存在严重的编码错误。 对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。 异常将包含信息对于调试很有用。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>方法抛出异常<xref:System.Threading.AbandonedMutexException>仅等待完成由于放弃的 mutex。 如果`waitHandles`包含使用较低的索引号比放弃的 mutex，释放的互斥体<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成且不会引发异常。  
  
> [!NOTE]
>  在版本的.NET Framework 早于 2.0 版中，如果线程退出或中止，且不显式释放<xref:System.Threading.Mutex>，且`Mutex`中位于索引 0 （零）`WaitAny`上另一线程，返回的索引的数组`WaitAny`是而不是 0 128。  
  
 此方法返回时，等待将终止，会向任何句柄发出信号或发生超时时。 如果多个对象将被发送信号呼叫期间，返回值将为所有终止的对象的最小索引值中具有终止对象的数组索引。 在某些实现中，如果多个传递的 64 句柄，<xref:System.NotSupportedException>引发。  
  
## <a name="notes-on-exiting-the-context"></a>在退出上下文的说明  
 `exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitAny%2A>从非默认托管上下文内部调用方法。 如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。 即使你当前正在执行一个方法不是派生的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。  
  
 你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.WaitAny%2A>方法。 线程的调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitAny%2A>方法完成。  
  
 这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。 在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。 如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitAny%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。 当<xref:System.Threading.WaitHandle.WaitAny%2A>方法返回时，调用线程必须等待重新进入的同步域。  
  
   
  
## Examples  
 下面的代码示例演示如何使用线程池可同时搜索的多个磁盘上的文件。 对于空间注意事项，搜索每个磁盘的根目录。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 参数为 <see langword="null" />。  
  
 或  
  
 <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 1.0 或 1.1。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待结束，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 2.0 或更高。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</param>
        <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">
          如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>等待指定数组中的任一元素收到信号，使用 <see cref="T:System.TimeSpan" /> 指定时间间隔并指定是否在等待之前退出同步域。</summary>
        <returns>满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <paramref name="timeout" /> 的时间间隔已过，则为 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`为零，该方法不会阻止。 它测试等待句柄的状态并立即返回。  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。 在以前版本，<xref:System.Threading.WaitHandle.WaitAny%2A>方法返回`true`如果等待完成因为放弃互斥体。 放弃的 mutex 通常表明存在严重的编码错误。 对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。 异常将包含信息对于调试很有用。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>方法抛出异常<xref:System.Threading.AbandonedMutexException>仅等待完成由于放弃的 mutex。 如果`waitHandles`包含使用较低的索引号比放弃的 mutex，释放的互斥体<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成且不会引发异常。  
  
> [!NOTE]
>  在版本的.NET Framework 早于 2.0 版中，如果线程退出或中止，且不显式释放<xref:System.Threading.Mutex>，且`Mutex`中位于索引 0 （零）`WaitAny`上另一线程，返回的索引的数组`WaitAny`是而不是 0 128。  
  
 此方法返回时，等待将终止，会向任何句柄发出信号或超时发生时。 如果多个对象将被发送信号呼叫期间，返回值将为所有终止的对象的最小索引值中具有终止对象的数组索引。 在某些实现中，如果多个传递的 64 句柄，<xref:System.NotSupportedException>引发。  
  
 最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
## <a name="notes-on-exiting-the-context"></a>在退出上下文的说明  
 `exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitAny%2A>从非默认托管上下文内部调用方法。 如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。 即使你当前正在执行一个方法不是派生的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。  
  
 你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.WaitAny%2A>方法。 线程的调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitAny%2A>方法完成。  
  
 这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。 在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。 如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitAny%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。 当<xref:System.Threading.WaitHandle.WaitAny%2A>方法返回时，调用线程必须等待重新进入的同步域。  
  
   
  
## Examples  
 下面的代码示例演示如何使用线程池可同时搜索的多个磁盘上的文件。 对于空间注意事项，搜索每个磁盘的根目录。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles" /> 参数为 <see langword="null" />。  
  
 或  
  
 <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 1.0 或 1.1。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。  
  
 或  
  
 <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待结束，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 2.0 或更高。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>阻止当前线程，直到当前 <see cref="T:System.Threading.WaitHandle" /> 收到信号。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>阻止当前线程，直到当前 <see cref="T:System.Threading.WaitHandle" /> 收到信号。</summary>
        <returns>
          如果当前实例收到信号，则为 <see langword="true" />。 如果当前实例永不发出信号，则 <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> 永不返回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。 在以前版本，<xref:System.Threading.WaitHandle.WaitOne%2A>方法返回`true`时放弃互斥体。 放弃的 mutex 通常表明存在严重的编码错误。 对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。 异常将包含信息对于调试很有用。  
  
 此方法将阻塞，直到当前实例无限期的调用方收到信号。 使用此方法进行阻止，直至<xref:System.Threading.WaitHandle>从另一个线程收到信号，如则会生成异步操作完成时。 有关详细信息，请参阅<xref:System.IAsyncResult>接口。  
  
 调用此方法重载是等效于调用<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>方法重载并指定-1 或<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>第一个参数和`false`为第二个参数。  
  
 重写此方法以自定义派生类的行为。  
  
   
  
## Examples  
 下面的代码示例演示如何使用等待句柄以防止进程终止等待后台线程完成执行时。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待结束，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
        <exception cref="T:System.InvalidOperationException">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
        <summary>阻止当前线程，直到当前 <see cref="T:System.Threading.WaitHandle" /> 收到信号，同时使用 32 位带符号整数指定时间间隔（以毫秒为单位）。</summary>
        <returns>
          如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`为零，该方法不会阻止。 它测试等待句柄的状态并立即返回。  
  
 此方法受到阻止，直到当前实例收到信号或超时的调用方时发生。 使用此方法进行阻止，直至<xref:System.Threading.WaitHandle>从另一个线程收到信号，如则会生成异步操作完成时。 有关详细信息，请参阅<xref:System.IAsyncResult>接口。  
  
 重写此方法以自定义派生类的行为。  
  
 调用此方法重载是调用相同<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。  
  
   
  
## Examples  
 下面的代码示例演示如何使用等待句柄以防止进程终止等待后台线程完成执行时。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待结束，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
        <exception cref="T:System.InvalidOperationException">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
        <summary>阻止当前线程，直到当前实例收到信号，同时使用 <see cref="T:System.TimeSpan" /> 指定时间间隔。</summary>
        <returns>
          如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`为零，该方法不会阻止。 它测试等待句柄的状态并立即返回。  
  
 此方法受到阻止，直到当前实例收到信号或超时的调用方时发生。 使用此方法进行阻止，直至<xref:System.Threading.WaitHandle>从另一个线程收到信号，如则会生成异步操作完成时。 有关详细信息，请参阅<xref:System.IAsyncResult>接口。  
  
 重写此方法以自定义派生类的行为。  
  
 最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
 调用此方法重载是调用相同<xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。  
  
 或  
  
 <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待结束，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
        <exception cref="T:System.InvalidOperationException">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</param>
        <param name="exitContext">
          如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>阻止当前线程，直到当前的 <see cref="T:System.Threading.WaitHandle" /> 收到信号为止，同时使用 32 位带符号整数指定时间间隔，并指定是否在等待之前退出同步域。</summary>
        <returns>
          如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`为零，该方法不会阻止。 它测试等待句柄的状态并立即返回。  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。 在以前版本，<xref:System.Threading.WaitHandle.WaitOne%2A>方法返回`true`时放弃互斥体。 放弃的 mutex 通常表明存在严重的编码错误。 对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。 异常将包含信息对于调试很有用。  
  
 此方法受到阻止，直到当前实例收到信号或超时的调用方时发生。 使用此方法进行阻止，直至<xref:System.Threading.WaitHandle>从另一个线程收到信号，如则会生成异步操作完成时。 有关详细信息，请参阅<xref:System.IAsyncResult>接口。  
  
 重写此方法以自定义派生类的行为。  
  
## <a name="notes-on-exiting-the-context"></a>在退出上下文的说明  
 `exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitOne%2A>从非默认托管上下文内部调用方法。 如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。 即使你当前正在执行一个方法不是派生的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。  
  
 你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.WaitOne%2A>方法。 线程的调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitOne%2A>方法完成。  
  
 这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。 在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。 如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitOne%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。 当<xref:System.Threading.WaitHandle.WaitOne%2A>方法返回时，调用线程必须等待重新进入的同步域。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>方法重载的行为在一个域中同步调用时。 首先的线程在等待`exitContext`设置为`false`并阻止，直到等待超时到期。 第二个线程执行之后的第一个线程终止，并等待`exitContext`设置为`true`。 不阻止发送信号等待句柄的此第二个线程的调用，并且在线程在等待超时前完成。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待结束，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
        <exception cref="T:System.InvalidOperationException">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">
          如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>阻止当前线程，直到当前实例收到信号为止，同时使用 <see cref="T:System.TimeSpan" /> 指定时间间隔，并指定是否在等待之前退出同步域。</summary>
        <returns>
          如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`为零，该方法不会阻止。 它测试等待句柄的状态并立即返回。  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。 在以前版本，<xref:System.Threading.WaitHandle.WaitOne%2A>方法返回`true`时放弃互斥体。 放弃的 mutex 通常表明存在严重的编码错误。 对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。 异常将包含信息对于调试很有用。  
  
 此方法受到阻止，直到当前实例收到信号或超时的调用方时发生。 使用此方法进行阻止，直至<xref:System.Threading.WaitHandle>从另一个线程收到信号，如则会生成异步操作完成时。 有关详细信息，请参阅<xref:System.IAsyncResult>接口。  
  
 重写此方法以自定义派生类的行为。  
  
 最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
## <a name="notes-on-exiting-the-context"></a>在退出上下文的说明  
 `exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitOne%2A>从非默认托管上下文内部调用方法。 如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。 即使你当前正在执行一个方法不是派生的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。  
  
 你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.WaitOne%2A>方法。 线程的调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitOne%2A>方法完成。  
  
 这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。 在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。 如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitOne%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。 当<xref:System.Threading.WaitHandle.WaitOne%2A>方法返回时，调用线程必须等待重新进入的同步域。  
  
   
  
## Examples  
 下面的代码示例演示如何使用等待句柄以防止进程终止等待后台线程完成执行时。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">已释放当前实例。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。  
  
 或  
  
 <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">等待结束，因为线程在未释放互斥的情况下退出。 在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</exception>
        <exception cref="T:System.InvalidOperationException">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>指示在任何等待句柄终止之前 <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> 操作已超时。 此字段为常数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此字段是一个可能的返回值的`WaitAny`。  
  
   
  
## Examples  
 下面的代码示例演示如何使用线程池可同时搜索的多个磁盘上的文件。 对于空间注意事项，搜索每个磁盘的根目录。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>