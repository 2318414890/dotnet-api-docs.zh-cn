<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9c30c9bf2d271da2afe9d173213a99d04fceefda" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531501" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="9ff63-101">封装等待对共享资源的独占访问的操作系统特定的对象。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9ff63-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-102"><xref:System.Threading.WaitHandle>类封装 Win32 同步句柄，并且用于表示在运行时允许多个等待操作的所有同步对象。</span><span class="sxs-lookup"><span data-stu-id="9ff63-102">The <xref:System.Threading.WaitHandle> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="9ff63-103">与其他同步对象的等待句柄的比较，请参阅[同步基元概述](~/docs/standard/threading/overview-of-synchronization-primitives.md)。</span><span class="sxs-lookup"><span data-stu-id="9ff63-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="9ff63-104"><xref:System.Threading.WaitHandle>本身的类为抽象类。</span><span class="sxs-lookup"><span data-stu-id="9ff63-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="9ff63-105">类派生自<xref:System.Threading.WaitHandle>定义信号机制，以指示获取或释放访问共享资源，但它们使用继承<xref:System.Threading.WaitHandle>方法若要在等待访问共享资源。</span><span class="sxs-lookup"><span data-stu-id="9ff63-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="9ff63-106">类派生自<xref:System.Threading.WaitHandle>包括：</span><span class="sxs-lookup"><span data-stu-id="9ff63-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="9ff63-107"><xref:System.Threading.Mutex> 类。</span><span class="sxs-lookup"><span data-stu-id="9ff63-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="9ff63-108">请参阅[互斥体](~/docs/standard/threading/mutexes.md)。</span><span class="sxs-lookup"><span data-stu-id="9ff63-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="9ff63-109"><xref:System.Threading.EventWaitHandle>类和派生的类，<xref:System.Threading.AutoResetEvent>和<xref:System.Threading.ManualResetEvent>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="9ff63-110">请参阅 [EventWaitHandle、AutoResetEvent、CountdownEvent、ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)。</span><span class="sxs-lookup"><span data-stu-id="9ff63-110">See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
-   <span data-ttu-id="9ff63-111"><xref:System.Threading.Semaphore> 类。</span><span class="sxs-lookup"><span data-stu-id="9ff63-111">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="9ff63-112">请参阅[Semaphore 和 SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md)。</span><span class="sxs-lookup"><span data-stu-id="9ff63-112">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="9ff63-113">线程在一个单独的等待句柄可以阻止通过调用实例方法<xref:System.Threading.WaitHandle.WaitOne%2A>，由派生自的类继承<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-113">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="9ff63-114">派生的类<xref:System.Threading.WaitHandle>其线程关联的行为有所不同。</span><span class="sxs-lookup"><span data-stu-id="9ff63-114">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="9ff63-115">事件等待句柄 (<xref:System.Threading.EventWaitHandle>， <xref:System.Threading.AutoResetEvent>，和<xref:System.Threading.ManualResetEvent>) 和信号量不具有线程关联; 任何线程都可以发送的事件等待句柄或信号量。</span><span class="sxs-lookup"><span data-stu-id="9ff63-115">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="9ff63-116">互斥锁，另一方面，具有线程关联;拥有互斥体的线程必须释放它，并且会引发异常，如果一个线程调用<xref:System.Threading.Mutex.ReleaseMutex%2A>上不拥有互斥体的方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-116">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="9ff63-117">因为<xref:System.Threading.WaitHandle>类派生自<xref:System.MarshalByRefObject>，这些类可以用于跨应用程序域边界同步线程活动。</span><span class="sxs-lookup"><span data-stu-id="9ff63-117">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="9ff63-118">及其派生类，除了<xref:System.Threading.WaitHandle>类具有多种直到一个阻塞线程的静态方法或更多的同步对象接收到信号...</span><span class="sxs-lookup"><span data-stu-id="9ff63-118">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal..</span></span> <span data-ttu-id="9ff63-119">这些方法包括：</span><span class="sxs-lookup"><span data-stu-id="9ff63-119">These include:</span></span>  
  
-   <span data-ttu-id="9ff63-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>它允许发出信号一个等待句柄并立即等待另一个线程。</span><span class="sxs-lookup"><span data-stu-id="9ff63-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="9ff63-121"><xref:System.Threading.WaitHandle.WaitAll%2A>它允许线程等待直到数组中的所有等待句柄都接收到信号。</span><span class="sxs-lookup"><span data-stu-id="9ff63-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="9ff63-122"><xref:System.Threading.WaitHandle.WaitAny%2A>它允许线程等待，直到已终止的一组指定等待句柄的任何一个。</span><span class="sxs-lookup"><span data-stu-id="9ff63-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</span></span>  
  
 <span data-ttu-id="9ff63-123">这些方法的重载提供放弃等待，并有机会输入允许使用的同步上下文其他线程在等待之前退出同步上下文的超时间隔。</span><span class="sxs-lookup"><span data-stu-id="9ff63-123">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="9ff63-124">此类型实现<xref:System.IDisposable>接口。</span><span class="sxs-lookup"><span data-stu-id="9ff63-124">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="9ff63-125">完成后使用的类型或其派生的类型的操作后，你应释放类型直接或间接。</span><span class="sxs-lookup"><span data-stu-id="9ff63-125">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="9ff63-126">若要直接释放类型，调用其<xref:System.Threading.WaitHandle.Close%2A>中的方法`try` / `catch`块。</span><span class="sxs-lookup"><span data-stu-id="9ff63-126">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="9ff63-127">若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。</span><span class="sxs-lookup"><span data-stu-id="9ff63-127">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="9ff63-128">有关详细信息，请参阅中的"使用实现 IDisposable 的对象"部分<xref:System.IDisposable>接口主题。</span><span class="sxs-lookup"><span data-stu-id="9ff63-128">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="9ff63-129"><xref:System.Threading.WaitHandle> 实现<xref:System.IDisposable.Dispose%2A>模式。</span><span class="sxs-lookup"><span data-stu-id="9ff63-129"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="9ff63-130">请参阅[释放模式](~/docs/standard/design-guidelines/dispose-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="9ff63-130">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="9ff63-131">派生自<xref:System.Threading.WaitHandle>，使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>属性来存储你的本机句柄操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="9ff63-131">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="9ff63-132">不需要重写受保护<xref:System.Threading.WaitHandle.Dispose%2A>方法除非使用更多的非托管的资源。</span><span class="sxs-lookup"><span data-stu-id="9ff63-132">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9ff63-133">下面的代码示例演示如何两个线程可以执行后台任务时主线程等待任务完成使用静态<xref:System.Threading.WaitHandle.WaitAny%2A>和<xref:System.Threading.WaitHandle.WaitAll%2A>方法<xref:System.Threading.WaitHandle>类。</span><span class="sxs-lookup"><span data-stu-id="9ff63-133">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="9ff63-134">此类型是线程安全的。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9ff63-134">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9ff63-135">初始化 <see cref="T:System.Threading.WaitHandle" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-135">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9ff63-136">释放由当前 <see cref="T:System.Threading.WaitHandle" /> 占用的所有资源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-136">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-137">此方法是的公共实现<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>方法<xref:System.Threading.WaitHandle>类和派生的类。</span><span class="sxs-lookup"><span data-stu-id="9ff63-137">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="9ff63-138">它提供调用的标准实现`Dispose(Boolean)`重载`true`自变量，然后调用<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-138">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="9ff63-139">调用此方法以释放由的实例所持有的所有资源`WaitHandle`或某个派生的类。</span><span class="sxs-lookup"><span data-stu-id="9ff63-139">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="9ff63-140">调用此方法后，对当前实例的引用会导致未定义的行为。</span><span class="sxs-lookup"><span data-stu-id="9ff63-140">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9ff63-141">始终调用<xref:System.Threading.WaitHandle.Close%2A>或<xref:System.Threading.WaitHandle.Dispose>在发布到最后一个引用之前<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-141">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="9ff63-142">否则，不会释放它所使用的资源。</span><span class="sxs-lookup"><span data-stu-id="9ff63-142">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="9ff63-143">应重写<see langword="Dispose(Boolean)" />方法来释放资源分配中派生类。</span>
            <span class="sxs-lookup">
              <span data-stu-id="9ff63-143">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9ff63-144">释放 <see cref="T:System.Threading.WaitHandle" /> 类的当前实例所使用的所有资源</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-144">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9ff63-145">释放 <see cref="T:System.Threading.WaitHandle" /> 类的当前实例所使用的所有资源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-145">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-146">此方法相当于<xref:System.Threading.WaitHandle.Close%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-146">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9ff63-147">始终调用<xref:System.Threading.WaitHandle.Close%2A>或<xref:System.Threading.WaitHandle.Dispose>在发布到最后一个引用之前<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-147">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="9ff63-148">否则，不会释放它所使用的资源。</span><span class="sxs-lookup"><span data-stu-id="9ff63-148">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <span data-ttu-id="9ff63-149">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-149">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-150">当在派生类中重写时，释放 <see cref="T:System.Threading.WaitHandle" /> 使用的非托管资源，并且可选择释放托管资源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-150">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-151">调用此方法<xref:System.Threading.WaitHandle.Close%2A>和<xref:System.Threading.WaitHandle.Dispose>方法`explicitDisposing`参数设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="9ff63-151">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="9ff63-152">当`explicitDisposing`参数是`true`，此方法释放由任何托管对象持有的全部资源此<xref:System.Threading.WaitHandle>对象引用。</span><span class="sxs-lookup"><span data-stu-id="9ff63-152">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="9ff63-153">应重写<see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />方法来释放资源分配中派生类。</span>
            <span class="sxs-lookup">
              <span data-stu-id="9ff63-153">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
            <span data-ttu-id="9ff63-154">
              <see cref="M:System.Threading.WaitHandle.Close" />或<see cref="M:System.Threading.WaitHandle.Dispose" />方法可以由其他对象调用多次。</span>
            <span class="sxs-lookup">
              <span data-stu-id="9ff63-154">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="9ff63-155">在重写此方法，请注意不要引用在以前调用之前释放对象<see langword="Dispose" />或<see langword="Close" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="9ff63-155">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9ff63-156">获取或设置本机操作系统句柄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-156">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9ff63-157">
            <see langword="IntPtr" />，它表示本机操作系统句柄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-157">An <see langword="IntPtr" /> representing the native operating system handle.</span>
          </span>
          <span data-ttu-id="9ff63-158">默认为 <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> 字段的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-158">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-159">分配新值赋给<xref:System.Threading.WaitHandle.Handle%2A>属性不会关闭上一个句柄。</span><span class="sxs-lookup"><span data-stu-id="9ff63-159">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="9ff63-160">这可能导致句柄泄漏。</span><span class="sxs-lookup"><span data-stu-id="9ff63-160">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="9ff63-161">在.NET Framework 版本 2.0 或更高版本; 不使用此属性使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>属性改为。</span><span class="sxs-lookup"><span data-stu-id="9ff63-161">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="9ff63-162">此属性设置为有效句柄还集<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>属性，但将其设置为<xref:System.Threading.WaitHandle.InvalidHandle>可能会导致句柄泄漏。</span><span class="sxs-lookup"><span data-stu-id="9ff63-162">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="9ff63-163">需要完全信任直接调用方中，设置属性值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-163">Requires full trust for the immediate caller to set the property value.</span>
          </span>
          <span data-ttu-id="9ff63-164">此成员不能通过部分受信任的或透明的代码中设置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-164">This member cannot be set by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="9ff63-165">派生的类型都必须具有<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />设置属性值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-165">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9ff63-166">表示无效的本机操作系统句柄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-166">Represents an invalid native operating system handle.</span>
          </span>
          <span data-ttu-id="9ff63-167">此字段为只读。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-167">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-168">在内部用于初始化<xref:System.Threading.WaitHandle.Handle%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="9ff63-168">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="9ff63-169">你可以使用此值以确定是否<see cref="P:System.Threading.WaitHandle.Handle" />属性包含有效的本机操作系统句柄。</span>
            <span class="sxs-lookup">
              <span data-stu-id="9ff63-169">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9ff63-170">获取或设置本机操作系统句柄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-170">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9ff63-171">
            <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />，它表示本机操作系统句柄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-171">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-172">当你将新值赋给<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>属性上, 一个句柄将被关闭时的上一个<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>收集对象。</span><span class="sxs-lookup"><span data-stu-id="9ff63-172">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="9ff63-173">请勿手动关闭该句柄，因为这会导致<xref:System.ObjectDisposedException>时<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>尝试关闭该句柄。</span><span class="sxs-lookup"><span data-stu-id="9ff63-173">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="9ff63-174"><xref:System.Threading.WaitHandle> 实现<xref:System.IDisposable.Dispose%2A>模式。</span><span class="sxs-lookup"><span data-stu-id="9ff63-174"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="9ff63-175">请参阅[释放模式](~/docs/standard/design-guidelines/dispose-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="9ff63-175">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="9ff63-176">派生自<xref:System.Threading.WaitHandle>，使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>属性来存储你的本机句柄操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="9ff63-176">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="9ff63-177">不需要重写受保护<xref:System.Threading.WaitHandle.Dispose%2A>方法除非使用更多的非托管的资源。</span><span class="sxs-lookup"><span data-stu-id="9ff63-177">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="9ff63-178">需要完全信任直接调用方。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-178">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="9ff63-179">此成员不能由部分受信任或不透明的代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-179">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="9ff63-180">派生的类型都必须具有<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />若要调用此成员。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-180">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9ff63-181">向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-181">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="9ff63-182">要发出信号的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-182">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="9ff63-183">要等待的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-183">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-184">向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-184">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-185">如果信号和等待都成功完成，则为 <see langword="true" />；如果等待没有完成，则此方法不返回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-185">
              <see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-186">此操作不能保证以保证不可分割。</span><span class="sxs-lookup"><span data-stu-id="9ff63-186">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="9ff63-187">当前线程的信号后`toSignal`，但在等待之前`toWaitOn`，在另一个处理器运行的线程可能指示`toWaitOn`或在其上等待。</span><span class="sxs-lookup"><span data-stu-id="9ff63-187">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9ff63-188">下面的代码示例使用<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>方法重载，以允许主线程发出信号被阻塞的线程并然后等待，直到线程完成任务。</span><span class="sxs-lookup"><span data-stu-id="9ff63-188">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="9ff63-189">上面的示例启动五个线程，使其上阻止<xref:System.Threading.EventWaitHandle>使用创建<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>标志和用户按下 ENTER 键的然后释放一个线程时间。</span><span class="sxs-lookup"><span data-stu-id="9ff63-189">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="9ff63-190">该示例然后另外五个线程并释放所有使用<xref:System.Threading.EventWaitHandle>使用创建<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>标志。</span><span class="sxs-lookup"><span data-stu-id="9ff63-190">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9ff63-191">
            <paramref name="toSignal" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-191">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-192">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-192">-or-</span>
          </span>
          <span data-ttu-id="9ff63-193">
            <paramref name="toWaitOn" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-193">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9ff63-194">在一个具有 <see cref="T:System.STAThreadAttribute" /> 的线程上调用了该方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-194">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="9ff63-195">Windows 98 或 Windows Millennium Edition 不支持此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-195">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-196">
            <paramref name="toSignal" /> 是信号量，已达到最大计数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-196">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-197">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-197">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-198">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-198">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="9ff63-199">要发出信号的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-199">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="9ff63-200">要等待的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-200">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="9ff63-201">一个整数，表示要等待的间隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-201">An integer that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="9ff63-202">如果值是 <see cref="F:System.Threading.Timeout.Infinite" />，即 -1，则等待是无限期的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-202">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="9ff63-203">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-203">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-204">向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个，指定超时间隔为 32 位有符号整数，并指定在进入等待前是否退出上下文的同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-204">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-205">如果信号发送和等待均成功完成，则为 <see langword="true" />；如果信号发送完成，但等待超时，则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-205">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-206">此操作不能保证以保证不可分割。</span><span class="sxs-lookup"><span data-stu-id="9ff63-206">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="9ff63-207">当前线程的信号后`toSignal`，但在等待之前`toWaitOn`，在另一个处理器运行的线程可能指示`toWaitOn`或在其上等待。</span><span class="sxs-lookup"><span data-stu-id="9ff63-207">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="9ff63-208">如果`millisecondsTimeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-208">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="9ff63-209">它测试的状态`toWaitOn`并立即返回。</span><span class="sxs-lookup"><span data-stu-id="9ff63-209">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="9ff63-210">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="9ff63-210">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="9ff63-211">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.SignalAndWait%2A>从非默认托管上下文内部调用方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-211">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="9ff63-212">如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-212">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="9ff63-213">即使你当前正在执行一个方法不是派生的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="9ff63-213">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="9ff63-214">你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-214">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="9ff63-215">线程的调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="9ff63-215">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="9ff63-216">这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-216">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="9ff63-217">在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="9ff63-217">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="9ff63-218">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="9ff63-218">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="9ff63-219">当<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法返回时，调用线程必须等待重新进入的同步域。</span><span class="sxs-lookup"><span data-stu-id="9ff63-219">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9ff63-220">
            <paramref name="toSignal" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-220">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-221">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-221">-or-</span>
          </span>
          <span data-ttu-id="9ff63-222">
            <paramref name="toWaitOn" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-222">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9ff63-223">对具有 <see cref="T:System.STAThreadAttribute" /> 的线程调用了此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-223">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="9ff63-224">Windows 98 或 Windows Millennium Edition 不支持此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-224">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-225">无法终止 <see cref="T:System.Threading.WaitHandle" />，因为它将超过其最大计数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-225">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9ff63-226">
            <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-226">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-227">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-227">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-228">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-228">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="9ff63-229">要发出信号的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-229">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="9ff63-230">要等待的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-230">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="9ff63-231">一个 <see cref="T:System.TimeSpan" />，表示要等待的间隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-231">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="9ff63-232">如果值是 -1，则等待是无限期的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-232">If the value is -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="9ff63-233">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-233">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-234">向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个，指定超时间隔为 <see cref="T:System.TimeSpan" />，并指定在进入等待前是否退出上下文的同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-234">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-235">如果信号发送和等待均成功完成，则为 <see langword="true" />；如果信号发送完成，但等待超时，则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-235">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-236">此操作不能保证以保证不可分割。</span><span class="sxs-lookup"><span data-stu-id="9ff63-236">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="9ff63-237">当前线程的信号后`toSignal`，但在等待之前`toWaitOn`，在另一个处理器运行的线程可能指示`toWaitOn`或在其上等待。</span><span class="sxs-lookup"><span data-stu-id="9ff63-237">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="9ff63-238">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-238">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9ff63-239">如果`timeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-239">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="9ff63-240">它测试的状态`toWaitOn`并立即返回。</span><span class="sxs-lookup"><span data-stu-id="9ff63-240">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="9ff63-241">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="9ff63-241">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="9ff63-242">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.SignalAndWait%2A>从非默认托管上下文内部调用方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-242">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="9ff63-243">如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-243">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="9ff63-244">即使你当前正在执行一个方法不是派生的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="9ff63-244">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="9ff63-245">你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-245">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="9ff63-246">线程的调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="9ff63-246">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="9ff63-247">这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-247">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="9ff63-248">在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="9ff63-248">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="9ff63-249">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="9ff63-249">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="9ff63-250">当<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法返回时，调用线程必须等待重新进入的同步域。</span><span class="sxs-lookup"><span data-stu-id="9ff63-250">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9ff63-251">
            <paramref name="toSignal" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-251">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-252">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-252">-or-</span>
          </span>
          <span data-ttu-id="9ff63-253">
            <paramref name="toWaitOn" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-253">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9ff63-254">在一个具有 <see cref="T:System.STAThreadAttribute" /> 的线程上调用了该方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-254">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="9ff63-255">Windows 98 或 Windows Millennium Edition 不支持此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-255">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-256">
            <paramref name="toSignal" /> 是信号量，已达到最大计数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-256">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9ff63-257">
            <paramref name="timeout" /> 计算为 -1 以外的负毫秒数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-257">
              <paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span>
          </span>
          <span data-ttu-id="9ff63-258">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-258">-or-</span>
          </span>
          <span data-ttu-id="9ff63-259">
            <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-259">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-260">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-260">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-261">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-261">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9ff63-262">等待指定数组中的所有元素都收到信号。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-262">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="9ff63-263">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-263">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="9ff63-264">此数组不能包含对同一对象的多个引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-264">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-265">等待指定数组中的所有元素都收到信号。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-265">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-266">如果 <see langword="true" /> 中的每个元素都收到信号，则返回 <paramref name="waitHandles" />；否则该方法永不返回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-266">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-267"><xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。</span><span class="sxs-lookup"><span data-stu-id="9ff63-267"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="9ff63-268">在以前版本，<xref:System.Threading.WaitHandle.WaitAll%2A>方法返回`true`时放弃互斥体。</span><span class="sxs-lookup"><span data-stu-id="9ff63-268">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="9ff63-269">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="9ff63-269">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="9ff63-270">对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-270">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="9ff63-271">异常将包含信息对于调试很有用。</span><span class="sxs-lookup"><span data-stu-id="9ff63-271">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="9ff63-272"><xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时所有句柄都已终止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-272">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="9ff63-273">在某些实现中，如果传递的 64 个以上的句柄，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="9ff63-273">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="9ff63-274">如果数组包含重复项，调用将失败并<xref:System.DuplicateWaitObjectException>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-274">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9ff63-275"><xref:System.Threading.WaitHandle.WaitAll%2A>方法不支持在具有的线程上<xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-275">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="9ff63-276">调用此方法重载是等效于调用<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>方法重载并指定-1 (或<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) 为`millisecondsTimeout`和`true`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="9ff63-276">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9ff63-277">下面的代码示例演示如何使用线程池来以异步方式创建和写入到一组文件。</span><span class="sxs-lookup"><span data-stu-id="9ff63-277">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="9ff63-278">完成后，每个写入操作进行排队作为工作项和信号。</span><span class="sxs-lookup"><span data-stu-id="9ff63-278">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="9ff63-279">主线程等待所有项发出信号，然后退出。</span><span class="sxs-lookup"><span data-stu-id="9ff63-279">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9ff63-280">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-280">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-281">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-281">-or-</span>
          </span>
          <span data-ttu-id="9ff63-282">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-282">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-283">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-283">-or-</span>
          </span>
          <span data-ttu-id="9ff63-284">
            <paramref name="waitHandles" /> 为不具有元素的数组且 .NET Framework 版本为 2.0 或更高版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-284">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="9ff63-285">在[适用于 Windows 应用商店应用的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或[可移植类库](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改为捕获基类异常 <see cref="T:System.ArgumentException" />。</span>
              <span class="sxs-lookup">
                <span data-stu-id="9ff63-285">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="9ff63-286">
            <paramref name="waitHandles" /> 数组包含重复的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-286">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9ff63-287">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-287">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="9ff63-288">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-288">-or-</span>
          </span>
          <span data-ttu-id="9ff63-289">
            <see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-289">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="9ff63-290">
            <paramref name="waitHandles" /> 数组不含任何元素，并且 .NET Framework 版本为 1.0 或 1.1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-290">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-291">等待终止，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-291">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-292">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-292">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-293">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-293">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="9ff63-294">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-294">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="9ff63-295">此数组不能包含对同一对象的多个引用（重复的元素）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-295">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="9ff63-296">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-296">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-297">等待指定数组中的所有元素接收信号，同时使用 <see cref="T:System.Int32" /> 值指定时间间隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-297">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-298">如果 <paramref name="waitHandles" /> 中的每个元素都已收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-298">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-299">如果`millisecondsTimeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-299">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="9ff63-300">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="9ff63-300">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="9ff63-301"><xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时，等待将终止，这意味着所有句柄都终止或超时发生时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-301">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="9ff63-302">在某些实现中，如果传递的 64 个以上的句柄，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="9ff63-302">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="9ff63-303">如果数组中存在重复项，调用将失败并<xref:System.DuplicateWaitObjectException>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-303">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9ff63-304"><xref:System.Threading.WaitHandle.WaitAll%2A>方法不支持在具有的线程上<xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-304">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="9ff63-305">调用此方法重载是调用相同<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="9ff63-305">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9ff63-306">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-306">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-307">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-307">-or-</span>
          </span>
          <span data-ttu-id="9ff63-308">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-308">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-309">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-309">-or-</span>
          </span>
          <span data-ttu-id="9ff63-310">
            <paramref name="waitHandles" /> 是一个不含任何元素的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-310">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="9ff63-311">在[适用于 Windows 应用商店应用的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或[可移植类库](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改为捕获基类异常 <see cref="T:System.ArgumentException" />。</span>
              <span class="sxs-lookup">
                <span data-stu-id="9ff63-311">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="9ff63-312">
            <paramref name="waitHandles" /> 数组包含重复的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-312">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9ff63-313">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-313">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="9ff63-314">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-314">-or-</span>
          </span>
          <span data-ttu-id="9ff63-315">
            <see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-315">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9ff63-316">
            <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-316">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-317">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-317">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-318">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-318">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-319">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-319">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="9ff63-320">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-320">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="9ff63-321">此数组不能包含对同一对象的多个引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-321">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="9ff63-322">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-322">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-323">等待指定数组中的所有元素接收信号，同时使用 <see cref="T:System.TimeSpan" /> 值指定时间间隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-323">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-324">如果 <paramref name="waitHandles" /> 中的每个元素都已收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-324">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-325">如果`timeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-325">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="9ff63-326">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="9ff63-326">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="9ff63-327"><xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时等待将终止，这意味着所有句柄都已终止或发生超时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-327">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="9ff63-328">在某些实现中，如果传递的 64 个以上的句柄，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="9ff63-328">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="9ff63-329">如果数组包含重复项，则调用将失败。</span><span class="sxs-lookup"><span data-stu-id="9ff63-329">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9ff63-330"><xref:System.Threading.WaitHandle.WaitAll%2A>方法不支持在具有的线程上<xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-330">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="9ff63-331">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-331">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9ff63-332">调用此方法重载是调用相同<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="9ff63-332">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9ff63-333">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-333">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-334">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-334">-or-</span>
          </span>
          <span data-ttu-id="9ff63-335">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-335">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-336">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-336">-or-</span>
          </span>
          <span data-ttu-id="9ff63-337">
            <paramref name="waitHandles" /> 是一个不含任何元素的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-337">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="9ff63-338">在[适用于 Windows 应用商店应用的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或[可移植类库](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改为捕获基类异常 <see cref="T:System.ArgumentException" />。</span>
              <span class="sxs-lookup">
                <span data-stu-id="9ff63-338">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="9ff63-339">
            <paramref name="waitHandles" /> 数组包含重复的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-339">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9ff63-340">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-340">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="9ff63-341">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-341">-or-</span>
          </span>
          <span data-ttu-id="9ff63-342">
            <see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-342">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9ff63-343">
            <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-343">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="9ff63-344">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-344">-or-</span>
          </span>
          <span data-ttu-id="9ff63-345">
            <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-345">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-346">等待终止，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-346">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-347">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-347">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-348">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-348">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="9ff63-349">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-349">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="9ff63-350">此数组不能包含对同一对象的多个引用（重复的元素）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-350">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="9ff63-351">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-351">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="9ff63-352">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-352">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-353">等待指定数组中的所有元素收到信号，使用 <see cref="T:System.Int32" /> 值指定时间间隔，并指定是否在等待之前退出同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-353">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-354">如果 <paramref name="waitHandles" /> 中的每个元素都已收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-354">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-355">如果`millisecondsTimeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-355">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="9ff63-356">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="9ff63-356">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="9ff63-357"><xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。</span><span class="sxs-lookup"><span data-stu-id="9ff63-357"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="9ff63-358">在以前版本，<xref:System.Threading.WaitHandle.WaitAll%2A>方法返回`true`时放弃互斥体。</span><span class="sxs-lookup"><span data-stu-id="9ff63-358">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="9ff63-359">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="9ff63-359">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="9ff63-360">对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-360">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="9ff63-361">异常将包含信息对于调试很有用。</span><span class="sxs-lookup"><span data-stu-id="9ff63-361">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="9ff63-362"><xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时，等待将终止，这意味着所有句柄都终止或超时发生时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-362">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="9ff63-363">在某些实现中，如果传递的 64 个以上的句柄，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="9ff63-363">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="9ff63-364">如果数组中存在重复项，调用将失败并<xref:System.DuplicateWaitObjectException>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-364">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9ff63-365"><xref:System.Threading.WaitHandle.WaitAll%2A>方法不支持在具有的线程上<xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-365">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="9ff63-366">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="9ff63-366">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="9ff63-367">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitAll%2A>从非默认托管上下文内部调用方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-367">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="9ff63-368">如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-368">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="9ff63-369">即使你当前正在执行一个方法不派生自的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="9ff63-369">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="9ff63-370">你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.WaitAll%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-370">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="9ff63-371">线程的调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitAll%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="9ff63-371">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="9ff63-372">这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>属性。</span><span class="sxs-lookup"><span data-stu-id="9ff63-372">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="9ff63-373">在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="9ff63-373">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="9ff63-374">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitAll%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="9ff63-374">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="9ff63-375">当<xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时，调用线程必须等待重新进入的同步域。</span><span class="sxs-lookup"><span data-stu-id="9ff63-375">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9ff63-376">下面的代码示例演示如何使用线程池来以异步方式创建和写入到一组文件。</span><span class="sxs-lookup"><span data-stu-id="9ff63-376">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="9ff63-377">完成后，每个写入操作进行排队作为工作项和信号。</span><span class="sxs-lookup"><span data-stu-id="9ff63-377">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="9ff63-378">主线程等待所有项发出信号，然后退出。</span><span class="sxs-lookup"><span data-stu-id="9ff63-378">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9ff63-379">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-379">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-380">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-380">-or-</span>
          </span>
          <span data-ttu-id="9ff63-381">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-381">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-382">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-382">-or-</span>
          </span>
          <span data-ttu-id="9ff63-383">
            <paramref name="waitHandles" /> 为不具有元素的数组且 .NET Framework 版本为 2.0 或更高版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-383">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="9ff63-384">
            <paramref name="waitHandles" /> 数组包含重复的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-384">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9ff63-385">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-385">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="9ff63-386">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-386">-or-</span>
          </span>
          <span data-ttu-id="9ff63-387">
            <see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-387">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="9ff63-388">
            <paramref name="waitHandles" /> 数组不含任何元素，并且 .NET Framework 版本为 1.0 或 1.1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-388">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9ff63-389">
            <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-389">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-390">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-390">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-391">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-391">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-392">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-392">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="9ff63-393">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-393">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="9ff63-394">此数组不能包含对同一对象的多个引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-394">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="9ff63-395">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-395">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="9ff63-396">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-396">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-397">等待指定数组中的所有元素收到信号，使用 <see cref="T:System.TimeSpan" /> 值指定时间间隔，并指定是否在等待之前退出同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-397">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-398">如果 <paramref name="waitHandles" /> 中的每个元素都收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-398">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-399">如果`timeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-399">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="9ff63-400">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="9ff63-400">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="9ff63-401"><xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。</span><span class="sxs-lookup"><span data-stu-id="9ff63-401"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="9ff63-402">在以前版本，<xref:System.Threading.WaitHandle.WaitAll%2A>方法返回`true`时放弃互斥体。</span><span class="sxs-lookup"><span data-stu-id="9ff63-402">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="9ff63-403">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="9ff63-403">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="9ff63-404">对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-404">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="9ff63-405">异常将包含信息对于调试很有用。</span><span class="sxs-lookup"><span data-stu-id="9ff63-405">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="9ff63-406"><xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时等待将终止，这意味着所有句柄都已终止或发生超时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-406">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="9ff63-407">在某些实现中，如果传递的 64 个以上的句柄，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="9ff63-407">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="9ff63-408">如果数组包含重复项，则调用将失败。</span><span class="sxs-lookup"><span data-stu-id="9ff63-408">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9ff63-409"><xref:System.Threading.WaitHandle.WaitAll%2A>方法不支持在具有的线程上<xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-409">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="9ff63-410">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-410">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="9ff63-411">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="9ff63-411">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="9ff63-412">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitAll%2A>从非默认托管上下文内部调用方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-412">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="9ff63-413">如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-413">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="9ff63-414">即使你当前正在执行一个方法不派生自的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="9ff63-414">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="9ff63-415">你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.WaitAll%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-415">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="9ff63-416">它的调用后将返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitAll%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="9ff63-416">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="9ff63-417">这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-417">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="9ff63-418">在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="9ff63-418">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="9ff63-419">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitAll%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="9ff63-419">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="9ff63-420">当<xref:System.Threading.WaitHandle.WaitAll%2A>方法返回时，调用线程必须等待重新进入的同步域。</span><span class="sxs-lookup"><span data-stu-id="9ff63-420">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9ff63-421">下面的代码示例演示如何使用线程池来以异步方式创建和写入到一组文件。</span><span class="sxs-lookup"><span data-stu-id="9ff63-421">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="9ff63-422">完成后，每个写入操作进行排队作为工作项和信号。</span><span class="sxs-lookup"><span data-stu-id="9ff63-422">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="9ff63-423">主线程等待所有项发出信号，然后退出。</span><span class="sxs-lookup"><span data-stu-id="9ff63-423">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9ff63-424">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-424">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-425">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-425">-or-</span>
          </span>
          <span data-ttu-id="9ff63-426">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-426">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-427">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-427">-or-</span>
          </span>
          <span data-ttu-id="9ff63-428">
            <paramref name="waitHandles" /> 为不具有元素的数组且 .NET Framework 版本为 2.0 或更高版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-428">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="9ff63-429">
            <paramref name="waitHandles" /> 数组包含重复的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-429">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9ff63-430">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-430">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="9ff63-431">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-431">-or-</span>
          </span>
          <span data-ttu-id="9ff63-432">
            <see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-432">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="9ff63-433">
            <paramref name="waitHandles" /> 数组不含任何元素，并且 .NET Framework 版本为 1.0 或 1.1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-433">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9ff63-434">
            <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-434">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="9ff63-435">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-435">-or-</span>
          </span>
          <span data-ttu-id="9ff63-436">
            <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-436">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-437">等待终止，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-437">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-438">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-438">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-439">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-439">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9ff63-440">等待指定数组中的任一元素收到信号。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-440">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="9ff63-441">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-441">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-442">等待指定数组中的任一元素收到信号。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-442">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-443">满足等待的对象的数组索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-443">The array index of the object that satisfied the wait.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-444"><xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。</span><span class="sxs-lookup"><span data-stu-id="9ff63-444"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="9ff63-445">在以前版本，<xref:System.Threading.WaitHandle.WaitAny%2A>方法返回`true`如果等待完成因为放弃互斥体。</span><span class="sxs-lookup"><span data-stu-id="9ff63-445">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="9ff63-446">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="9ff63-446">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="9ff63-447">对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-447">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="9ff63-448">异常将包含信息对于调试很有用。</span><span class="sxs-lookup"><span data-stu-id="9ff63-448">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="9ff63-449"><xref:System.Threading.WaitHandle.WaitAny%2A>方法抛出异常<xref:System.Threading.AbandonedMutexException>仅等待完成由于放弃的 mutex。</span><span class="sxs-lookup"><span data-stu-id="9ff63-449">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="9ff63-450">如果`waitHandles`包含使用较低的索引号比放弃的 mutex，释放的互斥体<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="9ff63-450">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9ff63-451">在版本的.NET Framework 早于 2.0 版中，如果线程退出或中止，且不显式释放<xref:System.Threading.Mutex>，且`Mutex`中位于索引 0 （零）`WaitAny`上另一线程，返回的索引的数组`WaitAny`是而不是 0 128。</span><span class="sxs-lookup"><span data-stu-id="9ff63-451">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="9ff63-452">此方法返回时任何句柄处于有信号状态。</span><span class="sxs-lookup"><span data-stu-id="9ff63-452">This method returns when any handle is signaled.</span></span> <span data-ttu-id="9ff63-453">如果多个对象将被发送信号呼叫期间，返回值将为所有终止的对象的最小索引值中具有终止对象的数组索引。</span><span class="sxs-lookup"><span data-stu-id="9ff63-453">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="9ff63-454">在某些实现中，如果多个传递的 64 句柄，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="9ff63-454">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="9ff63-455">调用此方法重载是等效于调用<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>方法重载并指定-1 (或<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) 为`millisecondsTimeout`和`true`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="9ff63-455">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9ff63-456">下面的代码示例演示如何调用<xref:System.Threading.WaitHandle.WaitAny%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-456">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9ff63-457">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-457">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-458">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-458">-or-</span>
          </span>
          <span data-ttu-id="9ff63-459">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-459">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9ff63-460">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-460">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="9ff63-461">
            <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 1.0 或 1.1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-461">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-462">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-462">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-463">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-463">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9ff63-464">
            <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 2.0 或更高。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-464">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-465">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-465">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="9ff63-466">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-466">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="9ff63-467">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-467">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-468">等待指定数组中的任意元素接收信号，同时使用 32 位有符号整数指定时间间隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-468">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-469">满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <paramref name="millisecondsTimeout" /> 的时间间隔已过，则为 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-469">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-470">如果`millisecondsTimeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-470">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="9ff63-471">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="9ff63-471">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="9ff63-472"><xref:System.Threading.WaitHandle.WaitAny%2A>方法抛出异常<xref:System.Threading.AbandonedMutexException>仅等待完成由于放弃的 mutex。</span><span class="sxs-lookup"><span data-stu-id="9ff63-472">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="9ff63-473">如果`waitHandles`包含使用较低的索引号比放弃的 mutex，释放的互斥体<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="9ff63-473">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="9ff63-474">此方法返回时，等待将终止，会向任何句柄发出信号或发生超时时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-474">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="9ff63-475">如果多个对象将被发送信号呼叫期间，返回值将为所有终止的对象的最小索引值中具有终止对象的数组索引。</span><span class="sxs-lookup"><span data-stu-id="9ff63-475">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="9ff63-476">在某些实现中，如果多个传递的 64 句柄，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="9ff63-476">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="9ff63-477">调用此方法重载是调用相同<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="9ff63-477">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9ff63-478">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-478">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-479">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-479">-or-</span>
          </span>
          <span data-ttu-id="9ff63-480">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-480">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9ff63-481">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-481">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9ff63-482">
            <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-482">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-483">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-483">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-484">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-484">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9ff63-485">
            <paramref name="waitHandles" /> 是一个不含任何元素的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-485">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-486">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-486">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="9ff63-487">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-487">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="9ff63-488">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-488">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-489">等待指定数组中的任意元素接收信号，同时使用 <see cref="T:System.TimeSpan" /> 指定时间间隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-489">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-490">满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <paramref name="timeout" /> 的时间间隔已过，则为 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-490">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-491">如果`timeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-491">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="9ff63-492">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="9ff63-492">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="9ff63-493"><xref:System.Threading.WaitHandle.WaitAny%2A>方法抛出异常<xref:System.Threading.AbandonedMutexException>仅等待完成由于放弃的 mutex。</span><span class="sxs-lookup"><span data-stu-id="9ff63-493">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="9ff63-494">如果`waitHandles`包含使用较低的索引号比放弃的 mutex，释放的互斥体<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="9ff63-494">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="9ff63-495">此方法返回时，等待将终止，会向任何句柄发出信号或超时发生时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-495">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="9ff63-496">如果多个对象将被发送信号呼叫期间，返回值将为所有终止的对象的最小索引值中具有终止对象的数组索引。</span><span class="sxs-lookup"><span data-stu-id="9ff63-496">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="9ff63-497">在某些实现中，如果多个传递的 64 句柄，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="9ff63-497">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="9ff63-498">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-498">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9ff63-499">调用此方法重载是调用相同<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="9ff63-499">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9ff63-500">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-500">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-501">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-501">-or-</span>
          </span>
          <span data-ttu-id="9ff63-502">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-502">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9ff63-503">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-503">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9ff63-504">
            <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-504">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="9ff63-505">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-505">-or-</span>
          </span>
          <span data-ttu-id="9ff63-506">
            <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-506">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-507">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-507">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-508">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-508">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9ff63-509">
            <paramref name="waitHandles" /> 是一个不含任何元素的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-509">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-510">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-510">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="9ff63-511">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-511">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="9ff63-512">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-512">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="9ff63-513">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-513">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-514">等待指定数组中的任一元素收到信号，使用 32 位带符号整数指定时间间隔并指定是否在等待之前退出同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-514">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-515">满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <paramref name="millisecondsTimeout" /> 的时间间隔已过，则为 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-515">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-516">如果`millisecondsTimeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-516">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="9ff63-517">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="9ff63-517">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="9ff63-518"><xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。</span><span class="sxs-lookup"><span data-stu-id="9ff63-518"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="9ff63-519">在以前版本，<xref:System.Threading.WaitHandle.WaitAny%2A>方法返回`true`如果等待完成因为放弃互斥体。</span><span class="sxs-lookup"><span data-stu-id="9ff63-519">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="9ff63-520">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="9ff63-520">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="9ff63-521">对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-521">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="9ff63-522">异常将包含信息对于调试很有用。</span><span class="sxs-lookup"><span data-stu-id="9ff63-522">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="9ff63-523"><xref:System.Threading.WaitHandle.WaitAny%2A>方法抛出异常<xref:System.Threading.AbandonedMutexException>仅等待完成由于放弃的 mutex。</span><span class="sxs-lookup"><span data-stu-id="9ff63-523">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="9ff63-524">如果`waitHandles`包含使用较低的索引号比放弃的 mutex，释放的互斥体<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="9ff63-524">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9ff63-525">在版本的.NET Framework 早于 2.0 版中，如果线程退出或中止，且不显式释放<xref:System.Threading.Mutex>，且`Mutex`中位于索引 0 （零）`WaitAny`上另一线程，返回的索引的数组`WaitAny`是而不是 0 128。</span><span class="sxs-lookup"><span data-stu-id="9ff63-525">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="9ff63-526">此方法返回时，等待将终止，会向任何句柄发出信号或发生超时时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-526">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="9ff63-527">如果多个对象将被发送信号呼叫期间，返回值将为所有终止的对象的最小索引值中具有终止对象的数组索引。</span><span class="sxs-lookup"><span data-stu-id="9ff63-527">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="9ff63-528">在某些实现中，如果多个传递的 64 句柄，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="9ff63-528">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="9ff63-529">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="9ff63-529">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="9ff63-530">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitAny%2A>从非默认托管上下文内部调用方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-530">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="9ff63-531">如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-531">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="9ff63-532">即使你当前正在执行一个方法不是派生的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="9ff63-532">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="9ff63-533">你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.WaitAny%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-533">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="9ff63-534">线程的调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitAny%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="9ff63-534">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="9ff63-535">这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-535">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="9ff63-536">在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="9ff63-536">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="9ff63-537">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitAny%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="9ff63-537">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="9ff63-538">当<xref:System.Threading.WaitHandle.WaitAny%2A>方法返回时，调用线程必须等待重新进入的同步域。</span><span class="sxs-lookup"><span data-stu-id="9ff63-538">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9ff63-539">下面的代码示例演示如何使用线程池可同时搜索的多个磁盘上的文件。</span><span class="sxs-lookup"><span data-stu-id="9ff63-539">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="9ff63-540">对于空间注意事项，搜索每个磁盘的根目录。</span><span class="sxs-lookup"><span data-stu-id="9ff63-540">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9ff63-541">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-541">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-542">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-542">-or-</span>
          </span>
          <span data-ttu-id="9ff63-543">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-543">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9ff63-544">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-544">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="9ff63-545">
            <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 1.0 或 1.1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-545">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9ff63-546">
            <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-546">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-547">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-547">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-548">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-548">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9ff63-549">
            <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 2.0 或更高。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-549">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-550">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-550">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="9ff63-551">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-551">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="9ff63-552">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-552">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="9ff63-553">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-553">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-554">等待指定数组中的任一元素收到信号，使用 <see cref="T:System.TimeSpan" /> 指定时间间隔并指定是否在等待之前退出同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-554">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-555">满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <paramref name="timeout" /> 的时间间隔已过，则为 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-555">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-556">如果`timeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-556">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="9ff63-557">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="9ff63-557">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="9ff63-558"><xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。</span><span class="sxs-lookup"><span data-stu-id="9ff63-558"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="9ff63-559">在以前版本，<xref:System.Threading.WaitHandle.WaitAny%2A>方法返回`true`如果等待完成因为放弃互斥体。</span><span class="sxs-lookup"><span data-stu-id="9ff63-559">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="9ff63-560">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="9ff63-560">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="9ff63-561">对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-561">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="9ff63-562">异常将包含信息对于调试很有用。</span><span class="sxs-lookup"><span data-stu-id="9ff63-562">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="9ff63-563"><xref:System.Threading.WaitHandle.WaitAny%2A>方法抛出异常<xref:System.Threading.AbandonedMutexException>仅等待完成由于放弃的 mutex。</span><span class="sxs-lookup"><span data-stu-id="9ff63-563">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="9ff63-564">如果`waitHandles`包含使用较低的索引号比放弃的 mutex，释放的互斥体<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="9ff63-564">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9ff63-565">在版本的.NET Framework 早于 2.0 版中，如果线程退出或中止，且不显式释放<xref:System.Threading.Mutex>，且`Mutex`中位于索引 0 （零）`WaitAny`上另一线程，返回的索引的数组`WaitAny`是而不是 0 128。</span><span class="sxs-lookup"><span data-stu-id="9ff63-565">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="9ff63-566">此方法返回时，等待将终止，会向任何句柄发出信号或超时发生时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-566">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="9ff63-567">如果多个对象将被发送信号呼叫期间，返回值将为所有终止的对象的最小索引值中具有终止对象的数组索引。</span><span class="sxs-lookup"><span data-stu-id="9ff63-567">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="9ff63-568">在某些实现中，如果多个传递的 64 句柄，<xref:System.NotSupportedException>引发。</span><span class="sxs-lookup"><span data-stu-id="9ff63-568">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="9ff63-569">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-569">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="9ff63-570">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="9ff63-570">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="9ff63-571">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitAny%2A>从非默认托管上下文内部调用方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-571">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="9ff63-572">如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-572">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="9ff63-573">即使你当前正在执行一个方法不是派生的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="9ff63-573">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="9ff63-574">你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.WaitAny%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-574">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="9ff63-575">线程的调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitAny%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="9ff63-575">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="9ff63-576">这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-576">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="9ff63-577">在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="9ff63-577">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="9ff63-578">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitAny%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="9ff63-578">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="9ff63-579">当<xref:System.Threading.WaitHandle.WaitAny%2A>方法返回时，调用线程必须等待重新进入的同步域。</span><span class="sxs-lookup"><span data-stu-id="9ff63-579">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9ff63-580">下面的代码示例演示如何使用线程池可同时搜索的多个磁盘上的文件。</span><span class="sxs-lookup"><span data-stu-id="9ff63-580">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="9ff63-581">对于空间注意事项，搜索每个磁盘的根目录。</span><span class="sxs-lookup"><span data-stu-id="9ff63-581">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9ff63-582">
            <paramref name="waitHandles" /> 参数为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-582">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="9ff63-583">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-583">-or-</span>
          </span>
          <span data-ttu-id="9ff63-584">
            <paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-584">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9ff63-585">
            <paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-585">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="9ff63-586">
            <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 1.0 或 1.1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-586">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9ff63-587">
            <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-587">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="9ff63-588">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-588">-or-</span>
          </span>
          <span data-ttu-id="9ff63-589">
            <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-589">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-590">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-590">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-591">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-591">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9ff63-592">
            <paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 2.0 或更高。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-592">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-593">
            <paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-593">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9ff63-594">阻止当前线程，直到当前 <see cref="T:System.Threading.WaitHandle" /> 收到信号。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-594">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9ff63-595">阻止当前线程，直到当前 <see cref="T:System.Threading.WaitHandle" /> 收到信号。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-595">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-596">如果当前实例收到信号，则为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-596">
              <see langword="true" /> if the current instance receives a signal.</span>
          </span>
          <span data-ttu-id="9ff63-597">如果当前实例永不发出信号，则 <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> 永不返回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-597">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-598"><xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。</span><span class="sxs-lookup"><span data-stu-id="9ff63-598"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="9ff63-599">在以前版本，<xref:System.Threading.WaitHandle.WaitOne%2A>方法返回`true`时放弃互斥体。</span><span class="sxs-lookup"><span data-stu-id="9ff63-599">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="9ff63-600">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="9ff63-600">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="9ff63-601">对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-601">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="9ff63-602">异常将包含信息对于调试很有用。</span><span class="sxs-lookup"><span data-stu-id="9ff63-602">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="9ff63-603">此方法将阻塞，直到当前实例无限期的调用方收到信号。</span><span class="sxs-lookup"><span data-stu-id="9ff63-603">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="9ff63-604">使用此方法进行阻止，直至<xref:System.Threading.WaitHandle>从另一个线程收到信号，如则会生成异步操作完成时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-604">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="9ff63-605">有关详细信息，请参阅<xref:System.IAsyncResult>接口。</span><span class="sxs-lookup"><span data-stu-id="9ff63-605">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="9ff63-606">调用此方法重载是等效于调用<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>方法重载并指定-1 或<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>第一个参数和`false`为第二个参数。</span><span class="sxs-lookup"><span data-stu-id="9ff63-606">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="9ff63-607">重写此方法以自定义派生类的行为。</span><span class="sxs-lookup"><span data-stu-id="9ff63-607">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9ff63-608">下面的代码示例演示如何使用等待句柄以防止进程终止等待后台线程完成执行时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-608">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="9ff63-609">已释放当前实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-609">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-610">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-610">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-611">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-611">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-612">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-612">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="9ff63-613">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-613">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-614">阻止当前线程，直到当前 <see cref="T:System.Threading.WaitHandle" /> 收到信号，同时使用 32 位带符号整数指定时间间隔（以毫秒为单位）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-614">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-615">如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-615">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-616">如果`millisecondsTimeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-616">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="9ff63-617">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="9ff63-617">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="9ff63-618">此方法受到阻止，直到当前实例收到信号或超时的调用方时发生。</span><span class="sxs-lookup"><span data-stu-id="9ff63-618">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="9ff63-619">使用此方法进行阻止，直至<xref:System.Threading.WaitHandle>从另一个线程收到信号，如则会生成异步操作完成时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-619">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="9ff63-620">有关详细信息，请参阅<xref:System.IAsyncResult>接口。</span><span class="sxs-lookup"><span data-stu-id="9ff63-620">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="9ff63-621">重写此方法以自定义派生类的行为。</span><span class="sxs-lookup"><span data-stu-id="9ff63-621">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="9ff63-622">调用此方法重载是调用相同<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="9ff63-622">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9ff63-623">下面的代码示例演示如何使用等待句柄以防止进程终止等待后台线程完成执行时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-623">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="9ff63-624">已释放当前实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-624">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9ff63-625">
            <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-625">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-626">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-626">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-627">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-627">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-628">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-628">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="9ff63-629">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-629">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-630">阻止当前线程，直到当前实例收到信号，同时使用 <see cref="T:System.TimeSpan" /> 指定时间间隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-630">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-631">如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-631">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-632">如果`timeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-632">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="9ff63-633">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="9ff63-633">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="9ff63-634">此方法受到阻止，直到当前实例收到信号或超时的调用方时发生。</span><span class="sxs-lookup"><span data-stu-id="9ff63-634">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="9ff63-635">使用此方法进行阻止，直至<xref:System.Threading.WaitHandle>从另一个线程收到信号，如则会生成异步操作完成时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-635">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="9ff63-636">有关详细信息，请参阅<xref:System.IAsyncResult>接口。</span><span class="sxs-lookup"><span data-stu-id="9ff63-636">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="9ff63-637">重写此方法以自定义派生类的行为。</span><span class="sxs-lookup"><span data-stu-id="9ff63-637">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="9ff63-638">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-638">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9ff63-639">调用此方法重载是调用相同<xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29>重载并指定`false`为`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="9ff63-639">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="9ff63-640">已释放当前实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-640">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9ff63-641">
            <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-641">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="9ff63-642">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-642">-or-</span>
          </span>
          <span data-ttu-id="9ff63-643">
            <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-643">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-644">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-644">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-645">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-645">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-646">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-646">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="9ff63-647">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-647">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="9ff63-648">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-648">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-649">阻止当前线程，直到当前的 <see cref="T:System.Threading.WaitHandle" /> 收到信号为止，同时使用 32 位带符号整数指定时间间隔，并指定是否在等待之前退出同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-649">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-650">如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-650">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-651">如果`millisecondsTimeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-651">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="9ff63-652">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="9ff63-652">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="9ff63-653"><xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。</span><span class="sxs-lookup"><span data-stu-id="9ff63-653"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="9ff63-654">在以前版本，<xref:System.Threading.WaitHandle.WaitOne%2A>方法返回`true`时放弃互斥体。</span><span class="sxs-lookup"><span data-stu-id="9ff63-654">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="9ff63-655">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="9ff63-655">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="9ff63-656">对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-656">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="9ff63-657">异常将包含信息对于调试很有用。</span><span class="sxs-lookup"><span data-stu-id="9ff63-657">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="9ff63-658">此方法受到阻止，直到当前实例收到信号或超时的调用方时发生。</span><span class="sxs-lookup"><span data-stu-id="9ff63-658">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="9ff63-659">使用此方法进行阻止，直至<xref:System.Threading.WaitHandle>从另一个线程收到信号，如则会生成异步操作完成时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-659">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="9ff63-660">有关详细信息，请参阅<xref:System.IAsyncResult>接口。</span><span class="sxs-lookup"><span data-stu-id="9ff63-660">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="9ff63-661">重写此方法以自定义派生类的行为。</span><span class="sxs-lookup"><span data-stu-id="9ff63-661">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="9ff63-662">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="9ff63-662">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="9ff63-663">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitOne%2A>从非默认托管上下文内部调用方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-663">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="9ff63-664">如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-664">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="9ff63-665">即使你当前正在执行一个方法不是派生的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="9ff63-665">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="9ff63-666">你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-666">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="9ff63-667">线程的调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitOne%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="9ff63-667">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="9ff63-668">这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-668">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="9ff63-669">在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="9ff63-669">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="9ff63-670">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitOne%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="9ff63-670">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="9ff63-671">当<xref:System.Threading.WaitHandle.WaitOne%2A>方法返回时，调用线程必须等待重新进入的同步域。</span><span class="sxs-lookup"><span data-stu-id="9ff63-671">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9ff63-672">下面的示例演示如何<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>方法重载的行为在一个域中同步调用时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-672">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="9ff63-673">首先的线程在等待`exitContext`设置为`false`并阻止，直到等待超时到期。</span><span class="sxs-lookup"><span data-stu-id="9ff63-673">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="9ff63-674">第二个线程执行之后的第一个线程终止，并等待`exitContext`设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="9ff63-674">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="9ff63-675">不阻止发送信号等待句柄的此第二个线程的调用，并且在线程在等待超时前完成。</span><span class="sxs-lookup"><span data-stu-id="9ff63-675">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="9ff63-676">已释放当前实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-676">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9ff63-677">
            <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-677">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-678">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-678">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-679">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-679">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-680">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-680">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="9ff63-681">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-681">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="9ff63-682">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-682">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9ff63-683">阻止当前线程，直到当前实例收到信号为止，同时使用 <see cref="T:System.TimeSpan" /> 指定时间间隔，并指定是否在等待之前退出同步域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-683">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9ff63-684">如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-684">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-685">如果`timeout`为零，该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-685">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="9ff63-686">它测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="9ff63-686">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="9ff63-687"><xref:System.Threading.AbandonedMutexException> .NET Framework 2.0 版中新增了。</span><span class="sxs-lookup"><span data-stu-id="9ff63-687"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="9ff63-688">在以前版本，<xref:System.Threading.WaitHandle.WaitOne%2A>方法返回`true`时放弃互斥体。</span><span class="sxs-lookup"><span data-stu-id="9ff63-688">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="9ff63-689">放弃的 mutex 通常表明存在严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="9ff63-689">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="9ff63-690">对于整个系统互斥体，则可能指示应用程序已 （例如，通过使用 Windows 任务管理器） 突然终止。</span><span class="sxs-lookup"><span data-stu-id="9ff63-690">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="9ff63-691">异常将包含信息对于调试很有用。</span><span class="sxs-lookup"><span data-stu-id="9ff63-691">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="9ff63-692">此方法受到阻止，直到当前实例收到信号或超时的调用方时发生。</span><span class="sxs-lookup"><span data-stu-id="9ff63-692">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="9ff63-693">使用此方法进行阻止，直至<xref:System.Threading.WaitHandle>从另一个线程收到信号，如则会生成异步操作完成时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-693">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="9ff63-694">有关详细信息，请参阅<xref:System.IAsyncResult>接口。</span><span class="sxs-lookup"><span data-stu-id="9ff63-694">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="9ff63-695">重写此方法以自定义派生类的行为。</span><span class="sxs-lookup"><span data-stu-id="9ff63-695">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="9ff63-696">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-696">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="9ff63-697">在退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="9ff63-697">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="9ff63-698">`exitContext`参数无任何效果，除非<xref:System.Threading.WaitHandle.WaitOne%2A>从非默认托管上下文内部调用方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-698">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="9ff63-699">如果你的线程位于对派生自的类的实例的调用会发生此<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-699">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="9ff63-700">即使你当前正在执行一个方法不是派生的类上<xref:System.ContextBoundObject>、 like <xref:System.String>，你可以在非默认上下文是如果<xref:System.ContextBoundObject>位于当前的应用程序域中的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="9ff63-700">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="9ff63-701">你的代码执行时在非默认上下文中，指定`true`为`exitContext`导致线程退出非默认托管的上下文 (即转换到默认上下文) 执行之前<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9ff63-701">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="9ff63-702">线程的调用后返回到原始的非默认上下文<xref:System.Threading.WaitHandle.WaitOne%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="9ff63-702">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="9ff63-703">这一点可能很有用，在此上下文绑定类具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="9ff63-703">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="9ff63-704">在这种情况下，对类的成员的所有调用将自动都同步，并且同步域是类的代码的整个正文。</span><span class="sxs-lookup"><span data-stu-id="9ff63-704">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="9ff63-705">如果某个成员的调用堆栈中的代码将调用<xref:System.Threading.WaitHandle.WaitOne%2A>方法并指定`true`为`exitContext`，在线程退出同步域，允许对象的任何成员的调用来继续在被阻止的线程。</span><span class="sxs-lookup"><span data-stu-id="9ff63-705">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="9ff63-706">当<xref:System.Threading.WaitHandle.WaitOne%2A>方法返回时，调用线程必须等待重新进入的同步域。</span><span class="sxs-lookup"><span data-stu-id="9ff63-706">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9ff63-707">下面的代码示例演示如何使用等待句柄以防止进程终止等待后台线程完成执行时。</span><span class="sxs-lookup"><span data-stu-id="9ff63-707">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="9ff63-708">已释放当前实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-708">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9ff63-709">
            <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-709">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="9ff63-710">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-710">-or-</span>
          </span>
          <span data-ttu-id="9ff63-711">
            <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-711">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="9ff63-712">等待结束，因为线程在未释放互斥的情况下退出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-712">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="9ff63-713">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-713">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9ff63-714">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-714">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="9ff63-715">指示在任何等待句柄终止之前 <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> 操作已超时。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-715">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span>
          </span>
          <span data-ttu-id="9ff63-716">此字段为常数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9ff63-716">This field is constant.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9ff63-717">此字段是一个可能的返回值的`WaitAny`。</span><span class="sxs-lookup"><span data-stu-id="9ff63-717">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9ff63-718">下面的代码示例演示如何使用线程池可同时搜索的多个磁盘上的文件。</span><span class="sxs-lookup"><span data-stu-id="9ff63-718">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="9ff63-719">对于空间注意事项，搜索每个磁盘的根目录。</span><span class="sxs-lookup"><span data-stu-id="9ff63-719">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>