<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a136bc8fb48fe619f1be21928afbfcd9094d7463" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30474581" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>通过 <see cref="T:System.Reflection.Emit.ILGenerator" /> 类成员（例如 <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />）为发出提供 Microsoft 中间语言 (MSIL) 指令的字段表示形式。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关成员操作码的详细说明，请参阅公共语言基础结构 (CLI) 文档，尤其是"第三部分： CIL 指令集"和"第 ii 部分： 元数据定义和语义"。 可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](http://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)。  
  
   
  
## Examples  
 下面的示例演示的动态方法使用构造<xref:System.Reflection.Emit.ILGenerator>发出`OpCodes`到<xref:System.Reflection.Emit.MethodBuilder>。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相加并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|58|添加|将添加两个数值，则返回一个新的数字值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`添加到`value2`。  
  
4.  将结果推送到堆栈上。  
  
 对于整数运算不检测溢出 (有关正确的溢出处理问题，请参阅<xref:System.Reflection.Emit.OpCodes.Add_Ovf>)。  
  
 整数加法包装，而不会使更饱满。 例如，假定 8 位整数其中`value1`都设置为 255 和`value2`设置为 1，已包装的结果是 0，而不是 256。  
  
 浮点溢出返回`+inf`(`PositiveInfinity`) 或`-inf`(`NegativeInfinity`)。  
  
 下表中列出的可接受的操作数类型和其相应的结果数据类型。 如果没有为特定类型组合项 (例如，`int32`和`float`;`int32`和`int64`)，它是无效 Microsoft 中间语言 (MSIL) 并生成错误。  
  
|操作数|value1 类型|value2 类型|结果类型|  
|-------------|-----------------|-----------------|-----------------|  
|添加|`int32`|`int32`|`int32`|  
|添加|`int32`|`native int`|`native int`|  
|添加|`int32`|`&`|`&`|  
|添加|`int32`|`*`|`*`|  
|添加|`int64`|`int64`|`int64`|  
|添加|`native int`|`int32`|`native int`|  
|添加|`native int`|`native int`|`native int`|  
|添加|`native int`|`&`|`&`|  
|添加|`native int`|`*`|`*`|  
|添加|`F`|`F`|`F`|  
|添加|`&`|`int32`|`&`|  
|添加|`&`|`native int`|`&`|  
|添加|`*`|`int32`|`*`|  
|添加|`*`|`native int`|`*`|  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`add`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个整数相加，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D6|add.ovf|将添加两个有符号的整数值的溢出检查。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`添加到`value2`加上溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 <xref:System.OverflowException> 如果结果不表示该结果类型中将引发。  
  
 你可以执行此操作对有符号整数。 对于浮点值，请使用<xref:System.Reflection.Emit.OpCodes.Add>。  
  
 下表中列出的可接受的操作数类型和其相应的结果数据类型。 如果没有为特定类型组合项 (例如，`int32`和`float`;`int32`和`int64`)，它是一个无效的 Microsoft 中间语言 (MSIL) 指令，将生成错误。  
  
|操作数|value1 类型|value2 类型|结果类型|  
|-------------|-----------------|-----------------|-----------------|  
|添加|`int32`|`int32`|`int32`|  
|添加|`int32`|`native int`|`native int`|  
|添加|`int32`|`&`|`&`|  
|添加|`int32`|`*`|`*`|  
|添加|`int64`|`int64`|`int64`|  
|添加|`native int`|`int32`|`native int`|  
|添加|`native int`|`native int`|`native int`|  
|添加|`native int`|`&`|`&`|  
|添加|`native int`|`*`|`*`|  
|添加|`F`|`F`|`F`|  
|添加|`&`|`int32`|`&`|  
|添加|`&`|`native int`|`&`|  
|添加|`*`|`int32`|`*`|  
|添加|`*`|`native int`|`*`|  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`add.ovf`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个无符号整数值相加，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D7|add.ovf.un|将添加两个无符号的整数值的溢出检查。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`添加到`value2`加上溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 <xref:System.OverflowException> 如果结果不表示该结果类型中将引发。  
  
 你可以执行此操作对有符号整数。 对于浮点值，请使用<xref:System.Reflection.Emit.OpCodes.Add>。  
  
 下表中列出的可接受的操作数类型和其相应的结果数据类型。 如果没有为特定类型组合项 (例如，`int32`和`float`;`int32`和`int64`)，它是一个无效的 Microsoft 中间语言 (MSIL) 指令，将生成错误。  
  
|操作数|value1 类型|value2 类型|结果类型|  
|-------------|-----------------|-----------------|-----------------|  
|添加|`int32`|`int32`|`int32`|  
|添加|`int32`|`native int`|`native int`|  
|添加|`int32`|`&`|`&`|  
|添加|`int32`|`*`|`*`|  
|添加|`int64`|`int64`|`int64`|  
|添加|`native int`|`int32`|`native int`|  
|添加|`native int`|`native int`|`native int`|  
|添加|`native int`|`&`|`&`|  
|添加|`native int`|`*`|`*`|  
|添加|`F`|`F`|`F`|  
|添加|`&`|`int32`|`&`|  
|添加|`&`|`native int`|`&`|  
|添加|`*`|`int32`|`*`|  
|添加|`*`|`native int`|`*`|  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`add.ovf.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算两个值的按位“与”并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|指令|描述|  
|------------|-----------------|-----------------|  
|5F|和|确定两个整数值的按位 AND。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value1` 和`value2`从堆栈中弹出计算两个值的按位 AND。  
  
4.  将结果推送到堆栈上。  
  
 `and`指令计算堆栈上的前两个值的按位 AND 并将结果留在堆栈上。  
  
 `And` 是一个整数特定操作。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`and`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回指向当前方法的参数列表的非托管指针。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 00|arglist|返回当前方法的自变量列表的句柄。|  
  
 此操作会不执行任何计算堆栈的行为。  
  
 `arglist`指令返回一个不透明的句柄 (类型的非托管的指针`native int`)，表示当前方法的自变量列表。 仅在当前方法的生存期内，此句柄有效。 但是，可以将该句柄传递给其他方法，只要当前方法将在控件的线程上。 你只能执行`arglist`采用数目可变的参数的方法中的指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`arglist`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果两个值相等，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq `target`|分支到目标指令，偏移量`target`如果两个值相等。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`等同于`value2`，执行分支操作。  
  
 `beq`指令将控制转移到指定的目标指令如果`value1`等同于`value2`。 效果是与执行相同`ceq`指令跟`brtrue`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 4 字节有符号偏移量。  
  
 下面概括了可接受的操作数类型：  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。  
  
 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令 (此类传输受到严格限制，必须使用<xref:System.Reflection.Emit.OpCodes.Leave>指令相反)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`beq`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果两个值相等，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|2E < `int8` >|beq.s `target`|分支到目标指令，偏移量`target`如果相等，缩写形式|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`等同于`value2`，执行分支操作。  
  
 `beq.s`指令将控制转移到指定的目标指令如果`value1`等同于`value2`。 效果是与执行相同`ceq`指令跟`brtrue`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 1 字节有符号偏移量。  
  
 下面概括了可接受的操作数类型：  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。  
  
 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令 (此类传输受到严格限制，必须使用<xref:System.Reflection.Emit.OpCodes.Leave>指令相反)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`beq.s`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于或等于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge `target`|到目标指令的第一个值是否大于或等于第二个值指定的偏移量处的分支。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`大于或等于`value2`，执行分支操作。  
  
 `bge`指令将控制转移到指定的目标指令如果`value1`大于或等于`value2`。 效果相当于执行`clt.un`指令跟`brfalse`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 4 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`bge`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于或等于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|2F `<int8>`|bge.s `target`|到目标指令的第一个值是否大于或等于第二个值，缩写形式指定的偏移量处的分支。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`大于或等于`value2`，执行分支操作。  
  
 `bge.s`指令将控制转移到指定的目标指令如果`value1`大于或等于`value2`。 效果相当于执行`clt.un`指令跟`brfalse`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 1 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`bge.s`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|41 `<int32>`|进行 `target`|到目标指令的第一个值是否大于或等于第二个值 （无符号值） 指定的偏移量处的分支。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`大于或等于`value2`，执行分支操作。  
  
 `bge.un`指令将控制转移到指定的目标指令如果`value1`大于或等于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果相当于执行`clt`指令跟`brfalse`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 4 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`bge.un`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|34 < `int8` >|进行 `target`|到目标指令的第一个值是否大于或等于第二个值 （无符号值），缩写形式指定的偏移量处的分支。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`大于或等于`value2`，执行分支操作。  
  
 `bge.un.s`指令将控制转移到指定的目标指令如果`value1`大于或等于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果相当于执行`clt`指令跟`brfalse`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 1 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`bge.un.s`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|3D < `int32` >|标题 `target`|到目标指令的第一个值是否大于第二个值指定的偏移量处的分支。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`大于`value2`，执行分支操作。  
  
 `bgt`指令将控制转移到指定的目标指令如果`value1`大于`value2`。 效果相当于执行`cgt`指令跟`brtrue`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 4 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`bgt`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|30 < `int8` >|bgt.s `target`|到目标指令的第一个值是否大于第二个值，缩写形式指定的偏移量处的分支。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`大于`value2`，执行分支操作。  
  
 `bgt.s`指令将控制转移到指定的目标指令如果`value1`大于`value2`。 效果相当于执行`cgt`指令跟`brtrue`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 1 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`bgt.s`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt.un `target`|到目标指令的第一个值是否大于第二个值 （无符号值） 指定的偏移量处的分支。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`大于`value2`，执行分支操作。  
  
 `bgt.un`指令将控制转移到指定的目标指令如果`value1`大于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果相当于执行`cgt.un`指令跟`brtrue`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 4 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`bgt.un`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|35 < `int8` >|进行 `target`|到目标指令的第一个值是否大于第二个值 （无符号值），缩写形式指定的偏移量处的分支。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`大于`value2`，执行分支操作。  
  
 `bgt.un.s`指令将控制转移到指定的目标指令如果`value1`大于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果相当于执行`cgt.un`指令跟`brtrue`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 1 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`bgt.un.s`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于或等于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|3E `<int32>`|的 `target`|到目标指令的第一个值是否小于或等于第二个值指定的偏移量处的分支。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`小于或等于`value2`，执行分支操作。  
  
 `ble`指令将控制转移到指定的目标指令如果`value1`小于或等于`value2`。 效果相当于执行`cgt`指令 (`cgt.un`对于浮点型值) 跟`brfalse`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 4 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ble`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于或等于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|31 `<int8>`|ble.s `target`|到目标指令的第一个值是否小于或等于第二个值，缩写形式指定的偏移量处的分支。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`小于或等于`value2`，执行分支操作。  
  
 `ble.s`指令将控制转移到指定的目标指令如果`value1`小于或等于`value2`。 效果相当于执行`cgt`指令 (`cgt.un`对于浮点型值) 指令跟`brfalse`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 1 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ble.s`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值小于或等于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|43 `<int32>`|时 `target`|到目标指令的第一个值是否小于或等于第二个值 （无符号值） 指定的偏移量处的分支。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`小于或等于`value2`，执行分支操作。  
  
 `ble.un`指令将控制转移到指定的目标指令如果`value1`小于或等于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果相当于执行`cgt.un`指令 (`cgt`对于浮点型值) 跟`brfalse`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 4 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ble.un`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值小于或等于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|36 `<int8>`|时 `target`|到目标指令的第一个值是否小于或等于第二个值 （无符号值），缩写形式指定的偏移量处的分支。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`小于或等于`value2`，执行分支操作。  
  
 `ble.un.s`指令将控制转移到指定的目标指令如果`value1`小于或等于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果相当于执行`cgt.un`指令 (`cgt`对于浮点型值) 跟`brfalse`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 1 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ble.un.s`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|3F < `int32` >|blt `target`|分支到指定的偏移量的第一个值是否小于第二个值在该目标指令。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`是小于`value2`，执行分支操作。  
  
 `blt`指令将控制转移到指定的目标指令如果`value1`小于或等于`value2`。 效果相当于执行`clt`指令跟`brtrue`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 4 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`blt`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|32 < `int8` >|blt.s `target`|按分支到目标指令指定的偏移量的第一个值是否小于第二个值，缩写形式。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`是小于`value2`，执行分支操作。  
  
 `blt.s`指令将控制转移到指定的目标指令如果`value1`是小于`value2`。 效果相当于执行`clt`指令跟`brtrue`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 1 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`blt.s`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值小于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt.un `target`|按分支到目标指令指定的偏移量的第一个值是否小于第二个值 （无符号值）。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`是小于`value2`，执行分支操作。  
  
 `blt.un`指令将控制转移到指定的目标指令如果`value1`是小于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果相当于执行`clt.un`指令跟`brtrue`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 4 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`blt.un`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值小于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt.un.s `target`|按分支到目标指令指定的偏移量的第一个值是否小于第二个值 （无符号值），缩写形式。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`是小于`value2`，执行分支操作。  
  
 `blt.un`指令将控制转移到指定的目标指令如果`value1`是小于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果相当于执行`clt.un`指令跟`brtrue`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 4 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`blt.un.s`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当两个无符号整数值或未经排序的浮点值不相等时，将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne.un `target`|分支到目标指令，如果两个无符号整数值指定的偏移量是不相等的 （无符号的值）。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`是否不等于`value2`，执行分支操作。  
  
 `bne.un`指令将控制转移到指定的目标指令如果`value1`是否不等于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果相当于执行`ceq`指令跟`brfalse`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 4 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`bne.un`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当两个无符号整数值或未经排序的浮点值不相等时，将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne.un.s `target`|分支到目标指令，如果两个无符号整数值指定的偏移量是不相等的 （无符号的值）、 缩写形式。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈; 弹出，则`value1`是否不等于`value2`，执行分支操作。  
  
 `bne.un`指令将控制转移到指定的目标指令如果`value1`是否不等于`value2`，当使用无符号的整数或未经排序的浮点值进行比较。 效果相当于执行`ceq`指令跟`brfalse`分支到特定目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 4 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`bne.un.s`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将值类转换为对象引用（<see langword="O" /> 类型）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|8C < `T` >|box `valTypeToken`|将值类型转换 (在指定的类型`valTypeToken`) 到真正的对象引用。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值类型推送到堆栈上。  
  
2.  从堆栈中弹出值类型`box`执行操作。  
  
3.  对生成的"装箱"的值类型的对象引用推送到堆栈上。  
  
 值类型有两个单独的表示形式中公共语言基础结构 (CLI):  
  
-   使用当嵌入值类型时，在另一个对象或在堆栈上的原始形式。  
  
-   装箱形式，其中的值类型中的数据被包装 （装箱） 到对象以便它可以作为一个独立的实体存在。  
  
 `box`指令将一个对象引用转换为原始 （未装箱） 的值类型 (类型`O`)。 通过创建一个新的对象并将数据复制到新分配的对象的值类型完成此操作。 `valTypeToken` 元数据标记指示堆栈上的值类型的类型。  
  
 <xref:System.OutOfMemoryException> 如果没有足够的内存来满足该请求将引发。  
  
 <xref:System.TypeLoadException> 如果找不到类将引发。 当 Microsoft 中间语言 (MSIL) 转换为本机代码，而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`box`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>无条件地将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|到目标指令指定的偏移量处的分支。|  
  
 此操作会不执行任何计算堆栈的行为。  
  
 `br`指令无条件将控制转移到目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 4 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`br`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>无条件地将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br.s `target`|到目标指令中指定的偏移位置，缩写的分支。|  
  
 此操作会不执行任何计算堆栈的行为。  
  
 `br.s`指令无条件将控制转移到目标指令。 从当前指令之后的指令的开头情况下，该目标指令表示为 1 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`br.s`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>向公共语言结构 (CLI) 发出信号以通知调试器已撞上了一个断点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|01|break|通知调试器已到达断点。|  
  
 此操作会不执行任何计算堆栈的行为。  
  
 `break`指令要求进行调试支持。 它发出信号，以通知调试器已撞上了一个中断 CLI。 它具有解释器状态没有其他影响。  
  
 `break`指令具有最小可能指令使代码大小与中断点修补和生成到周围的代码的影响最小。  
  
 `break`指令可以捕获调试器、 不执行任何操作，或引发安全异常。 具体的行为是实现定义的。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`break`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="false" />、空引用（Visual Basic 中的 <see langword="Nothing" />）或零，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|分支到目标指令在指定的偏移量如果`false`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上一操作。  
  
2.  `value` 从堆栈中弹出如果`value`是`false`，分支到`target`。  
  
 `brfalse`指令 (和其别名`brnull`和`brzero`) 将控制转移到指定的目标指令，如果`value`(类型的`int32`， `int64`，对象引用`O`、 托管指针`&`，暂时性指针`*`， `native int`) 为零 (`false`)。 如果`value`为非零 (`true`) 在下一条指令处继续执行。  
  
 从当前指令之后的指令的开头情况下，该目标指令表示为 4 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`brfalse`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="false" />、空引用或零，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|分支到目标指令在指定的偏移量如果`false`，缩写形式。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上一操作。  
  
2.  `value` 从堆栈中弹出如果`value`是`false`，分支到`target`。  
  
 `brfalse.s`指令 (和其别名`brnull`和`brzero`) 将控制转移到指定的目标指令，如果`value`(类型的`int32`， `int64`，对象引用`O`、 托管指针`&`，暂时性指针`*`， `native int`) 为零 (`false`)。 如果`value`为非零 (`true`) 在下一条指令处继续执行。  
  
 从当前指令之后的指令的开头情况下，该目标指令表示为 1 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`brfalse.s`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="true" />、非空或非零，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|如果非零分支到目标指令指定的偏移量处 (`true`)。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上一操作。  
  
2.  `value` 从堆栈中弹出如果`value`是`true`，分支到`target`。  
  
 `brtrue`指令将控制转移到指定的目标指令如果`value`(类型`native int`) 为非零值 (`true`)。 如果`value`为零 (`false`) 在下一条指令处继续执行。  
  
 如果`value`是一个对象引用 (类型`O`) 然后`brinst`(的别名`brtrue`) 将控制权，则在它表示对象的实例 (例如，如果它不是空对象引用中; 请参阅<xref:System.Reflection.Emit.OpCodes.Ldnull>)。  
  
 从当前指令之后的指令的开头情况下，该目标指令表示为 4 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`brtrue`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="true" />、非空或非零，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|如果非零分支到目标指令指定的偏移量处 (`true`)，缩写形式。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上一操作。  
  
2.  `value` 从堆栈中弹出如果`value`是`true`，分支到`target`。  
  
 `brtrue.s`指令将控制转移到指定的目标指令如果`value`(类型`native int`) 为非零值 (`true`)。 如果`value`为零 (`false`) 在下一条指令处继续执行。  
  
 如果`value`是一个对象引用 (类型`O`) 然后`brinst`(的别名`brtrue`) 将控制权，则在它表示对象的实例 (例如，如果它不是空对象引用中; 请参阅<xref:System.Reflection.Emit.OpCodes.Ldnull>)。  
  
 从当前指令之后的指令的开头情况下，该目标指令表示为 1 字节有符号偏移量。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`brtrue.s`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>调用由传递的方法说明符指示的方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|28 < `T` >|调用 `methodDesc`|调用所描述的方法`methodDesc`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  方法自变量`arg1`通过`argN`推送到堆栈上。  
  
2.  方法自变量`arg1`通过`argN`从堆栈中弹出方法调用执行用这些自变量和控制转移到其中的方法说明符所引用的方法。 完成后，返回值为被调用方方法生成并发送到调用方。  
  
3.  返回值推送到堆栈上。  
  
 `call`指令调用由传递通过该指令的方法说明符指示的方法。 方法描述符为元数据标记，该值指示在方法调用和数量、 类型和已放置在要传递给该方法，以及要使用的调用约定的堆栈的自变量的顺序。 `call`指令可以立即前面是`tail`(<xref:System.Reflection.Emit.OpCodes.Tailcall>) 前缀，以指定应将控制转移之前释放当前方法状态的指令。 如果调用将控制权转交给比原始方法的信任级别更高的方法，将不会释放堆栈帧。 相反，继续执行以无提示方式就像`tail`尚未提供。 元数据标记传送足够信息以确定是否该调用是对静态方法、 实例方法、 虚方法或全局函数。 在所有这些情况下的目标地址确定完全从方法说明符 (与此对比<xref:System.Reflection.Emit.OpCodes.Callvirt>用于调用虚方法，其中的目标地址还取决于实例的运行时类型的指令引用推送之前<xref:System.Reflection.Emit.OpCodes.Callvirt>)。  
  
 从左到右的顺序，可将自变量位于堆栈上。 即，第一个参数是计算并放置在堆栈上，则第二个参数，则第三个、，直到所有必需的参数以降序顺序堆栈顶部。 有三个重要的特殊情况：  
  
 1. 调用方法到实例 （或虚拟） 必须推送在任何的用户可见的自变量前该实例引用。 实例引用不得为空引用。 元数据中的签名不包含的参数列表中的条目`this`指针; 相反，它使用位指示方法是否需要传递`this`指针。  
  
 2. 可调用虚方法使用`call`(而非`callvirt`); 这指示该方法是使用指定的方法，而不是指定动态从正在调用的对象的类得到解决。  
  
 3. 请注意，该委托的`Invoke`方法可以调用使用`call`或`callvirt`指令。  
  
 <xref:System.Security.SecurityException> 如果系统安全性不会授予对所调用的方法的调用方访问权限，可能会引发。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是在运行时，可能进行安全检查。  
  
> [!NOTE]
>  当在值类型上调用的 System.Object 方法，请考虑使用`constrained`前缀`callvirt`指令而不是发出`call`指令。 因此，无需发出不同 IL 具体取决于值类型重写方法，避免潜在的版本控制问题。 请考虑使用`constrained`前缀调用接口方法的值类型，因为值类型方法实现的接口方法时可以使用更改`MethodImpl`。 中的更详细地描述了这些问题<xref:System.Reflection.Emit.OpCodes.Constrained>操作码。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`call`操作码：  
  
-   ILGenerator.Emit （操作码，MethodInfo）  
  
-   ILGenerator.EmitCall (操作码，MethodInfo Type[])  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>提供方法是为了`varargs`调用。 使用<xref:System.Reflection.Emit.ILGenerator.Emit%2A>正常调用的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>通过调用约定描述的参数调用在计算堆栈上指示的方法（作为指向入口点的指针）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|调用由调用约定描述的自变量指向的方法。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  方法自变量`arg1`通过`argN`推送到堆栈上。  
  
2.  方法入口指针推入堆栈。  
  
3.  方法自变量`arg1`通过`argN`和从堆栈中弹出方法入口指针; 执行对方法的调用。 完成后，返回值为被调用方方法生成并发送到调用方。  
  
4.  返回值推送到堆栈上。  
  
 `calli`指令调用带有自变量的方法条目指针`arg1`通过`argN`。 由特定调用约定描述这些自变量的类型 (`callSiteDesc`)。 `calli`可能紧靠指令`tail`前缀 (<xref:System.Reflection.Emit.OpCodes.Tailcall>)，以指定应将控制转移之前释放当前方法状态。 如果调用将转移到比原始方法的堆栈帧的信任级别更高的方法的控件将不释放;相反，执行将继续以静默方式就像`tail`尚未提供。  
  
 假定方法入口指针是指向 （的目标计算机） 可以使用通过调用约定 （独立签名的元数据标记） 描述的自变量以合法方式调用的本机代码的特定指针。 可以使用创建此类指针<xref:System.Reflection.Emit.OpCodes.Ldftn>或<xref:System.Reflection.Emit.OpCodes.Ldvirtftn>说明，或从本机代码中传递。  
  
 调用约定不会动态检查，因此使用的代码`calli`如果目标实际上没有使用指定的调用约定，指令无法正常工作。  
  
 从左到右的顺序，可将自变量位于堆栈上。 即，第一个参数是计算并放置在堆栈上，则第二个参数，则第三个、，直到所有必需的参数以降序顺序堆栈顶部。 实例或虚方法的自变量生成的代码序列必须将该实例引用 （即不得为空引用） 推送任何的用户可见的自变量之前。  
  
 <xref:System.Security.SecurityException> 如果系统安全性不会授予对所调用的方法的调用方访问权限，可能会引发。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是在运行时，可以进行安全检查。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>方法可以用于执行`calli`堆栈上的指令。 请注意，`calli`应通过调用以下方法，而无需使用<xref:System.Reflection.Emit.ILGenerator.Emit%2A>类以直接在堆栈上放置指令。  
  
-   ILGenerator.EmitCalli （操作码、 CallingConventions、 类型类型 []，Type[]) 的呼叫，使用托管的调用约定。  
  
-   ILGenerator.EmitCalli （操作码，CallingConvention，类型，Type[]) 调用使用非托管调用约定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>对对象调用后期绑定方法，并且将返回值推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|调用相关联的特定方法`obj`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用`obj`推送到堆栈上。  
  
2.  方法自变量`arg1`通过`argN`推送到堆栈上。  
  
3.  方法自变量`arg1`通过`argN`和对象引用`obj`从堆栈中弹出方法调用执行用这些自变量和控制转移到其中的方法中`obj`引用方法元数据标记。 完成后，返回值为被调用方方法生成并发送到调用方。  
  
4.  返回值推送到堆栈上。  
  
 `callvirt`指令对对象调用后期绑定方法。 也就是说，该方法根据选择的运行时类型`obj`而不是在方法指针中可见的编译时类。 `Callvirt` 可用来调用虚拟和实例方法。 `callvirt`可能紧靠指令`tail`(<xref:System.Reflection.Emit.OpCodes.Tailcall>) 前缀，以指定应将控制转移之前释放当前堆栈帧。 如果调用将转移到比原始方法的堆栈帧的信任级别更高的方法的控件将不释放。  
  
 提供的方法元数据标记的名称、 类和要调用的方法的签名。 与关联的类`obj`是它的实例的类。 如果类定义的非静态方法，与指示的方法名称和签名匹配，则调用此方法。 否则将按顺序检查基类链中的此类的所有类。 如果未不找到任何方法，则会出错。  
  
 `Callvirt` 在调用方法前弹出对象以及从计算堆栈的关联的参数。 如果该方法具有返回值，则它是在方法完成后在堆栈上推送。 在被调用方端`obj`参数访问作为自变量 0，`arg1`作为参数 1，依此类推。  
  
 从左到右的顺序，可将自变量位于堆栈上。 即，第一个参数是计算并放置在堆栈上，则第二个参数，则第三个、，直到所有必需的参数以降序顺序堆栈顶部。 实例引用`obj`(始终需要的`callvirt`) 必须在任何的用户可见的自变量前推送。 （中的元数据标记带有） 的签名不需要此包含参数列表中的条目指针。  
  
 请注意，还可以使用调用虚方法<xref:System.Reflection.Emit.OpCodes.Call>指令。  
  
 <xref:System.MissingMethodException> 如果与关联的类中找不到具有指定的名称和签名的非静态方法，将引发`obj`或任何其基类，这些类。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码，而不是在运行时，通常是检测到此问题。  
  
 <xref:System.NullReferenceException> obj 为 null 时引发。  
  
 <xref:System.Security.SecurityException> 如果系统安全性不会授予对所调用的方法的调用方访问权限将引发。 时 CIL 被转换为本机代码而不是在运行时，可能发生的安全检查。  
  
> [!NOTE]
>  当在值类型上调用的 System.Object 方法，请考虑使用`constrained`前缀`callvirt`指令。 因此，无需发出不同 IL 具体取决于值类型重写方法，避免潜在的版本控制问题。 请考虑使用`constrained`前缀调用接口方法的值类型，因为值类型方法实现的接口方法时可以使用更改`MethodImpl`。 中的更详细地描述了这些问题<xref:System.Reflection.Emit.OpCodes.Constrained>操作码。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`callvirt`操作码：  
  
-   ILGenerator.Emit （操作码，MethodInfo）  
  
-   ILGenerator.EmitCall (操作码，MethodInfo Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>尝试将引用传递的对象转换为指定的类。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|为新的对象类型的对象强制转换`class`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用推送到堆栈上。  
  
2.  从堆栈中弹出的对象引用被引用的对象被强制转换为指定`class`。  
  
3.  如果成功，新的对象引用推送到堆栈上。  
  
 `castclass`指令尝试将对象引用强制转换 (类型`O`) 为指定的类堆栈顶部。 元数据标记，该值指示所需的类指定新类。 如果在堆栈顶层对象的类不实现新类 （假定新类一个接口），并且不是派生的类的新类则<xref:System.InvalidCastException>引发。 如果对象引用为 null 引用，`castclass`成功并返回新的对象为 null 引用。  
  
 <xref:System.InvalidCastException> 如果 obj 不能强制转换为类将引发。  
  
 <xref:System.TypeLoadException> 如果找不到类将引发。 在 Microsoft 中间语言 (MSIL) 指令将转换为本机代码而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`castclass`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个值。 如果这两个值相等，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；否则，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 01|ceq|如果推送 1`value1`等于`value2`; 否则将 0 推送。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`与相比`value2`。  
  
4.  如果`value1`等同于`value2`，1 推入堆栈; 否则将 0 推送到堆栈上。  
  
 `ceq`指令进行比较`value1`和`value2`。 如果`value1`等同于`value2`，则将 1 (类型的`int32`) 推送到堆栈上。 否则为 0 (类型的`int32`) 推送到堆栈上。  
  
 为浮点数，`ceq`将返回 0，如果数字是无序 （或者两种方法是 NaN）。 无限期的值相等对其自身。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ceq`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个值。 如果第一个值大于第二个值，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；反之，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 02|cgt|如果推送 1`value1`大于`value2`; 否则将 0 推送。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`cgt`测试`value1`大于`value2`。  
  
4.  如果`value1`大于`value2`，1 推入堆栈; 否则将 0 推送到堆栈上。  
  
 `cgt`指令进行比较`value1`和`value2`。 如果`value1`完全大于`value2`，则`int32`值 1 推送到堆栈上。 否则为`int32`为 0 的值推送到堆栈上。  
  
-   对于浮点数，`cgt`如果这两个数字是无序的 （即，如果一个或两个自变量为 NaN 时），则返回 0。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`cgt`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个无符号的或未经排序的值。 如果第一个值大于第二个值，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；反之，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|如果推送 1`value1`大于`value2`; 其他推送 0 （无符号值）。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`cgt.un`测试`value1`大于`value2`。  
  
4.  如果`value1`大于`value2`，1 推入堆栈; 否则将 0 推送到堆栈上。  
  
 `int32`值 1 推送到堆栈上，如果以下任一条件`true`:  
  
 对于浮点数，`value1`不排序相对于`value2`。  
  
 对于整数值，`value1`完全大于`value2`时视为无符号数字。  
  
 否则为`int32`为 0 的值推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`cgt.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果值不是有限数，则引发 <see cref="T:System.ArithmeticException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|C3|ckfinite|引发<xref:System.ArithmeticException>如果值不是有限的数量。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上...  
  
2.  `value` 从堆栈中弹出和`ckfinite`指令会对其执行。  
  
3.  `value` 是如果推送回到堆栈上不会引发异常。  
  
 `ckfinite instruction`引发<xref:System.ArithmeticException>如果`value`（浮点数） 是"不是数字"值 (NaN) 或`+-`无穷大值。 `Ckfinite` 将值保留在堆栈上，如果不会引发异常。 如果执行是未指定`value`不是一个浮点数字。  
  
 <xref:System.ArithmeticException> 如果引发`value`不是正常的数字。  
  
 请注意，特殊异常或派生的类的<xref:System.ArithmeticException>可能更适合，将不正确的值传递给异常处理程序。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ckfinite`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个值。 如果第一个值小于第二个值，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；反之，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 04|clt|如果推送 1`value1`是小于`value2`; 否则将 0 推送。|  
  
 执行堆栈过渡行为按顺序排列，即：`value1`推送到堆栈上。  
  
1.  `value2` 推送到堆栈上。  
  
2.  `value2` 和`value1`从堆栈中弹出`clt`测试`value1`是小于`value2`。  
  
3.  如果`value1`是小于`value2`，1 推入堆栈; 否则将 0 推送到堆栈上。  
  
 `clt`指令进行比较`value1`和`value2`。 如果`value1`是严格小于`value2`，则`int32`值 1 推送到堆栈上。 否则为`int32`为 0 的值推送到堆栈上。  
  
-   对于浮点数，`clt`如果这两个数字是无序的 （即，如果一个或两个自变量为 NaN 时），则返回 0。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`clt`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较无符号的或不可排序的值 <paramref name="value1" /> 和 <paramref name="value2" />。 如果 <paramref name="value1" /> 小于 <paramref name="value2" />，则将整数值 1 <see langword="(int32" /> ) 推送到计算堆栈上；反之，将 0 ( <see langword="int32" /> ) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 05|clt.un|如果推送 1`value1`是小于`value2`; 其他推送 0 （无符号值）。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`clt.un`测试`value1`是小于`value2`。  
  
4.  如果`value1`是小于`value2`，1 推入堆栈; 否则将 0 推送到堆栈上。  
  
 `clt.un`指令进行比较`value1`和`value2`。 `int32`值 1 推送到堆栈上，如果以下任一条件成立：  
  
-   `value1` 是严格小于`value2`(同样适用于`clt`)。  
  
-   对于浮点数，`value1`不排序相对于`value2`。  
  
-   对于整数值，`value1`是严格小于`value2`时视为无符号数字。  
  
 否则为`int32`为 0 的值推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`clt.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>约束要对其进行虚方法调用的类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 16 < `T` >|约束。 `thisType`|调用类型上的虚拟方法约束类型`T`。|  
  
 `constrained`前缀允许仅在`callvirt`指令。  
  
 MSIL 堆栈此时的状态必须如下所示：  
  
1.  托管的指针， `ptr`，推送到堆栈上。 一种`ptr`必须是托管的指针 (`&`) 到`thisType`。 请注意，这不同于没有前缀的大小写`callvirt`指令，这需要的一个引用`thisType`。  
  
2.  方法自变量`arg1`通过`argN`推送到堆栈，即可按与没有前缀`callvirt`指令。  
  
 `constrained`前缀设计用于允许`callvirt`说明中进行一个统一的方式独立于是否`thisType`是值类型还是引用类型。  
  
 当`callvirt``method`指令为前缀的`constrained` `thisType`，执行指令，如下所示：  
  
-   如果`thisType`为引用类型 （而不是值类型） 则`ptr`取消引用，并传递到与 this 指针`callvirt`的`method`。  
  
-   如果`thisType`是值类型和`thisType`实现`method`然后`ptr`传递不变地指向的 this 指针`call``method`指令，用于实现的`method`通过`thisType`.  
  
-   如果`thisType`是值类型和`thisType`不实现`method`然后`ptr`被取消引用、 装箱，并传递到与 this 指针`callvirt``method`指令。  
  
 此最后一种情况可能发生时，才`method`上已定义<xref:System.Object>， <xref:System.ValueType>，或<xref:System.Enum>并且不由重写`thisType`。 在这种情况下，装箱会导致原始对象进行复制。 但是，因为的方法都不能<xref:System.Object>， <xref:System.ValueType>，和<xref:System.Enum>修改状态的对象，无法检测到这一事实。  
  
 `constrained`前缀支持创建泛型的代码的 IL 生成器。 通常`callvirt`指令不是有效的值类型。 因此，需要 IL 编译器有效地执行上述在编译时间，具体取决于类型的 this 转换`ptr`和被调用的方法。 但是，当`ptr`是在编译时是未知的一个泛型类型不是可以进行编译时此转换。  
  
 `constrained`操作码允许 IL 编译器能够对虚拟函数的调用以统一方式独立于是否`ptr`是值类型还是引用类型。 尽管适用于这种情况其中`thisType`是泛型类型变量，`constrained`前缀还适用于非泛型类型，并可以降低在隐藏值类型之间的差异的语言中生成虚拟调用的复杂性和引用类型。  
  
 使用`constrained`前缀还可以避免值类型的潜在版本问题。 如果`constrained`不使用前缀，具体取决于是否为值类型重写的 System.Object 方法必须发出不同的 IL。 例如，如果值类型`V`重写 Object.ToString() 方法中， `call` `V.ToString()`发出指令; 如果不是，请`box`指令和`callvirt``Object.ToString()`发出指令。 如果以后添加一个替代，版本控制问题可能产生的以前的情况下，如果重写更高版本中删除，并且在后一种情况。  
  
 `constrained`前缀还可调用接口方法的值类型，因为可以使用更改实现接口方法的值类型方法`MethodImpl`。 如果`constrained`不使用前缀时，编译器强制选择哪个值要在编译时绑定到的类型的方法。 使用`constrained`前缀允许要绑定到在运行时，而不是在编译时实现的接口方法的方法的 MSIL。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`constrained`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="native int" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D3|conv.i|将转换为`native int`、 推送`native int`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.i`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.i`或`conv.u`使用时，结果在这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数字转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正) 或负无穷大 (如果`value`为负) 返回。 转换到另一个的一个整数类型发生溢出时，是否将被截断高序位字节。 如果结果为小于`int32`，值进行符号扩展以填充槽。  
  
 发生溢出时是否将浮点类型转换为整数，则返回该值未指定。  
  
 时使用此字段不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>以等效的结果类型不正确表示的结果值时，将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.i`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int8" />，然后将其扩展（填充）为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|67|conv.i1|将转换为`int8`、 推送`int32`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.i1`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.i`或`conv.u`使用时，结果在这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数字转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正) 或负无穷大 (如果`value`为负) 返回。 转换到另一个的一个整数类型发生溢出时，是否将被截断高序位字节。 如果结果为小于`int32`，值进行符号扩展以填充槽。  
  
 发生溢出时是否将浮点类型转换为整数，则返回该值未指定。  
  
 时使用此字段不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>以等效的结果类型不正确表示的结果值时，将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.i1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int16" />，然后将其扩展（填充）为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|68|conv.i2|将转换为`int16`、 推送`int32`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.i2`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.i`或`conv.u`使用时，结果在这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数字转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正) 或负无穷大 (如果`value`为负) 返回。 转换到另一个的一个整数类型发生溢出时，是否将被截断高序位字节。 如果结果为小于`int32`，值进行符号扩展以填充槽。  
  
 发生溢出时是否将浮点类型转换为整数，则返回该值未指定。  
  
 时使用此字段不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>以等效的结果类型不正确表示的结果值时，将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.i2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|69|conv.i4|将转换为`int32`、 推送`int32`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.i4`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.i`或`conv.u`使用时，结果在这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数字转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正) 或负无穷大 (如果`value`为负) 返回。 转换到另一个的一个整数类型发生溢出时，是否将被截断高序位字节。 如果结果为小于`int32`，值进行符号扩展以填充槽。  
  
 发生溢出时是否将浮点类型转换为整数，则返回该值未指定。  
  
 时使用此字段不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>以等效的结果类型不正确表示的结果值时，将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.i4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|6A|conv.i8|将转换为`int64`、 推送`int64`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.i8`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.i`或`conv.u`使用时，结果在这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数字转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正) 或负无穷大 (如果`value`为负) 返回。 转换到另一个的一个整数类型发生溢出时，是否将被截断高序位字节。 如果结果为小于`int32`，值进行符号扩展以填充槽。  
  
 发生溢出时是否将浮点类型转换为整数，则返回该值未指定。  
  
 时使用此字段不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>以等效的结果类型不正确表示的结果值时，将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.i8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|将转换为`native int`(在堆栈上为`native int`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.i`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|将转换为无符号的值`native int`(在堆栈上为`native int`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i.un`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.i.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号的 <see langword="int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|将转换为`int8`(在堆栈上为`int32`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i1`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.i1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|将转换为无符号的值`int8`(在堆栈上为`int32`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i1.un`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.i1.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|将转换为`int16`(在堆栈上为`int32`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i2`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.i2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|将转换为无符号的值`int16`(在堆栈上为`int32`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i2.un`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.i2.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|将转换为`int32`(在堆栈上为`int32`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i4`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.i4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|将转换为无符号的值`int32`(在堆栈上为`int32`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i4.un`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.i4.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|将转换为`int64`(在堆栈上为`int64`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i8`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.i8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|将转换为无符号的值`int64`(在堆栈上为`int64`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.i8.un`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.i8.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|将转换为`unsigned native int`(在堆栈上为`native int`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.u`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|将无符号值到`unsigned native int`(在堆栈上为`native int`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u.un`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.uvf.u.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.u1|将转换为`unsigned int8`(在堆栈上为`int32`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u1`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.u1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|将转换为无符号的值`unsigned int8`(在堆栈上为`int32`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u1.un`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.u1.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|将转换为`unsigned int16`(在堆栈上为`int32`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u2`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.u2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|将转换为无符号的值`unsigned int16`(在堆栈上为`int32`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u2.un`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.u2.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|将转换为`unsigned int32`(在堆栈上为`int32`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u4`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.u4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|将转换为无符号的值`unsigned int32`(在堆栈上为`int32`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u4.un`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.u4.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|将转换为`unsigned int64`(在堆栈上为`int64`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u8`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.u8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|将转换为无符号的值`unsigned int64`(在堆栈上为`int64`) 并在溢出时引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。 如果发生溢出时，将引发异常。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.ovf.u8.un`操作码将转换`value`操作码，然后将转换后的堆栈顶部的值中指定的类型到堆栈顶部。 如果值为太大或太小而无法由目标类型表示，则引发异常。  
  
 从浮点数字转换为整数值将向截断数字零。 请注意，将小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.ovf.i`或`conv.ovf.u`习惯，这种情况下结果也是`native int`)。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.ovf.u8.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号整数值转换为 <see langword="float32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|76|conv.r.un|转换无符号的整数到浮点、 推送`F`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.r.un`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.i`或`conv.u`使用时，结果在这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数字转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正) 或负无穷大 (如果`value`为负) 返回。 转换到另一个的一个整数类型发生溢出时，是否将被截断高序位字节。 如果结果为小于`int32`，值进行符号扩展以填充槽。  
  
 如果发生溢出时将浮点类型转换为整数`result`返回未指定。 `conv.r.un`操作将从堆栈的一个整数，将其解释为无符号整数，并将替换要表示的浮点数： 任一`float32`，如果这是宽度不足以表示而不会丢失精度，整数或其他`float64`。  
  
 时使用此字段不会引发任何异常。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.r.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="float32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|6B|conv.r4|将转换为`float32`、 推送`F`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.r4`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.i`或`conv.u`使用时，结果在这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数字转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正) 或负无穷大 (如果`value`为负) 返回。 转换到另一个的一个整数类型发生溢出时，是否将被截断高序位字节。 如果结果为小于`int32`，值进行符号扩展以填充槽。  
  
 发生溢出时是否将浮点类型转换为整数，则返回该值未指定。  
  
 时使用此字段不会引发任何异常。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.r4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="float64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|6C|conv.r8|将转换为`float64`、 推送`F`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.r8`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.i`或`conv.u`使用时，结果在这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数字转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正) 或负无穷大 (如果`value`为负) 返回。 转换到另一个的一个整数类型发生溢出时，是否将被截断高序位字节。 如果结果为小于`int32`，值进行符号扩展以填充槽。  
  
 发生溢出时是否将浮点类型转换为整数，则返回该值未指定。  
  
 时使用此字段不会引发任何异常。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.r8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned native int" />，然后将其扩展为 <see langword="native int" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|E0|conv.u|将转换为`unsigned native int`、 推送`native int`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.u`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.i`或`conv.u`使用时，结果在这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数字转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正) 或负无穷大 (如果`value`为负) 返回。 转换到另一个的一个整数类型发生溢出时，是否将被截断高序位字节。 如果结果为小于`int32`，值进行符号扩展以填充槽。  
  
 发生溢出时是否将浮点类型转换为整数，则返回该值未指定。  
  
 时使用此字段不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>以等效的结果类型不正确表示的结果值时，将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.u`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int8" />，然后将其扩展为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D2|conv.u1|将转换为`int8`、 推送`int32`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.u1`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.i`或`conv.u`使用时，结果在这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数字转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正) 或负无穷大 (如果`value`为负) 返回。 转换到另一个的一个整数类型发生溢出时，是否将被截断高序位字节。 如果结果为小于`int32`，值进行符号扩展以填充槽。  
  
 发生溢出时是否将浮点类型转换为整数，则返回该值未指定。  
  
 时使用此字段不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>以等效的结果类型不正确表示的结果值时，将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.u1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int16" />，然后将其扩展为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D1|conv.u2|将转换为`int16`、 推送`int32`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.u2`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.i`或`conv.u`使用时，结果在这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数字转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正) 或负无穷大 (如果`value`为负) 返回。 转换到另一个的一个整数类型发生溢出时，是否将被截断高序位字节。 如果结果为小于`int32`，值进行符号扩展以填充槽。  
  
 发生溢出时是否将浮点类型转换为整数，则返回该值未指定。  
  
 时使用此字段不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>以等效的结果类型不正确表示的结果值时，将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.u2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int32" />，然后将其扩展为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|6D|conv.u4|将转换为`unsigned int32`、 推送`int32`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.u4`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.i`或`conv.u`使用时，结果在这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数字转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正) 或负无穷大 (如果`value`为负) 返回。 转换到另一个的一个整数类型发生溢出时，是否将被截断高序位字节。 如果结果为小于`int32`，值进行符号扩展以填充槽。  
  
 发生溢出时是否将浮点类型转换为整数，则返回该值未指定。  
  
 时使用此字段不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>以等效的结果类型不正确表示的结果值时，将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.u4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int64" />，然后将其扩展为 <see langword="int64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|6E|conv.u8|将转换为`int64`、 推送`int64`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出堆栈并且转换从尝试操作。  
  
3.  如果转换成功，所得到的值推送到堆栈上。  
  
 `conv.u8`操作码将转换`value`操作码，然后将的转换后的堆栈顶部的值中指定的类型到堆栈顶部。 小于 4 个字节的整数值扩展到`int32`被加载到计算堆栈时会 (除非`conv.i`或`conv.u`使用时，结果在这种情况下也是`native int`)。 浮点值转换为`F`类型。  
  
 从浮点数字转换为整数值将向截断数字零。 从转换时`float64`到`float32`，精度可能会丢失。 如果`value`太大而无法放入`float32 (F)`，正无穷大 (如果`value`为正) 或负无穷大 (如果`value`为负) 返回。 转换到另一个的一个整数类型发生溢出时，是否将被截断高序位字节。 如果结果为小于`int32`，值进行符号扩展以填充槽。  
  
 发生溢出时是否将浮点类型转换为整数，则返回该值未指定。  
  
 时使用此字段不会引发任何异常。 请参阅<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>以等效的结果类型不正确表示的结果值时，将引发异常的说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`conv.u8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指定数目的字节从源地址复制到目标地址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|将数据从一个内存块复制到另一个。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  目标地址推送到堆栈上。  
  
2.  源地址推送到堆栈上。  
  
3.  要复制的字节数被推送到堆栈上。  
  
4.  从堆栈; 中弹出的字节数、 源地址和目标地址数指定的数目的字节从源地址复制到目标地址。  
  
 `cpblk`指令将复制大量 (类型`unsigned int32`) 的字节从源地址 (类型的`*`， `native int`，或`&`) 到目标地址 (类型的`*`， `native int`，或`&`)。 行为`cpblk`未指定，如果源和目标区域重叠。  
  
 `cpblk` 假定的源和目标解决的对齐到自然机的大小。 `cpblk`指令可以立即前面是`unaligned.<prefix>`指令以指示源或目标不对齐。  
  
 该操作的`cpblk`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`cpblk`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于对象（<see langword="&amp;" />、<see langword="*" /> 或 <see langword="native int" /> 类型）地址的值类型复制到目标对象（<see langword="&amp;" />、<see langword="*" /> 或 <see langword="native int" /> 类型）的地址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|将值类型从的源对象到的目标对象。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  目标对象引用推送到堆栈上。  
  
2.  源对象引用推送到堆栈上。  
  
3.  从堆栈中弹出的两个对象引用源对象地址处的值类型复制到目标对象的地址。  
  
 行为`cpobj`如果源和目标对象的引用都不是指向类标记所表示的类的实例是未指定`classTok`(`typeref`或`typedef`)，或者如果`classTok`不表示值类型。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`cpobj`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相除并将结果作为浮点（<see langword="F" /> 类型）或商（<see langword="int32" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|5B|div|将两个值以返回商或浮点结果。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`除以`value2`。  
  
4.  将结果推送到堆栈上。  
  
 `result` = `value1` div value2 满足以下条件：  
  
 &#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;，和：  
  
 登录 (`result`) = +，如果登录 (`value1`) = 号 (`value2`)，或-，如果登录 (`value1`) ~ = 号 (`value2`)  
  
 `div`指令计算结果并将结果推送到堆栈上。  
  
 整数除法向零截断。  
  
 被零的有限数量的除法产生的正确签名的无限值。  
  
 除以零的零个或无穷大除以无穷大生成 NaN （非数字） 值。 任何数字除以无穷大将生成零值。  
  
 整数运算引发<xref:System.ArithmeticException>如果结果不能表示该结果类型中。 可能的原因是`value1`是最大负数的值，和`value2`为-1。  
  
 整数运算引发<xref:System.DivideByZeroException>如果`value2`为零。  
  
 请注意，在基于 Intel 的平台上<xref:System.OverflowException>计算 (minint div-1) 时引发。 浮点运算永远不会引发的异常 （它们产生 Nan 或无穷大相反）。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`div`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>两个无符号整数值相除并将结果 ( <see langword="int32" /> ) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|5C|div.un|两个值，未签名，返回商相除。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`除以`value2`。  
  
4.  将结果推送到堆栈上。  
  
 `div.un`指令计算`value1`除以`value2`，同时作为无符号的整数和推送`result`堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`div.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>复制计算堆栈上当前最顶端的值，然后将副本推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|25|dup|重复堆栈顶部的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 从重复堆栈中弹出。  
  
3.  `value` 为推送回到堆栈上。  
  
4.  重复的值推送到堆栈上。  
  
 `dup`指令重复堆栈的顶部元素并将留之上打开它的两个相同的值。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`dup`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将控制从异常的 <see langword="filter" /> 子句转移回公共语言结构 (CLI) 异常处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 11|endfilter|最终的 SEH 异常处理筛选器子句。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 从堆栈中弹出`endfilter`执行并将控制权转交给异常处理程序。  
  
 `Value` (其中的类型必须为`int32`并且是一组特定的值) 从筛选器子句返回。 它应该是之一：  
  
-   `exception_continue_search` (`value` = 0) 表示不继续搜索的异常处理程序  
  
-   `exception_execute_handler` (`value` = 1) 启动第二个阶段的异常处理在其上最后块运行直到该处理程序与此筛选器子句是所在。 在发现后，执行处理程序。  
  
 其他整数值将产生未指定的结果。  
  
 方法的异常表中所示的入口点的筛选器，必须为筛选器的代码块中的第一个指令。 `endfilter`指令必须为筛选器的代码块中的最后一个指令 (因此只能有一个`endfilter`任何单个筛选器块)。 执行后`endfilter`控件的指令，逻辑上流动回 CLI 异常处理机制。  
  
 无法将控制转移到一个筛选器块除外通过异常机制。 无法将控制转移注销除非使用`throw`指令或通过执行最终`endfilter`指令。 不能嵌入`try`中块`filter`块。 如果在引发异常`filter`块，截获和值为 0 (`exception_continue_search`) 返回。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`endfilter`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将控制从异常块的 <see langword="fault" /> 或 <see langword="finally" /> 子句转移回公共语言结构 (CLI) 异常处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|DC|endfinally<br /><br /> 同样|结束`finally`或`fault`子句的异常块。|  
  
 没有堆栈转换为此指令的行为。  
  
 `Endfinally` 和`endfault`表示的结尾`finally`或`fault`子句，以便该堆栈展开可以继续，直到调用异常处理程序。 `endfinally`或`endfault`指令将控制转移回 CLI 异常机制。 然后，此机制下一个搜索`finally`链如果受保护的块已退出，leave 指令中的子句。 如果退出受保护的块的异常，下一步将搜索 CLI`finally`或`fault`，或输入异常处理的第一个过程期间选择的异常处理程序。  
  
 `endfinally`指令可能仅显示在词法上`finally`块。 与不同`endfilter`指令，块的末尾不要求`endfinally`指令，并且有多个`endfinally`所需的块中的说明。 这些相同的限制适用于`endfault`指令和`fault`块。  
  
 无法将控制转移到`finally`(或`fault`) 通过异常机制阻止除外。 无法将控制转移外`finally`(或`fault`) 使用阻止除`throw`指令或执行`endfinally`(或`endfault`) 指令。 具体而言，你不能"掉"的`finally`(或`fault`) 块或执行<xref:System.Reflection.Emit.OpCodes.Ret>或<xref:System.Reflection.Emit.OpCodes.Leave>中的指令`finally`(或`fault`) 块。  
  
 请注意，`endfault`和`endfinally`说明是别名，即它们对应于相同的操作码。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`endfinally`(`endfault`) 操作码，以及`ILGenerator`方法<xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>。  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于特定地址的内存的指定块初始化为给定大小和初始值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 18|紧接|在为给定值的内存块中设置的每个位置。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  起始地址推送到堆栈上。  
  
2.  初始化值推送到堆栈上。  
  
3.  要初始化的字节数被推送到堆栈上。  
  
4.  中的字节数、 初始化值和的起始地址数弹出从堆栈，并按它们的值执行初始化。  
  
 `initblk`指令设置数 (`unsigned int32`) 的字节从指定地址开始 (类型的`native int`， `&`，或`*`) 到初始化值 (类型的`unsigned int8`)。 `initblk` 假定的起始地址对齐到自然机的大小。  
  
 该操作的`initblk`说明可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果检测到无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`initblk`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定地址的值类型的每个字段初始化为空引用或适当的基元类型的 0。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 15 < `T` >|`initobj` `typeTok`|初始化值类型。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  要初始化的值类型的地址推送到堆栈上。  
  
2.  从堆栈中弹出地址指定地址处的值类型被初始化为类型`typeTok`。  
  
 `initobj`指令初始化每个字段的推送的地址由指定的值类型 (类型的`native int`， `&`，或`*`) 为空引用或适当的基元类型的 0。 调用此方法后，该实例可调用的构造函数方法。 如果`typeTok`是引用类型，此指令具有相同的效果`ldnull`跟`stind.ref`。  
  
 与不同<xref:System.Reflection.Emit.OpCodes.Newobj>，`initobj`不调用构造函数方法。 `Initobj` 是用于初始化值类型，而`newobj`用于分配和初始化对象。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`initobj`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>测试对象引用（<see langword="O" /> 类型）是否为特定类的实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst `class`|测试一个对象引用的实例是否`class`、 返回空引用或该类的实例或接口。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用推送到堆栈上。  
  
2.  从堆栈中弹出记录并将对象引用进行测试以查看它是否传递中的类的实例`class`。  
  
3.  （一个对象引用或空引用） 将结果推送到堆栈上。  
  
 `Class` 元数据标记指示所需的类。 如果在堆栈顶层对象的类实现`class`(如果`class`是一个接口) 或作为派生的类的`class`(如果`class`是正则类) 则它被转换为类型`class`并将结果推送到堆栈上，完全像<xref:System.Reflection.Emit.OpCodes.Castclass>已调用一样。 否则为空引用推送到堆栈上。 如果对象引用本身为空引用，然后`isinst`同样返回空引用。  
  
 <xref:System.TypeLoadException> 如果找不到类将引发。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`isinst`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>退出当前方法并跳至指定方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|27 < `T` >|jmp `method`|退出当前方法并跳转到指定的方法。|  
  
 没有堆栈转换为此指令的行为。  
  
 `jmp` （跳转） 指令将控制转移到指定的方法`method`，即方法引用的元数据标记。 当前的自变量将传输到目标方法。  
  
 在执行此指令时，计算堆栈必须为空。 调用约定、 数和在目标地址的自变量的类型必须与匹配的当前方法。  
  
 `jmp`指令不能用于将控制转移出`try`， `filter`， `catch`，或`finally`块。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`jmp`操作码：  
  
-   ILGenerator.Emit （操作码，MethodInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将自变量（由指定索引值引用）加载到堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 09 < `unsigned int16` >|ldarg `index`|处的参数加载`index`到堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  参数值`index`推送到堆栈上。  
  
 `ldarg`指令将索引为的参数`index`、 参数进行索引从 0 开始，到计算堆栈。 `ldarg`指令可以用于通过将其复制从传入的参数加载值类型或基元值到堆栈上的。 自变量值的类型是参数的作为当前方法的签名指定的类型相同。  
  
 对于采用可变长度参数列表中，过程`ldarg`指令可以仅用于初始固定自变量，不是那些在签名的变量的一部分 (请参阅<xref:System.Reflection.Emit.OpCodes.Arglist>更多详细信息的指令)。  
  
 保存的整数值小于 4 个字节长的自变量进行扩展以键入`int32`被加载到堆栈时会。 浮点值扩展为其本机的大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldarg`操作码：  
  
-   ILGenerator.Emit(OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引为 0 的参数加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|02|ldarg.0|将参数 0 到堆栈上加载|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  索引 0 处的参数值推送到堆栈上。  
  
 `ldarg.0`指令是用于加载位于索引 0 处的参数值的有效编码。  
  
 `ldarg.0`指令将索引为 0 到计算堆栈的参数。 `ldarg.0`指令可以用于通过将其复制从传入的参数加载值类型或基元值到堆栈上的。 自变量值的类型是参数的作为当前方法的签名指定的类型相同。  
  
 保存的整数值小于 4 个字节长的自变量进行扩展以键入`int32`被加载到堆栈时会。 浮点值扩展为其本机的大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldarg.0`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引为 1 的自变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|03|ldarg.1|加载到堆栈的参数 1。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  索引 1 处的参数值推送到堆栈上。  
  
 `ldarg.1`指令是用于加载索引 1 处的参数值的有效编码。  
  
 `ldarg.1`指令将索引为 1 到计算堆栈的参数。 `ldarg.1`指令可以用于通过将其复制从传入的参数加载值类型或基元值到堆栈上的。 自变量值的类型是参数的作为当前方法的签名指定的类型相同。  
  
 保存的整数值小于 4 个字节长的自变量进行扩展以键入`int32`被加载到堆栈时会。 浮点值扩展为其本机的大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldarg.1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引为 2 的自变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|04|ldarg.2|加载到堆栈的参数 2。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  索引 2 处的参数值推送到堆栈上。  
  
 `ldarg.2`指令是用于加载索引 2 处的参数值的有效编码。  
  
 `ldarg.2`指令将索引为 2 到计算堆栈的参数。 `ldarg.2`指令可以用于通过将其复制从传入的参数加载值类型或基元值到堆栈上的。 自变量值的类型是参数的作为当前方法的签名指定的类型相同。  
  
 保存的整数值小于 4 个字节长的自变量进行扩展以键入`int32`被加载到堆栈时会。 浮点值扩展为其本机的大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldarg.2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引为 3 的自变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|05|ldarg.3|加载到堆栈的参数 3。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  索引 3 处的参数值推送到堆栈上。  
  
 `ldarg.3`指令是用于加载索引 3 处的参数值的有效编码。  
  
 `ldarg.3`指令将索引为 3 到计算堆栈的参数。 `ldarg.3`指令可以用于通过将其复制从传入的参数加载值类型或基元值到堆栈上的。 自变量值的类型是参数的作为当前方法的签名指定的类型相同。  
  
 保存的整数值小于 4 个字节长的自变量进行扩展以键入`int32`被加载到堆栈时会。 浮点值扩展为其本机的大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldarg.3`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将参数（由指定的短格式索引引用）加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg.s `index`|处的参数加载`index`到堆栈，缩写形式。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  参数值`index`推送到堆栈上。  
  
 `ldarg.s`指令是有效编码，为加载参数索引为从 4 到 255 之间。  
  
 `ldarg.s`指令将索引为的参数`index`、 参数进行索引从 0 开始，到计算堆栈。 `ldarg.s`指令可以用于通过将其复制从传入的参数加载值类型或基元值到堆栈上的。 自变量值的类型是参数的作为当前方法的签名指定的类型相同。  
  
 对于采用可变长度参数列表中，过程`ldarg.s`指令可以仅用于初始固定自变量，不是那些在签名的变量的一部分 (请参阅<xref:System.Reflection.Emit.OpCodes.Arglist>更多详细信息的指令)。  
  
 保存的整数值小于 4 个字节长的自变量进行扩展以键入`int32`被加载到堆栈时会。 浮点值扩展为其本机的大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldarg.s`操作码：  
  
-   ILGenerator.Emit （操作码，字节）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将自变量地址加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 0A < `unsigned int16` >|ldarga `index`|提取的参数按建立索引的地址`index`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  地址`addr`按建立索引的自变量的`index`推送到堆栈上。  
  
 `ldarga`指令获取地址 (类型的`*`) 按建立索引的自变量的`index`、 自变量从 0 开始的索引位置。 地址`addr`始终对齐到自然边界在目标计算机上。  
  
 对于采用可变长度参数列表中，过程`ldarga`指令可以仅用于初始固定自变量，不是那些在签名的变量的一部分。  
  
 `ldarga` 用于通过 ref 参数传递。 对于其他情况，<xref:System.Reflection.Emit.OpCodes.Ldarg>和<xref:System.Reflection.Emit.OpCodes.Starg>应使用。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldarga`操作码：  
  
-   ILGenerator.Emit(OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以短格式将参数地址加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|变 `index`|提取的参数按建立索引的地址`index`，缩写形式。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  地址`addr`按建立索引的自变量的`index`推送到堆栈上。  
  
 `ldarga.s` (的缩写形式`ldarga`) 应该用于自变量数字 0 到 255，并且更有效的编码。  
  
 `ldarga.s`指令获取地址 (类型的`*`) 按建立索引的自变量的`index`、 自变量从 0 开始的索引位置。 地址`addr`始终对齐到自然边界在目标计算机上。  
  
 对于采用可变长度参数列表中，过程`ldarga.s`指令可以仅用于初始固定自变量，不是那些在签名的变量的一部分。  
  
 `ldarga.s` 用于通过 ref 参数传递。 对于其他情况，<xref:System.Reflection.Emit.OpCodes.Ldarg_S>和<xref:System.Reflection.Emit.OpCodes.Starg_S>应使用。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldarga.s`操作码：  
  
-   ILGenerator.Emit （操作码，字节）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="int32" /> 类型的值作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc.i4 `num`|将值推送`num`到堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值`num`推送到堆栈上。  
  
 请注意，有特殊短 （并因此更有效） 编码为整数-128 到 127，和尤其是短编码为-1 到 8。 所有短编码推送到堆栈上的 4 字节整数。 较长的编码将用于 8 字节整数和 4 到 8 字节浮点数，以及不适合在短窗体中的 4 字节值。 有三种方法，以将推送到堆栈上的 8 字节整数常量  
  
 1. 使用<xref:System.Reflection.Emit.OpCodes.Ldc_I8>指令必须以多个 32 位为单位表示的常量。  
  
 2. 使用<xref:System.Reflection.Emit.OpCodes.Ldc_I4>指令跟<xref:System.Reflection.Emit.OpCodes.Conv_I8>需要 9 到 32 位的常量。  
  
 3. 使用短格式指令跟<xref:System.Reflection.Emit.OpCodes.Conv_I8>可以以 8 或更少位为单位表示的常量。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldc.i4`操作码：  
  
-   ILGenerator.Emit （操作码，int）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 0 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|推送到堆栈上的 0。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值 0 推入堆栈。  
  
 这是一个特殊短编码的整数值 0 推送。 所有特殊短编码推送到堆栈上的 4 字节整数。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldc.i4.0`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 1 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|推送到堆栈上的 1。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值 1 推送到堆栈上。  
  
 这是一个特殊短编码的整数值 0 推送。 所有特殊短编码推送到堆栈上的 4 字节整数。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldc.i4.1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 2 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|推送到堆栈的 2。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值 2 推送到堆栈上。  
  
 这是一个特殊短编码的整数值 0 推送。 所有特殊短编码推送到堆栈上的 4 字节整数。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldc.i4.2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 3 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|推送到堆栈的 3。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值 3 推入堆栈。  
  
 这是一个特殊短编码的整数值 0 推送。 所有特殊短编码推送到堆栈上的 4 字节整数。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldc.i4.3`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 4 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|推送到堆栈上的 4。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值 4 被推送到堆栈上。  
  
 这是一个特殊短编码的整数值 0 推送。 所有特殊短编码推送到堆栈上的 4 字节整数。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldc.i4.4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 5 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|推送到堆栈上的 5。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值 5 推入堆栈。  
  
 这是一个特殊短编码的整数值 0 推送。 所有特殊短编码推送到堆栈上的 4 字节整数。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldc.i4.5`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 6 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|推送到堆栈上的 6。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值 6 推入堆栈。  
  
 这是一个特殊短编码的整数值 0 推送。 所有特殊短编码推送到堆栈上的 4 字节整数。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldc.i4.6`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 7 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|推送到堆栈的 7。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值 7 推入堆栈。  
  
 这是一个特殊短编码的整数值 0 推送。 所有特殊短编码推送到堆栈上的 4 字节整数。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldc.i4.7`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 8 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|推送到堆栈上的 8。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  8 的值推送到堆栈上。  
  
 这是一个特殊短编码的整数值 0 推送。 所有特殊短编码推送到堆栈上的 4 字节整数。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldc.i4.8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 -1 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|推送到堆栈上的为-1。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值-1 推送到堆栈上。  
  
 这是一个特殊短编码的整数值 0 推送。 所有特殊短编码推送到堆栈上的 4 字节整数。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldc.i4.m1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将提供的 <see langword="int8" /> 值作为 <see langword="int32" /> 推送到计算堆栈上（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|1F < `int8` >|ldc.i4.s `num`|推送`num`到堆栈上为`int32`，缩写形式。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值`num`推送到堆栈上。  
  
 `ldc.i4.s` 是用于将从-128 到 127 之间的整数推送到计算堆栈上更高效的编码。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldc.i4.s`操作码：  
  
-   ILGenerator.Emit （操作码，字节）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="int64" /> 类型的值作为 <see langword="int64" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc.i8 `num`|推送`num`到堆栈上为`int64`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值`num`推送到堆栈上。  
  
 此编码推送`int64`到堆栈的值。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldc.i8`操作码：  
  
-   ILGenerator.Emit （操作码，长）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="float32" /> 类型的值作为 <see langword="F" /> (float) 类型推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc.r4 `num`|推送`num`到堆栈上为`F`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值`num`推送到堆栈上。  
  
 此编码推送`float32`到堆栈的值。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldc.r4`操作码：  
  
-   ILGenerator.Emit （操作码，单个）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="float64" /> 类型的值作为 <see langword="F" /> (float) 类型推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.r8 `num`|推送`num`到堆栈上为`F`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值`num`推送到堆栈上。  
  
 此编码推送`float64`到堆栈的值。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldc.r8`操作码：  
  
-   ILGenerator.Emit(OpCode, double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>按照指令中指定的类型，将指定数组索引中的元素加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem `typeTok`|加载处的元素`index`到作为类型堆栈的顶部`typeTok`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 和`array`从堆栈中弹出位置存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈中。  
  
 `ldelem`指令加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放在堆栈顶层。 数组是对象，并因此由类型的值`O`。  
  
 返回值的类型指定标记`typeTok`在指令中。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于上限`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldelem`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="native int" /> 类型的元素作为 <see langword="native int" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|97|ldelem.i|类型加载元素`native int`在`index`到作为堆栈的顶部`native int`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 和`array`从堆栈中弹出位置存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈中。  
  
 `ldelem.i`指令加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放在堆栈顶层。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.i`是`native int`。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldelem.i`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int8" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|类型加载元素`int8`在`index`到作为堆栈的顶部`int32`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 和`array`从堆栈中弹出位置存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈中。  
  
 `ldelem.i1`指令加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放在堆栈顶层。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.i1`是`int8`。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldelem.i1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int16" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|92|ldelem.i2|类型加载元素`int16`在`index`到作为堆栈的顶部`int32`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 和`array`从堆栈中弹出位置存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈中。  
  
 `ldelem.i2`指令加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放在堆栈顶层。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.i2`是`int16`。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldelem.i2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int32" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|类型加载元素`int32`在`index`到作为堆栈的顶部`int32`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 和`array`从堆栈中弹出位置存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈中。  
  
 `ldelem.i4`指令加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放在堆栈顶层。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.i4`是`int32`。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldelem.i4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int64" /> 类型的元素作为 <see langword="int64" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|96|ldelem.i8|类型加载元素`int64`在`index`到作为堆栈的顶部`int64`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 和`array`从堆栈中弹出位置存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈中。  
  
 `ldelem.i8`指令加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放在堆栈顶层。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.i8`是`int64`。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldelem.i8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="float32" /> 类型的元素作为 <see langword="F" /> 类型（浮点型）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|98|ldelem.r4|类型加载元素`float32`在`index`到堆栈上为一种类型的顶部`F`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 和`array`从堆栈中弹出位置存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈中。  
  
 `ldelem.r4`指令加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放在堆栈顶层。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.r4`是`float32`。  
  
 浮点值转换为类型`F`时加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldelem.r4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="float64" /> 类型的元素作为 <see langword="F" /> 类型（浮点型）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|99|ldelem.r8|类型加载元素`float64`在`index`到作为类型堆栈的顶部`F`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 和`array`从堆栈中弹出位置存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈中。  
  
 `ldelem.r8`指令加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放在堆栈顶层。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.r8`是`float64`。  
  
 浮点值转换为类型`F`时加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldelem.r8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的包含对象引用的元素作为 <see langword="O" /> 类型（对象引用）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|加载在一个对象引用的元素`index`到作为类型堆栈的顶部`O`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 和`array`从堆栈中弹出位置存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈中。  
  
 `ldelem.ref`指令加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放在堆栈顶层。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.ref`是类型`O`（对象引用）。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldelem.ref`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="unsigned int8" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|91|ldelem.u1|类型加载元素`unsigned int8`在`index`到作为堆栈的顶部`int32`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 和`array`从堆栈中弹出位置存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈中。  
  
 `ldelem.u1`指令加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放在堆栈顶层。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.u1`是`int8`。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldelem.u1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="unsigned int16" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|93|ldelem.u2|类型加载元素`unsigned int16`作为堆栈顶部的索引处`int32`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 和`array`从堆栈中弹出位置存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈中。  
  
 `ldelem.u2`指令加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放在堆栈顶层。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.u2`是`int16`。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldelem.u2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="unsigned int32" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|类型加载元素`unsigned int32`作为堆栈顶部的索引处`int32`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 和`array`从堆栈中弹出位置存储的值`index`中`array`查找。  
  
4.  将值推送到堆栈中。  
  
 `ldelem.u4`指令加载具有索引的元素的值`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放在堆栈顶层。 数组是对象，因此由类型的值`O`。  
  
 返回值`ldelem.u4`是`int32`。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果数组不包含所需的类型的元素将引发。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldelem.u4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引的数组元素的地址作为 <see langword="&amp;" /> 类型（托管指针）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema `class`|处的数组元素的地址加载`index`到作为类型计算堆栈的顶部`&`（托管的指针）。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用`array`推送到堆栈上。  
  
2.  索引值`index`推送到堆栈上。  
  
3.  `index` 和`array`从堆栈中弹出存储位置的地址`index`中`array`查找。  
  
4.  地址推送到堆栈中。  
  
 `ldelema`用于检索对象的数组中的特定索引处的对象的地址 (类型的`class`)。 `ldelema`指令加载索引处的值的地址`index`(类型`native int`) 中的从零开始的一维数组`array`并将其放在堆栈顶层。 数组是对象，因此由类型的值`O`。 值必须为类型`class`随指令一起传递。  
  
 返回值`ldelema`是托管的指针 (类型`&`)。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldelema`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>查找对象中其引用当前位于计算堆栈的字段的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|推送到堆栈上指定的对象中的字段的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  对象引用 （或指针） 推送到堆栈上。  
  
2.  从堆栈中弹出的对象引用 （或指针）找到的对象中的指定字段值。  
  
3.  在字段中存储的值推送到堆栈上。  
  
 `ldfld`指令将推送到堆栈的对象中的字段的值。 该对象必须是在堆栈上为一个对象引用 (类型`O`)，托管的指针 (类型`&`)，非托管的指针 (类型`native int`)，暂时性指针 (类型`*`)，或值类型的实例。 中可验证代码不允许使用的非托管指针。 由字段成员必须引用的元数据令牌指定对象的字段。 返回类型是相同的字段关联的一个。 （在这种情况下的对象必须不为空引用） 的实例字段或静态字段，则可能是字段。  
  
 `ldfld`指令可以跟一个或两个<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile>前缀。  
  
 <xref:System.NullReferenceException> 如果对象为 null，并且该字段不是静态，引发。  
  
 <xref:System.MissingFieldException> 元数据中找不到指定的字段时引发。 仅 Microsoft 中间语言 (MSIL) 指令不在运行时转换为本机代码时，通常选中此选项。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldfld`操作码：  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>查找对象中其引用当前位于计算堆栈的字段的地址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|地址推送`field`指定对象到堆栈中。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  对象引用 （或指针） 推送到堆栈上。  
  
2.  从堆栈中弹出的对象引用 （或指针）找到的对象中的指定字段的地址。  
  
3.  指定字段的地址推送到堆栈上。  
  
 `ldflda`指令将推送到堆栈的对象中字段的地址。 该对象必须是在堆栈上为一个对象引用 (类型`O`)，托管的指针 (类型`&`)，非托管的指针 (类型`native int`)，暂时性指针 (类型`*`)，或值类型的实例。 中可验证代码不允许使用的非托管指针。 由字段成员必须引用的元数据令牌指定对象的字段。  
  
 返回的值`ldflda`是托管的指针 (类型`&`) 除非对象推送到堆栈上为非托管指针上，在这种情况下的寄信人地址也是非托管的指针 (类型`native int`)。  
  
 `ldflda`指令可以跟一个或两个<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile>前缀。  
  
 <xref:System.InvalidOperationException> 如果对象不在正从其中访问它的应用程序域内将引发。 无法加载不在访问应用程序域内的字段的地址。  
  
 <xref:System.NullReferenceException> 如果对象为 null，并且该字段不是静态，引发。  
  
 <xref:System.MissingFieldException> 元数据中找不到指定的字段时引发。 仅 Microsoft 中间语言 (MSIL) 指令不在运行时转换为本机代码时，通常选中此选项。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldflda`操作码：  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指向实现特定方法的本机代码的非托管指针（<see langword="native int" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|ldftn `method`|推送到所引用方法的指针`method`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  指向特定方法的非托管的指针推入堆栈。  
  
 特定方法 (`method`) 可以使用调用<xref:System.Reflection.Emit.OpCodes.Calli>指令，如果所引用的托管的方法 （或从非托管代码到托管代码转换存根 （stub））。  
  
 值返回给使用 CLR 调用约定的本机代码的点。 作为回调例程之前，不应将此方法指针传递到非托管的本机代码。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldftn`操作码：  
  
-   ILGenerator.Emit （操作码，MethodInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="native int" /> 类型的值作为 <see langword="native int" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|4D|ldind.i|加载`native int`地址处值`addr`到堆栈上为`native int`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  获取的值推送到堆栈上。  
  
 `ldind.i`指令间接加载`native int`从指定的地址值 (类型的`native int`， `&`，或 *) 到堆栈上为`native int`。  
  
 所有`ldind`了的快捷方式说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。 浮点值转换为`F`时加载到计算堆栈上键入。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`使用中与指针的类型一致的方式的说明。  
  
 最初推入堆栈的地址必须符合的计算机上的对象的自然大小或<xref:System.NullReferenceException>可以发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀预防措施的指令)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 个字节的数据类型，字节排序是依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到了无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldind.i`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int8" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|46|ldind.i1|加载`int8`地址处值`addr`到堆栈上为`int32`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  获取的值推送到堆栈中...  
  
 `ldind.i1`指令间接加载`int8`从指定的地址值 (类型的`native int`， `&`，或 *) 到堆栈上为`int32`。  
  
 所有`ldind`了的快捷方式说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。 浮点值转换为`F`时加载到计算堆栈上键入。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`使用中与指针的类型一致的方式的说明。  
  
 最初推入堆栈的地址必须符合的计算机上的对象的自然大小或<xref:System.NullReferenceException>可以发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀预防措施的指令)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 个字节的数据类型，字节排序是依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到了无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldind.i1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int16" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|48|ldind.i2|加载`int16`地址处值`addr`到堆栈上为`int32`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  获取的值推送到堆栈上。  
  
 `ldind.i2`指令间接加载`int16`从指定的地址值 (类型的`native int`， `&`，或 *) 到堆栈上为`int32`。  
  
 所有`ldind`了的快捷方式说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。 浮点值转换为`F`时加载到计算堆栈上键入。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`使用中与指针的类型一致的方式的说明。  
  
 最初推入堆栈的地址必须符合的计算机上的对象的自然大小或<xref:System.NullReferenceException>可以发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀预防措施的指令)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 个字节的数据类型，字节排序是依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到了无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldind.i2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int32" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|4A|ldind.i4|加载`int32`地址处值`addr`到堆栈上为`int32`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  获取的值推送到堆栈上。  
  
 `ldind.i4`指令间接加载`int32`从指定的地址值 (类型的`native int`， `&`，或 *) 到堆栈上为`int32`。  
  
 所有`ldind`了的快捷方式说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。 浮点值转换为`F`时加载到计算堆栈上键入。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`使用中与指针的类型一致的方式的说明。  
  
 最初推入堆栈的地址必须符合的计算机上的对象的自然大小或<xref:System.NullReferenceException>可以发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀预防措施的指令)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 个字节的数据类型，字节排序是依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到了无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldind.i4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int64" /> 类型的值作为 <see langword="int64" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|4C|ldind.i8|加载`int64`地址处值`addr`到堆栈上为`int64`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  获取的值推送到堆栈上。  
  
 `ldind.i8`指令间接加载`int64`从指定的地址值 (类型的`native int`， `&`，或 *) 到堆栈上为`int64`。  
  
 所有`ldind`了的快捷方式说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。 浮点值转换为`F`时加载到计算堆栈上键入。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`使用中与指针的类型一致的方式的说明。  
  
 最初推入堆栈的地址必须符合的计算机上的对象的自然大小或<xref:System.NullReferenceException>可以发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀预防措施的指令)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 个字节的数据类型，字节排序是依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到了无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldind.i8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="float32" /> 类型的值作为 <see langword="F" /> (float) 类型间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|4E|ldind.r4|加载`float32`地址处值`addr`到堆栈上为类型`F`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  获取的值推送到堆栈上。  
  
 `ldind.r4`指令间接加载`float32`从指定的地址值 (类型的`native int`， `&`，或 *) 到堆栈上为类型`F`。  
  
 所有`ldind`了的快捷方式说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。 浮点值转换为`F`时加载到计算堆栈上键入。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`使用中与指针的类型一致的方式的说明。  
  
 最初推入堆栈的地址必须符合的计算机上的对象的自然大小或<xref:System.NullReferenceException>可以发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀预防措施的指令)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 个字节的数据类型，字节排序是依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到了无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldind.r4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="float64" /> 类型的值作为 <see langword="F" /> (float) 类型间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|4F|ldind.r8|加载`float64`地址处值`addr`到堆栈上为类型`F`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  获取的值推送到堆栈上。  
  
 `ldind.r8`指令间接加载`float64`从指定的地址值 (类型的`native int`， `&`，或 *) 到堆栈上为`float64`。  
  
 所有`ldind`了的快捷方式说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。 浮点值转换为`F`时加载到计算堆栈上键入。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`使用中与指针的类型一致的方式的说明。  
  
 最初推入堆栈的地址必须符合的计算机上的对象的自然大小或<xref:System.NullReferenceException>可以发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀预防措施的指令)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 个字节的数据类型，字节排序是依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到了无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldind.r8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将对象引用作为 <see langword="O" />（对象引用）类型间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|50|ldind.ref|加载地址处的对象引用`addr`到堆栈上为类型 `O`|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址的对象引用。  
  
3.  获取的引用推送到堆栈上。  
  
 `ldind.ref`指令间接加载对象引用指定的地址 (类型的`native int`， `&`，或 *) 到作为类型堆栈`O`。  
  
 所有`ldind`了的快捷方式说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。 浮点值转换为`F`时加载到计算堆栈上键入。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`使用中与指针的类型一致的方式的说明。  
  
 最初推入堆栈的地址必须符合的计算机上的对象的自然大小或<xref:System.NullReferenceException>可以发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀预防措施的指令)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 个字节的数据类型，字节排序是依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到了无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldind.ref`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="unsigned int8" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|47|ldind.u1|加载`unsigned int8`地址处值`addr`到堆栈上为`int32`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  获取的值推送到堆栈上。  
  
 `ldind.u1`指令间接加载`unsigned int8`从指定的地址值 (类型的`native int`， `&`，或 *) 到堆栈上为`int32`。  
  
 所有`ldind`了的快捷方式说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。 浮点值转换为`F`时加载到计算堆栈上键入。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`使用中与指针的类型一致的方式的说明。  
  
 最初推入堆栈的地址必须符合的计算机上的对象的自然大小或<xref:System.NullReferenceException>可以发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀预防措施的指令)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 个字节的数据类型，字节排序是依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到了无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldind.u1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="unsigned int16" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|49|ldind.u2|加载`unsigned int16`地址处值`addr`到堆栈上为`int32`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  获取的值推送到堆栈上。  
  
 `ldind.u2`指令间接加载`unsigned int16`从指定的地址值 (类型的`native int`， `&`，或 *) 到堆栈上为`int32`。  
  
 所有`ldind`了的快捷方式说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。 浮点值转换为`F`时加载到计算堆栈上键入。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`使用中与指针的类型一致的方式的说明。  
  
 最初推入堆栈的地址必须符合的计算机上的对象的自然大小或<xref:System.NullReferenceException>可以发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀预防措施的指令)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 个字节的数据类型，字节排序是依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到了无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldind.u2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="unsigned int32" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|4B|ldind.u4|加载`unsigned int32`地址处值`addr`到堆栈上为`int32`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  从堆栈中弹出地址提取位于地址处的值。  
  
3.  获取的值推送到堆栈上。  
  
 `ldind.u4`指令间接加载`unsigned int32`从指定的地址值 (类型的`native int`， `&`，或 *) 到堆栈上为`int32`。  
  
 所有`ldind`了的快捷方式说明<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相应的内置值类的指令。  
  
 请注意，将小于 4 个字节的整数值扩展到`int32`(不`native int`) 时，它们是加载到计算堆栈上。 浮点值转换为`F`时加载到计算堆栈上键入。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`使用中与指针的类型一致的方式的说明。  
  
 最初推入堆栈的地址必须符合的计算机上的对象的自然大小或<xref:System.NullReferenceException>可以发生 (请参阅<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀预防措施的指令)。 寄信人地址的所有 MSIL 指令的结果 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地对齐。 对于大于 1 个字节的数据类型，字节排序是依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException> 如果检测到了无效的地址，可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldind.u4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将从零开始的、一维数组的元素的数目推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|8E|ldlen|推送长度 (类型的`natural unsigned int`) 的数组在堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  对数组的对象引用推送到堆栈上。  
  
2.  从堆栈中弹出数组引用和计算长度。  
  
3.  长度推入堆栈。  
  
 数组是对象，因此由类型的值`O`。 长度返回为`natural unsigned int`。  
  
 <xref:System.NullReferenceException> 数组引用为 null 引用时引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldlen`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指定索引处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 0C < `unsigned int16` >|ldloc `index`|将索引处的局部变量加载`index`到堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  指定索引处的局部变量值推送到堆栈上。  
  
 `ldloc`指令将本地的可变数量的内容推送到计算堆栈上传递的索引处的本地变量的开始编号为 0。 仅当该方法中的初始化标志为 true，则输入方法之前，本地变量初始化为 0。 有 65,535 (2 ^16-1） 本地变量可能 (0-65534)。 索引 65,535 无效，因为实现很可能将使用的 2 字节整数来跟踪这两个局部变量的索引，以及给定方法的局部变量的总数目。 如果已经使 65535 索引有效，它将要求要跟踪此类方法中的局部变量的数目更宽的整数。  
  
 `ldloc.0`， `ldloc.1`， `ldloc.2`，和`ldloc.3`说明介绍了用于访问的前四个本地变量的有效编码。  
  
 值的类型是变量的本地，在方法标头中指定的类型相同。 请参阅小于 4 个字节长扩展为类型的分区 I.本地变量`int32`被加载到堆栈时会。 浮点值扩展为其本机的大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldloc`操作码：  
  
-   ILGenerator.Emit(OpCode, LocalBuilder)  
  
-   ILGenerator.Emit(OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 0 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|06|ldloc.0|将索引 0 处的局部变量加载到计算堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  在索引 0 处的局部变量值推送到堆栈上。  
  
 `ldloc.0` 是非常有效的编码为<xref:System.Reflection.Emit.OpCodes.Ldloc>，位于索引 0 处允许到本地变量的访问。  
  
 值的类型是变量的本地，在方法标头中指定的类型相同。 小于 4 个字节长的本地变量进行扩展以键入`int32`被加载到堆栈时会。 浮点值扩展为其本机的大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldloc.0`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 1 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|07|ldloc.1|将索引 1 处的局部变量加载到计算堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将索引 1 处的局部变量值推送到堆栈上。  
  
 `ldloc.1` 是非常有效的编码为<xref:System.Reflection.Emit.OpCodes.Ldloc>，位于索引 1 处允许到本地变量的访问。  
  
 值的类型是变量的本地，在方法标头中指定的类型相同。 小于 4 个字节长的本地变量进行扩展以键入`int32`被加载到堆栈时会。 浮点值扩展为其本机的大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldloc.1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 2 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|08|ldloc.2|将索引 2 处的局部变量加载到计算堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将索引 2 处的局部变量值推送到堆栈上。  
  
 `ldloc.2` 是非常有效的编码为<xref:System.Reflection.Emit.OpCodes.Ldloc>，它允许到本地变量的访问索引 2 处。  
  
 值的类型是变量的本地，在方法标头中指定的类型相同。 小于 4 个字节长的本地变量进行扩展以键入`int32`被加载到堆栈时会。 浮点值扩展为其本机的大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldloc.2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 3 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|09|ldloc.3|将索引 3 处的局部变量加载到计算堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将索引 3 处的局部变量值推送到堆栈上。  
  
 `ldloc.3` 是非常有效的编码为<xref:System.Reflection.Emit.OpCodes.Ldloc>，索引 3 处允许到本地变量的访问。  
  
 值的类型是变量的本地，在方法标头中指定的类型相同。 小于 4 个字节长的本地变量进行扩展以键入`int32`被加载到堆栈时会。 浮点值扩展为其本机的大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldloc.3`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将特定索引处的局部变量加载到计算堆栈上（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|将索引处的局部变量加载`index`到堆栈，缩写形式。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  指定索引处的局部变量值推送到堆栈上。  
  
 `ldloc.s`指令将本地的可变数量的内容推送到计算堆栈上传递的索引处的本地变量的开始编号为 0。 如果该方法中的初始化标志为 true，则输入方法之前，本地变量初始化为 0。 有 256 (2 ^8) 中的局部变量可能 (0-255) 的缩写形式，这是更有效的编码比`ldloc`。  
  
 值的类型是变量的本地，在方法标头中指定的类型相同。 请参阅小于 4 个字节长扩展为类型的分区 I.本地变量`int32`被加载到堆栈时会。 浮点值扩展为其本机的大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldloc.s`操作码：  
  
-   ILGenerator.Emit(OpCode, LocalBuilder)  
  
-   ILGenerator.Emit （操作码，字节）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于特定索引处的局部变量的地址加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE OD < `unsigned int16` >|ldloca `index`|处的局部变量的地址加载`index`到计算堆栈。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  存储在指定索引处的局部变量的地址推送到堆栈上。  
  
 `ldloca`指令将本地的可变数量的地址推送到堆栈上，传递的索引处其中本地变量是否为开始编号为 0。 推送到堆栈上的值已经正确对齐，用于等指令<xref:System.Reflection.Emit.OpCodes.Ldind_I>和<xref:System.Reflection.Emit.OpCodes.Stind_I>。 结果是暂时性的指针 (类型`*`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldloca`操作码：  
  
-   ILGenerator.Emit(OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于特定索引处的局部变量的地址加载到计算堆栈上（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|处的局部变量的地址加载`index`到计算堆栈缩写形式。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  存储在指定索引处的局部变量的地址推送到堆栈上。  
  
 `ldloca.s`指令将本地的可变数量的地址推送到堆栈上，传递的索引处其中本地变量是否为开始编号为 0。 推送到堆栈上的值已经正确对齐，用于等指令<xref:System.Reflection.Emit.OpCodes.Ldind_I>和<xref:System.Reflection.Emit.OpCodes.Stind_I>。 结果是暂时性的指针 (类型`*`)。  
  
 `ldloca.s`指令提供有效的编码以用于本地变量 0 到 255 之间。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldloca.s`操作码：  
  
-   ILGenerator.Emit （操作码，字节）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将空引用（<see langword="O" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|14|ldnull|推送到堆栈为空引用|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  空对象引用推送到堆栈上。  
  
 `ldnull` 将 null 引用推送 (类型`O`) 堆栈上。 这用于它们填充了数据之前, 或被拒绝时初始化位置。  
  
 `ldnull` 提供的大小无关的 null 引用。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldnull`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将地址指向的值类型对象复制到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|值类型的复制实例`class`到堆栈。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值类型对象的地址推送到堆栈上。  
  
2.  从堆栈中弹出地址和查找位于该特定地址的实例。  
  
3.  存储在该地址的对象的值推送到堆栈上。  
  
 `ldobj`指令用于将作为参数传递值类型。  
  
 `ldobj`指令将指向的值复制`addrOfValObj`(类型的`&`， `*`，或`native int`) 到堆栈顶部。 复制的字节数取决于类的大小 (所指定的`class`参数)。 `class`参数是元数据标记表示的值类型。  
  
 该操作的`ldobj`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.TypeLoadException> 如果找不到类将引发。 在 Microsoft 中间语言 (MSIL) 指令将转换为本机代码而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldobj`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将静态字段的值推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld `field`|将的值推入`field`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  特定字段的值推送到堆栈上。  
  
 `ldsfld`指令的静态 （在类的所有实例间共享） 值推送到堆栈上的字段。 与传递的元数据令牌相关联的返回类型是`field`。  
  
 `ldsfld`指令可以有<xref:System.Reflection.Emit.OpCodes.Volatile>前缀。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldsfld`操作码：  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将静态字段的地址推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda `field`|地址推送`field`堆栈上|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  特定字段的地址推送到堆栈上。  
  
 `ldsflda`指令静态 （在类的所有实例间共享） 的地址推送到堆栈上的字段。 该地址可表示为瞬态指针 (类型`*`) 如果元数据标记`field`引用来管理其内存的类型。 否则，它对应于非托管指针 (类型`native int`)。 请注意，`field`可以是静态分配的相对虚拟地址 （基址的情况下，其包含的 PE 文件加载到内存中的字段的偏移量） 全局内存是非托管。  
  
 `ldsflda`指令可以有<xref:System.Reflection.Emit.OpCodes.Volatile>前缀。  
  
 <xref:System.MissingFieldException> 元数据中找不到字段时引发。 仅当 Microsoft 中间语言 (MSIL) 指令转换为本机代码，而非运行时，通常选中此选项。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldsflda`操作码：  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送对元数据中存储的字符串的新对象引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|推送的元数据字符串标记的字符串对象`mdToken`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  对字符串的对象引用推送到堆栈上。  
  
 `ldstr`指令将一个对象引用 (类型`O`) 到一个新的字符串对象，表示存储的元数据中的特定字符串文本。 `ldstr`指令分配必需的内存量，并执行将字符串文本转换为字符串格式，在运行时所需的文件中使用的格式从所需的任何格式转换。  
  
 公共语言基础结构 (CLI) 可保证两个结果`ldstr`说明两个具有相同的字符序列的元数据标记引用返回相同的字符串对象 （称为"字符串暂留"的过程）。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldstr`操作码：  
  
-   ILGenerator.Emit(OpCode, string)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将元数据标记转换为其运行时表示形式，并将其推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D0 < `T` >|ldtoken `token`|将元数据标记转换为其运行时表示形式。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  传入的令牌转换为`RuntimeHandle`和推送到堆栈上。  
  
 `ldtoken`指令推送`RuntimeHandle`的指定元数据标记。 A`RuntimeHandle`可以是`fieldref/fielddef`、 `methodref/methoddef`，或`typeref/typedef`。  
  
 推送到堆栈上的值可在调用`Reflection`系统类库中的方法。  
  
 对运行时句柄的信息，请参阅以下类： <xref:System.RuntimeFieldHandle>， <xref:System.RuntimeTypeHandle>，和<xref:System.RuntimeMethodHandle>。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldtoken`操作码：  
  
-   ILGenerator.Emit （操作码，MethodInfo）  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指向实现与指定对象关联的特定虚方法的本机代码的非托管指针（<see langword="native int" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 07 < `T` >|ldvirtftn `method`|推送到对象的虚方法的指针`method`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用推送到堆栈上。  
  
2.  从堆栈并且入口点的地址中弹出的对象引用是对方法 (所指定的元数据标记`method`) 查找。  
  
3.  将指针与`method`推送到堆栈上。  
  
 生成的非托管的指针推入堆栈由`ldvirtftn`可以使用调用指令<xref:System.Reflection.Emit.OpCodes.Calli>指令，如果所引用的托管的方法 （或从非托管代码到托管代码转换存根 （stub））。  
  
 非托管的指针指向使用 CLR 调用约定的本机代码。 作为回调例程之前，不应将此方法指针传递到非托管的本机代码。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ldvirtftn`操作码：  
  
-   ILGenerator.Emit （操作码，MethodInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>退出受保护的代码区域，无条件将控制转移到特定目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|DD < `int32` >|保留 `target`|退出受保护的代码区域。|  
  
 不没有为此指令指定任何堆栈转换行为。  
  
 `leave`指令无条件将控制转移到特定目标指令，这表示为 4 字节有符号偏移量，从当前指令之后的指令的开头。  
  
 `leave`指令是类似于`br`指令，但它可以用于退出`try`， `filter`，或`catch`块，而普通分支指令仅可在这种块传输内的控制它。 `leave`指令清空计算堆栈，并确保周围适当`finally`块执行。  
  
 不能使用`leave`指令退出`finally`块。 为了简化在 catch 块以使用有效的方法是异常处理程序的代码生成`leave`指令以将控制权转交给中关联的任何指令`try`块。  
  
 如果指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`leave`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>退出受保护的代码区域，无条件将控制转移到目标指令（缩写形式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|DE < `int8` >|leave.s `target`|退出受保护的代码，短窗体区域。|  
  
 不没有为此指令指定任何堆栈转换行为。  
  
 `leave.s`指令无条件将控制转移到传递的目标指令，这表示为 1 字节有符号偏移量，从当前指令之后的指令的开头。  
  
 `leave.s`指令是类似于`br`指令，但它可以用于退出`try`， `filter`，或`catch`块，而普通分支指令仅可在这种块传输内的控制它。 `leave.s`指令清空计算堆栈，并确保周围适当`finally`块执行。  
  
 不能使用`leave.s`指令退出`finally`块。 为了简化在 catch 块以使用有效的方法是异常处理程序的代码生成`leave.s`指令以将控制权转交给中关联的任何指令`try`块。  
  
 如果指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`leave.s`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从本地动态内存池分配特定数目的字节并将第一个分配的字节的地址（瞬态指针，<see langword="*" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|从本地堆中分配空间。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  要分配的字节数被推送到堆栈上。  
  
2.  从堆栈中弹出的字节数从本地堆分配的大小相对应的内存量。  
  
3.  指向分配的内存的第一个字节的指针被推送到堆栈上。  
  
 `localloc`指令分配`size`(类型`natural unsigned int`) 从本地的动态内存的字节池和返回的地址 (暂时性的指针，类型`*`) 的已分配的第一个字节。 返回的内存块，将初始化为 0，仅当该方法中的初始化标志为`true`。 当前方法的执行时<xref:System.Reflection.Emit.OpCodes.Ret>，本地内存池将可供重用。  
  
 生成的地址对齐，因此任何基元数据类型可以存储那里使用`stind`说明 (如<xref:System.Reflection.Emit.OpCodes.Stind_I4>) 和使用加载`ldind`说明 (如<xref:System.Reflection.Emit.OpCodes.Ldind_I4>)。  
  
 `localloc`指令不能出现在`filter`， `catch`， `finally`，或`fault`块。  
  
 <xref:System.StackOverflowException> 如果没有足够的内存来为请求提供服务将引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`localloc`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将对特定类型实例的类型化引用推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|C6 < `T` >|mkrefany `class`|将类型的类型化的引用推送`class`到堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  指向的数据片段的推入堆栈。  
  
2.  弹出指针并将其转换为类型的类型化引用`class`。  
  
3.  类型化的引用推送到堆栈上。  
  
 `mkrefany`指令支持传递的动态类型化的引用。 指针的类型必须为`&`， `*`，或`native int`，并且保留一段数据的有效地址。 `Class` 类令牌描述由指针引用的数据类型。 `Mkrefany` 将类型化的引用推送到堆栈上，提供的指针和类型是不透明描述符`class`。  
  
 允许对类型化引用的唯一有效操作是将其传递给需要作为参数的类型化的引用的方法。 然后，被调用方可以使用<xref:System.Reflection.Emit.OpCodes.Refanytype>和<xref:System.Reflection.Emit.OpCodes.Refanyval>如何分别检索类型 （类） 和地址。  
  
 <xref:System.TypeLoadException> 如果引发`class`找不到。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`mkrefany`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相乘并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|5A|mul|将在堆栈上的两个值相乘。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`乘以`value2`。  
  
4.  将结果推送到堆栈上。  
  
 `mul`指令乘以`value1`通过`value2`并将结果推送到堆栈上。 整数运算以无提示方式截断高位上溢出。  
  
 请参阅<xref:System.Reflection.Emit.OpCodes.Mul_Ovf>整数特定的乘法运算而不进行溢出处理。  
  
 对于浮点类型，0 * 无穷大 = NaN。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`mul`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个整数值相乘，执行溢出检查，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D8|mul.ovf|溢出检查的堆栈上的两个整数值相乘。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`乘以`value2`，并且执行溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 `mul.ovf`指令乘以整数`value1`通过整数`value2`并将结果推送到堆栈上。 如果结果不符合结果类型中，将引发异常。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`mul.ovf`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个无符号整数值相乘，执行溢出检查，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|溢出检查的堆栈上的两个无符号的值相乘。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value1`乘以`value2`，并且执行溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 `mul.ovf.un`指令乘以无符号的整数`value1`由无符号整数`value2`并将结果推送到堆栈上。 如果结果不符合结果类型中，将引发异常。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`mul.ovf.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>对一个值执行求反并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|65|neg|当前位于堆栈顶部的值求反。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个值推送到堆栈上。  
  
2.  值为从堆栈中弹出并求反。  
  
3.  将结果推送到堆栈上。  
  
 `neg`指令值求反并将推送位于堆栈顶部的结果。 返回类型是操作数类型相同。  
  
 求反运算的整数值是标准 2 的补数求反。 具体而言，从而取消最小的负号 （它不具有正的副本） 会产生最小的负号。 若要检测此溢出，请改用<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>指令改为 （0，即减）。  
  
 从而取消浮点数不能溢出，并从而取消 NaN 返回 NaN。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`neg`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将对新的从零开始的一维数组（其元素属于特定类型）的对象引用推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr `etype`|创建一个新数组类型的元素`etype`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  数组中元素的数目推送到堆栈上。  
  
2.  从堆栈中弹出的元素数，并在创建数组。  
  
3.  对新数组的对象引用推送到堆栈上。  
  
 `newarr`指令将一个对象引用 (类型`O`) 到新的从零开始、 一维数组，将其元素是类型的`etype`（描述类型的元数据标记）。 新数组中元素的数目应指定为`native int`。 有效的数组索引范围是从 0 到减一的元素的最大数目。  
  
 数组的元素可以是任何类型，包括值类型。  
  
 使用引用相应的值类型的元数据标记创建的数字的对象的从零开始的一维数组 (<xref:System.Int32>，依次类推)。 数组的元素将初始化为适当类型的 0。  
  
 使用创建非从零开始的一维数组和多维数组<xref:System.Reflection.Emit.OpCodes.Newobj>而非`newarr`。 更常见的是，使用的方法创建它们<xref:System.Array>.NET Framework 中的类。  
  
 <xref:System.OutOfMemoryException> 如果没有足够的内存来满足该请求将引发。  
  
 <xref:System.OverflowException> 如果引发`numElems`小于 0。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`newarr`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>创建一个值类型的新对象或新实例，并将对象引用（<see langword="O" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|分配未初始化的对象或值类型和调用构造函数方法`ctor`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  自变量`arg1`通过`argn`序列中推送到堆栈上。  
  
2.  自变量`argn`通过`arg1`从堆栈中弹出并传递到`ctor`创建对象。  
  
3.  对新对象的引用推送到堆栈上。  
  
 `newobj`指令会创建一个新的对象或值类型的新实例。 `Ctor` 为元数据标记 (`methodref`或`methoddef`，必须将标记为一个构造函数)，该值指示名称、 类和要调用的构造函数的签名。  
  
 `newobj`指令分配与关联的类的新实例`ctor`并初始化为 0 （的正确的类型中） 或与相应的 null 引用的新实例中的所有字段。 然后，它调用构造函数`ctor`与给定的参数以及新创建的实例。 调用的构造函数后，将新初始化的对象引用 (类型`O`) 推送到堆栈上。  
  
 在构造函数的角度来看，未初始化的对象是参数 0，然后传递给 newobj 的其他参数按顺序。  
  
 使用创建所有从零开始的一维数组<xref:System.Reflection.Emit.OpCodes.Newarr>，而不`newobj`。 另一方面，使用创建 （更多维度，或是一维但不是从零开始） 的所有其他数组`newobj`。  
  
 值类型通常不创建使用`newobj`。 它们通常分配作为参数或局部变量，使用`newarr`（适用于从零开始的一维数组），或作为对象的字段。 分配后，它们将初始化使用<xref:System.Reflection.Emit.OpCodes.Initobj>。 但是，`newobj`指令可以用于创建在堆栈中，然后可以作为参数，存储在本地，并因此在传递的值类型的新实例。  
  
 <xref:System.OutOfMemoryException> 如果没有足够的内存来满足该请求将引发。  
  
 <xref:System.MissingMethodException> 如果构造函数方法将引发`ctor`具有指示的名称，类和签名找不到。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码，而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`newobj`操作码：  
  
-   ILGenerator.Emit （操作码，ConstructorInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果修补操作码，则填充空间。 尽管可能消耗处理周期，但未执行任何有意义的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|00|nop|执行操作而无需行为。|  
  
 不没有为此指令定义任何堆栈过渡行为。  
  
 `nop`操作不执行任何操作。 它旨在如果修补操作码，则填充空间。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`nop`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算堆栈顶部整数值的按位求补并将结果作为相同的类型推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|66|not|计算一个值的按位求补。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value` 推送到堆栈上。  
  
2.  `value` 将弹出从堆栈并且其按位求补计算。  
  
3.  将结果推送到堆栈上。  
  
 `not`指令计算整数值的按位求补并将推送到堆栈的结果。 返回类型是操作数类型相同。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`not`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算位于堆栈顶部的两个整数值的按位求补并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|60|或|计算的按位或两个整数值，返回一个整数。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈并且其按位 OR 弹出计算。  
  
4.  将结果推送到堆栈上。  
  
 `or`指令计算位于堆栈顶部的两个值的按位或推送到堆栈的结果。  
  
 `Or` 是一个整数特定操作。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`or`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>移除当前位于计算堆栈顶部的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|26|pop|弹出从堆栈顶部的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  从堆栈中弹出位于顶部的值。  
  
 `pop`指令从堆栈中移除顶部的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`pop`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定后面的数组地址操作在运行时不执行类型检查，并且返回可变性受限的托管指针。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 1E|readonly。|指定，后面的数组地址操作不执行类型检查在运行时，并且，它返回可变性受限的托管的指针。|  
  
 此前缀只能出现前面紧邻`ldelema`指令和对这两个特殊调用`Address`在阵列上的方法。 它对后续操作的影响是双重的：  
  
1.  在运行时，会不执行任何类型检查操作。 请注意是通常隐式类型检查`ldelema`和`stelem`指令时使用引用类型数组。 会永远不会运行时类型检查对于值类，因此`readonly`在这种情况下是不执行任何操作。  
  
2.  可变性受限还原时，验证程序将视为托管指针的地址的操作的结果。  
  
 指针被认为具有受限的可变性因为定义类型控制是否可以更改值。 对于公开的任何公共字段或更新的位置中的值的方法的值类，该指针为只读 (因此前缀的名称)。 具体而言，表示基元类型 (例如，System.Int32) 的类不会公开使用赋值函数，因此是只读的。  
  
 仅以下方式使用以这种方式受限的托管的指针：  
  
-   作为`object`参数`ldfld`， `ldflda`， `stfld`， `call`，或`constrained callvirt`说明。  
  
-   作为`pointer`参数`ldobj`指令或其中的某个`ldind`说明。  
  
-   作为`source`参数`cpobj`指令。  
  
 所有其他不允许操作，包括`stobj`， `initobj`，或`mkrefany`操作，或任何`stind`说明。  
  
 用途`readonly`前缀是从泛型代码中的数组中提取元素时避免执行类型检查。 例如，表达式`arr[i].m()`，其中的元素类型数组`arr`是被约束为具有方法的接口的泛型类型`m`，可能会编译成如下 MSIL。  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 而无需`readonly`前缀，`ldelema`指令将在这种情况中执行类型检查其中 ！ 0 是引用类型。 不只是这种类型检查效率低下，但在语义上不正确。 类型检查`ldelema`是完全匹配，即太强。 如果数组包含类型的子类 ！ 0，上面的代码将失败类型检查。  
  
 数组元素的地址提取，而不是元素本身，以便获得的句柄`arr[i]`适用于这两值类型和引用类型，并且因此可以传递给`constrained callvirt`指令。  
  
 一般情况下，它将不安全，以跳过运行时检查，如果数组包含引用类型的元素。 为安全起见，务必确保对数组做任何修改都通过此指针。 验证规则确保这一点。 可以作为实例方法调用的对象传递受限的托管的指针，因此它不是严格地说只读的值类型，但是没有值类型的类型安全问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`readonly`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索嵌入在类型化引用内的类型标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|推送存储在类型化的引用的类型标记。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值类型引用推送到堆栈上。  
  
2.  从堆栈中弹出类型化的引用，其相应的类型标记检索。  
  
3.  类型标记被推送到堆栈上。  
  
 类型化的引用包含类型标记和对象实例的地址。  
  
 `refanytype`指令检索嵌入在类型化引用内的类型标记。 请参阅<xref:System.Reflection.Emit.OpCodes.Mkrefany>指令有关创建类型化引用。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`refanytype`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索嵌入在类型化引用内的地址（<see langword="&amp;" /> 类型）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|地址存储在类型化引用推送。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值类型引用推送到堆栈上。  
  
2.  从堆栈中弹出类型化的引用和检索相应的地址。  
  
3.  地址推送到堆栈中。  
  
 类型化的引用包含类型标记和对象实例的地址。  
  
 `refanyval`指令检索嵌入在的地址类型化的引用。 嵌入在堆栈上提供的类型化引用的类型必须与由指定的类型匹配`type`(元数据令牌`typedef`或`typeref`)。 请参阅<xref:System.Reflection.Emit.OpCodes.Mkrefany>相关内容的指令。  
  
 <xref:System.InvalidCastException> 如果引发`type`并不到存储中的类型引用的类型完全相同 (在这种情况下，`type`类提供给<xref:System.Reflection.Emit.OpCodes.Mkrefany>构造的指令上述类型化的引用)。  
  
 <xref:System.TypeLoadException> 如果引发`type`找不到。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`refanyval`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相除并将余数推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|5D|rem|相除的余数推送`value1`通过`value2`到堆栈上。|  
  
> [!NOTE]
>  ReplaceThisText  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  A`value1`推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈并且的其余部分弹出`value1` `div` `value2`计算。  
  
4.  将结果推送到堆栈上。  
  
 `result` = `value1` `rem` `value2` 满足以下条件：  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`)，和：  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;，登录 (`result`) = 号 (`value1`)，其中`div`是向零截断的除法指令。  
  
 如果`value2`为零或`value1`为的无穷大，则结果为 NaN。 如果`value2`为无穷大，结果是`value1`(求反后的有关`-infinity`)。  
  
 整数运算引发<xref:System.DivideByZeroException>如果`value2`为零。  
  
 请注意，在基于 Intel 的平台上<xref:System.OverflowException>计算时，将引发 (minint `rem` -1)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`rem`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个无符号值相除并将余数推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|5E|rem.un|相除的余数推送无符号`value1`除以无符号`value2`到堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈并且的其余部分弹出`value1` `div` `value2`计算。  
  
4.  将结果推送到堆栈上。  
  
 `result` = `value1` `rem.un` `value2` 满足以下条件：  
  
 `result` = `value1` - `value2` x (`value1` `div.un` `value2`)，和：  
  
 0 = `result`  <  `value2`，其中`div.un`是无符号的除法指令。  
  
 `rem.un`指令计算`result`并将结果推送到堆栈上。 `Rem.un` 将其自变量视为无符号整数，而<xref:System.Reflection.Emit.OpCodes.Rem>会将它们视作有符号的整数。  
  
 `Rem.un` 未指定对于浮点数。  
  
 整数运算引发<xref:System.DivideByZeroException>如果`value2`为零。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`rem.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从当前方法返回，并将返回值（如果存在）从被调用方的计算堆栈推送到调用方的计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|2A|ret|从方法返回，可能返回一个值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  返回值是从被调用方计算堆栈中弹出。  
  
2.  获取在步骤 1 中的返回值推送到调用方计算堆栈上。  
  
 如果返回值不存在于被调用方计算堆栈上，则不返回任何值 （被调用方或调用方的方法没有堆栈转换行为）。  
  
 类型的返回值，如果有，当前方法确定要从堆栈顶部和复制到调用当前方法的方法的堆栈中提取值的类型。 当前方法的计算堆栈必须为空除外要返回的值。  
  
 `ret`指令不能用于将控制转移出`try`， `filter`， `catch`，或`finally`块。 在`try`或`catch`，使用<xref:System.Reflection.Emit.OpCodes.Leave>指令的目标与`ret`是所有封闭异常块的外部的指令。 因为`filter`和`finally`块在逻辑上是异常处理和不在其中嵌入其代码的方法的一部分，正确生成的 Microsoft 中间语言 (MSIL) 指令不执行中的返回方法`filter`或`finally`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`ret`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>再次引发当前异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 1A|重新引发|重新引发当前异常|  
  
 为此指令不定义了任何堆栈转换行为。  
  
 `rethrow`指令仅允许的主体内`catch`处理程序。 它将引发此处理程序捕获相同的异常。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`rethrow`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值左移（用零填充）指定的位数，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|62|shl|将左移 （用零移位） 整数。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个值推送到堆栈上。  
  
2.  Bits 要移动的量推入堆栈。  
  
3.  从堆栈中弹出要移动的比特数和值值是按照指定的位数左移。  
  
4.  将结果推送到堆栈上。  
  
 `shl`指令右移值 (类型`int32`，`int64`或`native int`) 指定数目的位向左。 比特数是类型的值`int32`或`native int`。 返回的值未指定要移动的比特数是否大于或等于提供的值的宽度 （以位为单位）。  
  
 `Shl` 在每个班次最低的位置中插入零位。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`shl`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值右移（保留符号）指定的位数，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|63|shr|将一个整数 （保留符号移位） 右移。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个值推送到堆栈上。  
  
2.  Bits 要移动的量推入堆栈。  
  
3.  从堆栈中弹出要移动的比特数和值值按照指定的位数向右位移。  
  
4.  将结果推送到堆栈上。  
  
 `shr.un`指令右移值 (类型`int32`，`int64`或`native int`) 权限，指定比特数。 比特数是类型的值`int32`或`native int`。 返回的值未指定要移动的比特数是否大于或等于提供的值的宽度 （以位为单位）。  
  
 `Shr` 复制在每一移位，保留原始值中的符号的高序位`result`。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`shr`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将无符号整数值右移（用零填充）指定的位数，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|64|shr.un|将整数向右 （并且位移用零填充）。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个值推送到堆栈上。  
  
2.  Bits 要移动的量推入堆栈。  
  
3.  从堆栈中弹出要移动的比特数和值值按照指定的位数向右位移。  
  
4.  将结果推送到堆栈上。  
  
 `shr.un`指令右移值 (类型`int32`，`int64`或`native int`) 权限，指定比特数。 比特数是类型的值`int32`，`int64`或`native int`。 返回的值未指定要移动的比特数是否大于或等于提供的值的宽度 （以位为单位）。  
  
 `Shr.un` 在每个班次的最高位置中插入零位。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`shr.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将提供的值类型的大小（以字节为单位）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 1C < `T` >|sizeof `valType`|推送大小，以字节为单位的值类型作为`unsigned int32`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  提供的值类型的大小 （以字节为单位） (`valType`) 推送到堆栈上。  
  
 `valType` 必须是元数据标记 (`typeref`或`typedef`)，它指定值类型、 引用类型或泛型类型参数。  
  
 对于引用类型，返回的大小是相应的引用值的大小键入 （32 位系统上为 4 字节），不由引用值引用的对象中存储的数据的大小。 仅在类型或将其定义的方法的主体中，可以使用泛型类型参数。 该类型或方法实例化时，泛型类型参数都替换为值类型或引用类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`sizeof`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值存储到位于指定索引的自变量槽中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 0B < `unsigned int16` >|starg `num`|弹出从堆栈顶部的值并将其存储在参数槽`num`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  弹出当前位于堆栈顶部的值并将其放在参数槽`num`。  
  
 `starg`指令弹出堆栈中的一个值，并将其放在参数槽`num`。 值的类型必须匹配在当前方法的签名中指定的参数的类型。  
  
 对于采用变量自变量列表中，过程`starg`指令可以仅用于初始固定自变量，不是那些在签名的变量的一部分。  
  
 当从堆栈移到自变量转换容纳的整数值小于 4 个字节长的自变量执行存储截断值。 从其原始大小浮点值舍入 (类型`F`) 到与该参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`starg`操作码：  
  
-   ILGenerator.Emit(OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值存储在自变量槽中的指定索引处（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg.s `num`|弹出从堆栈顶部的值并将其存储在参数槽`num`，缩写形式。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  弹出当前位于堆栈顶部的值并将其放在参数槽`num`。  
  
 `starg.s`指令弹出堆栈中的一个值，并将其放在参数槽`num`。 值的类型必须匹配在当前方法的签名中指定的参数的类型。  
  
 `starg.s`指令提供有效的编码与的前 256 个自变量一起使用。  
  
 对于采用变量自变量列表中，过程`starg.s`指令可以仅用于初始固定自变量，不是那些在签名的变量的一部分。  
  
 当从堆栈移到自变量转换容纳的整数值小于 4 个字节长的自变量执行存储截断值。 从其原始大小浮点值舍入 (类型`F`) 到与该参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`starg.s`操作码：  
  
-   ILGenerator.Emit （操作码，字节）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈中的值替换给定索引处的数组元素，其类型在指令中指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|A4 < `T` >|stelem `typeTok`|用提供的索引处的数组元素替换的类型的值`typeTok`堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  索引值， `index`，到中的元素`array`推送到堆栈上。  
  
3.  指令中指定类型的值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem`指令用一维数组中提供的从零开始索引处的元素的值替换`array`具有值。 值具有指定标记的类型`typeTok`在指令中。  
  
 数组是对象，并因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stelem`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="native int" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|9B|stelem.i|替换与提供的索引处的数组元素`native int`堆栈上的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  到中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.i`指令替换元素的值`index`一维数组中`array`与`native int`值推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stelem.i`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int8" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|替换与提供的索引处的数组元素`int8`堆栈上的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  到中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.i1`指令替换元素的值`index`一维数组中`array`与`int8`值推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stelem.i1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int16" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|替换与提供的索引处的数组元素`int16`堆栈上的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  到中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.i2`指令替换元素的值`index`一维数组中`array`与`int16`值推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stelem.i2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int32" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|替换与提供的索引处的数组元素`int32`堆栈上的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  到中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.i4`指令替换元素的值`index`一维数组中`array`与`int32`值推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stelem.i4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int64" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|替换与提供的索引处的数组元素`int64`堆栈上的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  到中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.i8`指令替换元素的值`index`一维数组中`array`与`int64`值推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stelem.i8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="float32" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|替换与提供的索引处的数组元素`float32`堆栈上的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  到中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.r4`指令替换元素的值`index`一维数组中`array`与`float32`值推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stelem.r4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="float64" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|A1|stelem.r8|替换与提供的索引处的数组元素`float64`堆栈上的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  到中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.r8`指令替换元素的值`index`一维数组中`array`与`float64`值推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stelem.r8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的对象 ref 值（<see langword="O" /> 类型）替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|替换与提供的索引处的数组元素`ref`值 (类型`O`) 堆栈上。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  到一个数组中的对象引用`array`，推送到堆栈上。  
  
2.  到中的元素的有效索引`array`推送到堆栈上。  
  
3.  一个值推送到堆栈上。  
  
4.  从堆栈中弹出值、 索引和数组引用值放入给定索引处的数组元素。  
  
 `stelem.ref`指令用一维数组中提供的索引处的元素的值替换`array`与`ref`(类型`O`) 值推送到堆栈上。  
  
 数组是对象，因此由类型的值`O`。 索引是类型`native int`。  
  
 请注意，`stelem.ref`隐式强制转换到的元素类型提供的值`array`之前的值分配给数组元素。 此转换可能会与此失败，即使对于验证代码。 因此`stelem.ref`指令可能引发<xref:System.InvalidCastException>。 对于不是从零开始的一维数组和多维数组，<xref:System.Array>类提供<xref:System.Array.SetValue%2A>方法。  
  
 <xref:System.NullReferenceException> 如果引发`array`为空引用。  
  
 <xref:System.IndexOutOfRangeException> 如果引发`index`为负，或者大于的边界`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果引发`array`不包含所需的类型的元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stelem.ref`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用新值替换在对象引用或指针的字段中存储的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld 从 `field`|替换的值`field`新值的对象。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  对象引用或指针推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和对象引用/指针值`field`对象中将替换所提供的值。  
  
 `stfld`指令替换对象的字段的值 (类型`O`) 或通过指针 (类型`native int`， `&`，或`*`) 与给定的值。 `Field` 是指字段成员引用的元数据标记。 `stfld`指令可以具有一个或两个前缀<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile>。  
  
 <xref:System.NullReferenceException> 如果对象引用或指针为空引用，并且该字段是静态将引发。  
  
 <xref:System.MissingFieldException> 如果引发`field`的元数据中找不到。 仅当 Microsoft 中间语言 (MSIL) 指令转换为本机代码，而非运行时，通常选中此选项。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stfld`操作码：  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="native int" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|DF|stind.i|存储`native int`在给定的地址的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址该值存储在地址中。  
  
 `stind.i`指令存储`native int`处提供的地址值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.i`指令用于与指针的类型一致的方式。 该操作的`stind.i`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐隐含指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stind.i`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int8" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|52|stind.i1|存储`int8`在给定的地址的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址该值存储在地址中。  
  
 `stind.i1`指令存储`int8`处提供的地址值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.i1`指令用于与指针的类型一致的方式。 该操作的`stind.i1`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐隐含指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stind.i1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int16" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|53|stind.i2|存储`int16`在给定的地址的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址该值存储在地址中。  
  
 `stind.i2`指令存储`int16`处提供的地址值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.2i`指令用于与指针的类型一致的方式。 该操作的`stind.i2`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐隐含指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stind.i2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int32" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|54|stind.i4|存储`int32`在给定的地址的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址该值存储在地址中。  
  
 `stind.i4`指令存储`int32`处提供的地址值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.i4`指令用于与指针的类型一致的方式。 该操作的`stind.i4`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐隐含指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stind.i4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int64" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|55|stind.i8|存储`int64`在给定的地址的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址该值存储在地址中。  
  
 `stind.i8`指令存储`int64`处提供的地址值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.i8`指令用于与指针的类型一致的方式。 该操作的`stind.i`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐隐含指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stind.i8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="float32" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|56|stind.r4|存储`float32`在给定的地址的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址该值存储在地址中。  
  
 `stind.r4`指令存储`float32`处提供的地址值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.r4`指令用于与指针的类型一致的方式。 该操作的`stind.r4`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐隐含指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stind.r4`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="float64" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|57|stind.r8|存储`float64`在给定的地址的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址该值存储在地址中。  
  
 `stind.r8`指令存储`float64`处提供的地址值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.r8`指令用于与指针的类型一致的方式。 该操作的`stind.r8`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐隐含指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stind.r8`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>存储所提供地址处的对象引用值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|51|stind.ref|将存储对象引用 (类型`O`) 在给定的地址的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  一个值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址该值存储在地址中。  
  
 `stind.ref`指令将存储在提供的地址的对象引用值 (类型`native int`， `*`，或`&`)。  
  
 类型安全操作要求`stind.ref`指令用于与指针的类型一致的方式。 该操作的`stind.ref`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.NullReferenceException> 如果引发`addr`不自然对齐隐含指令后缀与自变量类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stind.ref`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到指定索引处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 0E < `unsigned int16` >|stloc `index`|弹出堆栈中的一个值，并将其存储在本地变量`index`。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  从堆栈中弹出一个值并将其置于本地变量`index`。  
  
 `stloc`指令弹出从计算堆栈顶部的值，并将它移动到局部变量号`index`，其中本地变量，是开始编号为 0。 值的类型必须与在当前方法的本地签名中指定的本地变量类型匹配。  
  
 当从堆栈移到局部变量中容纳的整数值小于 4 个字节长存储截断值。 从其原始大小浮点值舍入 (类型`F`) 到与该参数关联的大小。  
  
 正确的 Microsoft 中间语言 (MSIL) 指令需要`index`是有效的本地索引。 有关`stloc`指令，`index`必须介于 0 到 65534 非独占 （具体而言，65535 无效）。 不包括 65535 的原因是实际： 实现很可能将使用的 2 字节整数跟踪局部变量的索引，以及给定方法的局部变量的总数。 如果已经使 65535 索引有效，它将要求要跟踪此类方法中的局部变量的数目更宽的整数。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stloc`操作码：  
  
-   ILGenerator.Emit(OpCode, LocalBuilder)  
  
-   ILGenerator.Emit(OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 0 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|0A|stloc.0|到本地变量 0 弹出堆栈中的一个值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值为从堆栈中弹出并放入索引为 0 的局部变量。  
  
 `stloc.0`指令弹出计算堆栈顶部的值，并将其移动到索引为 0 的局部变量。 值的类型必须与在当前方法的本地签名中指定的本地变量类型匹配。  
  
 `stloc.0` 是用于将值存储在本地变量 0 的非常有效的编码。  
  
 当从堆栈移到局部变量中容纳的整数值小于 4 个字节长存储截断值。 从其原始大小浮点值舍入 (类型`F`) 到与该参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stloc.0`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 1 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|0B|stloc.1|到本地变量 1 弹出堆栈中的一个值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值为从堆栈中弹出并放入索引为 1 的局部变量。  
  
 `stloc.1`指令弹出计算堆栈顶部的值，并将其移动到索引为 1 的局部变量。 值的类型必须与在当前方法的本地签名中指定的本地变量类型匹配。  
  
 `stloc.1` 是用于将值存储在本地变量 1 的非常有效的编码。  
  
 当从堆栈移到局部变量中容纳的整数值小于 4 个字节长存储截断值。 从其原始大小浮点值舍入 (类型`F`) 到与该参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stloc.1`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 2 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|0C|stloc.2|将值从堆栈中弹出到本地变量 2|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值为从堆栈中弹出并放入索引为 2 的局部变量。  
  
 `stloc.2`指令弹出计算堆栈顶部的值，并将其移动到索引为 2 的局部变量。 值的类型必须与在当前方法的本地签名中指定的本地变量类型匹配。  
  
 `stloc.2` 是用于将值存储在本地变量 2 的非常有效的编码。  
  
 当从堆栈移到局部变量中容纳的整数值小于 4 个字节长存储截断值。 从其原始大小浮点值舍入 (类型`F`) 到与该参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stloc.2`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 3 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|0D|stloc.3|将值从堆栈中弹出到局部变量 3|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  值为从堆栈中弹出并放入索引为 3 的局部变量。  
  
 `stloc.3`指令弹出计算堆栈顶部的值，并将其移动到索引为 3 的局部变量。 值的类型必须与在当前方法的本地签名中指定的本地变量类型匹配。  
  
 `stloc.3` 是用于将值存储在本地变量 3 的非常有效的编码。  
  
 当从堆栈移到局部变量中容纳的整数值小于 4 个字节长存储截断值。 从其原始大小浮点值舍入 (类型`F`) 到与该参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stloc.3`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储在局部变量列表中的 <paramref name="index" /> 处（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s `index`|弹出堆栈中的一个值，并将其存储在本地变量`index`，缩写形式。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  从堆栈中弹出一个值并将其置于本地变量`index`。  
  
 `stloc.s`指令弹出从计算堆栈顶部的值，并将它移动到局部变量号`index`，其中本地变量，是开始编号为 0。 值的类型必须与在当前方法的本地签名中指定的本地变量类型匹配。  
  
 `stloc.s`指令提供了用于本地变量 0 到 255 之间的有效编码。  
  
 当从堆栈移到局部变量中容纳的整数值小于 4 个字节长存储截断值。 从其原始大小浮点值舍入 (类型`F`) 到与该参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stloc.s`操作码：  
  
-   ILGenerator.Emit(OpCode, LocalBuilder)  
  
-   ILGenerator.Emit （操作码，字节）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指定类型的值从计算堆栈复制到所提供的内存地址中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|存储类型的值`class`从到内存堆栈。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
2.  类型的值类型对象`class`推送到堆栈上。  
  
3.  从堆栈中弹出对象和地址值类型对象存储在地址。  
  
 `stobj`指令将值类型对象复制到指定的地址的地址 (类型的指针`native int`， `*`，或`&`)。 复制的字节数取决于所表示的类的大小`class`、 表示值类型的元数据标记。  
  
 该操作的`stobj`指令可更改紧跟其后<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令。  
  
 <xref:System.TypeLoadException> 如果找不到类将引发。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stobj`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用来自计算堆栈的值替换静态字段的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|替换中的值`field`与提供的值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个值推送到堆栈上。  
  
2.  从堆栈中弹出值并将其存储在`field`。  
  
 `stsfld`指令用替换静态字段的值从堆栈的值。 `field` 是必须引用静态字段成员的元数据标记。  
  
 `stsfld`指令可能采用作为前缀<xref:System.Reflection.Emit.OpCodes.Volatile>。  
  
 <xref:System.MissingFieldException> 元数据中找不到字段时引发。 仅 Microsoft 中间语言 (MSIL) 指令不在运行时转换为本机代码时，通常选中此选项。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`stsfld`操作码：  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从其他值中减去一个值并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|59|sub|中减去从另一个，则返回一个新的数字值的一个值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value2`减去`value1`。  
  
4.  将结果推送到堆栈上。  
  
 对于整数运算不检测溢出 (有关正确的溢出处理问题，请参阅<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>)。  
  
 整数减法包装，而不会使更饱满。 例如： 假定 8 位整数，其中`value1`设置为 0 和`value2`设置为 1，则"包装"的结果将是 255。  
  
 浮点溢出返回`+inf`(`PositiveInfinity`) 或`-inf`(`NegativeInfinity`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`sub`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从另一值中减去一个整数值，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|DA|sub.ovf|减去从另一个具有溢出检查的一个整数值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value2`减去`value1`加上溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 对有符号整数; 执行此操作对于浮点值，请使用<xref:System.Reflection.Emit.OpCodes.Sub>。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`sub.ovf`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从另一值中减去一个无符号整数值，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|DB|sub.ovf.un|中减去一个无符号的整数值，从另一个具有溢出检查。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`从堆栈中弹出`value2`减去`value1`加上溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 <xref:System.OverflowException> 如果不可以结果类型中表示的结果，引发。  
  
 对有符号整数; 执行此操作对于浮点值，请使用<xref:System.Reflection.Emit.OpCodes.Sub>。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`sub.ovf.un`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>实现跳转表。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... < `int32` >|切换 (`N`， `t1`， `t2`...`tN`)|跳转到之一`N`值。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个值推送到堆栈上。  
  
2.  堆栈中弹出值和执行传输到索引的值的偏移量指令其中的值是小于`N`。  
  
 `switch`指令实现跳转表。 指令的格式是`unsigned int32`表示的目标数量`N`后, 跟`N`int32 值指定跳转的目标。 这些目标作为偏移量 （正或负） 表示从下这一条指令开头`switch`指令。  
  
 `switch`指令弹出堆栈的一个值，并将其，作为无符号整数到`N`。 如果值是小于`N`，执行传输到目标索引使用的值、 目标从 0 开始编号的位置 （例如，值为 0 采用第一个目标，值为 1 将第二个目标，依此类推）。 如果值为大于或等于`N`，在下一条指令 （贯穿） 处继续执行。  
  
 如果该目标指令具有一个或多个前缀代码，则仅将控制转移到第一个的这些前缀。  
  
 控制传输到和移出`try`， `catch`， `filter`，和`finally`块无法执行此指令。 （此类传输受到严格限制，必须改为使用 leave 指令）。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`switch`操作码。 `Label[]`参数是数组表示 32 位偏移量的标签。  
  
-   ILGenerator.Emit(OpCode, Label[])  
  
   
  
## Examples  
 下面的代码示例演示如何使用`Switch`操作码来生成跳转表使用的数组<xref:System.Reflection.Emit.Label>。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行后缀的方法调用指令，以便在执行实际调用指令前移除当前方法的堆栈帧。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 14|结尾。|后续调用终止当前方法|  
  
 不没有为此指令定义任何堆栈转换行为。  
  
 `tail`前缀指令必须紧跟<xref:System.Reflection.Emit.OpCodes.Call>， <xref:System.Reflection.Emit.OpCodes.Calli>，或<xref:System.Reflection.Emit.OpCodes.Callvirt>指令。 它指示执行调用指令前，应删除该当前方法的堆栈帧。 这也暗示从以下调用返回的值也是当前的方法，返回的值和调用因此可转换为跨方法跳转。  
  
 堆栈必须是空的以下调用由传来的参数除外。 之后调用指令的指令必须是 ret。因此唯一有效的代码序列是`tail. call`(或`calli`或`callvirt`)。 正确的 Microsoft 中间语言 (MSIL) 指令必须不分支到`call`指令，但它们可能分支到后续<xref:System.Reflection.Emit.OpCodes.Ret>。  
  
 无法放弃当前帧，控制传输时不受信任代码到受信任的代码，因为这将危害代码标识安全性。 .NET Framework 安全检查，因此可能会导致`tail`被忽略，将保留一个标准<xref:System.Reflection.Emit.OpCodes.Call>指令。 同样，为了允许的已同步的区域发生在调用返回后退出，则`tail`用于退出标记为已同步的方法时，将忽略前缀。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`tail`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">操作码对象的实例。</param>
        <summary>如果提供的操作码采用单字节自变量则返回真或假。</summary>
        <returns>
          <see langword="True" /> 或 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可以用于查找哪些 MSIL 操作码是"短形式"，用于在优化代码中。  
  
 `TakesSingleByteArgument` 返回`true`如果<xref:System.Reflection.Emit.OpCode>实例采用单字节参数在以下情况：  
  
-   操作码执行分支指令对字节大小的地址 (例如，<xref:System.Reflection.Emit.OpCodes.Br_S>和<xref:System.Reflection.Emit.OpCodes.Bgt_S>)。  
  
-   操作码推送到堆栈的字节值 (例如， <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>)。  
  
-   操作码引用变量或通过字节大小的"短格式"的自变量 (例如，<xref:System.Reflection.Emit.OpCodes.Ldloc_S>和<xref:System.Reflection.Emit.OpCodes.Stloc_S>)。  
  
 否则，它将返回 `false`。  
  
 下面的示例演示如何使用`TakesSingleByteArgument`通过反映到`OpCodes`类和测试以查看是否每个`OpCode`字段采用单字节参数。  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>引发当前位于计算堆栈上的异常对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|7A|throw|引发异常。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  （对异常） 的对象引用推送到堆栈上。  
  
2.  从堆栈并且引发的异常中弹出的对象引用。  
  
 `throw`指令引发的异常对象 (类型`O`) 当前堆栈上。  
  
 <xref:System.NullReferenceException> 对象引用为 null 引用时引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`throw`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示当前位于计算堆栈上的地址可能没有与紧接的 <see langword="ldind" />、<see langword="stind" />、<see langword="ldfld" />、<see langword="stfld" />、<see langword="ldobj" />、<see langword="stobj" />、<see langword="initblk" /> 或 <see langword="cpblk" /> 指令的自然大小对齐。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 12 < `unsigned int8` >|未对齐。 `alignment`|指示可能未对齐的后续指针指令。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
 `Unaligned` 指定的地址 (非托管的指针， `native int`) 在堆栈上可能未对齐的紧随的自然大小`ldind`， `stind`， `ldfld`， `stfld`， `ldobj`， `stobj`，`initblk`，或`cpblk`指令。 也就是说，对于<xref:System.Reflection.Emit.OpCodes.Ldind_I4>指令到 4 字节边界可能不到地址的对齐方式。 有关`initblk`和`cpblk`默认对齐方式是体系结构依赖 （在 32 位的 Cpu，64 位 Cpu 上为 8 字节 4 字节）。 必须使用不将其输出限制为 32 位字大小的代码生成器`unaligned`对齐如果未知，则在编译时为 8 字节。  
  
 对齐方式的值必须是 1、 2 或 4 和生成的代码应假定的地址是双字节的字节或四个字节对齐，分别表示。 请注意该暂时性指针 (类型`*`) 始终对齐。  
  
 尽管的对齐方式`cpblk`指令逻辑上需要两个数字 （一个用于源），一个用于目标，不会有明显影响性能如果仅指定较小的数字。  
  
 `unaligned`和`volatile`前缀可以按任意顺序组合。 它们必须紧跟`ldind`， `stind`， `ldfld`， `stfld`， `ldobj`， `stobj`， `initblk`，或`cpblk`指令。 仅<xref:System.Reflection.Emit.OpCodes.Volatile>前缀可用于进行<xref:System.Reflection.Emit.OpCodes.Ldsfld>和<xref:System.Reflection.Emit.OpCodes.Stsfld>说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`unaligned`操作码：  
  
-   ILGenerator.Emit (标签中的操作码）  
  
-   ILGenerator.Emit （操作码，字节）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将值类型的已装箱的表示形式转换为其未装箱的形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|79 < `T` >|取消装箱 `valType`|提取中的值类型数据`obj`，将其已装箱的表示。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用推送到堆栈上。  
  
2.  对象引用是从堆栈中弹出和取消装箱到值类型指针。  
  
3.  值类型指针推入堆栈。  
  
 值类型有两个单独的表示形式中公共语言基础结构 (CLI):  
  
-   使用值类型嵌入在另一个对象时的原始形式。  
  
-   装箱形式，其中的值类型中的数据被包装 （装箱） 到对象以便它可以作为一个独立的实体存在。  
  
 `unbox`指令将对象引用转换 (类型`O`)，则为值类型指针装箱值类型，表示形式 (是托管的指针，类型`&`)，将其未装箱的形式。 提供的值类型 (`valType`) 是元数据标记，该值指示值类型装箱的对象中包含的类型。  
  
 与不同<xref:System.Reflection.Emit.OpCodes.Box>，所需在对象中，请使用值类型的副本`unbox`不需要从对象复制的值类型。 通常，它只计算已存在的装箱对象内的值类型的地址。  
  
 <xref:System.InvalidCastException> 如果该对象未被装箱为引发`valType`。  
  
 <xref:System.NullReferenceException> 对象引用为 null 引用时引发。  
  
 <xref:System.TypeLoadException> 如果类型值，将引发`valType`找不到。 在 Microsoft 中间语言 (MSIL) 指令转换为本机代码，而不是在运行时，通常是检测到此问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`unbox`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指令中指定类型的已装箱的表示形式转换成未装箱形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|A5 < `T` >|unbox.any `typeTok`|从中提取数据`obj`，将其已装箱的表示。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  一个对象引用`obj`推送到堆栈上。  
  
2.  对象引用是从堆栈中弹出和取消装箱到指令中指定的类型。  
  
3.  生成的对象引用或值类型推送到堆栈上。  
  
 当应用于值类型，装箱形式时`unbox.any`指令提取内包含的值`obj`(类型的`O`)，并且因此等效于`unbox`跟`ldobj`。  
  
 当应用于引用类型，`unbox.any`指令具有相同的效果`castclass` `typeTok`。  
  
 如果操作数`typeTok`为泛型类型参数，则运行时行为由为该泛型类型参数指定的类型。  
  
 <xref:System.InvalidCastException> 如果引发`obj`不是装箱的类型。  
  
 <xref:System.NullReferenceException> 如果引发`obj`为空引用。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`unbox.any`操作码：  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定当前位于计算堆栈顶部的地址可以是易失的，并且读取该位置的结果不能被缓存，或者对该地址的多个存储区不能被取消。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|FE 13|易失性。|指示后续指针引用是易失性。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  将地址推送到堆栈上。  
  
 `volatile`。 指定的地址是易失的地址 （即，其可以引用外部到当前线程的执行） 和读取位置不能被缓存或对该位置的多个存储区不能禁止显示的结果。 将标记为访问`volatile`只影响该单一访问; 因此，必须单独标记其他访问到相同的位置。 不需要以原子方式执行访问的易失性的位置。  
  
 <xref:System.Reflection.Emit.OpCodes.Unaligned>和`volatile`前缀可以按任意顺序组合。 它们必须紧跟`ldind`， `stind`， `ldfld`， `stfld`， `ldobj`， `stobj`， `initblk`，或`cpblk`指令。 仅`volatile`前缀可用于进行<xref:System.Reflection.Emit.OpCodes.Ldsfld>和<xref:System.Reflection.Emit.OpCodes.Stsfld>说明。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`volatile`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算位于计算堆栈顶部的两个值的按位异或，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出指令的十六进制转义序列和 Microsoft 中间语言 (MSIL) 程序集格式，以及简要参考摘要：  
  
|格式|程序集格式|描述|  
|------------|---------------------|-----------------|  
|61|xor|计算两个整数值的按位异或，并返回一个整数。|  
  
 执行堆栈过渡行为按顺序排列，即：  
  
1.  `value1` 推送到堆栈上。  
  
2.  `value2` 推送到堆栈上。  
  
3.  `value2` 和`value1`弹出，从堆栈并且其按位异或计算。  
  
4.  按位异或`value2`和`value1`推送到堆栈上。  
  
 `xor`指令计算顶部的两个的按位异或值在堆栈上，并将结果留在堆栈上。  
  
 `Xor` 是一个整数特定操作。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以使用`xor`操作码：  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>