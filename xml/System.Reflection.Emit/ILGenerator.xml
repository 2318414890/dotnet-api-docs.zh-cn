<Type Name="ILGenerator" FullName="System.Reflection.Emit.ILGenerator">
  <TypeSignature Language="C#" Value="public class ILGenerator : System.Runtime.InteropServices._ILGenerator" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit ILGenerator extends System.Object implements class System.Runtime.InteropServices._ILGenerator" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.ILGenerator" />
  <TypeSignature Language="VB.NET" Value="Public Class ILGenerator&#xA;Implements _ILGenerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class ILGenerator : System::Runtime::InteropServices::_ILGenerator" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._ILGenerator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ILGenerator))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="0a3cb-101">生成 Microsoft 中间语言 (MSIL) 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-101">Generates Microsoft intermediate language (MSIL) instructions.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-102"><xref:System.Reflection.Emit.ILGenerator> 用于在动态程序集中生成的方法和构造函数的方法体 (由表示<xref:System.Reflection.Emit.MethodBuilder>和<xref:System.Reflection.Emit.ConstructorBuilder>类) 和独立动态方法 (由表示<xref:System.Reflection.Emit.DynamicMethod>类)。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-102"><xref:System.Reflection.Emit.ILGenerator> is used to generate method bodies for methods and constructors in dynamic assemblies (represented by the <xref:System.Reflection.Emit.MethodBuilder> and <xref:System.Reflection.Emit.ConstructorBuilder> classes) and for standalone dynamic methods (represented by the <xref:System.Reflection.Emit.DynamicMethod> class).</span></span> <span data-ttu-id="0a3cb-103">若要获取<xref:System.Reflection.Emit.ILGenerator>，使用<xref:System.Reflection.Emit.ConstructorBuilder.GetILGenerator%2A?displayProperty=nameWithType>， <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A?displayProperty=nameWithType>，和<xref:System.Reflection.Emit.MethodBuilder.GetILGenerator%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-103">To obtain an <xref:System.Reflection.Emit.ILGenerator>, use the <xref:System.Reflection.Emit.ConstructorBuilder.GetILGenerator%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Emit.MethodBuilder.GetILGenerator%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="0a3cb-104">MSIL 用作到实时 (JIT) 编译器的输入。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-104">MSIL is used as input to a just-in-time (JIT) compiler.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BeginCatchBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginCatchBlock (Type exceptionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginCatchBlock(class System.Type exceptionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginCatchBlock(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginCatchBlock (exceptionType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginCatchBlock(Type ^ exceptionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptionType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="exceptionType"><span data-ttu-id="0a3cb-105">表示异常的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-105">The <see cref="T:System.Type" /> object that represents the exception.</span></span></param>
        <summary><span data-ttu-id="0a3cb-106">开始 Catch 块。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-106">Begins a catch block.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-107">发出分支指令到当前的异常块的末尾。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-107">Emits a branch instruction to the end of the current exception block.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a3cb-108">如果筛选器异常块返回`constant exception_execute_handler`（请参阅常见的语言基础结构指令集的文档） 的自变量`BeginCatchBlock`未选中。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-108">If the filter exception block returns the `constant exception_execute_handler` (see the documentation for the Common Language Infrastructure Instruction Set), the argument to the `BeginCatchBlock` is not checked.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-109">下面的代码示例演示的上下文用法`BeginCatchBlock`方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-109">The code sample below demonstrates the contextual usage of the `BeginCatchBlock` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0a3cb-110">Catch 块在已筛选的异常中。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-110">The catch block is within a filtered exception.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a3cb-111"><paramref name="exceptionType" /> 为 <see langword="null" />，并且异常筛选器块没有返回一个值，该值指示在找到此 Catch 块之前应一直运行 Finally 块。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-111"><paramref name="exceptionType" /> is <see langword="null" />, and the exception filter block has not returned a value that indicates that finally blocks should be run until this catch block is located.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a3cb-112">要生成的 Microsoft 中间语言 (MSIL) 当前不在异常块中。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-112">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginExceptFilterBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginExceptFilterBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginExceptFilterBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginExceptFilterBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginExceptFilterBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginExceptFilterBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a3cb-113">开始已筛选异常的异常块。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-113">Begins an exception block for a filtered exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-114">发出分支指令到当前的异常块的末尾。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-114">Emits a branch instruction to the end of the current exception block.</span></span>  
  
 <span data-ttu-id="0a3cb-115">如果当前<xref:System.Reflection.Emit.ILGenerator>与关联<xref:System.Reflection.Emit.DynamicMethod>不支持对象，发出筛选后的异常块。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-115">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, emitting filtered exception blocks is not supported.</span></span> <span data-ttu-id="0a3cb-116"><xref:System.Reflection.Emit.DynamicILInfo> 可以用于构造使用筛选异常块的动态方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-116"><xref:System.Reflection.Emit.DynamicILInfo> can be used to construct a dynamic method that uses filtered exception blocks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a3cb-117">要生成的 Microsoft 中间语言 (MSIL) 当前不在异常块中。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-117">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</span></span>  
  
 <span data-ttu-id="0a3cb-118">或</span><span class="sxs-lookup"><span data-stu-id="0a3cb-118">-or-</span></span>  
  
 <span data-ttu-id="0a3cb-119">此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 属于某个 <see cref="T:System.Reflection.Emit.DynamicMethod" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-119">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginExceptionBlock">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.Label BeginExceptionBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.Emit.Label BeginExceptionBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginExceptionBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginExceptionBlock () As Label" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::Label BeginExceptionBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.Label</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a3cb-120">开始非筛选异常的异常块。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-120">Begins an exception block for a non-filtered exception.</span></span></summary>
        <returns><span data-ttu-id="0a3cb-121">块结尾的标签。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-121">The label for the end of the block.</span></span> <span data-ttu-id="0a3cb-122">这将使你停在正确的位置以执行 Finally 块或完成 Try 块。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-122">This will leave you in the correct place to execute finally blocks or to finish the try.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-123">创建的异常块记录一些信息，但不会实际发出任何的 Microsoft 中间语言 (MSIL) 流。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-123">Creating an exception block records some information, but does not actually emit any Microsoft intermediate language (MSIL) onto the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-124">下面的代码示例演示的上下文用法`BeginExceptionBlock`方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-124">The code sample below demonstrates the contextual usage of the `BeginExceptionBlock` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFaultBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginFaultBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFaultBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginFaultBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginFaultBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginFaultBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a3cb-125">在 Microsoft 中间语言 (MSIL) 流中开始一个异常错误块。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-125">Begins an exception fault block in the Microsoft intermediate language (MSIL) stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-126">如果当前<xref:System.Reflection.Emit.ILGenerator>与关联<xref:System.Reflection.Emit.DynamicMethod>不支持对象，发出异常错误块。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-126">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, emitting exception fault blocks is not supported.</span></span> <span data-ttu-id="0a3cb-127"><xref:System.Reflection.Emit.DynamicILInfo> 可用来构造一个使用异常错误块的动态方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-127"><xref:System.Reflection.Emit.DynamicILInfo> can be used to construct a dynamic method that uses exception fault blocks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-128">下面的代码示例演示如何使用`BeginFaultBlock`。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-128">The following code sample illustrates the use of `BeginFaultBlock`.</span></span>  
  
 [!code-cpp[ILGenerator_BeginFaultBlock#1](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/CPP/ilgenerator_beginfaultblock.cpp#1)]
 [!code-csharp[ILGenerator_BeginFaultBlock#1](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/CS/ilgenerator_beginfaultblock.cs#1)]
 [!code-vb[ILGenerator_BeginFaultBlock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/VB/ilgenerator_beginfaultblock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a3cb-129">生成的 MSIL 当前不在异常块中。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-129">The MSIL being generated is not currently in an exception block.</span></span>  
  
 <span data-ttu-id="0a3cb-130">或</span><span class="sxs-lookup"><span data-stu-id="0a3cb-130">-or-</span></span>  
  
 <span data-ttu-id="0a3cb-131">此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 属于某个 <see cref="T:System.Reflection.Emit.DynamicMethod" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-131">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFinallyBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginFinallyBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFinallyBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginFinallyBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginFinallyBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginFinallyBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a3cb-132">在 Microsoft 中间语言 (MSIL) 指令流中开始一个 Finally 块。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-132">Begins a finally block in the Microsoft intermediate language (MSIL) instruction stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a3cb-133">下面的代码示例演示如何使用`BeginFinallyBlock`。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-133">The following code sample illustrates the use of `BeginFinallyBlock`.</span></span>  
  
 [!code-cpp[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/CPP/ILGenerator_BeginFinallyBlock_2.cpp#2)]
 [!code-csharp[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/CS/ilgenerator_beginfinallyblock_2.cs#2)]
 [!code-vb[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/VB/ilgenerator_beginfinallyblock_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a3cb-134">生成的 MSIL 当前不在异常块中。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-134">The MSIL being generated is not currently in an exception block.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginScope">
      <MemberSignature Language="C#" Value="public virtual void BeginScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginScope();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a3cb-135">开始词法范围。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-135">Begins a lexical scope.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-136">此方法用于发出符号信息。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-136">This method is used to emit symbolic information.</span></span> <span data-ttu-id="0a3cb-137">声明后的本地变量<xref:System.Reflection.Emit.ILGenerator.BeginScope%2A>相应之前范围<xref:System.Reflection.Emit.ILGenerator.EndScope%2A>调用。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-137">Local variables declared after <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A> are scoped until the corresponding <xref:System.Reflection.Emit.ILGenerator.EndScope%2A> is called.</span></span>  
  
 <span data-ttu-id="0a3cb-138">如果当前<xref:System.Reflection.Emit.ILGenerator>与关联<xref:System.Reflection.Emit.DynamicMethod>对象，它不支持符号化信息。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-138">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, it does not support symbolic information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-139">下面的代码示例演示如何使用`BeginScope`和`EndScope`。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-139">The following code sample illustrates the use of `BeginScope` and `EndScope`.</span></span>  
  
 [!code-cpp[ILGenerator_Begin_EndScope#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CPP/ilgenerator_begin_endscope.cpp#2)]
 [!code-csharp[ILGenerator_Begin_EndScope#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CS/ilgenerator_begin_endscope.cs#2)]
 [!code-vb[ILGenerator_Begin_EndScope#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_Begin_EndScope/VB/ilgenerator_begin_endscope.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a3cb-140">此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 属于某个 <see cref="T:System.Reflection.Emit.DynamicMethod" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-140">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeclareLocal">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0a3cb-141">声明局部变量。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-141">Declares a local variable.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeclareLocal">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DeclareLocal(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeclareLocal (localType As Type) As LocalBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.LocalBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="localType"><span data-ttu-id="0a3cb-142">一个 <see cref="T:System.Type" /> 对象，表示局部变量的类型。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-142">A <see cref="T:System.Type" /> object that represents the type of the local variable.</span></span></param>
        <summary><span data-ttu-id="0a3cb-143">声明指定类型的局部变量。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-143">Declares a local variable of the specified type.</span></span></summary>
        <returns><span data-ttu-id="0a3cb-144">已声明的局部变量。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-144">The declared local variable.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-145">在当前词法范围内; 创建本地变量例如，如果代码发出`for`循环 (`For`在 Visual Basic 中的循环)，该变量的作用域是循环。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-145">The local variable is created in the current lexical scope; for example, if code is being emitted in a `for` loop (`For` loop in Visual Basic), the scope of the variable is the loop.</span></span>  
  
 <span data-ttu-id="0a3cb-146">使用此重载创建的本地变量不固定。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-146">A local variable created with this overload is not pinned.</span></span> <span data-ttu-id="0a3cb-147">若要使用非托管指针创建固定的变量以便使用，使用<xref:System.Reflection.Emit.ILGenerator.DeclareLocal%28System.Type%2CSystem.Boolean%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-147">To create a pinned variable for use with unmanaged pointers, use the <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%28System.Type%2CSystem.Boolean%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-148">下面的代码示例演示如何将`DeclareLocal`方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-148">The following code example demonstrates the use of the `DeclareLocal` method.</span></span> <span data-ttu-id="0a3cb-149">此代码的一个更大的代码示例摘自<xref:System.Reflection.Emit.LocalBuilder>类。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-149">This code is part of a larger code example for the <xref:System.Reflection.Emit.LocalBuilder> class.</span></span>  
  
 [!code-cpp[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/cpp/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/CPP/localbuilder_sample_4.cpp#2)]
 [!code-csharp[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/csharp/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/CS/localbuilder_sample_4.cs#2)]
 [!code-vb[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/VB/localbuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a3cb-150"><paramref name="localType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-150"><paramref name="localType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a3cb-151">包含类型已由 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法创建。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-151">The containing type has been created by the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeclareLocal">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType, bool pinned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DeclareLocal(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeclareLocal (localType As Type, pinned As Boolean) As LocalBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType, bool pinned);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.LocalBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localType" Type="System.Type" />
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="localType"><span data-ttu-id="0a3cb-152">一个 <see cref="T:System.Type" /> 对象，表示局部变量的类型。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-152">A <see cref="T:System.Type" /> object that represents the type of the local variable.</span></span></param>
        <param name="pinned">
          <span data-ttu-id="0a3cb-153">如果要将对象固定在内存中，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-153"><see langword="true" /> to pin the object in memory; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0a3cb-154">声明指定类型的局部变量，还可以选择固定该变量所引用的对象。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-154">Declares a local variable of the specified type, optionally pinning the object referred to by the variable.</span></span></summary>
        <returns><span data-ttu-id="0a3cb-155">一个 <see cref="T:System.Reflection.Emit.LocalBuilder" /> 对象，表示局部变量。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-155">A <see cref="T:System.Reflection.Emit.LocalBuilder" /> object that represents the local variable.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-156">在当前词法范围内; 创建本地变量例如，如果代码发出`for`循环 (`For`在 Visual Basic 中的循环)，该变量的作用域是循环。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-156">The local variable is created in the current lexical scope; for example, if code is being emitted in a `for` loop (`For` loop in Visual Basic), the scope of the variable is the loop.</span></span>  
  
 <span data-ttu-id="0a3cb-157">在不安全代码中，可以由非托管指针引用之前，必须固定对象。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-157">In unsafe code, an object must be pinned before it can be referred to by an unmanaged pointer.</span></span> <span data-ttu-id="0a3cb-158">被引用的对象已固定，而垃圾回收无法移动它。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-158">While the referenced object is pinned, it cannot be moved by garbage collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a3cb-159"><paramref name="localType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-159"><paramref name="localType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a3cb-160">包含类型已由 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法创建。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-160">The containing type has been created by the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span></span>  
  
 <span data-ttu-id="0a3cb-161">或</span><span class="sxs-lookup"><span data-stu-id="0a3cb-161">-or-</span></span>  
  
 <span data-ttu-id="0a3cb-162">封闭方法的方法体已由 <see cref="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" /> 方法创建。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-162">The method body of the enclosing method has been created by the <see cref="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" /> method.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a3cb-163">与此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 关联的方法不由 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 来表示。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-163">The method with which this <see cref="T:System.Reflection.Emit.ILGenerator" /> is associated is not represented by a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineLabel">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.Label DefineLabel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.Emit.Label DefineLabel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DefineLabel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DefineLabel () As Label" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::Label DefineLabel();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.Label</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a3cb-164">声明新标签。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-164">Declares a new label.</span></span></summary>
        <returns><span data-ttu-id="0a3cb-165">返回可用作分支令牌的新标签。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-165">Returns a new label that can be used as a token for branching.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-166">若要设置流中的标签的位置，你必须调用<xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-166">To set the position of the label within the stream, you must call <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.</span></span>  
  
 <span data-ttu-id="0a3cb-167">这只是一个标记，并不表示任何流内的特定位置。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-167">This is just a token and does not yet represent any particular location within the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-168">下面的代码示例演示的上下文用法`DefineLabel`方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-168">The code sample below demonstrates the contextual usage of the `DefineLabel` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.Label Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.Label Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.Label Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Emit">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0a3cb-169">将指令放到实时 (JIT) 编译器的 Microsoft 中间语言 (MSIL) 流上。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-169">Puts an instruction onto the Microsoft Intermediate Language (MSIL) stream for the just-in-time (JIT) compiler.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-170">要放到流上的 Microsoft 中间语言 (MSIL) 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-170">The Microsoft Intermediate Language (MSIL) instruction to be put onto the stream.</span></span></param>
        <summary><span data-ttu-id="0a3cb-171">将指定的指令放到指令流上。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-171">Puts the specified instruction onto the stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-172">如果`opcode`参数需要参数，调用方必须确保自变量长度与匹配的声明的参数的长度。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-172">If the `opcode` parameter requires an argument, the caller must ensure that the argument length matches the length of the declared parameter.</span></span> <span data-ttu-id="0a3cb-173">否则，结果将是不可预知的。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-173">Otherwise, results will be unpredictable.</span></span> <span data-ttu-id="0a3cb-174">例如，如果 Emit 指令需要一个 2 字节的操作数，并且调用方提供一个 4 字节的操作数，运行时将发出指令流到两个额外的字节。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-174">For example, if the Emit instruction requires a 2-byte operand and the caller supplies a 4-byte operand, the runtime will emit two additional bytes to the instruction stream.</span></span> <span data-ttu-id="0a3cb-175">这些额外字节将<xref:System.Reflection.Emit.OpCodes.Nop>说明。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-175">These extra bytes will be <xref:System.Reflection.Emit.OpCodes.Nop> instructions.</span></span>  
  
 <span data-ttu-id="0a3cb-176">在中定义的指令值<xref:System.Reflection.Emit.OpCodes>。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-176">The instruction values are defined in <xref:System.Reflection.Emit.OpCodes>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-177">下面的代码示例演示如何使用`Emit`以生成 MSIL 输出的实例通过<xref:System.Reflection.Emit.ILGenerator>。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-177">The code sample below demonstrates the use of `Emit` to generate MSIL output via an instance of <xref:System.Reflection.Emit.ILGenerator>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, byte arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, unsigned int8 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Byte arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-178">要放到流上的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-178">The MSIL instruction to be put onto the stream.</span></span></param>
        <param name="arg"><span data-ttu-id="0a3cb-179">紧接着该指令推到流中的字符参数。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-179">The character argument pushed onto the stream immediately after the instruction.</span></span></param>
        <summary><span data-ttu-id="0a3cb-180">将指定的指令和字符参数放到 Microsoft 中间语言 (MSIL) 指令流上。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-180">Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-181">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-181">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, double arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, float64 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, double arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-182">要放到流上的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-182">The MSIL instruction to be put onto the stream.</span></span> <span data-ttu-id="0a3cb-183">在 <see langword="OpCodes" /> 枚举中定义。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-183">Defined in the <see langword="OpCodes" /> enumeration.</span></span></param>
        <param name="arg"><span data-ttu-id="0a3cb-184">紧接着该指令推到流中的数字参数。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-184">The numerical argument pushed onto the stream immediately after the instruction.</span></span></param>
        <summary><span data-ttu-id="0a3cb-185">将指定的指令和数值参数放到 Microsoft 中间语言 (MSIL) 指令流上。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-185">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-186">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-186">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, short arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int16 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int16)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, short arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-187">要发出到流的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-187">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="arg"><span data-ttu-id="0a3cb-188">紧接着该指令推到流中的 <see langword="Int" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-188">The <see langword="Int" /> argument pushed onto the stream immediately after the instruction.</span></span></param>
        <summary><span data-ttu-id="0a3cb-189">将指定的指令和数值参数放到 Microsoft 中间语言 (MSIL) 指令流上。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-189">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-190">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-190">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, int arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int32 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, int arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-191">要放到流上的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-191">The MSIL instruction to be put onto the stream.</span></span></param>
        <param name="arg"><span data-ttu-id="0a3cb-192">紧接着该指令推到流中的数字参数。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-192">The numerical argument pushed onto the stream immediately after the instruction.</span></span></param>
        <summary><span data-ttu-id="0a3cb-193">将指定的指令和数值参数放到 Microsoft 中间语言 (MSIL) 指令流上。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-193">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-194">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-194">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, long arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int64 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, long arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-195">要放到流上的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-195">The MSIL instruction to be put onto the stream.</span></span></param>
        <param name="arg"><span data-ttu-id="0a3cb-196">紧接着该指令推到流中的数字参数。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-196">The numerical argument pushed onto the stream immediately after the instruction.</span></span></param>
        <summary><span data-ttu-id="0a3cb-197">将指定的指令和数值参数放到 Microsoft 中间语言 (MSIL) 指令流上。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-197">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-198">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-198">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.ConstructorInfo con);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.ConstructorInfo con) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::ConstructorInfo ^ con);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-199">要发出到流的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-199">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="con"><span data-ttu-id="0a3cb-200">表示构造函数的 <see langword="ConstructorInfo" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-200">A <see langword="ConstructorInfo" /> representing a constructor.</span></span></param>
        <summary><span data-ttu-id="0a3cb-201">将指定构造函数的指定指令和元数据令牌放到 Microsoft 中间语言 (MSIL) 指令流上。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-201">Puts the specified instruction and metadata token for the specified constructor onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-202">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-202">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="0a3cb-203">位置`con`记录，以便在指令流时可以进行修补如有必要将模块持续到可移植可执行 (PE) 文件。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-203">The location of `con` is recorded so that the instruction stream can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a3cb-204"><paramref name="con" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-204"><paramref name="con" /> is <see langword="null" />.</span></span> <span data-ttu-id="0a3cb-205">此异常是 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 中新出现的。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-205">This exception is new in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)].</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.Emit.Label label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::Label label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="label" Type="System.Reflection.Emit.Label" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-206">要发出到流的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-206">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="label"><span data-ttu-id="0a3cb-207">从此位置分支到的标签。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-207">The label to which to branch from this location.</span></span></param>
        <summary><span data-ttu-id="0a3cb-208">将指定的指令放到 Microsoft 中间语言 (MSIL) 流上，并留出在完成修正时加上标签所需的空白。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-208">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-209">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-209">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="0a3cb-210">使用创建标签<xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A>，并将流中的其位置通过使用固定<xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-210">Labels are created using <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A>, and their location within the stream is fixed by using <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.</span></span> <span data-ttu-id="0a3cb-211">如果使用单字节指令，则标签可以表示最多 127 个字节流的跳转。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-211">If a single-byte instruction is used, the label can represent a jump of at most 127 bytes along the stream.</span></span> <span data-ttu-id="0a3cb-212">`opcode` 必须表示分支指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-212">`opcode` must represent a branch instruction.</span></span> <span data-ttu-id="0a3cb-213">分支是相对的指令，因为`label`在修复过程将替换到分支的正确偏移量。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-213">Because branches are relative instructions, `label` will be replaced with the correct offset to branch during the fixup process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-214">下面的代码示例说明如何创建具有跳转表的动态方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-214">The code sample below illustrates the creation of a dynamic method with a jump table.</span></span> <span data-ttu-id="0a3cb-215">使用数组的生成跳转表<xref:System.Reflection.Emit.Label>。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-215">The jump table is built using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label[] labels);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.Emit.Label[] labels) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, cli::array &lt;System::Reflection::Emit::Label&gt; ^ labels);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="labels" Type="System.Reflection.Emit.Label[]" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-216">要发出到流的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-216">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="labels"><span data-ttu-id="0a3cb-217">从此位置分支到的标签对象的数组。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-217">The array of label objects to which to branch from this location.</span></span> <span data-ttu-id="0a3cb-218">将使用所有标签。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-218">All of the labels will be used.</span></span></param>
        <summary><span data-ttu-id="0a3cb-219">将指定的指令放到 Microsoft 中间语言 (MSIL) 流上，并留出在完成修正时加上标签所需的空白。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-219">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-220">发出开关表。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-220">Emits a switch table.</span></span>  
  
 <span data-ttu-id="0a3cb-221">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-221">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="0a3cb-222">使用创建标签<xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A>，并且它们将流内的位置通过使用固定<xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-222">Labels are created using <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> and their location within the stream is fixed by using <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.</span></span> <span data-ttu-id="0a3cb-223">如果使用单字节指令，则标签可以表示最多 127 个字节流的跳转。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-223">If a single-byte instruction is used, the label can represent a jump of at most 127 bytes along the stream.</span></span> <span data-ttu-id="0a3cb-224">`opcode` 必须表示分支指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-224">`opcode` must represent a branch instruction.</span></span> <span data-ttu-id="0a3cb-225">分支是相对的指令，因为`label`在修复过程将替换到分支的正确偏移量。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-225">Because branches are relative instructions, `label` will be replaced with the correct offset to branch during the fixup process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-226">下面的代码示例说明如何创建具有跳转表的动态方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-226">The code sample below illustrates the creation of a dynamic method with a jump table.</span></span> <span data-ttu-id="0a3cb-227">使用数组的生成跳转表<xref:System.Reflection.Emit.Label>。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-227">The jump table is built using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a3cb-228"><paramref name="con" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-228"><paramref name="con" /> is <see langword="null" />.</span></span> <span data-ttu-id="0a3cb-229">此异常是 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 中新出现的。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-229">This exception is new in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)].</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.LocalBuilder local);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.Emit.LocalBuilder local) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::LocalBuilder ^ local);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="local" Type="System.Reflection.Emit.LocalBuilder" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-230">要发出到流的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-230">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="local"><span data-ttu-id="0a3cb-231">局部变量。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-231">A local variable.</span></span></param>
        <summary><span data-ttu-id="0a3cb-232">将指定的指令放到 Microsoft 中间语言 (MSIL) 流上，后跟给定局部变量的索引。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-232">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the index of the given local variable.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-233">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-233">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0a3cb-234"><paramref name="local" /> 参数的父方法与此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 关联的方法不匹配。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-234">The parent method of the <paramref name="local" /> parameter does not match the method associated with this <see cref="T:System.Reflection.Emit.ILGenerator" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a3cb-235"><paramref name="local" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-235"><paramref name="local" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a3cb-236"><paramref name="opcode" /> 是单字节指令，并且 <paramref name="local" /> 表示索引大于 <see langword="Byte.MaxValue" /> 的局部变量。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-236"><paramref name="opcode" /> is a single-byte instruction, and <paramref name="local" /> represents a local variable with an index greater than <see langword="Byte.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.SignatureHelper signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.Emit.SignatureHelper signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::SignatureHelper ^ signature);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="signature" Type="System.Reflection.Emit.SignatureHelper" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-237">要发出到流的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-237">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="signature"><span data-ttu-id="0a3cb-238">用于构造签名令牌的帮助程序。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-238">A helper for constructing a signature token.</span></span></param>
        <summary><span data-ttu-id="0a3cb-239">将指定的指令和签名令牌放到 Microsoft 中间语言 (MSIL) 指令流上。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-239">Puts the specified instruction and a signature token onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-240">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-240">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a3cb-241"><paramref name="signature" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-241"><paramref name="signature" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::FieldInfo ^ field);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-242">要发出到流的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-242">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="field"><span data-ttu-id="0a3cb-243">表示字段的 <see langword="FieldInfo" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-243">A <see langword="FieldInfo" /> representing a field.</span></span></param>
        <summary><span data-ttu-id="0a3cb-244">将指定字段的指定指令和元数据令牌放到 Microsoft 中间语言 (MSIL) 指令流上。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-244">Puts the specified instruction and metadata token for the specified field onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-245">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-245">The instruction values are defined in the `OpCodes` enumeration.</span></span> <span data-ttu-id="0a3cb-246">位置`field`记录，以便在指令流时可以进行修补如有必要将模块持续到可移植可执行 (PE) 文件。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-246">The location of `field` is recorded so that the instruction stream can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo meth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo meth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ meth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="meth" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-247">要发出到流的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-247">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="meth"><span data-ttu-id="0a3cb-248">表示方法的 <see langword="MethodInfo" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-248">A <see langword="MethodInfo" /> representing a method.</span></span></param>
        <summary><span data-ttu-id="0a3cb-249">将指定的指令放到 Microsoft 中间语言 (MSIL) 流上，后跟给定方法的元数据令牌。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-249">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-250">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-250">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="0a3cb-251">位置`meth`记录，以便在指令流时可以进行修补如有必要将模块持续到可移植可执行 (PE) 文件。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-251">The location of `meth` is recorded so that the instruction stream can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 <span data-ttu-id="0a3cb-252">如果`meth`表示泛型方法，它必须是一个泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-252">If `meth` represents a generic method, it must be a generic method definition.</span></span> <span data-ttu-id="0a3cb-253">即，其[MethodInfo.IsGenericMethodDefinition](xref:System.Reflection.MethodBase.IsGenericMethodDefinition)属性必须为`true`。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-253">That is, its [MethodInfo.IsGenericMethodDefinition](xref:System.Reflection.MethodBase.IsGenericMethodDefinition) property must be `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a3cb-254"><paramref name="meth" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-254"><paramref name="meth" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="0a3cb-255"><paramref name="meth" /> 为泛型方法，其 <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> 属性为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-255"><paramref name="meth" /> is a generic method for which the <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public void Emit (System.Reflection.Emit.OpCode opcode, sbyte arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int8 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Emit(System::Reflection::Emit::OpCode opcode, System::SByte arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-256">要放到流上的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-256">The MSIL instruction to be put onto the stream.</span></span></param>
        <param name="arg"><span data-ttu-id="0a3cb-257">紧接着该指令推到流中的字符参数。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-257">The character argument pushed onto the stream immediately after the instruction.</span></span></param>
        <summary><span data-ttu-id="0a3cb-258">将指定的指令和字符参数放到 Microsoft 中间语言 (MSIL) 指令流上。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-258">Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-259">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-259">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, float arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, float32 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, float arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-260">要放到流上的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-260">The MSIL instruction to be put onto the stream.</span></span></param>
        <param name="arg"><span data-ttu-id="0a3cb-261">紧接着该指令推到流中的 <see langword="Single" /> 参数。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-261">The <see langword="Single" /> argument pushed onto the stream immediately after the instruction.</span></span></param>
        <summary><span data-ttu-id="0a3cb-262">将指定的指令和数值参数放到 Microsoft 中间语言 (MSIL) 指令流上。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-262">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-263">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-263">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-264">要发出到流的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-264">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="str"><span data-ttu-id="0a3cb-265">要发出的 <see langword="String" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-265">The <see langword="String" /> to be emitted.</span></span></param>
        <summary><span data-ttu-id="0a3cb-266">将指定的指令放到 Microsoft 中间语言 (MSIL) 流上，后跟给定字符串的元数据令牌。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-266">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given string.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-267">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-267">The instruction values are defined in the `OpCodes` enumeration.</span></span> <span data-ttu-id="0a3cb-268">位置`str`模块持续到可移植可执行 (PE) 文件时，为将来的修正记录。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-268">The location of `str` is recorded for future fixups if the module is persisted to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, Type cls);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Type cls) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, Type ^ cls);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="cls" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-269">要放到流上的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-269">The MSIL instruction to be put onto the stream.</span></span></param>
        <param name="cls"><span data-ttu-id="0a3cb-270"><see langword="Type" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-270">A <see langword="Type" />.</span></span></param>
        <summary><span data-ttu-id="0a3cb-271">将指定的指令放到 Microsoft 中间语言 (MSIL) 流上，后跟给定类型的元数据令牌。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-271">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-272">在中定义的指令值`OpCodes`枚举。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-272">The instruction values are defined in the `OpCodes` enumeration.</span></span> <span data-ttu-id="0a3cb-273">位置`cls`记录，以便在将模块持续到可移植可执行 (PE) 文件时可以对标记进行必要的修补。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-273">The location of `cls` is recorded so that the token can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a3cb-274"><paramref name="cls" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-274"><paramref name="cls" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EmitCall">
      <MemberSignature Language="C#" Value="public virtual void EmitCall (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo methodInfo, Type[] optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCall(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo methodInfo, class System.Type[] optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCall(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ methodInfo, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-275">要发出到流的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-275">The MSIL instruction to be emitted onto the stream.</span></span> <span data-ttu-id="0a3cb-276">必须为 <see cref="F:System.Reflection.Emit.OpCodes.Call" />、<see cref="F:System.Reflection.Emit.OpCodes.Callvirt" /> 或 <see cref="F:System.Reflection.Emit.OpCodes.Newobj" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-276">Must be <see cref="F:System.Reflection.Emit.OpCodes.Call" />, <see cref="F:System.Reflection.Emit.OpCodes.Callvirt" />, or <see cref="F:System.Reflection.Emit.OpCodes.Newobj" />.</span></span></param>
        <param name="methodInfo"><span data-ttu-id="0a3cb-277">要调用的 <see langword="varargs" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-277">The <see langword="varargs" /> method to be called.</span></span></param>
        <param name="optionalParameterTypes"><span data-ttu-id="0a3cb-278">如果方法是 <see langword="varargs" /> 方法，则为可选参数的类型；否则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-278">The types of the optional arguments if the method is a <see langword="varargs" /> method; otherwise, <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="0a3cb-279">将 <see langword="call" /> 或 <see langword="callvirt" /> 指令置于 Microsoft 中间语言 (MSIL) 流，以调用 <see langword="varargs" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-279">Puts a <see langword="call" /> or <see langword="callvirt" /> instruction onto the Microsoft intermediate language (MSIL) stream to call a <see langword="varargs" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-280"><xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>方法用于发出调用`varargs`方法的重载均不是<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法，它指定变量的自变量的参数类型。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-280">The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is used to emit calls to `varargs` methods because there is no overload of the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method that specifies the parameter types of the variable arguments.</span></span>  
  
 <span data-ttu-id="0a3cb-281">发出对不使用的方法的调用<xref:System.Reflection.CallingConventions.VarArgs>调用约定，使用<xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-281">To emit calls to methods that do not use the <xref:System.Reflection.CallingConventions.VarArgs> calling convention, use the <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29> method overload.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="0a3cb-282">版本信息</span><span class="sxs-lookup"><span data-stu-id="0a3cb-282">Version Information</span></span>  
 <span data-ttu-id="0a3cb-283">从.NET Framework 2.0 版中，开始<xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>方法不会引发异常的方法，不是为指定可选的参数类型时`varargs`。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-283">Beginning with the .NET Framework version 2.0, the <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method does not throw an exception when optional parameter types are specified for a method that is not `varargs`.</span></span> <span data-ttu-id="0a3cb-284"><xref:System.InvalidProgramException> 执行调用时引发。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-284"><xref:System.InvalidProgramException> is thrown when the call is executed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-285">下面的代码示例发出两种方法，`varargs`方法和方法调用`varargs`方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-285">The following code example emits two methods, a `varargs` method and a method that calls the `varargs` method.</span></span> <span data-ttu-id="0a3cb-286">`EmitCall`方法用于发出调用`varargs`方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-286">The `EmitCall` method is used to emit the call to the `varargs` method.</span></span>  
  
 [!code-cpp[Emit.ArgIterator#1](~/samples/snippets/cpp/VS_Snippets_CLR/Emit.ArgIterator/cpp/source.cpp#1)]
 [!code-csharp[Emit.ArgIterator#1](~/samples/snippets/csharp/VS_Snippets_CLR/Emit.ArgIterator/cs/source.cs#1)]
 [!code-vb[Emit.ArgIterator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Emit.ArgIterator/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a3cb-287"><paramref name="opcode" /> 未指定方法调用。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-287"><paramref name="opcode" /> does not specify a method call.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a3cb-288"><paramref name="methodInfo" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-288"><paramref name="methodInfo" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a3cb-289">该方法的调用约定不是 <see langword="varargs" />，但提供可选的参数类型。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-289">The calling convention for the method is not <see langword="varargs" />, but optional parameter types are supplied.</span></span> <span data-ttu-id="0a3cb-290">.NET Framework 版本 1.0 和 1.1 中会引发此异常，后续版本中不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-290">This exception is thrown in the .NET Framework versions 1.0 and 1.1, In subsequent versions, no exception is thrown.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EmitCalli">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0a3cb-291">将 <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> 指令放到 Microsoft 中间语言 (MSIL) 流上。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-291">Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EmitCalli">
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Runtime.InteropServices.CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Runtime.InteropServices.CallingConvention unmanagedCallConv, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Runtime::InteropServices::CallingConvention unmanagedCallConv, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="unmanagedCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-292">要发出到流的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-292">The MSIL instruction to be emitted onto the stream.</span></span> <span data-ttu-id="0a3cb-293">必须为 <see cref="F:System.Reflection.Emit.OpCodes.Calli" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-293">Must be <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</span></span></param>
        <param name="unmanagedCallConv"><span data-ttu-id="0a3cb-294">要使用的非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-294">The unmanaged calling convention to be used.</span></span></param>
        <param name="returnType"><span data-ttu-id="0a3cb-295">结果的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-295">The <see cref="T:System.Type" /> of the result.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="0a3cb-296">指令的必选参数的类型。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-296">The types of the required arguments to the instruction.</span></span></param>
        <summary><span data-ttu-id="0a3cb-297">将 <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> 指令放到 Microsoft 中间语言 (MSIL) 流，并指定间接调用的非托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-297">Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream, specifying an unmanaged calling convention for the indirect call.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-298">使用<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>将<xref:System.Reflection.Emit.OpCodes.Calli>指令放到流。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-298">Use <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> to put a <xref:System.Reflection.Emit.OpCodes.Calli> instruction onto the stream.</span></span> <span data-ttu-id="0a3cb-299">不要使用 <xref:System.Reflection.Emit.ILGenerator.Emit%2A>。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-299">Do not use <xref:System.Reflection.Emit.ILGenerator.Emit%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-300">下面的代码示例演示的上下文用法<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>方法调用非托管的类型方法动态类的外部。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-300">The following code sample demonstrates the contextual usage of the <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> method to call an unmanaged type method external to the dynamic class.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmitCalli">
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type[] optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="optionalParameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="0a3cb-301">要发出到流的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-301">The MSIL instruction to be emitted onto the stream.</span></span> <span data-ttu-id="0a3cb-302">必须为 <see cref="F:System.Reflection.Emit.OpCodes.Calli" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-302">Must be <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="0a3cb-303">要使用的托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-303">The managed calling convention to be used.</span></span></param>
        <param name="returnType"><span data-ttu-id="0a3cb-304">结果的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-304">The <see cref="T:System.Type" /> of the result.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="0a3cb-305">指令的必选参数的类型。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-305">The types of the required arguments to the instruction.</span></span></param>
        <param name="optionalParameterTypes"><span data-ttu-id="0a3cb-306"><see langword="varargs" /> 调用的可选参数的类型。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-306">The types of the optional arguments for <see langword="varargs" /> calls.</span></span></param>
        <summary><span data-ttu-id="0a3cb-307">将 <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> 指令放到 Microsoft 中间语言 (MSIL) 流，并指定间接调用的托管调用约定。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-307">Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream, specifying a managed calling convention for the indirect call.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-308">使用<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>将<xref:System.Reflection.Emit.OpCodes.Calli>指令放到流。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-308">Use <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> to put a <xref:System.Reflection.Emit.OpCodes.Calli> instruction onto the stream.</span></span> <span data-ttu-id="0a3cb-309">不要使用 <xref:System.Reflection.Emit.ILGenerator.Emit%2A>。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-309">Do not use <xref:System.Reflection.Emit.ILGenerator.Emit%2A>.</span></span>  
  
 <span data-ttu-id="0a3cb-310">如果`optionalParameterTypes`指定可选参数，`callingConvention`必须包括<xref:System.Reflection.CallingConventions.VarArgs?displayProperty=nameWithType>标志。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-310">If `optionalParameterTypes` specifies optional arguments, `callingConvention` must include the <xref:System.Reflection.CallingConventions.VarArgs?displayProperty=nameWithType> flag.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a3cb-311"><paramref name="optionalParameterTypes" /> 不为 <see langword="null" />，但 <paramref name="callingConvention" /> 不包括 <see cref="F:System.Reflection.CallingConventions.VarArgs" /> 标志。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-311"><paramref name="optionalParameterTypes" /> is not <see langword="null" />, but <paramref name="callingConvention" /> does not include the <see cref="F:System.Reflection.CallingConventions.VarArgs" /> flag.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EmitWriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0a3cb-312">使用不同类型的值发出对 <see cref="M:System.Console.WriteLine" /> 的调用的 Helper 函数。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-312">Helper functions to emit a call to <see cref="M:System.Console.WriteLine" /> with different types of values.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (System.Reflection.Emit.LocalBuilder localBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(class System.Reflection.Emit.LocalBuilder localBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.Reflection.Emit.LocalBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::Reflection::Emit::LocalBuilder ^ localBuilder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localBuilder" Type="System.Reflection.Emit.LocalBuilder" />
      </Parameters>
      <Docs>
        <param name="localBuilder"><span data-ttu-id="0a3cb-313">其值将写入控制台的本地变量。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-313">The local variable whose value is to be written to the console.</span></span></param>
        <summary><span data-ttu-id="0a3cb-314">发出使用给定本地变量调用 <see cref="Overload:System.Console.WriteLine" /> 时必需的 Microsoft 中间语言 (MSIL)。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-314">Emits the Microsoft intermediate language (MSIL) necessary to call <see cref="Overload:System.Console.WriteLine" /> with the given local variable.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-315">一种`localBuilder`必须匹配的重载的参数类型<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-315">The type of `localBuilder` must match the parameter type of an overload of the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-316">下面的代码示例演示的上下文用法<xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A>方法以向动态方法中的控制台写入一个字符串。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-316">The code sample below demonstrates the contextual usage of the <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> method to write a string to the console in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0a3cb-317"><paramref name="localBuilder" /> 的类型是不受支持的 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.EnumBuilder" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-317">The type of <paramref name="localBuilder" /> is <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.EnumBuilder" />, which are not supported.</span></span>  
  
 <span data-ttu-id="0a3cb-318">或</span><span class="sxs-lookup"><span data-stu-id="0a3cb-318">-or-</span></span>  
  
 <span data-ttu-id="0a3cb-319">没有 <see cref="Overload:System.Console.WriteLine" /> 的重载接受 <paramref name="localBuilder" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-319">There is no overload of <see cref="Overload:System.Console.WriteLine" /> that accepts the type of <paramref name="localBuilder" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a3cb-320"><paramref name="localBuilder" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-320"><paramref name="localBuilder" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (System.Reflection.FieldInfo fld);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(class System.Reflection.FieldInfo fld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitWriteLine (fld As FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::Reflection::FieldInfo ^ fld);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fld" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="fld"><span data-ttu-id="0a3cb-321">其值将写入控制台的字段。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-321">The field whose value is to be written to the console.</span></span></param>
        <summary><span data-ttu-id="0a3cb-322">发出用给定字段调用 <see cref="Overload:System.Console.WriteLine" /> 所需的 Microsoft 中间语言 (MSIL)。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-322">Emits the Microsoft intermediate language (MSIL) necessary to call <see cref="Overload:System.Console.WriteLine" /> with the given field.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-323">一种`fld`必须匹配的重载的参数类型<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-323">The type of `fld` must match the parameter type of an overload of the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-324">下面的代码示例演示如何使用<xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A>方法以向动态方法中的控制台写入一个字符串。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-324">The following code sample demonstrates the use of the <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> method to write a string to the console in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0a3cb-325">不存在接受指定字段类型的 <see cref="Overload:System.Console.WriteLine" /> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-325">There is no overload of the <see cref="Overload:System.Console.WriteLine" /> method that accepts the type of the specified field.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a3cb-326"><paramref name="fld" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-326"><paramref name="fld" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a3cb-327">字段类型为 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.EnumBuilder" />，这两种类型都不受支持。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-327">The type of the field is <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.EnumBuilder" />, which are not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitWriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="0a3cb-328">要打印的字符串。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-328">The string to be printed.</span></span></param>
        <summary><span data-ttu-id="0a3cb-329">发出 Microsoft 中间语言 (MSIL) 以用字符串调用 <see cref="Overload:System.Console.WriteLine" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-329">Emits the Microsoft intermediate language (MSIL) to call <see cref="Overload:System.Console.WriteLine" /> with a string.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-330">字符串必须已定义。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-330">The string must have already been defined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-331">下面的代码示例演示的上下文用法`EmitWriteLine`方法以向动态方法中的控制台写入一个字符串。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-331">The code sample below demonstrates the contextual usage of the `EmitWriteLine` method to write a string to the console in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndExceptionBlock">
      <MemberSignature Language="C#" Value="public virtual void EndExceptionBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndExceptionBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EndExceptionBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndExceptionBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndExceptionBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a3cb-332">结束异常块。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-332">Ends an exception block.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a3cb-333">下面的代码示例演示的上下文用法`EndExceptionBlock`方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-333">The code sample below demonstrates the contextual usage of the `EndExceptionBlock` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a3cb-334">结束异常块在代码流中的意外位置出现。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-334">The end exception block occurs in an unexpected place in the code stream.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a3cb-335">要生成的 Microsoft 中间语言 (MSIL) 当前不在异常块中。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-335">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndScope">
      <MemberSignature Language="C#" Value="public virtual void EndScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EndScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndScope();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a3cb-336">结束词法范围。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-336">Ends a lexical scope.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-337">此方法用于发出符号信息。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-337">This method is used to emit symbolic information.</span></span> <span data-ttu-id="0a3cb-338">它用于<xref:System.Reflection.Emit.ILGenerator.BeginScope%2A>。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-338">It is used with <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A>.</span></span>  
  
 <span data-ttu-id="0a3cb-339">如果当前<xref:System.Reflection.Emit.ILGenerator>与关联<xref:System.Reflection.Emit.DynamicMethod>对象，它不支持符号化信息。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-339">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, it does not support symbolic information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-340">下面的代码示例演示如何使用`BeginScope`和`EndScope`。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-340">The following code sample illustrates the use of `BeginScope` and `EndScope`.</span></span>  
  
 [!code-cpp[ILGenerator_Begin_EndScope#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CPP/ilgenerator_begin_endscope.cpp#2)]
 [!code-csharp[ILGenerator_Begin_EndScope#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CS/ilgenerator_begin_endscope.cs#2)]
 [!code-vb[ILGenerator_Begin_EndScope#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_Begin_EndScope/VB/ilgenerator_begin_endscope.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a3cb-341">此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 属于某个 <see cref="T:System.Reflection.Emit.DynamicMethod" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-341">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ILOffset">
      <MemberSignature Language="C#" Value="public virtual int ILOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ILOffset" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ILGenerator.ILOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ILOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ILOffset { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0a3cb-342">获取由 <see cref="T:System.Reflection.Emit.ILGenerator" /> 发出的 Microsoft 中间语言 (MSIL) 流中的当前偏移量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-342">Gets the current offset, in bytes, in the Microsoft intermediate language (MSIL) stream that is being emitted by the <see cref="T:System.Reflection.Emit.ILGenerator" />.</span></span></summary>
        <value><span data-ttu-id="0a3cb-343">MSIL 流中的偏移量，将在此处发出下一个指令。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-343">The offset in the MSIL stream at which the next instruction will be emitted.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-344">此方法是透明的并可以从部分受信任代码调用。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-344">This method is transparent, and can be called from partially trusted code.</span></span>  
  
 <span data-ttu-id="0a3cb-345">如果<xref:System.Reflection.Emit.ILGenerator.ILOffset%2A>之前已发出任何 MSIL 指令访问属性，它将返回 0 （零）。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-345">If the <xref:System.Reflection.Emit.ILGenerator.ILOffset%2A> property is accessed before any MSIL instructions have been emitted, it returns 0 (zero).</span></span>  
  
 <span data-ttu-id="0a3cb-346">当动态语言生成 MSIL 时，此属性可以用于将 MSIL 流中的偏移量映射到源代码行号。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-346">When MSIL is generated for dynamic languages, this property can be used to map offsets in the MSIL stream to source code line numbers.</span></span> <span data-ttu-id="0a3cb-347">所生成的信息可以用于引发异常时提供堆栈跟踪。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-347">The resulting information can be used to provide stack traces when exceptions are thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkLabel">
      <MemberSignature Language="C#" Value="public virtual void MarkLabel (System.Reflection.Emit.Label loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkLabel(valuetype System.Reflection.Emit.Label loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MarkLabel (loc As Label)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MarkLabel(System::Reflection::Emit::Label loc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loc" Type="System.Reflection.Emit.Label" />
      </Parameters>
      <Docs>
        <param name="loc"><span data-ttu-id="0a3cb-348">为其设置索引的标签。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-348">The label for which to set an index.</span></span></param>
        <summary><span data-ttu-id="0a3cb-349">用给定标签标记 Microsoft 中间语言 (MSIL) 流的当前位置。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-349">Marks the Microsoft intermediate language (MSIL) stream's current position with the given label.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-350">标签不能定义不止一次。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-350">A label cannot be defined more than once.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a3cb-351">下面的代码示例演示的上下文用法`MarkLabel`来实现分支中的动态方法的 MSIL。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-351">The code sample below demonstrates the contextual usage of `MarkLabel` to implement MSIL branching in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a3cb-352"><paramref name="loc" /> 表示标签数组中的无效索引。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-352"><paramref name="loc" /> represents an invalid index into the label array.</span></span>  
  
 <span data-ttu-id="0a3cb-353">或</span><span class="sxs-lookup"><span data-stu-id="0a3cb-353">-or-</span></span>  
  
 <span data-ttu-id="0a3cb-354">已定义 <paramref name="loc" /> 的索引。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-354">An index for <paramref name="loc" /> has already been defined.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MarkSequencePoint">
      <MemberSignature Language="C#" Value="public virtual void MarkSequencePoint (System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkSequencePoint(class System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MarkSequencePoint (document As ISymbolDocumentWriter, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MarkSequencePoint(System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document"><span data-ttu-id="0a3cb-355">为其定义序列点的文档。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-355">The document for which the sequence point is being defined.</span></span></param>
        <param name="startLine"><span data-ttu-id="0a3cb-356">序列点开始的行。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-356">The line where the sequence point begins.</span></span></param>
        <param name="startColumn"><span data-ttu-id="0a3cb-357">序列点开始的行中的列。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-357">The column in the line where the sequence point begins.</span></span></param>
        <param name="endLine"><span data-ttu-id="0a3cb-358">序列点结束的行。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-358">The line where the sequence point ends.</span></span></param>
        <param name="endColumn"><span data-ttu-id="0a3cb-359">序列点结束的行中的列。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-359">The column in the line where the sequence point ends.</span></span></param>
        <summary><span data-ttu-id="0a3cb-360">在 Microsoft 中间语言 (MSIL) 流中标记序列点。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-360">Marks a sequence point in the Microsoft intermediate language (MSIL) stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-361">行号是从 1 开始索引。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-361">Line numbers are indexed from 1.</span></span> <span data-ttu-id="0a3cb-362">列被索引为 0。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-362">Columns are indexed from 0.</span></span>  
  
 <span data-ttu-id="0a3cb-363">符号化信息通常包括每个源行的至少一个 MSIL 偏移量。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-363">The symbolic information normally includes at least one MSIL offset for each source line.</span></span> <span data-ttu-id="0a3cb-364">当实时 (JIT) 编译器要编译方法时，它会请求分析服务提供应保留的 MSIL 偏移量列表。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-364">When the just-in-time (JIT) compiler is about to compile a method, it asks the profiling services for a list of MSIL offsets that should be preserved.</span></span> <span data-ttu-id="0a3cb-365">这些 MSIL 偏移量称为*序列点*。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-365">These MSIL offsets are called *sequence points*.</span></span>  
  
 <span data-ttu-id="0a3cb-366">如果当前<xref:System.Reflection.Emit.ILGenerator>与关联<xref:System.Reflection.Emit.DynamicMethod>对象，它不支持符号化信息。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-366">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, it does not support symbolic information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a3cb-367"><paramref name="startLine" /> 或 <paramref name="endLine" /> 为 &lt;= 0。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-367"><paramref name="startLine" /> or <paramref name="endLine" /> is &lt;= 0.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a3cb-368">此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 属于某个 <see cref="T:System.Reflection.Emit.DynamicMethod" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-368">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _ILGenerator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_ILGenerator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="0a3cb-369">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-369">Reserved for future use.</span></span> <span data-ttu-id="0a3cb-370">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-370">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="0a3cb-371">要映射的名称的传入数组。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-371">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="0a3cb-372">要映射的名称的计数。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-372">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="0a3cb-373">要在其中解释名称的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-373">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="0a3cb-374">调用方分配的数组，用于接收与名称对应的 ID。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-374">Caller-allocated array that receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="0a3cb-375">将一组名称映射为对应的一组调度标识符。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-375">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-376">此方法是用于从非托管代码，访问托管的类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-376">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="0a3cb-377">有关详细信息`IDispatch::GetIDsOfNames`，请参阅 MSDN 库。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-377">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="0a3cb-378">此方法称为使用 COM <c>IDispatch</c> 接口的后期绑定。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-378">The method is called late-bound using the COM <c>IDispatch</c> interface.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _ILGenerator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_ILGenerator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="0a3cb-379">要返回的类型信息。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-379">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="0a3cb-380">类型信息的区域设置标识符。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-380">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="0a3cb-381">接收一个指针，指向请求的类型信息对象。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-381">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="0a3cb-382">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-382">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-383">此方法是用于从非托管代码，访问托管的类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-383">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="0a3cb-384">有关详细信息`IDispatch::GetTypeInfo`，请参阅 MSDN 库。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-384">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="0a3cb-385">此方法称为使用 COM <c>IDispatch</c> 接口的后期绑定。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-385">The method is called late-bound using the COM <c>IDispatch</c> interface.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _ILGenerator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_ILGenerator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="0a3cb-386">指向一个位置，该位置接收对象提供的类型信息接口的数量。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-386">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="0a3cb-387">检索对象提供的类型信息接口的数量（0 或 1）。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-387">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-388">此方法是用于从非托管代码，访问托管的类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-388">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="0a3cb-389">有关详细信息`IDispatch::GetTypeInfoCount`，请参阅 MSDN 库。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-389">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="0a3cb-390">此方法称为使用 COM <c>IDispatch</c> 接口的后期绑定。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-390">The method is called late-bound using the COM <c>IDispatch</c> interface.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.Invoke">
      <MemberSignature Language="C#" Value="void _ILGenerator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _ILGenerator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_ILGenerator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="0a3cb-391">标识成员。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-391">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="0a3cb-392">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-392">Reserved for future use.</span></span> <span data-ttu-id="0a3cb-393">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-393">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="0a3cb-394">要在其中解释参数的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-394">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="0a3cb-395">描述调用的上下文的标志。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-395">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="0a3cb-396">指向一个结构的指针，该结构包含一个自变量数组、一个命名自变量的 DISPID 自变量数组和数组中元素数的计数。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-396">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="0a3cb-397">指向要存储结果的位置的指针。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-397">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="0a3cb-398">指向一个包含异常信息的结构的指针。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-398">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="0a3cb-399">第一个出错自变量的索引。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-399">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="0a3cb-400">提供对某一对象公开的属性和方法的访问。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-400">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-401">此方法是用于从非托管代码，访问托管的类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-401">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="0a3cb-402">有关详细信息`IDispatch::Invoke`，请参阅 MSDN 库。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-402">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="0a3cb-403">此方法称为使用 COM <c>IDispatch</c> 接口的后期绑定。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-403">The method is called late-bound using the COM <c>IDispatch</c> interface.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowException">
      <MemberSignature Language="C#" Value="public virtual void ThrowException (Type excType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ThrowException(class System.Type excType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.ThrowException(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ThrowException (excType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ThrowException(Type ^ excType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="excType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="excType"><span data-ttu-id="0a3cb-404">要引发的异常类型的类。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-404">The class of the type of exception to throw.</span></span></param>
        <summary><span data-ttu-id="0a3cb-405">发出指令以引发异常。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-405">Emits an instruction to throw an exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0a3cb-406">下面的代码示例演示的上下文用法`ThrowException`引发的一种动态方法的 msil 异常。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-406">The following code sample demonstrates the contextual usage of `ThrowException` to throw an exception inside the MSIL of a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a3cb-407"><paramref name="excType" /> 不是 <see cref="T:System.Exception" /> 类或 <see cref="T:System.Exception" /> 的派生类。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-407"><paramref name="excType" /> is not the <see cref="T:System.Exception" /> class or a derived class of <see cref="T:System.Exception" />.</span></span>  
  
 <span data-ttu-id="0a3cb-408">或</span><span class="sxs-lookup"><span data-stu-id="0a3cb-408">-or-</span></span>  
  
 <span data-ttu-id="0a3cb-409">此类型没有默认的构造函数。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-409">The type does not have a default constructor.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a3cb-410"><paramref name="excType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-410"><paramref name="excType" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UsingNamespace">
      <MemberSignature Language="C#" Value="public virtual void UsingNamespace (string usingNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UsingNamespace(string usingNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.UsingNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UsingNamespace (usingNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UsingNamespace(System::String ^ usingNamespace);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usingNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="usingNamespace"><span data-ttu-id="0a3cb-411">用于计算当前活动词法范围的局部变量和监视值的命名空间</span><span class="sxs-lookup"><span data-stu-id="0a3cb-411">The namespace to be used in evaluating locals and watches for the current active lexical scope</span></span></param>
        <summary><span data-ttu-id="0a3cb-412">指定用于计算当前活动词法范围的局部变量和监视值的命名空间。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-412">Specifies the namespace to be used in evaluating locals and watches for the current active lexical scope.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a3cb-413">如果当前<xref:System.Reflection.Emit.ILGenerator>与关联<xref:System.Reflection.Emit.DynamicMethod>对象，不支持此方法。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-413">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, this method is not supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0a3cb-414"><paramref name="usingNamespace" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-414">Length of <paramref name="usingNamespace" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a3cb-415"><paramref name="usingNamespace" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-415"><paramref name="usingNamespace" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a3cb-416">此 <see cref="T:System.Reflection.Emit.ILGenerator" /> 属于某个 <see cref="T:System.Reflection.Emit.DynamicMethod" />。</span><span class="sxs-lookup"><span data-stu-id="0a3cb-416">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>