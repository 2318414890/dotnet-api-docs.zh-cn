<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="337c0dfc53fd303d550b5b9161734953e0f07c58" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36469944" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>定义并表示可以编译、执行和丢弃的一种动态方法。 丢弃的方法可用于垃圾回收。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用<xref:System.Reflection.Emit.DynamicMethod>类进行生成并在运行时，执行一种方法，而无需生成动态程序集和一个动态类型，以包含方法。 回收由实时 (JIT) 编译器创建的可执行代码时<xref:System.Reflection.Emit.DynamicMethod>回收对象。 动态方法是代码的生成和执行少量的最有效方式。  
  
 可以匿名托管的动态方法，也可以是逻辑上相关联的模块或类型。  
  
-   如果匿名托管的动态方法，它位于系统提供的程序集，并因此是独立于其他代码。 默认情况下，它没有访问的任何非公共数据。 匿名托管的动态方法可以具有受限制地跳过 JIT 编译器的可见性检查，如果它已被授予<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标志。 动态方法访问其非公共成员的程序集的信任级别必须等于或其子集发出动态方法的调用堆栈的信任级别。 有关匿名托管的动态方法的详细信息，请参阅[演练： 在部分信任方案中发出代码](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)。  
  
-   如果动态方法与你指定的模块关联，则动态方法是该模块在全局范围内有效。 它可以访问该模块中的所有类型和所有`internal`(`Friend`在 Visual Basic 中) 的类型的成员。 你可以将关联动态方法与任何模块，无论是否创建了该模块，提供程序的要求<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>标志可以通过包括你的代码的调用堆栈来满足。 如果<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>标志包括在授权后，该动态方法可以跳过 JIT 编译器的可见性检查并访问所有类型声明为模块中或任何程序集中的任何其他模块中的私有数据。  
  
    > [!NOTE]
    >  当指定动态方法与之关联的模块时，该模块不能用于匿名承载的系统提供程序集中。  
  
-   如果动态方法与你指定的类型相关联，它将有权访问的类型，所有成员，无论访问级别。 此外，可以跳过 JIT 可见性检查。 这为在相同的模块或任何程序集中的任何其他模块中声明其他类型的专用数据提供动态方法访问。 你可以使用任何类型，关联的动态方法，但你的代码必须获得<xref:System.Security.Permissions.ReflectionPermission>两种版本同时<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>和<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess>标志。  
  
 下表显示哪些类型和成员都是可供匿名托管的动态方法，而无需 JIT 可见性检查，具体取决于是否与访问<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>授予标志。  
  
||不带 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|通过 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|  
|-|-|-|  
|不要跳过 JIT 可见性检查|任何程序集中的公共类型的公共成员。|任何程序集中的公共类型的公共成员。|  
|正在跳过 JIT 可见性检查，但存在限制|任何程序集中的公共类型的公共成员。|所有类型，仅在其信任级别都等于或小于发出动态方法的程序集的信任级别的程序集中的所有成员。|  
  
> [!NOTE]
>  之前[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，发出所需代码<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>标志。 默认情况下，在 FullTrust 和称为权限集，包括此权限，但不是在 Internet 权限集。 因此，在早期版本的[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]库可以用于 Internet 权限，只有在它<xref:System.Security.SecurityCriticalAttribute>特性且还执行<xref:System.Security.PermissionSet.Assert%2A>为<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>。 这种库需要进行仔细的安全检查，因为编码错误可能会导致安全漏洞。 [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] 允许以部分信任形式发出代码而无需发出任何安全请求，因为生成代码本身不是一项特权操作。 也就是说，生成的代码不会具有比发出它的程序集更多的权限。 这使得发出代码的库是安全透明的，且不再需要断言 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>，这简化了编写安全库任务。 若要使用此功能，你的应用程序应面向[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]或更高版本。  
  
 下表显示哪些类型和成员都可以访问与模块或使用模块中的类型相关联的动态方法。  
  
||与模块关联|与类型关联|  
|-|-|-|  
|不要跳过 JIT 可见性检查|模块中的公共、 内部和私有类型的公共和内部成员。<br /><br /> 任何程序集中的公共类型的公共成员。|关联的类型的所有成员。 模块中的所有其他类型的公共和内部成员。<br /><br /> 任何程序集中的公共类型的公共成员。|  
|正在跳过 JIT 可见性检查|任何程序集中的所有类型的所有成员。|任何程序集中的所有类型的所有成员。|  
  
 与模块相关联的动态方法具有该模块的权限。 与类型关联的动态方法具有包含该类型的模块的权限。  
  
 动态方法和其参数不需要进行命名，但你可以指定名称以协助调试。 对动态方法或其参数不支持自定义属性。  
  
 动态方法虽然`static`方法 (`Shared`在 Visual Basic 中的方法)，则为的委托绑定中引入宽松规则[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]允许绑定到一个对象，对象的动态方法，以便其行为类似于实例方法时使用该委托实例调用。 示例演示这一操作，提供有关<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>方法重载。  
  
> [!NOTE]
>  在[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，动态方法不支持所符号信息、 本地变量的名称和行号映射。 可能的未来版本中取消此限制。 你可以使用<xref:System.Reflection.Emit.AssemblyBuilder>开发简化调试生成的 Microsoft 中间语言 (MSIL)，并切换至动态方法最终在部署期间，因为期间<xref:System.Reflection.Emit.ILGenerator>调用是这两个用例中相同。  
  
## <a name="verification"></a>确认  
 以下列表总结了在其下动态方法包含无法验证的代码的条件。 (例如，一个动态方法是无法验证如果其<xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A>属性设置为`false`。)  
  
-   与安全关键的程序集关联的动态方法也是安全关键的并且可以跳过验证。 例如，由运行时没有安全属性作为桌面应用程序运行的程序集被处理为安全关键。 如果将动态方法与程序集相关联，动态方法可包含无法验证的代码。  
  
-   如果动态方法包含无法验证的代码与具有 1 级透明度的程序集关联，在实时 (JIT) 编译器将插入的安全要求。 仅当完全受信任的代码执行动态方法时，要求成功。 请参阅[安全透明的代码，级别 1](~/docs/framework/misc/security-transparent-code-level-1.md)。  
  
-   如果动态方法包含无法验证的代码与具有 2 级透明度 （如 mscorlib.dll) 的程序集关联，它将引发异常 （由 JIT 编译器插入），而不是进行安全要求。 请参阅[安全透明的代码，级别 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
-   匿名承载的动态方法始终包含无法验证的代码引发异常。 它可以永远不会跳过验证，，即使它是创建和执行由完全受信任的代码。  
  
 无法验证的代码时引发的异常而异调用动态方法的方式。 如果调用动态方法使用从返回委托<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法，<xref:System.Security.VerificationException>引发。 如果通过使用调用该动态方法<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法，<xref:System.Reflection.TargetInvocationException>引发内部<xref:System.Security.VerificationException>。  
  
   
  
## Examples  
 下面的代码示例创建一个采用两个参数的动态方法。 该示例发出简单函数体打印到控制台，第一个参数，该示例将用作该方法的返回值的第二个参数。 该示例完成方法通过创建委托，调用委托，它具有不同的参数，并最后调用动态方法使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法。  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建动态方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <summary>初始化匿名承载的动态方法，指定方法名称、返回类型和参数类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建的动态方法是匿名的程序集，而不是一个现有类型或模块相关联。 匿名程序集存在只是为了，它是提供动态方法，一个沙盒环境，以将其隔离其他代码。 此环境，使安全的动态方法发出和部分受信任的代码执行。  
  
 此构造函数指定，在实时 (JIT) 可见性检查将会对 Microsoft 中间语言 (MSIL) 强制执行动态方法。 即动态方法中的代码有权访问的公共类的公共方法。 如果尝试访问的类型或成员的方法引发异常`private`， `protected`，或`internal`(`Friend`在 Visual Basic 中)。 若要创建一个具有受限制地跳过 JIT 可见性检查的动态方法，使用<xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29>构造函数。  
  
 当构造一个匿名托管的动态方法时，将包含发出程序集的调用堆栈。 当调用的方法时，而不是实际调用方的权限使用发出程序集的权限。 因此，无法在比发出它，即使它是传递给并且由具有更高的信任级别的程序集执行的程序集的更高级别权限执行该动态方法。  
  
 此构造函数指定方法属性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，和调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
> [!NOTE]
>  此构造函数中引入了[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="restrictedSkipVisibility">如果为 <see langword="true" />，则跳过针对动态方法的 MSIL 访问的类型和成员进行的 JIT 可见性检查，含此限制：包含这些类型和成员的程序集的信任级别必须等于或小于发出动态方法的调用堆栈的信任级别；否则为 <see langword="false" />。</param>
        <summary>初始化匿名托管的动态方法，同时指定方法名称、返回类型、参数类型并指定是否应针对动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员跳过实时 (JIT) 可见性检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建的动态方法是匿名的程序集，而不是一个现有类型或模块相关联。 匿名程序集存在只是为了，它是提供动态方法，一个沙盒环境，以将其隔离其他代码。 此环境，使安全的动态方法发出和部分受信任的代码执行。  
  
 匿名托管的动态方法不能对任何类型或成员的自动访问`private`， `protected`，或`internal`(`Friend`在 Visual Basic 中)。 这是不同的动态方法与一个现有的类型或模块，其关联的作用域中具有隐藏成员访问权限。  
  
 指定`true`为`restrictedSkipVisibility`如果动态方法具有类型或成员的访问权`private`， `protected`，或`internal`。 这为这些成员提供受限的动态方法访问。 也就是说，可以访问成员，仅当满足以下条件：  
  
-   目标成员所属的级别为等于或小于发出动态方法的调用堆栈的信任程序集。  
  
-   授予发出动态方法的调用堆栈<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标志。 以完全信任模式执行的代码，这是始终 true。 对于部分受信任的代码，它为 true，仅当主机显式授予权限。  
  
    > [!IMPORTANT]
    >  如果尚未授予权限，安全异常时引发<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>称为或动态方法调用时，不在此构造函数调用。 发出动态方法不需要任何特殊权限。  
  
 例如，使用创建的动态方法`restrictedSkipVisibility`设置为`true`可以访问私有成员的调用堆栈上的任何程序集，调用堆栈是否已被授予受限的成员访问权限。 如果调用堆栈上的部分受信任代码创建动态方法，它不能访问私有成员中的类型的[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]程序集，因为这样的程序集是完全受信任。  
  
 如果`restrictedSkipVisibility`是`false`，JIT 可见性检查会强制执行。 动态方法中的代码有权访问的公共类的公共方法，以及如果它尝试访问的类型或成员所引发异常`private`， `protected`，或`internal`。  
  
 当构造一个匿名托管的动态方法时，将包含发出程序集的调用堆栈。 当调用的方法时，而不是实际调用方的权限使用发出调用堆栈的权限。 因此，无法在比发出它，即使它是传递给并且由具有更高的信任级别的程序集执行的程序集的更高级别权限执行该动态方法。  
  
 此构造函数指定方法属性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，和调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
> [!NOTE]
>  此构造函数中引入了[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="m">一个 <see cref="T:System.Reflection.Module" />，表示动态方法将与之逻辑关联的模块。</param>
        <summary>创建一个对模块全局有效的动态方法，指定方法名称、返回类型、参数类型和模块。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数指定方法属性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>，和不跳过在实时 (JIT) 可见性检查。  
  
 使用此构造函数创建的动态方法有权访问公共和`internal`(`Friend`在 Visual Basic 中) 的模块中包含的所有类型的成员`m`。  
  
> [!NOTE]
>  为了向后兼容，此构造函数可能需要<xref:System.Security.Permissions.SecurityPermission>与<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>标志如果以下条件都 true:`m`是一个模块以外的调用的模块，以及对需求<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>标志已失败。 如果为需<xref:System.Security.Permissions.SecurityPermission>成功，允许执行该操作。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，此成员不再需要<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>标志。 (请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
   
  
## Examples  
 下面的代码示例创建一个采用两个参数的动态方法。 该示例发出简单函数体打印到控制台，第一个参数，该示例将用作该方法的返回值的第二个参数。 该示例完成方法通过创建委托，调用委托，它具有不同的参数，并最后调用动态方法使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29>方法。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  - 或 -  <paramref name="m" /> 是为动态方法提供匿名承载的模块。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  - 或 -  <paramref name="m" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">若要将动态方法与不同调用模块的模块相关联。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="owner">动态方法与之在逻辑上相关联的 <see cref="T:System.Type" />。 动态方法有权访问此类型的所有成员。</param>
        <summary>创建动态方法，并指定方法的名称、 返回类型、 参数类型和此动态方法与之在逻辑上相关联的类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此构造函数创建的动态方法有权访问该类型的所有成员`owner`，并为公共和`internal`(`Friend`在 Visual Basic 中) 中包含的模块的所有其他类型的成员`owner`。  
  
 此构造函数指定方法属性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>，和不跳过在实时 (JIT) 可见性检查。  
  
> [!NOTE]
>  为了向后兼容，此构造函数可能需要<xref:System.Security.Permissions.SecurityPermission>与<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>标志如果以下条件都 true:`owner`所在的模块之外调用模块，以及对需求<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>标志已失败。 如果为需<xref:System.Security.Permissions.SecurityPermission>成功，允许执行该操作。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，此成员不再需要<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>标志。 (请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Reflection.Emit.DynamicMethod>逻辑上与该键相关联的类型。 此关联使其可以访问该类型的私有成员。  
  
 代码示例定义一个名为`Example`私有字段，与类名为`DerivedFromxample`派生自的第一个类，名为的委托类型`UseLikeStatic`返回<xref:System.Int32>和具有类型参数`Example`和<xref:System.Int32>，和名为的委托类型`UseLikeInstance`返回<xref:System.Int32>并且具有一个类型的参数<xref:System.Int32>。  
  
 然后，该示例代码创建<xref:System.Reflection.Emit.DynamicMethod>更改的实例的私有字段`Example`并返回以前的值。  
  
> [!NOTE]
>  一般情况下，更改类的内部字段是不好的面向对象的编码做法。  
  
 该示例代码创建的实例`Example`，然后创建两个委托。 第一个委托类型的`UseLikeStatic`，它具有与动态方法相同的参数。 第二个属于类型`UseLikeInstance`，该委托的第一个参数缺少 (类型的`Example`)。 使用创建此委托<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>方法重载; 第二个参数的该方法重载是的一个实例`Example`，在这种情况下刚创建的实例绑定到新创建的委托。 每当调用该委托，动态方法都作用于的绑定实例`Example`。  
  
> [!NOTE]
>  这是宽松规则的一个示例为的委托绑定中引入[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，以及的新重载<xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>方法。 有关更多信息，请参见 <xref:System.Delegate> 类。  
  
 `UseLikeStatic`调用委托时，传递的实例中`Example`，它绑定到`UseLikeInstance`委托。 则`UseLikeInstance`调用委托时，以便这两个委托都作用于的同一个实例`Example`。 中的内部字段的值的更改将显示每次调用之后。 最后，`UseLikeInstance`委托绑定到某个实例的`DerivedFromxample`，并且委托调用重复出现。  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  - 或 -  <paramref name="owner" /> 是一个接口、数组、开放式泛型类型，或者是泛型类型或方法的类型参数。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  - 或 -  <paramref name="owner" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> 是 <see langword="null" />，或 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">若要将动态方法与不同调用模块的模块中的类型相关联。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="m">一个 <see cref="T:System.Reflection.Module" />，表示动态方法将与之逻辑关联的模块。</param>
        <param name="skipVisibility">若要跳过对动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />。</param>
        <summary>创建一个对模块全局有效的动态方法，指定方法名称、返回类型、参数类型和模块，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数指定方法属性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，、 调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
 使用此构造函数创建的动态方法有权访问公共和`internal`(`Friend`在 Visual Basic 中) 包含模块中的所有类型的成员`m`。 跳过 JIT 编译器的可见性检查将允许要访问的所有其他类型的私有和受保护成员的动态方法。 这很有用，例如，在编写代码用于序列化对象时。  
  
> [!NOTE]
>  为了向后兼容，此构造函数可能需要<xref:System.Security.Permissions.SecurityPermission>与<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>标志如果以下条件都 true:`m`是一个模块以外的调用的模块，以及对需求<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>标志已失败。 如果为需<xref:System.Security.Permissions.SecurityPermission>成功，允许执行该操作。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，此成员不再需要<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>标志。 (请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  - 或 -  <paramref name="m" /> 是为动态方法提供匿名承载的模块。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  - 或 -  <paramref name="m" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">若要将动态方法与不同调用模块的模块相关联。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="owner">动态方法与之在逻辑上相关联的 <see cref="T:System.Type" />。 动态方法有权访问此类型的所有成员。</param>
        <param name="skipVisibility">若要跳过对动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>创建一个动态方法，指定方法名称、返回类型、参数类型，以及与该动态方法逻辑上相关联的类型，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此构造函数创建的动态方法有权访问该类型的所有成员`owner`，并为公共和`internal`(`Friend`在 Visual Basic 中) 中包含的模块的所有其他类型的成员`owner`。 跳过 JIT 编译器的可见性检查将允许要访问的所有其他类型的私有和受保护成员的动态方法。 这很有用，例如，在编写代码用于序列化对象时。  
  
 此构造函数指定方法属性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，、 调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
> [!NOTE]
>  为了向后兼容，此构造函数可能需要<xref:System.Security.Permissions.SecurityPermission>与<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>标志如果以下条件都 true:`owner`所在的模块之外调用模块，以及对需求<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>标志已失败。 如果为需<xref:System.Security.Permissions.SecurityPermission>成功，允许执行该操作。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，此成员不再需要<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>标志。 (请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  - 或 -  <paramref name="owner" /> 是一个接口、数组、开放式泛型类型，或者是泛型类型或方法的类型参数。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  - 或 -  <paramref name="owner" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> 是 <see langword="null" />，或 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">若要将动态方法与不同调用模块的模块中的类型相关联。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="attributes">用于指定动态方法属性的 <see cref="T:System.Reflection.MethodAttributes" /> 值的按位组合。 允许的唯一组合为 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
        <param name="callingConvention">动态方法的调用约定。 必须为 <see cref="F:System.Reflection.CallingConventions.Standard" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="m">To be added.</param>
        <param name="skipVisibility">若要跳过对动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>创建一个对模块全局有效的动态方法，指定方法名称、属性、调用约定、返回类型、参数类型和模块，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此构造函数创建的动态方法有权访问公共和`internal`(`Friend`在 Visual Basic 中) 的模块中包含的所有公共和内部类型的成员`m`。  
  
 跳过 JIT 编译器的可见性检查将允许要访问的所有其他类型的模块中和所有其他程序集中的私有和受保护成员的动态方法。 这很有用，例如，在编写代码用于序列化对象时。  
  
> [!NOTE]
>  为了向后兼容，此构造函数可能需要<xref:System.Security.Permissions.SecurityPermission>与<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>标志如果以下条件都 true:`m`是一个模块以外的调用的模块，以及对需求<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>标志已失败。 如果为需<xref:System.Security.Permissions.SecurityPermission>成功，允许执行该操作。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，此成员不再需要<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>标志。 (请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  - 或 -  <paramref name="m" /> 是为动态方法提供匿名承载的模块。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  - 或 -  <paramref name="m" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" /> 是标志的组合，而不是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" /> 的组合。  - 或 -  <paramref name="callingConvention" /> 不为 <see cref="F:System.Reflection.CallingConventions.Standard" />。  - 或 -  <paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">若要将动态方法与不同调用模块的模块相关联。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="attributes">用于指定动态方法属性的 <see cref="T:System.Reflection.MethodAttributes" /> 值的按位组合。 允许的唯一组合为 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
        <param name="callingConvention">动态方法的调用约定。 必须为 <see cref="F:System.Reflection.CallingConventions.Standard" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="owner">动态方法与之在逻辑上相关联的 <see cref="T:System.Type" />。 动态方法有权访问此类型的所有成员。</param>
        <param name="skipVisibility">若要跳过对动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>创建一个动态方法，指定方法名称、属性、调用约定、返回类型、参数类型，以及与该动态方法逻辑上相关联的类型，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 动态方法适用于包含的类型的模块`owner`。 它可以访问的类型的所有成员`owner`。  
  
 使用此构造函数创建的动态方法有权访问该类型的所有成员`owner`，并为公共和`internal`(`Friend`在 Visual Basic 中) 中包含的模块包含的所有类型的成员`owner`。 跳过 JIT 编译器的可见性检查将允许要访问的所有其他类型的私有和受保护成员的动态方法。 这很有用，例如，在编写代码用于序列化对象时。  
  
> [!NOTE]
>  为了向后兼容，此构造函数可能需要<xref:System.Security.Permissions.SecurityPermission>与<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>标志如果以下条件都 true:`owner`所在的模块之外调用模块，以及对需求<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>标志已失败。 如果为需<xref:System.Security.Permissions.SecurityPermission>成功，允许执行该操作。  
  
> [!NOTE]
>  从开始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，此成员不再需要<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>标志。 (请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  - 或 -  <paramref name="owner" /> 是一个接口、数组、开放式泛型类型，或者是泛型类型或方法的类型参数。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。  - 或 -  <paramref name="owner" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" /> 是标志的组合，而不是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" /> 的组合。  - 或 -  <paramref name="callingConvention" /> 不为 <see cref="F:System.Reflection.CallingConventions.Standard" />。  - 或 -  <paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">若要将动态方法与不同调用模块的模块中的类型相关联。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>创建动态方法后获取指定的属性。</summary>
        <value>表示此方法的属性的 <see cref="T:System.Reflection.MethodAttributes" /> 的值的按位组合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前，动态方法的方法属性始终是<xref:System.Reflection.MethodAttributes.Public>和<xref:System.Reflection.MethodAttributes.Static>。  
  
   
  
## Examples  
 下面的代码示例显示一个动态方法的方法属性。 此代码示例摘自更大的示例为提供<xref:System.Reflection.Emit.DynamicMethod>类。  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>创建动态方法后获取指定的调用约定。</summary>
        <value>表示此方法的调用约定的一个 <see cref="T:System.Reflection.CallingConventions" /> 的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前，一个动态方法的调用约定是始终<xref:System.Reflection.CallingConventions.Standard>。  
  
   
  
## Examples  
 下面的代码示例显示一个动态方法的调用约定。 此代码示例摘自更大的示例为提供<xref:System.Reflection.Emit.DynamicMethod>类。  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>完成动态方法并创建一个可执行此方法的委托。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">其签名与动态方法匹配的委托类型。</param>
        <summary>完成动态方法并创建一个可执行此方法的委托。</summary>
        <returns>可用于执行此动态方法的指定类型的委托。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法完成动态方法。 任何进一步尝试 alter 动态方法，例如修改参数定义或发出多个 Microsoft 中间语言 (MSIL)，将被忽略;不引发异常。  
  
 若要创建一个动态方法的方法主体拥有自己的 MSIL 生成器时，调用<xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A>方法来获取<xref:System.Reflection.Emit.DynamicILInfo>对象。 如果你没有你自己的 MSIL 生成器，调用<xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A>方法来获取<xref:System.Reflection.Emit.ILGenerator>可以用于生成方法主体的对象。  
  
   
  
## Examples  
 下面的代码示例创建一个采用两个参数的动态方法。 该示例发出简单函数体打印到控制台，第一个参数，该示例将用作该方法的返回值的第二个参数。 该示例完成方法通过创建委托，调用委托，它具有不同的参数，并最后调用动态方法使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态方法没有方法体。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" /> 的参数数量或参数类型不正确。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">一个签名与动态方法的签名匹配的委托类型，不包括第一个参数。</param>
        <param name="target">委托绑定到的对象。 其类型必须与动态方法的第一个参数的类型相同。</param>
        <summary>完成动态方法并创建一个可用于执行该方法的委托，指定委托类型和委托绑定到的对象。</summary>
        <returns>一个指定类型的委托，可用于对指定的目标对象执行动态方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重载创建委托绑定到特定的对象。 此类委托被称为关闭通过其第一个参数。 尽管此方法是静态的但其表现就像它是实例方法;实例是`target`。  
  
 此方法重载都需要`target`相同的类型作为第一个参数的动态方法，或将赋值给该类型 （例如，派生类）。  签名`delegateType`具有除第一个动态方法的所有参数。 例如，如果动态方法不具有参数<xref:System.String>， <xref:System.Int32>，和<xref:System.Byte>，然后`delegateType`具有参数<xref:System.Int32>和<xref:System.Byte>;`target`属于类型<xref:System.String>。  
  
 调用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法完成动态方法。 任何进一步尝试 alter 动态方法，例如修改参数定义或发出多个 Microsoft 中间语言 (MSIL)，将被忽略;不引发异常。  
  
 若要创建一个动态方法的方法主体拥有自己的 MSIL 生成器时，调用<xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A>方法来获取<xref:System.Reflection.Emit.DynamicILInfo>对象。 如果你没有你自己的 MSIL 生成器，调用<xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A>方法来获取<xref:System.Reflection.Emit.ILGenerator>可以用于生成方法主体的对象。  
  
   
  
## Examples  
 下面的代码示例创建绑定的委托<xref:System.Reflection.Emit.DynamicMethod>到一种类型的实例，以便每次对同一个实例担任方法调用它。  
  
 代码示例定义一个名为`Example`私有字段，与类名为`DerivedFromxample`派生自的第一个类，名为的委托类型`UseLikeStatic`返回<xref:System.Int32>和具有类型参数`Example`和<xref:System.Int32>，和名为的委托类型`UseLikeInstance`返回<xref:System.Int32>并且具有一个类型的参数<xref:System.Int32>。  
  
 然后，该示例代码创建<xref:System.Reflection.Emit.DynamicMethod>更改的实例的私有字段`Example`并返回以前的值。  
  
> [!NOTE]
>  一般情况下，更改类的内部字段是不好的面向对象的编码做法。  
  
 该示例代码创建的实例`Example`，然后创建两个委托。 第一个委托类型的`UseLikeStatic`，它具有与动态方法相同的参数。 第二个属于类型`UseLikeInstance`，该委托的第一个参数缺少 (类型的`Example`)。 使用创建此委托<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>方法重载; 第二个参数的该方法重载是的一个实例`Example`，在这种情况下刚创建的实例绑定到新创建的委托。 每当调用该委托，动态方法都作用于的绑定实例`Example`。  
  
> [!NOTE]
>  这是宽松规则的一个示例为的委托绑定中引入[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]，以及的新重载<xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>方法。 有关更多信息，请参见 <xref:System.Delegate> 类。  
  
 `UseLikeStatic`调用委托时，传递的实例中`Example`，它绑定到`UseLikeInstance`委托。 则`UseLikeInstance`调用委托时，以便这两个委托都作用于的同一个实例`Example`。 中的内部字段的值的更改将显示每次调用之后。 最后，`UseLikeInstance`委托绑定到某个实例的`DerivedFromxample`，并且委托调用重复出现。  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态方法没有方法体。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> 的类型与动态方法的第一个参数的类型不同，不能赋值给该类型。  - 或 -  <paramref name="delegateType" /> 的参数数量或参数类型不正确。</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取声明方法的类型，对于动态方法，此类型始终为 <see langword="null" />。</summary>
        <value>总是为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性始终返回`null`对于动态方法。 即使在动态方法逻辑上相关联的类型，它不是由声明类型。  
  
   
  
## Examples  
 下面的代码示例显示一个动态方法的声明类型。 此代码示例摘自更大的示例为提供<xref:System.Reflection.Emit.DynamicMethod>类。  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">参数在参数列表中的位置。 通过第一个参数以数字 1 开头对参数编制索引。</param>
        <param name="attributes">用于指定参数属性的 <see cref="T:System.Reflection.ParameterAttributes" /> 值的按位组合。</param>
        <param name="parameterName">参数的名称。 名称可以是长度为零的字符串。</param>
        <summary>定义动态方法的参数。</summary>
        <returns>始终返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`position`为 0，<xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>方法引用的返回值。 设置参数信息不起返回的值上。  
  
 如果动态方法已完成，通过调用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法，<xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>方法不起作用。 不引发异常。  
  
   
  
## Examples  
 下面的代码示例演示如何定义动态方法的参数信息。 此代码示例摘自更大的示例为提供<xref:System.Reflection.Emit.DynamicMethod>类。  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">此方法没有参数。  - 或 -  <paramref name="position" /> 小于 0。  - 或 -  <paramref name="position" /> 大于此方法的参数数目。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回方法的基实现。</summary>
        <returns>方法的基实现。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法始终返回当前`DynamicMethod`对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回应用于此方法的自定义属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">为 <see langword="true" /> 则搜索方法的继承链以查找自定义属性；为 <see langword="false" /> 则仅检查当前方法。</param>
        <summary>返回为该方法定义的所有自定义属性。</summary>
        <returns>一个对象数组，这些对象表示此方法的所有自定义属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于动态方法，指定`true`为`inherit`没有任何作用，因为未在类型中声明方法。  
  
> [!NOTE]
>  目前，动态方法不支持自定义属性。 唯一的属性，则返回<xref:System.Runtime.CompilerServices.MethodImplAttribute>; 你可以获取该方法实现标志更轻松地使用<xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">一个 <see cref="T:System.Type" />，表示要返回的自定义特性类型。</param>
        <param name="inherit">为 <see langword="true" /> 则搜索方法的继承链以查找自定义属性；为 <see langword="false" /> 则仅检查当前方法。</param>
        <summary>返回已应用到此方法的指定类型的自定义属性。</summary>
        <returns>一个对象数组，表示此方法的属性为 <paramref name="attributeType" /> 类型或派生自 <paramref name="attributeType" /> 类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于动态方法，指定`true`为`inherit`没有任何作用，因为未在类型中声明方法。  
  
> [!NOTE]
>  目前，动态方法不支持自定义属性。 唯一的属性，则返回<xref:System.Runtime.CompilerServices.MethodImplAttribute>; 你可以获取该方法实现标志更轻松地使用<xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个 <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 对象，该对象可用于从元数据标记、范围和 Microsoft 中间语言 (MSIL) 流生成方法体。</summary>
        <returns>一个 <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 对象，可用于从元数据标记、范围和 MSIL 流生成方法体。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicILInfo>提供类以支持非托管的代码生成。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要执行非托管的代码。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回可用于发出动态方法的主体的 MSIL 生成器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为具有默认 64 字节 Microsoft 中间语言 (MSIL) 流大小的方法返回 MSIL 生成器。</summary>
        <returns>该方法的 <see cref="T:System.Reflection.Emit.ILGenerator" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已完成动态方法，通过调用后<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法，任何进一步尝试添加 MSIL 将被忽略。 不引发异常。  
  
> [!NOTE]
>  没有对动态方法，甚至在某些完全信任方案中无法验证代码的限制。 请参阅“验证”部分中的 <xref:System.Reflection.Emit.DynamicMethod> 注释。  
  
   
  
## Examples  
 下面的代码示例创建一个采用两个参数的动态方法。 该示例发出简单函数体打印到控制台，第一个参数，该示例将用作该方法的返回值的第二个参数。 该示例完成方法通过创建委托，调用委托，它具有不同的参数，并最后调用动态方法使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">MSIL 流的大小（以字节为单位）。</param>
        <summary>为方法返回一个具有指定 MSIL 流大小的 Microsoft 中间语言 (MSIL) 生成器。</summary>
        <returns>方法的 <see cref="T:System.Reflection.Emit.ILGenerator" /> 对象，具有指定的 MSIL 流大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已完成动态方法，通过调用后<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法，任何进一步尝试添加 MSIL 将被忽略。 不引发异常。  
  
> [!NOTE]
>  没有对动态方法，甚至在某些完全信任方案中无法验证代码的限制。 请参阅“验证”部分中的 <xref:System.Reflection.Emit.DynamicMethod> 注释。  
  
   
  
## Examples  
 下面的代码示例演示此方法重载。 此代码示例摘自更大的示例为提供<xref:System.Reflection.Emit.DynamicMethod>类。  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为此方法返回实现标志。</summary>
        <returns>
          <see cref="T:System.Reflection.MethodImplAttributes" /> 值的按位组合，表示此方法的实现标志。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前，对于动态方法的方法实现属性始终是<xref:System.Reflection.MethodImplAttributes.IL>和<xref:System.Reflection.MethodImplAttributes.NoInlining>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回动态方法的参数。</summary>
        <returns>表示动态方法的参数的 <see cref="T:System.Reflection.ParameterInfo" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.ParameterInfo>此方法返回的对象是仅用于提供信息。 使用<xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>方法来设置或更改参数的特征。  
  
   
  
## Examples  
 下面的代码示例显示一个动态方法的参数。 此代码示例摘自更大的示例为提供<xref:System.Reflection.Emit.DynamicMethod>类。  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示方法中的本地变量是否初始化为零。</summary>
        <value>如果该方法中的本地变量初始化为零，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性设置为`true`，发出的 Microsoft 中间语言 (MSIL) 包括本地变量的初始化。 如果设置为`false`、 未初始化本地变量和生成的代码也无法进行验证。  
  
   
  
## Examples  
 下面的代码示例显示<xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A>的动态方法的属性。 此代码示例摘自更大的示例为提供<xref:System.Reflection.Emit.DynamicMethod>类。  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">对动态方法忽略此参数，因为它们是静态的。 指定 <see langword="null" />。</param>
        <param name="invokeAttr">
          <see cref="T:System.Reflection.BindingFlags" /> 值的按位组合。</param>
        <param name="binder">一个 <see cref="T:System.Reflection.Binder" /> 对象，该对象通过反射来启用绑定、参数类型强制、成员调用以及对 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。 如果 <c>binder</c> 为 <see langword="null" />，则使用默认活页夹。 有关更多详细信息，请参阅 <see cref="T:System.Reflection.Binder" />。</param>
        <param name="parameters">自变量列表。 此参数数组在数量、顺序和类型方面与要调用的方法的参数相同。 如果没有任何参数，则此参数应为 <see langword="null" />。</param>
        <param name="culture">用于控制类型强制的 <see cref="T:System.Globalization.CultureInfo" /> 的实例。 如果这是 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。 例如，将表示 1000 的 <see cref="T:System.String" /> 正确转换为 <see cref="T:System.Double" /> 值时需要此信息，因为不同的区域性使用不同的形式表示 1000。</param>
        <summary>在指定的活页夹的约束下，用指定的区域性信息，使用指定的参数调用动态方法。</summary>
        <returns>一个 <see cref="T:System.Object" />，包含调用的方法的返回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除了列出异常，异常调用的代码应准备好捕获的动态方法引发的任何异常。  
  
 通过创建的委托执行动态方法<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法比执行其与<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法。  
  
 调用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法或<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法完成动态方法。 任何进一步尝试 alter 动态方法，例如修改参数定义或发出多个 Microsoft 中间语言 (MSIL)，将被忽略;不引发异常。  
  
 所有动态方法是静态的因此`obj`始终忽略参数。 若要将动态方法，就像它是实例方法，使用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>采用对象的实例的重载。  
  
 如果动态方法没有任何参数，值`parameters`应`null`。 否则数量、 类型和参数数组中的元素的顺序应该是相同数量、 类型和动态方法的参数顺序。  
  
> [!NOTE]
>  调用此方法重载<xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29>方法重载继承自<xref:System.Reflection.MethodBase>类，因此上面的备注适用于这两个重载。  
  
 此方法不要求权限直接，但调用动态方法可能会导致安全请求，具体取决于该方法。 例如，没有任何要求对匿名托管的动态方法与创建`restrictedSkipVisibility`参数设置为`false`。 另一方面，如果创建方法，以`restrictedSkipVisibility`设置为`true`以便它可以访问目标程序集的隐藏的成员，该方法将导致加号的目标程序集的权限的要求<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>标志。  
  
> [!NOTE]
>  之前[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，此方法需要<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess>标志。  
  
   
  
## Examples  
 下面的代码示例时，将调用动态方法与使用美国英语区域性的确切绑定。 此代码示例摘自更大的示例为提供<xref:System.Reflection.Emit.DynamicMethod>类。  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不支持 <see cref="F:System.Reflection.CallingConventions.VarArgs" /> 调用约定。</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <paramref name="parameters" /> 中的元素数量与动态方法中的参数数量不匹配。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameters" /> 的一个或多个元素的类型与动态方法的相应参数的类型不匹配。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">该动态方法与模块关联，并且不是匿名承载的，而是在 <paramref name="skipVisibility" /> 设置为 <see langword="false" /> 的情况下构造的，但是该动态方法可以访问不是 <see langword="public" /> 或 <see langword="internal" />（在 Visual Basic 中为 <see langword="Friend" />）的成员。  - 或 -  动态方法被以匿名方式托管，并在 <paramref name="skipVisibility" /> 设置为 <see langword="false" /> 的情况下构造，但是它访问不是 <see langword="public" /> 的成员。  - 或 -  动态方法包含无法验证的代码。 请参阅“验证”部分中的 <see cref="T:System.Reflection.Emit.DynamicMethod" /> 注释。</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">一个 <see cref="T:System.Type" />，表示要搜索的自定义特性类型。</param>
        <param name="inherit">为 <see langword="true" /> 则搜索方法的继承链以查找自定义属性；为 <see langword="false" /> 则仅检查当前方法。</param>
        <summary>表示是否定义了指定的自定义属性类型。</summary>
        <returns>如果定义了指定的自定义属性类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于动态方法，指定`true`为`inherit`不起作用。 动态方法具有没有继承链。  
  
> [!NOTE]
>  目前，动态方法不支持自定义属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前的动态方法是否为安全关键或安全可靠关键，以执行关键操作。</summary>
        <value>如果当前动态方法是安全关键的或安全可靠关键的，则为 <see langword="true" />；如果它是透明的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>， <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>，和<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>属性报告由公共语言运行时 (CLR) 的动态方法的透明度级别。 下表中显示的这些属性的组合：  
  
|安全级别|IsSecurityCritical|IsSecurityCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|严重|`true`|`false`|`false`|  
|可靠关键|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
 动态方法的透明度依赖于与之关联的模块。 如果动态方法与类型而不是模块关联，其透明度取决于包含的类型的模块。 动态方法没有安全批注，因此它们被分配相关联的模块的默认透明度。  
  
-   匿名托管的动态方法始终是透明的因为包含它们的系统提供的模块是透明的。  
  
-   下表描述了受信任的程序集 （即，具有强名称程序集安装在全局程序集缓存），与关联的动态方法的透明度。  
  
    |程序集批注|1 级透明度|级别 2 透明度|  
    |-------------------------|--------------------------|--------------------------|  
    |完全透明|透明|透明|  
    |完全关键|严重|严重|  
    |混合的透明度|透明|透明|  
    |安全无关|安全-关键|严重|  
  
     例如，如果将动态方法的类型属于 mscorlib.dll，后者具有级别 2 的混合的透明度，与关联的动态方法是透明的并无法执行关键代码。 有关透明度级别的信息，请参阅[安全透明的代码，级别 1](~/docs/framework/misc/security-transparent-code-level-1.md)和[安全透明的代码，级别 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
    > [!NOTE]
    >  将动态方法与安全无关，（如 system.dll），受信任的第 1 级程序集中的模块关联不允许使用提升的信任。 如果调用动态方法的代码的授予集不包括 System.dll （即，完全信任） 的授予集<xref:System.Security.SecurityException>调用动态方法时引发。  
  
-   与部分受信任的程序集关联的动态方法的透明度取决于在加载程序集的方式。 如果以 （例如，到沙盒应用程序域中） 的部分信任方式加载程序集，则运行时将忽略程序集的安全批注。 程序集和所有其类型和成员，包括动态方法被视为透明。 运行时才会注意到安全批注只在部分信任程序集加载 （例如，到桌面应用程序的默认应用程序域） 的完全信任的情况。 在这种情况下，运行时将分配的动态方法根据程序集的批注的方法的默认透明度。  
  
 有关反射发出和透明度，请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。 透明度有关的信息，请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态方法没有方法体。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前动态方法在当前信任级别上是否是安全可靠关键的；即它是否可以执行关键操作并可以由透明代码访问。</summary>
        <value>如果动态方法在当前信任级别上是安全可靠关键的，则为 <see langword="true" />；如果它是安全关键的或透明的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>， <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>，和<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>属性报告由公共语言运行时 (CLR) 的动态方法的透明度级别。 下表中显示的这些属性的组合：  
  
|安全级别|IsSecurityCritical|IsSecurityCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|严重|`true`|`false`|`false`|  
|可靠关键|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
 动态方法的透明度依赖于与之关联的模块。 如果动态方法与类型而不是模块关联，其透明度取决于包含的类型的模块。 动态方法没有安全批注，因此它们被分配相关联的模块的默认透明度。  
  
-   匿名托管的动态方法始终是透明的因为包含它们的系统提供的模块是透明的。  
  
-   下表描述了受信任的程序集 （即，具有强名称程序集安装在全局程序集缓存），与关联的动态方法的透明度。  
  
    |程序集批注|1 级透明度|级别 2 透明度|  
    |-------------------------|--------------------------|--------------------------|  
    |完全透明|透明|透明|  
    |完全关键|严重|严重|  
    |混合的透明度|透明|透明|  
    |安全无关|安全-关键|严重|  
  
     例如，如果将动态方法的类型属于 mscorlib.dll，后者具有级别 2 的混合的透明度，与关联的动态方法是透明的并无法执行关键代码。 有关透明度级别的信息，请参阅[安全透明的代码，级别 1](~/docs/framework/misc/security-transparent-code-level-1.md)和[安全透明的代码，级别 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
    > [!NOTE]
    >  将动态方法与安全无关，（如 system.dll），受信任的第 1 级程序集中的模块关联不允许使用提升的信任。 如果调用动态方法的代码的授予集不包括 System.dll （即，完全信任） 的授予集<xref:System.Security.SecurityException>调用动态方法时引发。  
  
-   与部分受信任的程序集关联的动态方法的透明度取决于在加载程序集的方式。 如果以 （例如，到沙盒应用程序域中） 的部分信任方式加载程序集，则运行时将忽略程序集的安全批注。 程序集和所有其类型和成员，包括动态方法被视为透明。 运行时才会注意到安全批注只在部分信任程序集加载 （例如，到桌面应用程序的默认应用程序域） 的完全信任的情况。 在这种情况下，运行时将分配的动态方法根据程序集的批注的方法的默认透明度。  
  
 有关反射发出和透明度，请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。 透明度有关的信息，请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态方法没有方法体。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前的动态方法是否在当前的信任级别是透明的，并因此无法执行关键操作。</summary>
        <value>如果动态方法在当前信任级别上是安全透明的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>， <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>，和<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>属性报告由公共语言运行时 (CLR) 的动态方法的透明度级别。 下表中显示的这些属性的组合：  
  
|安全级别|IsSecurityCritical|IsSecurityCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|严重|`true`|`false`|`false`|  
|可靠关键|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
 动态方法的透明度依赖于与之关联的模块。 如果动态方法与类型而不是模块关联，其透明度取决于包含的类型的模块。 动态方法没有安全批注，因此它们被分配相关联的模块的默认透明度。  
  
-   匿名托管的动态方法始终是透明的因为包含它们的系统提供的模块是透明的。  
  
-   下表描述了受信任的程序集 （即，具有强名称程序集安装在全局程序集缓存），与关联的动态方法的透明度。  
  
    |程序集批注|1 级透明度|级别 2 透明度|  
    |-------------------------|--------------------------|--------------------------|  
    |完全透明|透明|透明|  
    |完全关键|严重|严重|  
    |混合的透明度|透明|透明|  
    |安全无关|安全-关键|严重|  
  
     例如，如果将动态方法的类型属于 mscorlib.dll，后者具有级别 2 的混合的透明度，与关联的动态方法是透明的并无法执行关键代码。 有关透明度级别的信息，请参阅[安全透明的代码，级别 1](~/docs/framework/misc/security-transparent-code-level-1.md)和[安全透明的代码，级别 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
    > [!NOTE]
    >  将动态方法与安全无关，（如 system.dll），受信任的第 1 级程序集中的模块关联不允许使用提升的信任。 如果调用动态方法的代码的授予集不包括 System.dll （即，完全信任） 的授予集<xref:System.Security.SecurityException>调用动态方法时引发。  
  
-   与部分受信任的程序集关联的动态方法的透明度取决于在加载程序集的方式。 如果以 （例如，到沙盒应用程序域中） 的部分信任方式加载程序集，则运行时将忽略程序集的安全批注。 程序集和所有其类型和成员，包括动态方法被视为透明。 运行时才会注意到安全批注只在部分信任程序集加载 （例如，到桌面应用程序的默认应用程序域） 的完全信任的情况。 在这种情况下，运行时将分配的动态方法根据程序集的批注的方法的默认透明度。  
  
 有关反射发出和透明度，请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。 透明度有关的信息，请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态方法没有方法体。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>不支持动态方法。</summary>
        <value>不支持动态方法。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">不允许动态方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取动态方法与之在逻辑上相关联的模块。</summary>
        <value>动态方法当前关联的 <see cref="T:System.Reflection.Module" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定了模块创建动态方法后，此属性将返回该模块。 如果创建动态方法后，已为所有者指定的类型，此属性将返回模块，其中包含该类型。  
  
   
  
## Examples  
 下面的代码示例显示<xref:System.Reflection.Emit.DynamicMethod.Module%2A>的动态方法的属性。 此代码示例摘自更大的示例为提供<xref:System.Reflection.Emit.DynamicMethod>类。  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取动态方法的名称。</summary>
        <value>方法的简单名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  不需要对动态方法进行命名。  
  
   
  
## Examples  
 下面的代码示例显示一个动态方法的名称。 此代码示例摘自更大的示例为提供<xref:System.Reflection.Emit.DynamicMethod>类。  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在反射中用于获取该方法的类。</summary>
        <value>总是为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性始终返回`null`对于动态方法。  
  
   
  
## Examples  
 下面的代码示例显示一个动态方法的反射的类型。 此代码示例摘自更大的示例为提供<xref:System.Reflection.Emit.DynamicMethod>类。  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取动态方法的返回参数。</summary>
        <value>总是为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性始终返回`null`对于动态方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取动态方法的返回值的类型。</summary>
        <value>一个 <see cref="T:System.Type" />，表示当前方法的返回值的类型；如果该方法没有返回类型，则为 <see cref="T:System.Void" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`null`时创建动态方法后，此属性返回的返回类型指定<xref:System.Void?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的代码示例显示一个动态方法的返回类型。 此代码示例摘自更大的示例为提供<xref:System.Reflection.Emit.DynamicMethod>类。  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取动态方法的返回类型的自定义属性。</summary>
        <value>一个 <see cref="T:System.Reflection.ICustomAttributeProvider" />，表示动态方法的返回类型的自定义属性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因此通过返回自定义特性的数组的动态方法的返回类型不支持自定义特性<xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A>方法始终为空。  
  
   
  
## Examples  
 下面的代码示例演示如何显示动态方法的返回类型的自定义属性。 此代码示例摘自更大的示例为提供<xref:System.Reflection.Emit.DynamicMethod>类。  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示为字符串的方法的签名。</summary>
        <returns>一个表示方法签名的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果有的话，签名包括仅类型和方法名称。 参数名称不包括。  
  
   
  
## Examples  
 下面的代码示例显示<xref:System.Reflection.Emit.DynamicMethod.ToString%2A>的动态方法的方法。 此代码示例摘自更大的示例为提供<xref:System.Reflection.Emit.DynamicMethod>类。  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>