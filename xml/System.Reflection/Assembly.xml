<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Assembly.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5d3d5877ccfca1ad46bc974cf9102a85adaba2a32.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d3d5877ccfca1ad46bc974cf9102a85adaba2a32</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Represents an assembly, which is a reusable, versionable, and self-describing building block of a common language runtime application.</source>
          <target state="translated">表示一个程序集，它是一个可重用、无版本冲突并且可自我描述的公共语言运行时应用程序构建基块。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> class to load assemblies, to explore the metadata and constituent parts of assemblies, to discover the types contained in assemblies, and to create instances of those types.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>类加载程序集，若要浏览的元数据和构成部分的程序集，以便发现的类型包含在程序集中，从而创建这些类型的实例。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>To get an array of <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> objects representing the assemblies currently loaded into an application domain (for example, the default application domain of a simple project), use the <ph id="ph2">&lt;xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">若要获取的数组<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>对象当前表示程序集加载到应用程序域 （例如，默认应用程序域的一个简单的项目），使用<ph id="ph2">&lt;xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>To load assemblies dynamically, the <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> class provides the following static methods (<ph id="ph2">`Shared`</ph> methods in Visual Basic).</source>
          <target state="translated">动态，加载程序集<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>类提供的以下静态方法 (<ph id="ph2">`Shared`</ph>在 Visual Basic 中的方法)。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>Assemblies are loaded into the application domain where the load operation occurs.</source>
          <target state="translated">程序集是加载到加载操作的出现位置的应用程序域。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The recommended way to load assemblies is to use the <ph id="ph1">&lt;xref:System.AppDomain.Load%2A&gt;</ph> method, which identifies the assembly to be loaded by its display name (for example, "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089").</source>
          <target state="translated">加载程序集的建议的方法是使用<ph id="ph1">&lt;xref:System.AppDomain.Load%2A&gt;</ph>方法，它标识要按其显示名称加载的程序集 (例如，"System.Windows.Forms，Version = 2.0.0.0，区域性 = neutral，PublicKeyToken = b77a5c561934e089")。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The search for the assembly follows the rules described in <bpt id="p1">[</bpt>How the Runtime Locates Assemblies<ept id="p1">](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)</ept>.</source>
          <target state="translated">程序集搜索将遵循中所述的规则<bpt id="p1">[</bpt>运行时如何定位程序集<ept id="p1">](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)</ept>。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods enable you to load an assembly for reflection, but not for execution.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph>方法使你能够加载为反射，但不是为执行程序集。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>For example, an assembly that targets a 64-bit platform can be examined by code that is running on a 32-bit platform.</source>
          <target state="translated">例如，可以通过在 32 位平台运行的代码将检查面向 64 位平台程序集。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> methods are provided for rare scenarios in which an assembly must be identified by path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法为在其中必须由路径标识程序集的极少数情况下提供。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>To get an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object for the currently executing assembly, use the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetExecutingAssembly%2A&gt;</ph> method.</source>
          <target state="translated">若要获取<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>对于当前正在执行的程序集，使用对象<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetExecutingAssembly%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>Many members of the <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> class provide information about an assembly.</source>
          <target state="translated">许多成员<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>类提供有关程序集的信息。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>For example:</source>
          <target state="translated">例如:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetName%2A&gt;</ph> method returns an <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object that provides access to the parts of the assembly display name.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.GetName%2A&gt;</ph>方法返回<ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph>提供各部分的程序集显示名称的访问的对象。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A&gt;</ph> method lists the attributes applied to the assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A&gt;</ph>方法列出应用于程序集的特性。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetFiles%2A&gt;</ph> method provides access to the files in the assembly manifest.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.GetFiles%2A&gt;</ph>方法提供对程序集清单中的文件的访问。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceNames%2A&gt;</ph> method provides the names of the resources in the assembly manifest.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceNames%2A&gt;</ph>方法提供的程序集清单中的资源的名称。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> method lists all the types in the assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph>方法列举程序集中的所有类型。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A&gt;</ph> method lists the types that are visible to callers outside the assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A&gt;</ph>方法列出对调用方的程序集外部可见的类型。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph> method can be used to search for a particular type in the assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph>方法可以用于搜索的程序集中的特定类型。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%2A&gt;</ph> method can be used to search for and create instances of types in the assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%2A&gt;</ph>方法可以用于搜索并在程序集中创建类型的实例。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>For more information on assemblies, see the "Application Domains and Assemblies" section in the <bpt id="p1">[</bpt>Application Domains<ept id="p1">](~/docs/framework/app-domains/application-domains.md)</ept> topic.</source>
          <target state="translated">程序集的详细信息，请参阅中的"应用程序域和程序集"部分<bpt id="p1">[</bpt>应用程序域<ept id="p1">](~/docs/framework/app-domains/application-domains.md)</ept>主题。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The following code example shows how to obtain the currently executing assembly, create an instance of a type contained in that assembly, and invoke one of the type's methods with late binding.</source>
          <target state="translated">下面的代码示例演示如何获取当前正在执行的程序集，创建包含该程序集中，类型的实例并调用与后期绑定的类型的方法之一。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>For this purpose, the code example defines a class named <ph id="ph1">`Example`</ph>, with a method named <ph id="ph2">`SampleMethod`</ph>.</source>
          <target state="translated">为此目的，下面的代码示例定义一个名为<ph id="ph1">`Example`</ph>，使用一个名为方法<ph id="ph2">`SampleMethod`</ph>。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The constructor of the class accepts an integer, which is used to compute the return value of the method.</source>
          <target state="translated">类的构造函数接受一个整数，用于计算的方法的返回值。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The code example also demonstrates the use of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetName%2A&gt;</ph> method to obtain an <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object that can be used to parse the full name of the assembly.</source>
          <target state="translated">代码示例还演示了利用<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetName%2A&gt;</ph>方法来获取<ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph>可以用于分析的程序集的完整名称的对象。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The example displays the version number of the assembly, the <ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph> property, and the <ph id="ph2">&lt;xref:System.Reflection.Assembly.EntryPoint%2A&gt;</ph> property.</source>
          <target state="translated">该示例显示的程序集的版本号<ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph>属性，与<ph id="ph2">&lt;xref:System.Reflection.Assembly.EntryPoint%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>for full trust for inheritors.</source>
          <target state="translated">对继承者的完全信任。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">此类不能由部分受信任的代码继承。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>This type is thread safe.</source>
          <target state="translated">此类型是线程安全的。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.#ctor">
          <source>This constructor is invoked by derived classes during the construction of <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> objects.</source>
          <target state="translated">此构造函数由派生类调用的构造过程<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.CodeBase">
          <source>Gets the location of the assembly as specified originally, for example, in an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated">获取最初指定的程序集的位置，例如，在 <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> 对象中指定的位置。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>The location of the assembly as specified originally.</source>
          <target state="translated">程序集的位置（按照最初的指定）。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>To get the absolute path to the loaded manifest-containing file, use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType&gt;</ph> property instead.</source>
          <target state="translated">若要获取的清单包含已加载文件的绝对路径，请使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType&gt;</ph>属性改为。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>If the assembly was loaded as a byte array, using an overload of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that takes an array of bytes, this property returns the location of the caller of the method, not the location of the loaded assembly.</source>
          <target state="translated">如果程序集被加载作为字节数组，使用的重载<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>采用的字节数组的方法，此属性返回的方法，而不加载的程序集的位置的调用方的位置。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph> property.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>for access to the path.</source>
          <target state="translated">用于访问路径。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CodeBase">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Locates a type from this assembly and creates an instance of it using the system activator.</source>
          <target state="translated">从此程序集中查找某个类型，然后使用系统激活器创建它的实例。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> of the type to locate.</source>
          <target state="translated">要查找类型的 <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>Locates the specified type from this assembly and creates an instance of it using the system activator, using case-sensitive search.</source>
          <target state="translated">使用区分大小写的搜索，从此程序集中查找指定的类型，然后使用系统激活器创建它的实例。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>An instance of the specified type created with the default constructor; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">使用默认构造函数创建的指定类型的实例；如果未找到 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 则为 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The type is resolved using the default binder, without specifying culture or activation attributes, and with <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> set to <ph id="ph2">&lt;see langword="Public" /&gt;</ph> or <ph id="ph3">&lt;see langword="Instance" /&gt;</ph>.</source>
          <target state="translated">该类型使用默认联编程序解析，而无需指定区域性或激活属性，并将 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 设置为 <ph id="ph2">&lt;see langword="Public" /&gt;</ph> 或 <ph id="ph3">&lt;see langword="Instance" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>If the runtime is unable to find <ph id="ph1">`typeName`</ph> in the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> instance, it returns <ph id="ph3">`null`</ph> instead of throwing an exception.</source>
          <target state="translated">如果运行时找不到<ph id="ph1">`typeName`</ph>中<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>实例，它将返回<ph id="ph3">`null`</ph>而不是引发异常。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>This might happen because:</source>
          <target state="translated">这可能是因为：</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>You haven't specified the fully qualified name of the type.</source>
          <target state="translated">你还没有指定类型的完全限定的名称。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>You've specified the fully qualified type name, but its case doesn’t match the case of the type's <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">你指定的完全限定的类型名称，但其大小写不匹配的类型的大小写<ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>For a case-insensitive comparison of <ph id="ph1">`typeName`</ph> with the type's full name, call the <ph id="ph2">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29&gt;</ph> overload and specify <ph id="ph3">`true`</ph> for the <ph id="ph4">`ignoreCase`</ph> argument.</source>
          <target state="translated">有关不区分大小写的比较<ph id="ph1">`typeName`</ph>使用该类型的全名，调用<ph id="ph2">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29&gt;</ph>重载并指定<ph id="ph3">`true`</ph>为<ph id="ph4">`ignoreCase`</ph>自变量。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The type doesn’t exist in the current <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> instance.</source>
          <target state="translated">类型不存在于当前<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The following example defines a <ph id="ph1">`Person`</ph> class and calls the <ph id="ph2">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%29&gt;</ph> method to instantiate it.</source>
          <target state="translated">下面的示例定义<ph id="ph1">`Person`</ph>类和调用<ph id="ph2">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%29&gt;</ph>其进行实例化的方法。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is an empty string ("") or a string beginning with a null character.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 为空字符串 ("") 或以空字符开头的字符串。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The current assembly was loaded into the reflection-only context.</source>
          <target state="translated">当前程序集已加载到仅反射上下文中。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>No matching constructor was found.</source>
          <target state="translated">未找到匹配的构造函数。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 所需的从属程序集无法找到。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 所需的从属程序集已找到，但无法加载。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">当前程序集被加载到仅反射上下文中，并且 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 所需的从属程序集未预先加载。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 需要一个从属程序集，但该文件不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> of the type to locate.</source>
          <target state="translated">要查找类型的 <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore the case of the type name; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，则忽略类型名的大小写；否则，为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search.</source>
          <target state="translated">使用可选的区分大小写搜索，从此程序集中查找指定的类型，然后使用系统激活器创建它的实例。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>An instance of the specified type created with the default constructor; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">使用默认构造函数创建的指定类型的实例；如果未找到 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 则为 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The type is resolved using the default binder, without specifying culture or activation attributes, and with <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> set to <ph id="ph2">&lt;see langword="Public" /&gt;</ph> or <ph id="ph3">&lt;see langword="Instance" /&gt;</ph>.</source>
          <target state="translated">该类型使用默认联编程序解析，而无需指定区域性或激活属性，并将 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 设置为 <ph id="ph2">&lt;see langword="Public" /&gt;</ph> 或 <ph id="ph3">&lt;see langword="Instance" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>If the runtime is unable to find <ph id="ph1">`typeName`</ph> in the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> instance, it returns <ph id="ph3">`null`</ph> instead of throwing an exception.</source>
          <target state="translated">如果运行时找不到<ph id="ph1">`typeName`</ph>中<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>实例，它将返回<ph id="ph3">`null`</ph>而不是引发异常。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>This might happen because:</source>
          <target state="translated">这可能是因为：</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>You haven't specified the fully qualified name of the type.</source>
          <target state="translated">你还没有指定类型的完全限定的名称。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The type doesn’t exist in the current <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> instance.</source>
          <target state="translated">类型不存在于当前<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The following example defines a <ph id="ph1">`Person`</ph> class.</source>
          <target state="translated">下面的示例定义<ph id="ph1">`Person`</ph>类。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%29&gt;</ph> method to instantiate it, but because the casing of the <ph id="ph2">`typeName`</ph> argument doesn’t match that of the type's <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph> property, the method returns <ph id="ph4">`null`</ph>.</source>
          <target state="translated">然后，它调用<ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%29&gt;</ph>方法可实例化，但是，由于的大小写<ph id="ph2">`typeName`</ph>自变量不匹配的类型的<ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>属性，该方法返回<ph id="ph4">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>When the example passes the same string to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29&gt;</ph> overload and specifies that the comparison should be case-insensitive, the <ph id="ph2">`Person`</ph> class is found, and a <ph id="ph3">`Person`</ph> object is successfully instantiated.</source>
          <target state="translated">当示例将传递到相同的字符串<ph id="ph1">&lt;xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29&gt;</ph>重载，并指定比较应区分大小写，<ph id="ph2">`Person`</ph>找到该类，和一个<ph id="ph3">`Person`</ph>成功实例化对象。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is an empty string ("") or a string beginning with a null character.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 为空字符串 ("") 或以空字符开头的字符串。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context.</source>
          <target state="translated">当前程序集已加载到仅反射上下文中。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>No matching constructor was found.</source>
          <target state="translated">未找到匹配的构造函数。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 所需的从属程序集无法找到。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 所需的从属程序集已找到，但无法加载。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">当前程序集被加载到仅反射上下文中，并且 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 所需的从属程序集未预先加载。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 需要一个从属程序集，但该文件不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> of the type to locate.</source>
          <target state="translated">要查找类型的 <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore the case of the type name; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，则忽略类型名的大小写；否则，为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">影响执行搜索的方式的位掩码。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The value is a combination of bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">此值是 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 中的位标志的组合。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects via reflection.</source>
          <target state="translated">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> 对象的检索。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用默认活页夹。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array that contains the arguments to be passed to the constructor.</source>
          <target state="translated">包含要传递给构造函数的自变量的数组。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to be invoked.</source>
          <target state="translated">此自变量数组在数量、顺序和类型方面必须与要调用的构造函数的参数匹配。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the default constructor is desired, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果需要默认的构造函数，则 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 必须是空数组或 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">用于控制类型强制的 <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> 的实例。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If this is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">如果这是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用当前线程的 <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>(This is necessary to convert a <ph id="ph1">&lt;see langword="String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see langword="Double" /&gt;</ph> value, for example, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">（例如，这对于将表示 1000 的 <ph id="ph1">&lt;see langword="String" /&gt;</ph> 转换为 <ph id="ph2">&lt;see langword="Double" /&gt;</ph> 值是必需的，因为不同的区域性以不同的方式表示 1000。）</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">包含一个或多个可以参与激活的特性的数组。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">通常，为包含单个 <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> 对象的数组，该对象指定激活远程对象所需的 URL。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">此参数与客户端激活的对象相关。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">应改用 Windows Communication Foundation 来开发分布式应用程序。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search and having the specified culture, arguments, and binding and activation attributes.</source>
          <target state="translated">使用可选的区分大小写搜索并具有指定的区域性、自变量和绑定及激活特性，从此程序集中查找指定的类型，并使用系统激活器创建它的实例。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An instance of the specified type, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">如果未找到 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则为指定的类型实例或 <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The supplied arguments are used to resolve the type, and to bind the constructor that is used to create the instance.</source>
          <target state="translated">所提供的自变量用于解析类型，以及绑定用于创建实例的构造函数。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is an empty string ("") or a string beginning with a null character.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 为空字符串 ("") 或以空字符开头的字符串。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The current assembly was loaded into the reflection-only context.</source>
          <target state="translated">当前程序集已加载到仅反射上下文中。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>No matching constructor was found.</source>
          <target state="translated">未找到匹配的构造函数。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A non-empty activation attributes array is passed to a type that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">向非继承自 <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph> 的类型传递非空的激活特性数组。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 所需的从属程序集无法找到。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 所需的从属程序集已找到，但无法加载。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">当前程序集被加载到仅反射上下文中，并且 <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 所需的从属程序集未预先加载。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 需要一个从属程序集，但该文件不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> requires a dependent assembly which that was compiled for a version of the runtime that is later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>to create an instance of a delegate.</source>
          <target state="translated">若要创建委托的一个实例。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>The display name of an assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>The full name of a type.</source>
          <target state="translated">类型的全名。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>Creates the name of a type qualified by the display name of its assembly.</source>
          <target state="translated">创建由类型的程序集的显示名称限定的类型的名称。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>The full name of the type qualified by the display name of the assembly.</source>
          <target state="translated">由程序集的显示名称限定的类型的完整名称。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>The format of the returned string is:</source>
          <target state="translated">返回字符串的格式为：</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source><ph id="ph1">\&lt;</ph>FullTypeName&gt;, <ph id="ph2">\&lt;</ph>AssemblyDisplayName&gt;</source>
          <target state="translated"><ph id="ph1">\&lt;</ph>FullTypeName&gt;, <ph id="ph2">\&lt;</ph>AssemblyDisplayName&gt;</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for a description of the format of the display name of an assembly.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>有关程序集的显示名称的格式的说明。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>To accommodate changes in versions of the common language runtime, use this method rather than constructing the qualified name yourself.</source>
          <target state="translated">若要适应的公共语言运行时版本中的更改，请使用此方法，而不是无需自行构造的限定的名称。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
          <source>For information about qualified assembly names, see <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">有关限定的程序集名称的信息，请参阅<ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.CustomAttributes">
          <source>Gets a collection that contains this assembly's custom attributes.</source>
          <target state="translated">获取包含此程序集自定义属性的集合。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.CustomAttributes">
          <source>A collection that contains this assembly's custom attributes.</source>
          <target state="translated">包含此程序集自定义属性的集合。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.DefinedTypes">
          <source>Gets a collection of the types defined in this assembly.</source>
          <target state="translated">获取定义在此程序集中的类型的集合。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.DefinedTypes">
          <source>A collection of the types defined in this assembly.</source>
          <target state="translated">定义在此程序集中的类型的集合。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.DefinedTypes">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A&gt;</ph> property is comparable to the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph> method, except that the <ph id="ph3">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A&gt;</ph> property returns a collection of <ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph> objects, and the <ph id="ph5">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph> method returns an array of <ph id="ph6">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A&gt;</ph>属性相当于<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph>方法，只不过<ph id="ph3">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A&gt;</ph>属性返回的集合<ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph>对象，与<ph id="ph5">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph>方法返回的数组<ph id="ph6">&lt;xref:System.Type&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.DefinedTypes">
          <source>The returned array includes nested types.</source>
          <target state="translated">返回的数组包含嵌套的类型。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.EntryPoint">
          <source>Gets the entry point of this assembly.</source>
          <target state="translated">获取此程序集的入口点。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.EntryPoint">
          <source>An object that represents the entry point of this assembly.</source>
          <target state="translated">表示此程序集入口点的对象。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.EntryPoint">
          <source>If no entry point is found (for example, the assembly is a DLL), <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">如果没有找到入口点（例如，此程序集是一个 DLL），则返回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Equals(System.Object)">
          <source>The object to compare with this instance.</source>
          <target state="translated">与该实例进行比较的对象。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Equals(System.Object)">
          <source>Determines whether this assembly and the specified object are equal.</source>
          <target state="translated">确定此程序集和指定的对象是否相等。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is equal to this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="o" /&gt;</ph> 等于此实例，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.Equals%2A&gt;</ph> method performs a test for reference equality to determine whether the current instance and <ph id="ph2">`o`</ph> are equal.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.Equals%2A&gt;</ph>方法执行测试引用相等性来确定是否当前的实例和<ph id="ph2">`o`</ph>是否相等。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.EscapedCodeBase">
          <source>Gets the URI, including escape characters, that represents the codebase.</source>
          <target state="translated">获取 URI，包括表示基本代码的转义符。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.EscapedCodeBase">
          <source>A URI with escape characters.</source>
          <target state="translated">带有转义符的 URI。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.EscapedCodeBase">
          <source>for access to the path.</source>
          <target state="translated">用于访问路径。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.EscapedCodeBase">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.Evidence">
          <source>Gets the evidence for this assembly.</source>
          <target state="translated">获取此程序集的证据。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Evidence">
          <source>The evidence for this assembly.</source>
          <target state="translated">此程序集的证据。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Evidence">
          <source>Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</source>
          <target state="translated">证据是输入安全策略决策的一组信息（如代码可授予哪些权限）。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Evidence">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Evidence">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.ExportedTypes">
          <source>Gets a collection of the public types defined in this assembly that are visible outside the assembly.</source>
          <target state="translated">获取此程序集中定义的公共类型的集合，这些公共类型在程序集外可见。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ExportedTypes">
          <source>A collection of the public types defined in this assembly that are visible outside the assembly.</source>
          <target state="translated">此程序集中定义的公共类型的集合，这些公共类型在程序集外可见。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.FullName">
          <source>Gets the display name of the assembly.</source>
          <target state="translated">获取程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for a description of the format of the display name of an assembly.</source>
          <target state="translated">请参阅<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>有关程序集的显示名称的格式的说明。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>Writing your own code to parse display names is not recommended.</source>
          <target state="translated">不建议编写你自己的代码来分析显示名称。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>Instead, pass the display name to the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.%23ctor%2A&gt;</ph> constructor, which parses it and populates the appropriate fields of the new <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph>.</source>
          <target state="translated">相反，将传递到的显示名称<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.%23ctor%2A&gt;</ph>构造函数，也不能对其进行分析将填充新的相应字段<ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">在.NET Framework 2.0 版中，处理器体系结构添加到程序集标识，并且可以指定为程序集名称字符串的一部分。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">但是，不包括在返回的字符串<ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A&gt;</ph>属性，出于兼容性原因。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.FullName">
          <source>The following example retrieves the display name of the currently executing assembly, and the display name of the assembly that contains the <ph id="ph1">&lt;xref:System.Int32&gt;</ph> type (<ph id="ph2">`int`</ph> in C#, <ph id="ph3">`Integer`</ph> in Visual Basic).</source>
          <target state="translated">以下示例检索的当前正在执行的程序集的显示名称和包含的程序集的显示名称<ph id="ph1">&lt;xref:System.Int32&gt;</ph>类型 (<ph id="ph2">`int`</ph>在 C# 中，<ph id="ph3">`Integer`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>An object representing a type in the assembly that will be returned.</source>
          <target state="translated">一个对象，该对象表示将返回的程序集中的类型。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>Gets the currently loaded assembly in which the specified type is defined.</source>
          <target state="translated">获取在其中定义指定类型的当前加载的程序集。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>The assembly in which the specified type is defined.</source>
          <target state="translated">在其中定义指定类型的程序集。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>Calling this method is equivalent to retrieving the value of the  <ph id="ph1">&lt;xref:System.Type.Assembly?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">调用此方法相当于检索的值的<ph id="ph1">&lt;xref:System.Type.Assembly?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>However, the <ph id="ph1">&lt;xref:System.Type.Assembly?displayProperty=nameWithType&gt;</ph> property typically offers superior performance.</source>
          <target state="translated">但是，<ph id="ph1">&lt;xref:System.Type.Assembly?displayProperty=nameWithType&gt;</ph>属性通常提供优异的性能。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>In order to call this method, you must have a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object, which means that the assembly in which the class is defined must already be loaded.</source>
          <target state="translated">若要调用此方法，您必须<ph id="ph1">&lt;xref:System.Type&gt;</ph>对象，这意味着，在其中定义类的程序集必须已经是加载。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>The following example retrieves the assembly that contains the <ph id="ph1">&lt;xref:System.Int32&gt;</ph> type and displays its name and file location.</source>
          <target state="translated">下面的示例检索包含的程序集<ph id="ph1">&lt;xref:System.Int32&gt;</ph>键入并显示其名称和文件的位置。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetAssembly(System.Type)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> of the method that invoked the currently executing method.</source>
          <target state="translated">返回方法（该方法调用当前正在执行的方法）的 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>The <ph id="ph1">&lt;see langword="Assembly" /&gt;</ph> object of the method that invoked the currently executing method.</source>
          <target state="translated">方法（该方法调用当前正在执行的方法）的 <ph id="ph1">&lt;see langword="Assembly" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>If the method that calls the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> method is expanded inline by the just-in-time (JIT) compiler, or if its caller is expanded inline, the assembly that is returned by <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> may differ unexpectedly.</source>
          <target state="translated">如果该方法的调用<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>方法是内联展开的由实时 (JIT) 编译器，或者如果其调用方是内联展开的该程序集，则返回<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>可能会发生异常。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>For example, consider the following methods and assemblies:</source>
          <target state="translated">例如，考虑以下方法和程序集：</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>Method <ph id="ph1">`M1`</ph> in assembly <ph id="ph2">`A1`</ph> calls <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>.</source>
          <target state="translated">方法<ph id="ph1">`M1`</ph>集中<ph id="ph2">`A1`</ph>调用<ph id="ph3">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>Method <ph id="ph1">`M2`</ph> in assembly <ph id="ph2">`A2`</ph> calls <ph id="ph3">`M1`</ph>.</source>
          <target state="translated">方法<ph id="ph1">`M2`</ph>集中<ph id="ph2">`A2`</ph>调用<ph id="ph3">`M1`</ph>。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>Method <ph id="ph1">`M3`</ph> in assembly <ph id="ph2">`A3`</ph> calls <ph id="ph3">`M2`</ph>.</source>
          <target state="translated">方法<ph id="ph1">`M3`</ph>集中<ph id="ph2">`A3`</ph>调用<ph id="ph3">`M2`</ph>。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>When <ph id="ph1">`M1`</ph> is not inlined, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> returns <ph id="ph3">`A2`</ph>.</source>
          <target state="translated">当<ph id="ph1">`M1`</ph>不是内联，<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>返回<ph id="ph3">`A2`</ph>。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>When <ph id="ph1">`M1`</ph> is inlined, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> returns <ph id="ph3">`A3`</ph>.</source>
          <target state="translated">当<ph id="ph1">`M1`</ph>是内联，<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>返回<ph id="ph3">`A3`</ph>。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>Similarly, when <ph id="ph1">`M2`</ph> is not inlined, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> returns <ph id="ph3">`A2`</ph>.</source>
          <target state="translated">同样，当<ph id="ph1">`M2`</ph>不是内联，<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>返回<ph id="ph3">`A2`</ph>。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>When <ph id="ph1">`M2`</ph> is inlined, <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph> returns <ph id="ph3">`A3`</ph>.</source>
          <target state="translated">当<ph id="ph1">`M2`</ph>是内联，<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>返回<ph id="ph3">`A3`</ph>。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>This effect also occurs when <ph id="ph1">`M1`</ph> executes as a tail call from <ph id="ph2">`M2`</ph>, or when <ph id="ph3">`M2`</ph> executes as a tail call from <ph id="ph4">`M3`</ph>.</source>
          <target state="translated">这种效果也会发生时<ph id="ph1">`M1`</ph>作为尾调用从执行<ph id="ph2">`M2`</ph>，或当<ph id="ph3">`M2`</ph>作为尾调用从执行<ph id="ph4">`M3`</ph>。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>You can prevent the JIT compiler from inlining the method that calls <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>, by applying the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph> attribute with the <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType&gt;</ph> flag, but there is no similar mechanism for preventing tail calls.</source>
          <target state="translated">你可以阻止从 JIT 编译器内联调用的方法<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>，通过应用<ph id="ph2">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph>特性与<ph id="ph3">&lt;xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType&gt;</ph>标志，但没有任何类似机制来防止尾调用。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCallingAssembly">
          <source>The following example gets the calling assembly of the current method.</source>
          <target state="translated">下面的示例获取当前方法的调用程序集。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets the custom attributes for this assembly.</source>
          <target state="translated">获取此程序集的自定义属性。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>This argument is ignored for objects of type <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</source>
          <target state="translated">对于 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> 类型的对象，将忽略此参数。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Gets all the custom attributes for this assembly.</source>
          <target state="translated">获取此程序集的所有自定义属性。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>An array that contains the custom attributes for this assembly.</source>
          <target state="translated">包含此程序集自定义属性的数组。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>This method implements the corresponding <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider&gt;</ph> interface method.</source>
          <target state="translated">此方法实现相应<ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider&gt;</ph>接口方法。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Therefore, the <ph id="ph1">`inherit`</ph> parameter must be specified even though it is ignored.</source>
          <target state="translated">因此，<ph id="ph1">`inherit`</ph>必须指定参数，即使它将被忽略。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</source>
          <target state="translated">伪属性指示该属性为存在时必须设置的核心元数据位。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</source>
          <target state="translated">不同于扩展类型的元数据并保存与类型的自定义属性，一个伪属性修改类型的元数据，并则将被丢弃。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Some of the resulting bits cannot be accessed using existing reflection APIs.</source>
          <target state="translated">无法使用现有的反射 Api 访问某些生成的数据位。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</source>
          <target state="translated">下表总结了不同的伪属性和可用于反射的位的访问。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Pseudo-Attribute</source>
          <target state="translated">Pseudo-Attribute</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Metadata Bits</source>
          <target state="translated">元数据位</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Reflection Accessor</source>
          <target state="translated">反射访问器</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>DllImportAttribute</source>
          <target state="translated">Sub</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorPInvokeMap</source>
          <target state="translated">CorPInvokeMap</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>DLL name</source>
          <target state="translated">DLL 名称</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor for PInvokeMap for ordinary method/global method attributes.</source>
          <target state="translated">有关 PInvokeMap 普通方法/全局方法属性没有访问器。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor for DLL name.</source>
          <target state="translated">DLL 的名称没有访问器。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>GuidAttribute</source>
          <target state="translated">GuidAttribute</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Stored as a real custom attribute.</source>
          <target state="translated">存储的实际的自定义特性。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Accessed as a real custom attribute.</source>
          <target state="translated">访问的实际的自定义特性。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>ComImportAttribute</source>
          <target state="translated">ComImportAttribute</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdImport</source>
          <target state="translated">CorTypeAttr.tdImport</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.Import</source>
          <target state="translated">Type.Attributes.Import</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>SerializableAttribute</source>
          <target state="translated">SerializableAttribute</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdSerializable</source>
          <target state="translated">CorTypeAttr.tdSerializable</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.Serializable</source>
          <target state="translated">Type.Attributes.Serializable</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>NonSerializedAttribute</source>
          <target state="translated">NonSerializedAttribute</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorFieldAttr.fdNotSerialized</source>
          <target state="translated">CorFieldAttr.fdNotSerialized</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>FieldInfo.Attributes.NotSerialized</source>
          <target state="translated">FieldInfo.Attributes.NotSerialized</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>MethodImplAttribute</source>
          <target state="translated">MethodImplAttribute</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorMethodImpl</source>
          <target state="translated">CorMethodImpl</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>MethodInfo.GetMethodImplementationFlags()</source>
          <target state="translated">MethodInfo.GetMethodImplementationFlags()</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>ConstructorInfo.GetMethodImplementationFlags()</source>
          <target state="translated">ConstructorInfo.GetMethodImplementationFlags()</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>MarshalAsAttribute</source>
          <target state="translated">MarshalAsAttribute</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Various bits.</source>
          <target state="translated">各种位。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">没有访问器。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>PreserveSigAttribute</source>
          <target state="translated">PreserveSigAttribute</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorMethodImpl.miOLE</source>
          <target state="translated">CorMethodImpl.miOLE</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>MethodInfo.GetMethodImplementationFlags().OLE</source>
          <target state="translated">MethodInfo.GetMethodImplementationFlags().OLE</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>ConstructorInfo.GetMethodImplementationFlags().OLE</source>
          <target state="translated">ConstructorInfo.GetMethodImplementationFlags().OLE</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>InAttribute</source>
          <target state="translated">InAttribute</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorParamAttr.pdIn</source>
          <target state="translated">CorParamAttr.pdIn</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>ParameterInfo.Attributes.In</source>
          <target state="translated">ParameterInfo.Attributes.In</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>OutAttribute</source>
          <target state="translated">OutAttribute</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorParamAttr.pdOut</source>
          <target state="translated">CorParamAttr.pdOut</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>ParameterInfo.Attributes.Out</source>
          <target state="translated">ParameterInfo.Attributes.Out</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>StructLayoutAttribute</source>
          <target state="translated">StructLayoutAttribute</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdLayoutSequential</source>
          <target state="translated">CorTypeAttr.tdLayoutSequential</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdExplicitLayout</source>
          <target state="translated">CorTypeAttr.tdExplicitLayout</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdAnsiClass</source>
          <target state="translated">CorTypeAttr.tdAnsiClass</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdUnicodeClass</source>
          <target state="translated">CorTypeAttr.tdUnicodeClass</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorTypeAttr.tdAutoClass</source>
          <target state="translated">CorTypeAttr.tdAutoClass</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Class packing.</source>
          <target state="translated">类封装。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.LayoutSequential</source>
          <target state="translated">Type.Attributes.LayoutSequential</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.ExplicitLayout</source>
          <target state="translated">Type.Attributes.ExplicitLayout</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.AnsiClass</source>
          <target state="translated">Type.Attributes.AnsiClass</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.UnicodeClass</source>
          <target state="translated">Type.Attributes.UnicodeClass</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Type.Attributes.AutoClass</source>
          <target state="translated">Type.Attributes.AutoClass</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">没有访问器。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>FieldOffsetAttribute</source>
          <target state="translated">FieldOffsetAttribute</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Field offset.</source>
          <target state="translated">字段的偏移量。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">没有访问器。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>AssemblyLoadAttribute</source>
          <target state="translated">AssemblyLoadAttribute</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>CorAssemblyFlags</source>
          <target state="translated">CorAssemblyFlags</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>No accessor or enumerator.</source>
          <target state="translated">没有访问器或枚举器。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type for which the custom attributes are to be returned.</source>
          <target state="translated">要为其返回自定义属性的类型。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of type <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</source>
          <target state="translated">对于 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> 类型的对象，将忽略此参数。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Gets the custom attributes for this assembly as specified by type.</source>
          <target state="translated">获取按类型指定的此程序集的自定义属性。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array that contains the custom attributes for this assembly as specified by <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>.</source>
          <target state="translated">一个数组，它包含由 <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> 指定的此程序集的自定义属性。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This method implements the corresponding <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider&gt;</ph> interface method.</source>
          <target state="translated">此方法实现相应<ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider&gt;</ph>接口方法。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Therefore, the <ph id="ph1">`inherit`</ph> parameter must be specified even though it is ignored.</source>
          <target state="translated">因此，<ph id="ph1">`inherit`</ph>必须指定参数，即使它将被忽略。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</source>
          <target state="translated">伪属性指示该属性为存在时必须设置的核心元数据位。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</source>
          <target state="translated">不同于扩展类型的元数据并保存与类型的自定义属性，一个伪属性修改类型的元数据，并则将被丢弃。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Some of the resulting bits cannot be accessed using existing reflection APIs.</source>
          <target state="translated">无法使用现有的反射 Api 访问某些生成的数据位。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</source>
          <target state="translated">下表总结了不同的伪属性和可用于反射的位的访问。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Pseudo-Attribute</source>
          <target state="translated">Pseudo-Attribute</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Metadata Bits</source>
          <target state="translated">元数据位</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Reflection Accessor</source>
          <target state="translated">反射访问器</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>DllImportAttribute</source>
          <target state="translated">Sub</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorPInvokeMap</source>
          <target state="translated">CorPInvokeMap</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>DLL name</source>
          <target state="translated">DLL 名称</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor for PInvokeMap for ordinary method/global method attributes.</source>
          <target state="translated">有关 PInvokeMap 普通方法/全局方法属性没有访问器。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor for DLL name.</source>
          <target state="translated">DLL 的名称没有访问器。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>GuidAttribute</source>
          <target state="translated">GuidAttribute</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Stored as a real custom attribute.</source>
          <target state="translated">存储的实际的自定义特性。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Accessed as a real custom attribute.</source>
          <target state="translated">访问的实际的自定义特性。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>ComImportAttribute</source>
          <target state="translated">ComImportAttribute</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdImport</source>
          <target state="translated">CorTypeAttr.tdImport</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.Import</source>
          <target state="translated">Type.Attributes.Import</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>SerializableAttribute</source>
          <target state="translated">SerializableAttribute</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdSerializable</source>
          <target state="translated">CorTypeAttr.tdSerializable</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.Serializable</source>
          <target state="translated">Type.Attributes.Serializable</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>NonSerializedAttribute</source>
          <target state="translated">NonSerializedAttribute</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorFieldAttr.fdNotSerialized</source>
          <target state="translated">CorFieldAttr.fdNotSerialized</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>FieldInfo.Attributes.NotSerialized</source>
          <target state="translated">FieldInfo.Attributes.NotSerialized</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>MethodImplAttribute</source>
          <target state="translated">MethodImplAttribute</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorMethodImpl</source>
          <target state="translated">CorMethodImpl</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>MethodInfo.GetMethodImplementationFlags()</source>
          <target state="translated">MethodInfo.GetMethodImplementationFlags()</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>ConstructorInfo.GetMethodImplementationFlags()</source>
          <target state="translated">ConstructorInfo.GetMethodImplementationFlags()</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>MarshalAsAttribute</source>
          <target state="translated">MarshalAsAttribute</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Various bits.</source>
          <target state="translated">各种位。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">没有访问器。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>PreserveSigAttribute</source>
          <target state="translated">PreserveSigAttribute</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorMethodImpl.miOLE</source>
          <target state="translated">CorMethodImpl.miOLE</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>MethodInfo.GetMethodImplementationFlags().OLE</source>
          <target state="translated">MethodInfo.GetMethodImplementationFlags().OLE</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>ConstructorInfo.GetMethodImplementationFlags().OLE</source>
          <target state="translated">ConstructorInfo.GetMethodImplementationFlags().OLE</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>InAttribute</source>
          <target state="translated">InAttribute</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorParamAttr.pdIn</source>
          <target state="translated">CorParamAttr.pdIn</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>ParameterInfo.Attributes.In</source>
          <target state="translated">ParameterInfo.Attributes.In</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>OutAttribute</source>
          <target state="translated">OutAttribute</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorParamAttr.pdOut</source>
          <target state="translated">CorParamAttr.pdOut</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>ParameterInfo.Attributes.Out</source>
          <target state="translated">ParameterInfo.Attributes.Out</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>StructLayoutAttribute</source>
          <target state="translated">StructLayoutAttribute</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdLayoutSequential</source>
          <target state="translated">CorTypeAttr.tdLayoutSequential</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdExplicitLayout</source>
          <target state="translated">CorTypeAttr.tdExplicitLayout</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdAnsiClass</source>
          <target state="translated">CorTypeAttr.tdAnsiClass</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdUnicodeClass</source>
          <target state="translated">CorTypeAttr.tdUnicodeClass</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorTypeAttr.tdAutoClass</source>
          <target state="translated">CorTypeAttr.tdAutoClass</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Class packing.</source>
          <target state="translated">类封装。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.LayoutSequential</source>
          <target state="translated">Type.Attributes.LayoutSequential</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.ExplicitLayout</source>
          <target state="translated">Type.Attributes.ExplicitLayout</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.AnsiClass</source>
          <target state="translated">Type.Attributes.AnsiClass</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.UnicodeClass</source>
          <target state="translated">Type.Attributes.UnicodeClass</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Type.Attributes.AutoClass</source>
          <target state="translated">Type.Attributes.AutoClass</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">没有访问器。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>FieldOffsetAttribute</source>
          <target state="translated">FieldOffsetAttribute</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Field offset.</source>
          <target state="translated">字段的偏移量。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor.</source>
          <target state="translated">没有访问器。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>AssemblyLoadAttribute</source>
          <target state="translated">AssemblyLoadAttribute</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>CorAssemblyFlags</source>
          <target state="translated">CorAssemblyFlags</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>No accessor or enumerator.</source>
          <target state="translated">没有访问器或枚举器。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a runtime type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> 不是运行时类型。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>Returns information about the attributes that have been applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>, expressed as <ph id="ph2">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects.</source>
          <target state="translated">返回有关已应用于当前 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>（表示为 <ph id="ph2">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> 对象）的特性的信息。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>A generic list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects representing data about the attributes that have been applied to the current assembly.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> 对象的泛型列表，这些对象表示有关已应用于当前程序集的特性的数据。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</source>
          <target state="translated">此方法用于检查要在其中加载到只反射上下文的代码中定义的自定义属性本身的情况下的仅限反射上下文中的代码的自定义属性。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>Methods like <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> cannot be used in such cases, because they create instances of the attributes.</source>
          <target state="translated">等方法<ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph>不能在这种情况下，因为它们创建实例的属性。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>Code in the reflection-only context cannot be executed.</source>
          <target state="translated">仅反射上下文中的代码不能执行。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetCustomAttributesData">
          <source>For more information and for example code, see the <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> class.</source>
          <target state="translated">有关详细信息和有关示例代码，请参阅<ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>Gets the process executable in the default application domain.</source>
          <target state="translated">获取默认应用程序域中的进程可执行文件。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>In other application domains, this is the first executable that was executed by <ph id="ph1">&lt;see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /&gt;</ph>.</source>
          <target state="translated">在其他的应用程序域中，这是由 <ph id="ph1">&lt;see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /&gt;</ph> 执行的第一个可执行文件。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>The assembly that is the process executable in the default application domain, or the first executable that was executed by <ph id="ph1">&lt;see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /&gt;</ph>.</source>
          <target state="translated">程序集是默认应用程序域中的进程可执行文件，或是由 <ph id="ph1">&lt;see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /&gt;</ph> 执行的第一个可执行文件。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>Can return <ph id="ph1">&lt;see langword="null" /&gt;</ph> when called from unmanaged code.</source>
          <target state="translated">当从非托管代码调用时可返回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetEntryAssembly%2A&gt;</ph> method can return <ph id="ph2">`null`</ph> when a managed assembly has been loaded from an unmanaged application.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.GetEntryAssembly%2A&gt;</ph>方法可以返回<ph id="ph2">`null`</ph>托管程序集已从非托管应用程序加载。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetEntryAssembly">
          <source>For example, if an unmanaged application creates an instance of a COM component written in C#, a call to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetEntryAssembly%2A&gt;</ph> method from the C# component returns null, because the entry point for the process was unmanaged code rather than a managed assembly.</source>
          <target state="translated">例如，如果非托管应用程序创建的编写 C# 中，调用的 COM 组件实例<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetEntryAssembly%2A&gt;</ph>从 C# 组件的方法将返回 null，因为该过程的入口点非托管的代码而不是托管程序集。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>Gets the assembly that contains the code that is currently executing.</source>
          <target state="translated">获取包含当前执行的代码的程序集。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>The assembly that contains the code that is currently executing.</source>
          <target state="translated">包含当前执行的代码的程序集。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>For performance reasons, you should call this method only when you do not know at design time what assembly is currently executing.</source>
          <target state="translated">出于性能原因，你应仅当你不知道在设计时当前正在执行哪些程序集时才调用此方法。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>The recommended way to retrieve an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object that represents the current assembly is to use the <ph id="ph2">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> property of a type found in the assembly, as the following example illustrates.</source>
          <target state="translated">检索的建议的方法<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>对象，表示当前程序集是使用<ph id="ph2">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph>如下面的示例所示，在程序集中，找到的一种类型的属性。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>To get the assembly that contains the method that called the currently executing code, use <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>.</source>
          <target state="translated">若要获取包含调用当前正在执行代码的方法的程序集，请使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetCallingAssembly%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> property to get the currently executing assembly based on a type contained in that assembly.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph>要获取当前正在执行的程序集属性基于该程序集中所包含的类型。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExecutingAssembly">
          <source>It also calls the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExecutingAssembly%2A&gt;</ph> method to show that it returns an <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> object that represents the same assembly.</source>
          <target state="translated">它还会调用<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExecutingAssembly%2A&gt;</ph>方法来显示它返回<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>表示相同的程序集的对象。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>Gets the public types defined in this assembly that are visible outside the assembly.</source>
          <target state="translated">获取此程序集中定义的公共类型，这些公共类型在程序集外可见。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>An array that represents the types defined in this assembly that are visible outside the assembly.</source>
          <target state="translated">一个数组，表示此程序集中定义并在程序集外可见的类型。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>The only types visible outside an assembly are public types and public types nested within other public types.</source>
          <target state="translated">程序集外部可见的唯一类型是公共类型和嵌套在其他公共类型的公共类型。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>The following code sample defines a number of classes with various access levels, and calls <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A&gt;</ph> to display the ones that are visible from outside the assembly.</source>
          <target state="translated">下面的代码示例定义了多个类使用各种访问级别和调用<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A&gt;</ph>以显示在程序集外部可见的。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>The assembly is a dynamic assembly.</source>
          <target state="translated">程序集是动态程序集。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetExportedTypes">
          <source>Unable to load a dependent assembly.</source>
          <target state="translated">无法加载从属程序集。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>The name of the specified file.</source>
          <target state="translated">指定文件的名称。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>Do not include the path to the file.</source>
          <target state="translated">不包括文件的路径。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> for the specified file in the file table of the manifest of this assembly.</source>
          <target state="translated">获取此程序集清单的文件表中指定文件的 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>A stream that contains the specified file, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the file is not found.</source>
          <target state="translated">包含指定文件的流，如果找不到文件则为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>This method works on both public and private resource files.</source>
          <target state="translated">此方法对这两个公共和私有资源文件起作用。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>The <ph id="ph1">`name`</ph> should not include the path to the file.</source>
          <target state="translated"><ph id="ph1">`name`</ph>不应包含文件的路径。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 参数为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="name" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>for access to the path and for reading the specified file.</source>
          <target state="translated">访问路径，用于读取指定的文件。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFile(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph> and <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>和 <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets the files in the file table of an assembly manifest.</source>
          <target state="translated">获取程序集清单文件表中的文件。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles">
          <source>Gets the files in the file table of an assembly manifest.</source>
          <target state="translated">获取程序集清单文件表中的文件。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles">
          <source>An array of streams that contain the files.</source>
          <target state="translated">包含这些文件的流数组。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFiles">
          <source>This method works on public and private resource files.</source>
          <target state="translated">此方法对公共和私有资源文件起作用。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFiles">
          <source>This overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29&gt;</ph> overload and specifying <ph id="ph2">`false`</ph>.</source>
          <target state="translated">此重载是等效于调用<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29&gt;</ph>重载并指定<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles">
          <source>A file was not found.</source>
          <target state="translated">未找到文件。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles">
          <source>A file was not a valid assembly.</source>
          <target state="translated">文件不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to include resource modules; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 则包括资源模块；否则，为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>Gets the files in the file table of an assembly manifest, specifying whether to include resource modules.</source>
          <target state="translated">获取程序集清单的文件表中的文件，指定是否包括资源模块。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>An array of streams that contain the files.</source>
          <target state="translated">包含这些文件的流数组。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>This method works on public and private resource files.</source>
          <target state="translated">此方法对公共和私有资源文件起作用。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>A file was not found.</source>
          <target state="translated">未找到文件。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetFiles(System.Boolean)">
          <source>A file was not a valid assembly.</source>
          <target state="translated">文件不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">返回此实例的哈希代码。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">32 位有符号整数哈希代码。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets all the loaded modules that are part of this assembly.</source>
          <target state="translated">获取作为此程序集的一部分的所有加载模块。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetLoadedModules">
          <source>Gets all the loaded modules that are part of this assembly.</source>
          <target state="translated">获取作为此程序集的一部分的所有加载模块。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetLoadedModules">
          <source>An array of modules.</source>
          <target state="translated">模块的数组。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to include resource modules; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 则包括资源模块；否则，为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)">
          <source>Gets all the loaded modules that are part of this assembly, specifying whether to include resource modules.</source>
          <target state="translated">获取属于此程序集的所有已加载模块，同时指定是否包括资源模块。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)">
          <source>An array of modules.</source>
          <target state="translated">模块的数组。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>The case-sensitive name of the resource.</source>
          <target state="translated">区分大小写的资源名称。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>Returns information about how the given resource has been persisted.</source>
          <target state="translated">返回关于给定资源如何保持的信息。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>An object that is populated with information about the resource's topology, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the resource is not found.</source>
          <target state="translated">用关于资源拓扑的信息填充的对象；如果未找到资源，则为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>Resource information is returned only if the resource is visible to the caller, or the caller has <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">仅当资源对调用方可见或调用方具有返回资源信息<ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceName" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="resourceName" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceName" /&gt;</ph> 参数为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>Returns the names of all the resources in this assembly.</source>
          <target state="translated">返回此程序集中的所有资源的名称。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>An array that contains the names of all the resources.</source>
          <target state="translated">包含所有资源名称的数组。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>You can use each resource name in the array returned by this method as follows:</source>
          <target state="translated">返回此方法，如下所示的数组中，可以使用每个资源名称：</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>You can pass the resource name to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceInfo%2A&gt;</ph> method to get additional information about the resource.</source>
          <target state="translated">你可以将传递到的资源名称<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceInfo%2A&gt;</ph>方法以获取有关资源的其他信息。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>If the name identifies a binary .resources file, you can remove its .resources file extension and pass it to the <ph id="ph1">&lt;xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType&gt;</ph> constructor to instantiate the resource manager.</source>
          <target state="translated">如果该名称标识的二进制.resources 文件，你可以删除其.resources 文件扩展名，然后将其传递到<ph id="ph1">&lt;xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType&gt;</ph>构造函数实例化的资源管理器。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>You can pass the resource name to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> object that you can then pass to the <ph id="ph3">&lt;xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">你可以将传递到的资源名称<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph>方法来检索<ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph>对象，然后你可以将其传递给<ph id="ph3">&lt;xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>You can pass the resource name to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> object that you can then pass to the <ph id="ph3">&lt;xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">你可以将传递到的资源名称<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph>方法来检索<ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph>对象，然后你可以将其传递给<ph id="ph3">&lt;xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>Resource information is returned only if the resource is visible to the caller, or the caller has <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">仅当资源对调用方可见或调用方具有返回资源信息<ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceNames">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads the specified manifest resource from this assembly.</source>
          <target state="translated">从此程序集加载指定的清单资源。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>The case-sensitive name of the manifest resource being requested.</source>
          <target state="translated">所请求的清单资源的名称（区分大小写）。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>Loads the specified manifest resource from this assembly.</source>
          <target state="translated">从此程序集加载指定的清单资源。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>The manifest resource; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no resources were specified during compilation or if the resource is not visible to the caller.</source>
          <target state="translated">如果在编译期间没有指定任何资源，或者资源对调用方不可见，则为清单资源或者为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</source>
          <target state="translated">清单资源是嵌入在编译时程序集中的某个资源 （例如图像文件）。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>For more information about manifest resources, see <bpt id="p1">[</bpt>Microsoft .NET Framework Resource Basics<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=204554)</ept> in the MSDN Library.</source>
          <target state="translated">有关清单资源的详细信息，请参阅<bpt id="p1">[</bpt>Microsoft.NET Framework 资源基础知识<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=204554)</ept>MSDN 库中。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>Resource information is returned only if the resource is visible to the caller, or the caller has <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">仅当资源对调用方可见或调用方具有返回资源信息<ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>This method returns <ph id="ph1">`null`</ph> if a private resource in another assembly is accessed and the caller does not have <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">此方法返回<ph id="ph1">`null`</ph>如果访问另一个程序集中的私有资源并且调用方没有<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>与<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph>标志。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>If the assembly manifest lists a resource file, <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> returns a <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> object even if the resource file cannot be found on disk at the time.</source>
          <target state="translated">如果程序集清单列出的资源文件，<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph>返回<ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph>对象即使资源文件不能在时找到磁盘上。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>If the resource file is not found, passing the resulting <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> object to the <ph id="ph2">&lt;xref:System.Resources.ResourceReader&gt;</ph> constructor causes an <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">如果找不到资源文件，则传递生成<ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph>对象传递给<ph id="ph2">&lt;xref:System.Resources.ResourceReader&gt;</ph>构造函数导致<ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 参数为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">在<bpt id="p1">[</bpt>适用于 Windows 应用商店应用的 .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> 或<bpt id="p2">[</bpt>可移植类库<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>中，改为捕获基类异常 <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="name" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>Resource length is greater than <ph id="ph1">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</source>
          <target state="translated">资源的长度大于 <ph id="ph1">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>The type whose namespace is used to scope the manifest resource name.</source>
          <target state="translated">其命名空间用于确定清单资源名的范围的类型。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>The case-sensitive name of the manifest resource being requested.</source>
          <target state="translated">所请求的清单资源的名称（区分大小写）。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>Loads the specified manifest resource, scoped by the namespace of the specified type, from this assembly.</source>
          <target state="translated">从此程序集加载指定清单资源，清单资源的范围由指定类型的命名空间确定。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>The manifest resource; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no resources were specified during compilation or if the resource is not visible to the caller.</source>
          <target state="translated">如果在编译期间没有指定任何资源，或者资源对调用方不可见，则为清单资源或者为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>For example, if the full name specified for <ph id="ph1">`type`</ph> is "MyNameSpace.MyClasses" and <ph id="ph2">`name`</ph> is "Net", this method overload searches for a resource named "MyNameSpace.Net".</source>
          <target state="translated">例如，如果为指定的完整名称<ph id="ph1">`type`</ph>是"MyNameSpace.MyClasses"和<ph id="ph2">`name`</ph>是"Net"，此方法重载搜索名为"MyNameSpace.Net"的资源。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</source>
          <target state="translated">清单资源是嵌入在编译时程序集中的某个资源 （例如图像文件）。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>For more information about manifest resources, see <bpt id="p1">[</bpt>Microsoft .NET Framework Resource Basics<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=204554)</ept> in the MSDN Library.</source>
          <target state="translated">有关清单资源的详细信息，请参阅<bpt id="p1">[</bpt>Microsoft.NET Framework 资源基础知识<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=204554)</ept>MSDN 库中。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>Resource information is returned only if the resource is visible to the caller, or the caller has <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">仅当资源对调用方可见或调用方具有返回资源信息<ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>This method returns <ph id="ph1">`null`</ph> if a private resource in another assembly is accessed and the caller does not have <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">此方法返回<ph id="ph1">`null`</ph>如果访问另一个程序集中的私有资源并且调用方没有<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>与<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph>标志。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>If the assembly manifest lists a resource file, <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph> returns a <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> object even if the resource file cannot be found on disk at the time.</source>
          <target state="translated">如果程序集清单列出的资源文件，<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetManifestResourceStream%2A&gt;</ph>返回<ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph>对象即使资源文件不能在时找到磁盘上。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>If the resource file is not found, passing the resulting <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> object to the <ph id="ph2">&lt;xref:System.Resources.ResourceReader&gt;</ph> constructor causes an <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">如果找不到资源文件，则传递生成<ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph>对象传递给<ph id="ph2">&lt;xref:System.Resources.ResourceReader&gt;</ph>构造函数导致<ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 参数为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="name" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>Resource length is greater than <ph id="ph1">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</source>
          <target state="translated">资源的长度大于 <ph id="ph1">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>The name of the module being requested.</source>
          <target state="translated">请求的模块的名称。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Gets the specified module in this assembly.</source>
          <target state="translated">获取此程序集中的指定模块。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>The module being requested, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the module is not found.</source>
          <target state="translated">所请求的模块，若未找到该模块则为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>This method works on file names.</source>
          <target state="translated">此方法适用于文件的名称。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Classes in the <ph id="ph1">`Reflection.Emit`</ph> namespace emit the scope name for a dynamic module.</source>
          <target state="translated">中的类<ph id="ph1">`Reflection.Emit`</ph>命名空间发出的动态模块的范围名称。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>The scope name can be determined by the <ph id="ph1">&lt;xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">可以通过确定作用域名称<ph id="ph1">&lt;xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Pass the kind of module you want to <ph id="ph1">`Assembly.GetModule`</ph>.</source>
          <target state="translated">传递到所需的模块类型<ph id="ph1">`Assembly.GetModule`</ph>。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>For example, if you want the module that contains the assembly manifest, pass the scope name of the module to <ph id="ph1">`GetModule`</ph>.</source>
          <target state="translated">例如，如果你想包含程序集清单的模块，传递到模块作用域名称<ph id="ph1">`GetModule`</ph>。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Otherwise, pass the file name of the module.</source>
          <target state="translated">否则，将传递该模块的文件名。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Assemblies loaded by one of the <ph id="ph1">`Load`</ph> methods that have a byte[] parameter have only one module, and that is the manifest module.</source>
          <target state="translated">程序集加载的之一<ph id="ph1">`Load`</ph>具有 byte [] 参数的方法具有只有一个模块，并且这是清单的模块。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Always seek these modules using the scope name.</source>
          <target state="translated">始终查找这些模块使用该作用域名称。</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>A type can be retrieved from a specific module using <ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">一种类型可检索特定模块使用<ph id="ph1">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>Calling <ph id="ph1">`Module.GetType`</ph> on the module containing the manifest will not initiate a search of the entire assembly.</source>
          <target state="translated">调用<ph id="ph1">`Module.GetType`</ph>模块包含清单将不会发起的整个程序集搜索。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>To retrieve a type from an assembly, regardless of which module it is in, you must call <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">若要从一个程序集，无论是哪个模块什么会在中，检索类型必须调用<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 参数为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> was not found.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="name" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModule(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets all the modules that are part of this assembly.</source>
          <target state="translated">获取作为此程序集的一部分的所有模块。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules">
          <source>Gets all the modules that are part of this assembly.</source>
          <target state="translated">获取作为此程序集的一部分的所有模块。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules">
          <source>An array of modules.</source>
          <target state="translated">模块的数组。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModules">
          <source>This method works on public and private resource files.</source>
          <target state="translated">此方法对公共和私有资源文件起作用。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModules">
          <source>Modules must be emitted with file name extensions.</source>
          <target state="translated">模块必须发出具有文件扩展名。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModules">
          <source>The following example displays the name of the module in the returned array that contains the assembly manifest.</source>
          <target state="translated">下面的示例显示返回的数组，其中包含程序集清单的模块的名称。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules">
          <source>The module to be loaded does not specify a file name extension.</source>
          <target state="translated">要加载的模块未指定文件扩展名。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to include resource modules; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 则包括资源模块；否则，为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules(System.Boolean)">
          <source>Gets all the modules that are part of this assembly, specifying whether to include resource modules.</source>
          <target state="translated">获取属于此程序集的所有模块，同时指定是否包括资源模块。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetModules(System.Boolean)">
          <source>An array of modules.</source>
          <target state="translated">模块的数组。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModules(System.Boolean)">
          <source>This method works on public and private resource files.</source>
          <target state="translated">此方法对公共和私有资源文件起作用。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetModules(System.Boolean)">
          <source>Modules must be emitted with file name extensions.</source>
          <target state="translated">模块必须发出具有文件扩展名。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> for this assembly.</source>
          <target state="translated">获取此程序集的 <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetName">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> for this assembly.</source>
          <target state="translated">获取此程序集的 <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetName">
          <source>An object that contains the fully parsed display name for this assembly.</source>
          <target state="translated">包含此程序集的完全分析的显示名称的对象。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetName">
          <source>for access to the path of the assembly.</source>
          <target state="translated">用于访问程序集的路径。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetName">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetName(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the <ph id="ph2">&lt;see cref="P:System.Reflection.Assembly.CodeBase" /&gt;</ph> to the location of the assembly after it was shadow copied; <ph id="ph3">&lt;see langword="false" /&gt;</ph> to set <ph id="ph4">&lt;see cref="P:System.Reflection.Assembly.CodeBase" /&gt;</ph> to the original location.</source>
          <target state="translated">如果为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，则将 <ph id="ph2">&lt;see cref="P:System.Reflection.Assembly.CodeBase" /&gt;</ph> 设置为程序集被影像复制后的位置；如果为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>，则将 <ph id="ph4">&lt;see cref="P:System.Reflection.Assembly.CodeBase" /&gt;</ph> 设置为原位置。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetName(System.Boolean)">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> for this assembly, setting the codebase as specified by <ph id="ph2">&lt;paramref name="copiedName" /&gt;</ph>.</source>
          <target state="translated">获取此程序集的 <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>，并按 <ph id="ph2">&lt;paramref name="copiedName" /&gt;</ph> 指定的那样设置基本代码。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetName(System.Boolean)">
          <source>An object that contains the fully parsed display name for this assembly.</source>
          <target state="translated">包含此程序集的完全分析的显示名称的对象。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetName(System.Boolean)">
          <source>for access to the path of the assembly.</source>
          <target state="translated">用于访问程序集的路径。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetName(System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object to be populated with serialization information.</source>
          <target state="translated">用序列化信息填充的对象。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The destination context of the serialization.</source>
          <target state="translated">序列化的目标上下文。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Gets serialization information with all of the data needed to reinstantiate this assembly.</source>
          <target state="translated">获取序列化信息，其中包含重新实例化此程序集所需的所有数据。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> objects for all the assemblies referenced by this assembly.</source>
          <target state="translated">获取此程序集引用的所有程序集的 <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>An array that contains the fully parsed display names of all the assemblies referenced by this assembly.</source>
          <target state="translated">包含此程序集引用的所有程序集的完全分析的显示名称的数组。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.HashAlgorithm%2A&gt;</ph> property of an <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object that is returned by this method is <ph id="ph4">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType&gt;</ph> if there is no hash algorithm for the referenced assembly, or if the hash algorithm of the referenced assembly is not identified by the <ph id="ph5">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>、<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.HashAlgorithm%2A&gt;</ph>属性<ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph>此方法返回的对象是<ph id="ph4">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType&gt;</ph>如果没有引用的程序集，哈希算法或引用的程序集的哈希算法不是由标识<ph id="ph5">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType&gt;</ph>枚举。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>In previous versions of the .NET Framework, the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.HashAlgorithm%2A&gt;</ph> property returned <ph id="ph2">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType&gt;</ph> in this situation.</source>
          <target state="translated">在以前版本的.NET Framework 中，<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.HashAlgorithm%2A&gt;</ph>属性返回<ph id="ph2">&lt;xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType&gt;</ph>在此情况下。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>The following code example demonstrates calling the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetReferencedAssemblies%2A&gt;</ph> method.</source>
          <target state="translated">下面的代码示例演示如何调用<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetReferencedAssemblies%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetReferencedAssemblies">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> class.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets the satellite assembly.</source>
          <target state="translated">获取附属程序集。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The specified culture.</source>
          <target state="translated">指定的区域性。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>Gets the satellite assembly for the specified culture.</source>
          <target state="translated">获取指定区域性的附属程序集。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The specified satellite assembly.</source>
          <target state="translated">指定的附属程序集。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</source>
          <target state="translated">附属程序集包含本地化的资源，不同于主应用程序程序集，其中包含非本地化可执行代码和单个区域性用作默认或非特定区域性的资源。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>Call this method to use your current assembly version.</source>
          <target state="translated">调用此方法以使用您当前的程序集版本。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The assembly cannot be found.</source>
          <target state="translated">找不到此程序集。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The satellite assembly with a matching file name was found, but the <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> did not match the one specified.</source>
          <target state="translated">找到了具有匹配文件名的附属程序集，但 <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> 与所指定的不匹配。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)">
          <source>The satellite assembly is not a valid assembly.</source>
          <target state="translated">附属程序集不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The specified culture.</source>
          <target state="translated">指定的区域性。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The version of the satellite assembly.</source>
          <target state="translated">附属程序集的版本。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>Gets the specified version of the satellite assembly for the specified culture.</source>
          <target state="translated">获取指定区域性的附属程序集的指定版本。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The specified satellite assembly.</source>
          <target state="translated">指定的附属程序集。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</source>
          <target state="translated">附属程序集包含本地化的资源，不同于主应用程序程序集，其中包含非本地化可执行代码和单个区域性用作默认或非特定区域性的资源。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>Call the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29&gt;</ph> overload to use your current assembly version.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29&gt;</ph>重载以使用你当前的程序集版本。</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>If <ph id="ph1">`version`</ph> is <ph id="ph2">`null`</ph>, the current assembly version is used if both the resource and main assemblies are signed.</source>
          <target state="translated">如果<ph id="ph1">`version`</ph>是<ph id="ph2">`null`</ph>，如果资源和主程序集进行签名，则使用当前的程序集版本。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The satellite assembly with a matching file name was found, but the <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> or the version did not match the one specified.</source>
          <target state="translated">找到了具有匹配的文件名的附属程序集，但 <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> 或版本与所指定的不匹配。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The assembly cannot be found.</source>
          <target state="translated">找不到该程序集。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
          <source>The satellite assembly is not a valid assembly.</source>
          <target state="translated">附属程序集不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the specified type.</source>
          <target state="translated">获取表示指定类型的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>The full name of the type.</source>
          <target state="translated">类型的全名。</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object with the specified name in the assembly instance.</source>
          <target state="translated">获取程序集实例中具有指定名称的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>An object that represents the specified class, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the class is not found.</source>
          <target state="translated">表示指定类的对象，若未找到该类则为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>This method only searches the current assembly instance.</source>
          <target state="translated">此方法仅搜索当前程序集实例。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>The <ph id="ph1">`name`</ph> parameter includes the namespace but not the assembly.</source>
          <target state="translated"><ph id="ph1">`name`</ph>参数包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>To search other assemblies for a type, use the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph> method overload, which can optionally include an assembly display name as part of the type name.</source>
          <target state="translated">若要搜索的一种类型的其他程序集，请使用<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph>方法重载，它可以选择性地包含程序集显示名称作为类型名称的一部分。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">如果类型已被转发给另一个程序集，它仍将返回此方法。</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">类型转发的信息，请参阅<bpt id="p1">[</bpt>公共语言运行时中的类型转发<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>The following example defines an abstract <ph id="ph1">`MeansOfTransportation`</ph> class in the <ph id="ph2">`Transportation`</ph> namespace.</source>
          <target state="translated">下面的示例定义一个抽象<ph id="ph1">`MeansOfTransportation`</ph>类<ph id="ph2">`Transportation`</ph>命名空间。</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>It calls the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%29&gt;</ph> method to retrieve its <ph id="ph2">&lt;xref:System.Type&gt;</ph> object, calls the <ph id="ph3">&lt;xref:System.Type.GetProperties%2A?displayProperty=nameWithType&gt;</ph> method to get an array of <ph id="ph4">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects that represent the type's properties, and then displays information on the type's abstract properties.</source>
          <target state="translated">它调用<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%29&gt;</ph>方法来检索其<ph id="ph2">&lt;xref:System.Type&gt;</ph>对象、 调用<ph id="ph3">&lt;xref:System.Type.GetProperties%2A?displayProperty=nameWithType&gt;</ph>方法以获取数组的<ph id="ph4">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>对象，表示该类型的属性，然后将信息显示在该类型的抽象属性。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>Note that the call to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%29&gt;</ph> method uses the type's fully qualified name (that is, its namespace along with its type name).</source>
          <target state="translated">请注意，调用<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%29&gt;</ph>方法使用该类型的完全限定的名称 （即，其类型名称以及其命名空间）。</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 所需的从属程序集无法找到。</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">在<bpt id="p1">[</bpt>适用于 Windows 应用商店应用的 .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> 或<bpt id="p2">[</bpt>可移植类库<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>中，改为捕获基类异常 <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;/para&gt;</ph><ph id="ph2">
</ph><ph id="ph3">&lt;/block&gt;</ph><ph id="ph4">
</ph><ph id="ph5">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;/para&gt;</ph><ph id="ph2">
</ph><ph id="ph3">&lt;/block&gt;</ph><ph id="ph4">
</ph><ph id="ph5">&lt;paramref name="name" /&gt;</ph> 所需的从属程序集已找到，但无法加载。</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">当前程序集被加载到仅反射上下文中，并且 <ph id="ph1">&lt;paramref name="name" /&gt;</ph> 所需的从属程序集未预先加载。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 需要一个从属程序集，但该文件不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>The full name of the type.</source>
          <target state="translated">类型的全名。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type is not found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示在找不到该类型时引发异常；<ph id="ph2">&lt;see langword="false" /&gt;</ph> 则表示返回 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object with the specified name in the assembly instance and optionally throws an exception if the type is not found.</source>
          <target state="translated">获取程序集实例中具有指定名称的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象，并选择在找不到该类型时引发异常。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>An object that represents the specified class.</source>
          <target state="translated">表示指定类的对象。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>This method only searches the current assembly instance.</source>
          <target state="translated">此方法仅搜索当前程序集实例。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">`name`</ph> parameter includes the namespace but not the assembly.</source>
          <target state="translated"><ph id="ph1">`name`</ph>参数包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>To search other assemblies for a type, use the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph> method overload, which can optionally include an assembly display name as part of the type name.</source>
          <target state="translated">若要搜索的一种类型的其他程序集，请使用<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph>方法重载，它可以选择性地包含程序集显示名称作为类型名称的一部分。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">如果类型已被转发给另一个程序集，它仍将返回此方法。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">类型转发的信息，请参阅<bpt id="p1">[</bpt>公共语言运行时中的类型转发<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter only affects what happens when the type is not found.</source>
          <target state="translated"><ph id="ph1">`throwOnError`</ph>参数仅影响找不到类型时，会发生什么情况。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>It does not affect any other exceptions that might be thrown.</source>
          <target state="translated">它不会影响任何其他可能引发的异常。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>In particular, if the type is found but cannot be loaded, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> can be thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">具体而言，如果找到的类型，但不能加载，<ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph>可以引发即使<ph id="ph2">`throwOnError`</ph>是<ph id="ph3">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> exceeds 1024 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 的长度超过 1024 个字符。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, and the type cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，且找不到此类型。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 所需的从属程序集无法找到。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 所需的从属程序集已找到，但无法加载。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">当前程序集被加载到仅反射上下文中，并且 <ph id="ph1">&lt;paramref name="name" /&gt;</ph> 所需的从属程序集未预先加载。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 需要一个从属程序集，但该文件不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The full name of the type.</source>
          <target state="translated">类型的全名。</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type is not found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 表示在找不到该类型时引发异常；<ph id="ph2">&lt;see langword="false" /&gt;</ph> 则表示返回 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore the case of the type name; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，则忽略类型名的大小写；否则，为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object with the specified name in the assembly instance, with the options of ignoring the case, and of throwing an exception if the type is not found.</source>
          <target state="translated">获取程序集实例中具有指定名称的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象，带有忽略大小写和在找不到该类型时引发异常的选项。</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An object that represents the specified class.</source>
          <target state="translated">表示指定类的对象。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>This method only searches the current assembly instance.</source>
          <target state="translated">此方法仅搜索当前程序集实例。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`name`</ph> parameter includes the namespace but not the assembly.</source>
          <target state="translated"><ph id="ph1">`name`</ph>参数包含命名空间而不是程序集。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To search other assemblies for a type, use the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph> method overload, which can optionally include an assembly display name as part of the type name.</source>
          <target state="translated">若要搜索的一种类型的其他程序集，请使用<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType&gt;</ph>方法重载，它可以选择性地包含程序集显示名称作为类型名称的一部分。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type has been forwarded to another assembly, it is still returned by this method.</source>
          <target state="translated">如果类型已被转发给另一个程序集，它仍将返回此方法。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">类型转发的信息，请参阅<bpt id="p1">[</bpt>公共语言运行时中的类型转发<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter only affects what happens when the type is not found.</source>
          <target state="translated"><ph id="ph1">`throwOnError`</ph>参数仅影响找不到类型时，会发生什么情况。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>It does not affect any other exceptions that might be thrown.</source>
          <target state="translated">它不会影响任何其他可能引发的异常。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In particular, if the type is found but cannot be loaded, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> can be thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">具体而言，如果找到的类型，但不能加载，<ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph>可以引发即使<ph id="ph2">`throwOnError`</ph>是<ph id="ph3">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> exceeds 1024 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 的长度超过 1024 个字符。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, and the type cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="true" /&gt;</ph>，且找不到此类型。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 所需的从属程序集无法找到。</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was found but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 所需的从属程序集已找到，但无法加载。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The current assembly was loaded into the reflection-only context, and <ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly that was not preloaded.</source>
          <target state="translated">当前程序集被加载到仅反射上下文中，并且 <ph id="ph1">&lt;paramref name="name" /&gt;</ph> 所需的从属程序集未预先加载。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly, but the file is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 需要一个从属程序集，但该文件不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetTypes">
          <source>Gets the types defined in this assembly.</source>
          <target state="translated">获取此程序集中定义的类型。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetTypes">
          <source>An array that contains all the types that are defined in this assembly.</source>
          <target state="translated">一个数组，包含此程序集中定义的所有类型。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>The returned array includes nested types.</source>
          <target state="translated">返回的数组包含嵌套的类型。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> method is called on an assembly and a type in that assembly is dependent on a type in an assembly that has not been loaded (for example, if it derives from a type in the second assembly), a <ph id="ph2">&lt;xref:System.Reflection.ReflectionTypeLoadException&gt;</ph> is thrown.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph>对程序集和类型调用方法，该程序集中依赖于尚未加载 （例如，如果它派生于第二个程序集中的类型），程序集中的类型<ph id="ph2">&lt;xref:System.Reflection.ReflectionTypeLoadException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>For example, this can happen if the first assembly was loaded with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods, and the second assembly was not loaded.</source>
          <target state="translated">例如，可能的原因是第一个程序集被加载与<ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph>方法和第二个程序集未加载。</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>It can also happen with assemblies loaded using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> methods if the second assembly cannot be located when the <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> method is called.</source>
          <target state="translated">它也可能会导致与使用加载的程序集<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法如果第二个程序集不能定位时<ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph>调用方法。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>If a type has been forwarded to another assembly, it is not included in the returned array.</source>
          <target state="translated">如果类型已被转发给另一个程序集，它不是包括在返回的数组。</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>For information on type forwarding, see <bpt id="p1">[</bpt>Type Forwarding in the Common Language Runtime<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>.</source>
          <target state="translated">类型转发的信息，请参阅<bpt id="p1">[</bpt>公共语言运行时中的类型转发<ept id="p1">](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)</ept>。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>To retrieve a collection of <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> objects instead of an array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects, use the <ph id="ph3">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">若要检索的集合<ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph>对象而不是数组的<ph id="ph2">&lt;xref:System.Type&gt;</ph>对象，请使用<ph id="ph3">&lt;xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.GetTypes">
          <source>The following example displays parameters of one method on a type in the specified assembly.</source>
          <target state="translated">下面的示例显示在指定的程序集中的类型上的一种方法的参数。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetTypes">
          <source>The assembly contains one or more types that cannot be loaded.</source>
          <target state="translated">该程序集包含一个或多个无法加载的类型。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.GetTypes">
          <source>The array returned by the <ph id="ph1">&lt;see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /&gt;</ph> property of this exception contains a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object for each type that was loaded and <ph id="ph3">&lt;see langword="null" /&gt;</ph> for each type that could not be loaded, while the <ph id="ph4">&lt;see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /&gt;</ph> property contains an exception for each type that could not be loaded.</source>
          <target state="translated">此异常的 <ph id="ph1">&lt;see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /&gt;</ph> 属性返回的数组针对已加载的每个类型包含一个 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 对象，针对无法加载的每个类型包含一个 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，而 <ph id="ph4">&lt;see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /&gt;</ph> 属性针对无法加载的每个类型包含一个异常。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.GlobalAssemblyCache">
          <source>Gets a value indicating whether the assembly was loaded from the global assembly cache.</source>
          <target state="translated">获取一个值，该值指示程序集是否是从全局程序集缓存加载的。</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.GlobalAssemblyCache">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the assembly was loaded from the global assembly cache; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果程序集是从全局程序集缓存加载的，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.HostContext">
          <source>Gets the host context with which the assembly was loaded.</source>
          <target state="translated">获取用于加载程序集的主机上下文。</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.HostContext">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph> value that indicates the host context with which the assembly was loaded, if any.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Int64" /&gt;</ph> 值，指示用于加载程序集的主机上下文（如果有）。</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>Gets a string representing the version of the common language runtime (CLR) saved in the file containing the manifest.</source>
          <target state="translated">获取表示公共语言运行时 (CLR) 的版本的字符串，该信息保存在包含清单的文件中。</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>The CLR version folder name.</source>
          <target state="translated">CLR 版本的文件夹名。</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>This is not a full path.</source>
          <target state="translated">这不是完整路径。</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>For example, the value for the .NET Framework version 1.1 would be v1.1.4322.</source>
          <target state="translated">例如，.NET Framework 1.1 版的值将 v1.1.4322。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>The binary files for that version would be located in the path %windir%\Microsoft.NET\Framework\v1.1.4322.</source>
          <target state="translated">该版本的二进制文件将位于路径 %windir%\microsoft.net\framework\v1.1.4322。</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>By default, <ph id="ph1">&lt;xref:System.Reflection.Assembly.ImageRuntimeVersion%2A&gt;</ph> is set to the version of the CLR used to build the assembly.</source>
          <target state="translated">默认情况下，<ph id="ph1">&lt;xref:System.Reflection.Assembly.ImageRuntimeVersion%2A&gt;</ph>已设置为用于生成程序集的 clr 版本。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ImageRuntimeVersion">
          <source>However, it might have been set to another value at compile time.</source>
          <target state="translated">但是，它可能已设置为其他值在编译时。</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source>The type of the attribute to be checked for this assembly.</source>
          <target state="translated">要为此程序集检查的属性类型。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">对于该类型的对象，将忽略此自变量。</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source>Indicates whether or not a specified attribute has been applied to the assembly.</source>
          <target state="translated">指示指定的属性是否已应用于该程序集。</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the attribute has been applied to the assembly; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果已将该属性应用于程序集，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source>The following code example applies the <ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph> attribute to an assembly and then uses <ph id="ph2">&lt;xref:System.Reflection.Assembly.IsDefined%2A&gt;</ph> to indicate whether it was applied.</source>
          <target state="translated">下面的代码示例适用<ph id="ph1">&lt;xref:System.Reflection.AssemblyTitleAttribute&gt;</ph>属性设置为程序集，然后使用<ph id="ph2">&lt;xref:System.Reflection.Assembly.IsDefined%2A&gt;</ph>以指示它是否已应用。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source>It also tests an attribute that was not applied.</source>
          <target state="translated">它还会测试未应用的属性。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> uses an invalid type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> 使用的类型无效。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.IsDynamic">
          <source>Gets a value that indicates whether the current assembly was generated dynamically in the current process by using reflection emit.</source>
          <target state="translated">获取一个值，该值指示当前程序集是否是通过使用反射发出在当前进程中动态生成的。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.IsDynamic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current assembly was generated dynamically in the current process; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果当前程序集是在当前进程中动态生成的，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.IsDynamic">
          <source>Dynamic assemblies are represented by the derived class <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>.</source>
          <target state="translated">由派生类表示动态程序集<ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.IsDynamic">
          <source>When a dynamic assembly is saved to disk, the saved assembly is not dynamic.</source>
          <target state="translated">当动态程序集保存到磁盘，已保存的程序集不是动态的。</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.IsDynamic">
          <source>If the saved assembly is loaded into another application domain or process, the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsDynamic%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">如果已保存的程序集加载到另一个应用程序域或进程，<ph id="ph1">&lt;xref:System.Reflection.Assembly.IsDynamic%2A&gt;</ph>属性返回<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.IsFullyTrusted">
          <source>Gets a value that indicates whether the current assembly is loaded with full trust.</source>
          <target state="translated">获取一个值，该值指示当前程序集是否是以完全信任方式加载的。</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.IsFullyTrusted">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current assembly is loaded with full trust; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果当前程序集是以完全信任方式加载的，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads an assembly.</source>
          <target state="translated">加载程序集。</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>A byte array that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">字节数组，它是包含已发出程序集的基于 COFF 的映像。</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly.</source>
          <target state="translated">加载带有基于通用对象文件格式 (COFF) 的映像的程序集，该映像包含已发出的程序集。</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>The assembly is loaded into the application domain of the caller.</source>
          <target state="translated">此程序集将会加载到调用方的应用程序域中。</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</source>
          <target state="translated">使用此方法加载程序集的信任级别操作调用程序集的信任级别相同。</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>To load an assembly from a byte array with the trust level of the application domain, use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29&gt;</ph> method overload.</source>
          <target state="translated">若要从应用程序域的信任级别的字节数组加载程序集，使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>For more information about the use of evidence with overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that take byte arrays, see the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29&gt;</ph> method overload.</source>
          <target state="translated">有关使用的具有重载的证据的详细信息<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法采用字节数组，请参阅<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">在 c + + 可执行文件上进行反射可能会引发<ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">这很可能是由 c + + 编译器去除的重定位地址或<ph id="ph1">`.reloc`</ph>从可执行文件的部分。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">若要保留<ph id="ph1">`.reloc`</ph>c + + 可执行文件的地址，指定<ph id="ph2">`/fixed:no`</ph>在链接时。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>Note that this method overload always creates a new <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object with its own mapping.</source>
          <target state="translated">请注意此方法重载始终创建一个新<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>具有其自己的映射对象。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The object that describes the assembly to be loaded.</source>
          <target state="translated">描述要加载的程序集的对象。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Loads an assembly given its <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</source>
          <target state="translated">在给定程序集的 <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> 的情况下，加载程序集。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown if <ph id="ph2">`assemblyRef`</ph> specifies the full assembly name and the first assembly that matches the simple name has a different version, culture, or public key token.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> 如果引发<ph id="ph2">`assemblyRef`</ph>指定完整的程序集名称和匹配的简单名称的第一个程序集具有不同的版本、 区域性或公钥标记。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The loader does not continue probing for other assemblies that match the simple name.</source>
          <target state="translated">加载程序将无法继续探测的其他程序集的简单名称匹配。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Do not use an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> with only the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> property set.</source>
          <target state="translated">不要使用<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>并且仅带有<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>属性集。</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>属性不提供任何元素 （如名称或版本） 的程序集标识，因此加载不会发生根据负载通过标识规则，如你所料从<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Instead, the assembly is loaded using load-from rules.</source>
          <target state="translated">相反，使用负载从规则加载的程序集。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>For information about the disadvantages of using the load-from context, see the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph> method overload or <bpt id="p1">[</bpt>Best Practices for Assembly Loading<ept id="p1">](~/docs/framework/deployment/best-practices-for-assembly-loading.md)</ept>.</source>
          <target state="translated">有关使用加载源上下文的缺点的信息，请参阅<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph>方法重载或<bpt id="p1">[</bpt>用于程序集加载的最佳实践<ept id="p1">](~/docs/framework/deployment/best-practices-for-assembly-loading.md)</ept>。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">是否将特定的权限授予程序集是基于证据的。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">程序集和安全证据的合并的规则如下所示：</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法没有<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>参数，则与加载程序提供的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法替换<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>合并参数，证据。</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">作为参数提供的证据<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法取代加载程序提供的证据。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法重载<ph id="ph2">`Byte[]`</ph>从调用的程序集继承参数，以加载通用对象文件格式 (COFF) 图像，证据。</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</source>
          <target state="translated">这适用于.NET Framework 1.1 版 Service Pack 1 (SP1) 和后续版本。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is combined.</source>
          <target state="translated">在.NET Framework 1.0 版，而无需 SP1 中，如果你使用的版本 1.1 中<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法重载<ph id="ph2">`Byte[]`</ph>参数加载 COFF 映像，证据结合。</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph><ph id="ph2">`Url`</ph>和<ph id="ph3">`Site`</ph>从调用程序集，继承和<ph id="ph4">`Hash`</ph>和<ph id="ph5">`StrongName`</ph>摘自 COFF 程序集。</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法替换<ph id="ph2">`Byte[]`</ph>参数和<ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph>若要加载的 COFF 映像，请使用提供的证据。</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">调用程序集的证据和 COFF 图像的证据将被忽略。</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">在 c + + 可执行文件上进行反射可能会引发<ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">这很可能是由 c + + 编译器去除的重定位地址或<ph id="ph1">`.reloc`</ph>从可执行文件的部分。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">若要保留<ph id="ph1">`.reloc`</ph>c + + 可执行文件的地址，指定<ph id="ph2">`/fixed:no`</ph>在链接时。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>If both the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> property).</source>
          <target state="translated">如果这两个<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph>属性和<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph>属性设置，在首次尝试加载程序集使用的显示名称 (包括版本、 区域性和等等，返回为<ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph>属性)。</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>If the file is not found, <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> is used to search for the assembly.</source>
          <target state="translated">如果未找到该文件，<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>用于搜索程序集。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>If the assembly is found using <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>, the display name is matched against the assembly.</source>
          <target state="translated">如果使用找到的程序集<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>，与程序集匹配的显示名称。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>If the match fails, a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown.</source>
          <target state="translated">如果匹配失败，<ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The following example instantiates an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and uses it to load the <ph id="ph2">`sysglobal.dll`</ph> assembly.</source>
          <target state="translated">下面的示例实例化<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>对象并使用它来加载<ph id="ph2">`sysglobal.dll`</ph>程序集。</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>The example then displays the full name of the assembly's public types.</source>
          <target state="translated">此示例然后显示程序集的公共类型的完整名称。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">在<bpt id="p1">[</bpt>适用于 Windows 应用商店应用的 .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> 或<bpt id="p2">[</bpt>可移植类库<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>中，改为捕获基类异常 <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">用于读取一个 URI，不以"file://"开头。</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The long form of the assembly name.</source>
          <target state="translated">程序集名称的长格式。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Loads an assembly given the long form of its name.</source>
          <target state="translated">通过给定程序集的长格式名称加载程序集。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The long form of an assembly name consists of its simple name (such as "System" for the System.dll assembly) along with its version, culture, public key token, and optionally its processor architecture.</source>
          <target state="translated">程序集名称的长格式由其 （如"系统"System.dll 程序集） 以及其版本、 区域性、 公钥标记和 （可选） 及其处理器体系结构的简单名称组成。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>It corresponds to the assembly's <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A&gt;</ph> property.</source>
          <target state="translated">它对应于程序集的<ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The following example illustrates the use of a long name to load the System.dll assembly for the .NET Framework 4.</source>
          <target state="translated">下面的示例演示如何使用以加载.NET Framework 4 的 System.dll 程序集的名称太长。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown if <ph id="ph2">`assemblyString`</ph> specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> 如果引发<ph id="ph2">`assemblyString`</ph>指定完整的程序集名称，并与简单名称匹配的第一个程序集具有不同的版本、 区域性或公钥标记。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The loader does not continue probing for other assemblies that match the simple name.</source>
          <target state="translated">加载程序将无法继续探测的其他程序集的简单名称匹配。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">是否将特定的权限授予程序集是基于证据的。</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">程序集和安全证据的合并的规则如下所示：</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法没有<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>参数，则与加载程序提供的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法替换<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>合并参数，证据。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">作为参数提供的证据<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法取代加载程序提供的证据。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法重载<ph id="ph2">`Byte[]`</ph>从调用的程序集继承参数，以加载通用对象文件格式 (COFF) 图像，证据。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</source>
          <target state="translated">这适用于.NET Framework 1.1 版 Service Pack 1 (SP1) 和后续版本。</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is combined.</source>
          <target state="translated">在.NET Framework 1.0 版，而无需 SP1 中，如果你使用的版本 1.1 中<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法重载<ph id="ph2">`Byte[]`</ph>参数加载 COFF 映像，证据结合。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph><ph id="ph2">`Url`</ph>和<ph id="ph3">`Site`</ph>从调用程序集，继承和<ph id="ph4">`Hash`</ph>和<ph id="ph5">`StrongName`</ph>摘自 COFF 程序集。</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法替换<ph id="ph2">`Byte[]`</ph>参数和<ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph>若要加载的 COFF 映像，请使用提供的证据。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">调用程序集的证据和 COFF 图像的证据将被忽略。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">在 c + + 可执行文件上进行反射可能会引发<ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">这很可能是由 c + + 编译器去除的重定位地址或<ph id="ph1">`.reloc`</ph>从可执行文件的部分。</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">若要保留<ph id="ph1">`.reloc`</ph>c + + 可执行文件的地址，指定<ph id="ph2">`/fixed:no`</ph>在链接时。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">在.NET Framework 2.0 版中，处理器体系结构添加到程序集标识，并且可以指定为程序集名称字符串的一部分。</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">例如，"ProcessorArchitecture = msil"。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>However, the recommended way to specify an assembly name is to create an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and pass it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">但是，若要指定程序集名称的建议的方法是创建<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>对象，并将其传递给适当的重载<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>The following example loads an assembly given its fully qualified name, and lists all the types contained in the specified assembly.</source>
          <target state="translated">下面的示例给定其完全限定的名称，加载程序集，并列出所有包含在指定的程序集中的类型。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">若要运行此代码示例，你必须提供完全限定程序集名称。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">有关如何获取完全限定程序集名称的信息，请参阅<bpt id="p1">[</bpt>程序集名称<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>。</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 是一个长度为零的字符串。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>A byte array that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">字节数组，它是包含已发出程序集的基于 COFF 的映像。</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>A byte array that contains the raw bytes representing the symbols for the assembly.</source>
          <target state="translated">包含表示程序集符号的原始字节的字节数组。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols for the assembly.</source>
          <target state="translated">加载带有基于通用对象文件格式 (COFF) 的映像的程序集，此映像包含一个已发出的程序集，并且还可以选择包括程序集的符号。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>The assembly is loaded into the application domain of the caller.</source>
          <target state="translated">此程序集将会加载到调用方的应用程序域中。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</source>
          <target state="translated">使用此方法加载程序集的信任级别操作调用程序集的信任级别相同。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>To load an assembly from a byte array with the trust level of the application domain, use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29&gt;</ph> method overload.</source>
          <target state="translated">若要从应用程序域的信任级别的字节数组加载程序集，使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>For more information about the use of evidence with overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that take byte arrays, see the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29&gt;</ph> method overload.</source>
          <target state="translated">有关使用的具有重载的证据的详细信息<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法采用字节数组，请参阅<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">在 c + + 可执行文件上进行反射可能会引发<ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">这很可能是由 c + + 编译器去除的重定位地址或<ph id="ph1">`.reloc`</ph>从可执行文件的部分。</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">若要保留<ph id="ph1">`.reloc`</ph>c + + 可执行文件的地址，指定<ph id="ph2">`/fixed:no`</ph>在链接时。</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>Note that this method overload always creates a new <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object with its own mapping.</source>
          <target state="translated">请注意此方法重载始终创建一个新<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>具有其自己的映射对象。</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The object that describes the assembly to be loaded.</source>
          <target state="translated">描述要加载的程序集的对象。</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">用于加载程序集的证据。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Loads an assembly given its <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</source>
          <target state="translated">在给定程序集的 <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> 的情况下，加载程序集。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The assembly is loaded into the domain of the caller using the supplied evidence.</source>
          <target state="translated">使用提供的证据将该程序集加载到调用方的域中。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown if <ph id="ph2">`assemblyRef`</ph> specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> 如果引发<ph id="ph2">`assemblyRef`</ph>指定完整的程序集名称，并与简单名称匹配的第一个程序集具有不同的版本、 区域性或公钥标记。</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The loader does not continue probing for other assemblies that match the simple name.</source>
          <target state="translated">加载程序将无法继续探测的其他程序集的简单名称匹配。</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Do not use an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> with only the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> property set.</source>
          <target state="translated">不要使用<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>并且仅带有<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>属性集。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>属性不提供任何元素 （如名称或版本） 的程序集标识，因此加载不会发生根据负载通过标识规则，如你所料从<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Instead, the assembly is loaded using load-from rules.</source>
          <target state="translated">相反，使用负载从规则加载的程序集。</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>For information about the disadvantages of using the load-from context, see the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph> method overload or <bpt id="p1">[</bpt>Best Practices for Assembly Loading<ept id="p1">](~/docs/framework/deployment/best-practices-for-assembly-loading.md)</ept>.</source>
          <target state="translated">有关使用加载源上下文的缺点的信息，请参阅<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph>方法重载或<bpt id="p1">[</bpt>用于程序集加载的最佳实践<ept id="p1">](~/docs/framework/deployment/best-practices-for-assembly-loading.md)</ept>。</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">是否将特定的权限授予程序集是基于证据的。</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">程序集和安全证据的合并的规则如下所示：</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法没有<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>参数，则与加载程序提供的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法替换<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>合并参数，证据。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">作为参数提供的证据<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法取代加载程序提供的证据。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法重载<ph id="ph2">`Byte[]`</ph>从调用的程序集继承参数，以加载通用对象文件格式 (COFF) 图像，证据。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</source>
          <target state="translated">这适用于.NET Framework 1.1 版 Service Pack 1 (SP1) 和后续版本。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is combined.</source>
          <target state="translated">在.NET Framework 1.0 版，而无需 SP1 中，如果你使用的版本 1.1 中<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法重载<ph id="ph2">`Byte[]`</ph>参数加载 COFF 映像，证据结合。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph><ph id="ph2">`Url`</ph>和<ph id="ph3">`Site`</ph>从调用程序集，继承和<ph id="ph4">`Hash`</ph>和<ph id="ph5">`StrongName`</ph>摘自 COFF 程序集。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法替换<ph id="ph2">`Byte[]`</ph>参数和<ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph>若要加载的 COFF 映像，请使用提供的证据。</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">调用程序集的证据和 COFF 图像的证据将被忽略。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">在 c + + 可执行文件上进行反射可能会引发<ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">这很可能是由 c + + 编译器去除的重定位地址或<ph id="ph1">`.reloc`</ph>从可执行文件的部分。</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">若要保留<ph id="ph1">`.reloc`</ph>c + + 可执行文件的地址，指定<ph id="ph2">`/fixed:no`</ph>在链接时。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>If both the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> property).</source>
          <target state="translated">如果这两个<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph>属性和<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph>属性设置，在首次尝试加载程序集使用的显示名称 (包括版本、 区域性和等等，返回为<ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph>属性)。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>If the file is not found, <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> is used to search for the assembly.</source>
          <target state="translated">如果未找到该文件，<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>用于搜索程序集。</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>If the assembly is found using <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>, the display name is matched against the assembly.</source>
          <target state="translated">如果使用找到的程序集<ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>，与程序集匹配的显示名称。</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>If the match fails, a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown.</source>
          <target state="translated">如果匹配失败，<ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <ph id="ph2">&lt;xref:System.IO.FileLoadException&gt;</ph> because the equality and integrity of the different evidence specifications cannot be determined.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法超过一次在同一个程序集，但与指定不同的证据，公共语言运行时不会引发<ph id="ph2">&lt;xref:System.IO.FileLoadException&gt;</ph>因为相等性和不同的证据规范完整性不能为确定。</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The evidence that first succeeds is the evidence that is used.</source>
          <target state="translated">第一次成功的证据是使用的证据。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">用于读取一个 URI，不以"file://"开头。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">用于加载程序集的证据。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Loads an assembly given its display name, loading the assembly into the domain of the caller using the supplied evidence.</source>
          <target state="translated">通过给定的程序集的显示名称来加载程序集，使用提供的证据将程序集加载到调用方的域中。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown if <ph id="ph2">`assemblyString`</ph> specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> 如果引发<ph id="ph2">`assemblyString`</ph>指定完整的程序集名称，并与简单名称匹配的第一个程序集具有不同的版本、 区域性或公钥标记。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>The loader does not continue probing for other assemblies that match the simple name.</source>
          <target state="translated">加载程序将无法继续探测的其他程序集的简单名称匹配。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">是否将特定的权限授予程序集是基于证据的。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">程序集和安全证据的合并的规则如下所示：</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法没有<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>参数，则与加载程序提供的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法替换<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>合并参数，证据。</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">作为参数提供的证据<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法取代加载程序提供的证据。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法重载<ph id="ph2">`Byte[]`</ph>从调用的程序集继承参数，以加载通用对象文件格式 (COFF) 图像，证据。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</source>
          <target state="translated">这适用于.NET Framework 1.1 版 Service Pack 1 (SP1) 和后续版本。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is combined.</source>
          <target state="translated">在.NET Framework 1.0 版，而无需 SP1 中，如果你使用的版本 1.1 中<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法重载<ph id="ph2">`Byte[]`</ph>参数加载 COFF 映像，证据结合。</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph><ph id="ph2">`Url`</ph>和<ph id="ph3">`Site`</ph>从调用程序集，继承和<ph id="ph4">`Hash`</ph>和<ph id="ph5">`StrongName`</ph>摘自 COFF 程序集。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法替换<ph id="ph2">`Byte[]`</ph>参数和<ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph>若要加载的 COFF 映像，请使用提供的证据。</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">调用程序集的证据和 COFF 图像的证据将被忽略。</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">在 c + + 可执行文件上进行反射可能会引发<ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">这很可能是由 c + + 编译器去除的重定位地址或<ph id="ph1">`.reloc`</ph>从可执行文件的部分。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">若要保留<ph id="ph1">`.reloc`</ph>c + + 可执行文件的地址，指定<ph id="ph2">`/fixed:no`</ph>在链接时。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> because the equality and integrity of the different evidence specifications cannot be determined.</source>
          <target state="translated">如果在同一程序集但不同的证据指定不止一次调用此方法，公共语言运行时不会引发<ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph>因为无法确定相等性和不同的证据规范的完整性。</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>The evidence that first succeeds is the evidence that is used.</source>
          <target state="translated">第一次成功的证据是使用的证据。</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">在.NET Framework 2.0 版中，处理器体系结构添加到程序集标识，并且可以指定为程序集名称字符串的一部分。</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">例如，"ProcessorArchitecture = msil"。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>However, the recommended way to specify an assembly name is to create an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and pass it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">但是，若要指定程序集名称的建议的方法是创建<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>对象，并将其传递给适当的重载<ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>A byte array that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">字节数组，它是包含已发出程序集的基于 COFF 的映像。</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>A byte array that contains the raw bytes representing the symbols for the assembly.</source>
          <target state="translated">包含表示程序集符号的原始字节的字节数组。</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">用于加载程序集的证据。</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and evidence for the assembly.</source>
          <target state="translated">加载带有基于通用对象文件格式 (COFF) 的映像的程序集，此映像包含一个已发出的程序集，并且还可选择包括程序集的符号和证据。</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The assembly is loaded into the application domain of the caller.</source>
          <target state="translated">此程序集将会加载到调用方的应用程序域中。</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The assembly is loaded into the domain of the caller using the supplied evidence.</source>
          <target state="translated">使用提供的证据将该程序集加载到调用方的域中。</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The raw bytes representing the symbols for the assembly are also loaded.</source>
          <target state="translated">此外加载表示程序集符号的原始字节。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">是否将特定的权限授予程序集是基于证据的。</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">程序集和安全证据的合并的规则如下所示：</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法没有<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>参数，则与加载程序提供的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法替换<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>合并参数，证据。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">作为参数提供的证据<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法取代加载程序提供的证据。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is inherited from the calling assembly.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法重载<ph id="ph2">`Byte[]`</ph>从调用的程序集继承参数，以加载 COFF 图像，证据。</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</source>
          <target state="translated">这适用于.NET Framework 1.1 版 Service Pack 1 (SP1) 和后续版本。</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method overload with a <ph id="ph2">`Byte[]`</ph> parameter to load a COFF image, evidence is combined.</source>
          <target state="translated">在.NET Framework 1.0 版，而无需 SP1 中，如果你使用的版本 1.1 中<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法重载<ph id="ph2">`Byte[]`</ph>参数加载 COFF 映像，证据结合。</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph><ph id="ph2">`Url`</ph>和<ph id="ph3">`Site`</ph>从调用程序集，继承和<ph id="ph4">`Hash`</ph>和<ph id="ph5">`StrongName`</ph>摘自 COFF 程序集。</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法替换<ph id="ph2">`Byte[]`</ph>参数和<ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph>若要加载的 COFF 映像，请使用提供的证据。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Evidence of the calling assembly and evidence of the COFF image are ignored.</source>
          <target state="translated">忽略调用程序集的证据和 COFF 图像的证据。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Reflecting on C++ executable files might throw a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>.</source>
          <target state="translated">在 c + + 可执行文件上进行反射可能会引发<ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the <ph id="ph1">`.reloc`</ph> section from your executable file.</source>
          <target state="translated">这很可能是由 c + + 编译器去除的重定位地址或<ph id="ph1">`.reloc`</ph>从可执行文件的部分。</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>To preserve the <ph id="ph1">`.reloc`</ph> address for your C++ executable file, specify <ph id="ph2">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">若要保留<ph id="ph1">`.reloc`</ph>c + + 可执行文件的地址，指定<ph id="ph2">`/fixed:no`</ph>在链接时。</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>If you call the [<ph id="ph1">\]</ph>, Byte<ph id="ph2">\&lt;</ph>xref:System.Reflection.Assembly.Load%2A&gt; method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <ph id="ph3">&lt;xref:System.IO.FileLoadException&gt;</ph> because the equality and integrity of the different evidence specifications cannot be determined.</source>
          <target state="translated">如果调用 [<ph id="ph1">\]</ph>，字节<ph id="ph2">\&lt;</ph>xref:System.Reflection.Assembly.Load%2A &gt; 方法超过一次在同一个程序集，但与指定不同的证据，公共语言运行时不会引发<ph id="ph3">&lt;xref:System.IO.FileLoadException&gt;</ph>因为无法确定相等性和不同的证据规范的完整性。</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The evidence that first succeeds is the evidence that is used.</source>
          <target state="translated">第一次成功的证据是使用的证据。</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Note that this method overload always creates a new <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object with its own mapping.</source>
          <target state="translated">请注意此方法重载始终创建一个新<ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>具有其自己的映射对象。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">一个程序集或模块用两个不同的证据加载了两次。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>By default, legacy CAS policy is not enabled in the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>; when it is not enabled, <ph id="ph2">&lt;paramref name="securityEvidence" /&gt;</ph> must be <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">默认情况下，<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> 中未启用旧版 CAS 策略；如果未启用，则 <ph id="ph2">&lt;paramref name="securityEvidence" /&gt;</ph> 必须为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>for the ability to supply evidence.</source>
          <target state="translated">提供证据的功能。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">安全操作： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>A byte array that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">字节数组，它是包含已发出程序集的基于 COFF 的映像。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>A byte array that contains the raw bytes representing the symbols for the assembly.</source>
          <target state="translated">包含表示程序集符号的原始字节的字节数组。</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>The source of the security context.</source>
          <target state="translated">安全上下文的源。</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and specifying the source for the security context.</source>
          <target state="translated">加载带有基于通用对象文件格式 (COFF) 的映像的程序集，此映像包含一个已发出的程序集，并且还可选择包括符号和指定安全上下文的源。</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>The assembly is loaded into the application domain of the caller.</source>
          <target state="translated">此程序集将会加载到调用方的应用程序域中。</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>The assembly is loaded into the application domain of the caller using the specified source for the security context.</source>
          <target state="translated">程序集被加载到调用方的安全上下文中使用指定的源的应用程序域。</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>If <ph id="ph1">`rawSymbolStore`</ph> was specified, the raw bytes that represent the symbols for the assembly are also loaded.</source>
          <target state="translated">如果<ph id="ph1">`rawSymbolStore`</ph>已指定，还加载表示程序集符号的原始字节。</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 使用高于当前所加载版本的公共语言运行时版本编译而成。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)">
          <source>The value of <ph id="ph1">&lt;paramref name="securityContextSource" /&gt;</ph> is not one of the enumeration values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityContextSource" /&gt;</ph> 的值为枚举值之一。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads the contents of an assembly file.</source>
          <target state="translated">加载程序集文件的内容。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>The fully qualified path of the file to load.</source>
          <target state="translated">要加载的文件的完全限定路径。</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>Loads the contents of an assembly file on the specified path.</source>
          <target state="translated">加载指定路径上的程序集文件的内容。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method to load and examine assemblies that have the same identity, but are located in different paths.<ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph></source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法来加载和检查程序集具有相同的标识，但位于不同的路径。<ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph></target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>does not load files into the load-from  context, and does not resolve dependencies using the load path, as the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method does.</source>
          <target state="translated">不会将文件加载到加载源上下文中，并且未解决依赖项使用的负载路径，作为<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法执行。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> is useful in this limited scenario because <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> 此有限的情况下很有用因为<ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>不能用于加载程序集具有相同标识但不同的路径; 它将加载只有第一个此类程序集。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> argument is not an absolute path.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 参数不是绝对路径。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is an empty string ("") or does not exist.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 参数为空字符串 ("") 或不存在。</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="path" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="path" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>The fully qualified path of the assembly file.</source>
          <target state="translated">程序集文件的完全限定路径。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">用于加载程序集的证据。</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Loads an assembly given its path, loading the assembly into the domain of the caller using the supplied evidence.</source>
          <target state="translated">通过给定的程序集的路径来加载程序集，使用提供的证据将程序集加载到调用方的域中。</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method to load and examine assemblies that have the same identity, but are located in different paths.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法来加载和检查程序集具有相同的标识，但位于不同的路径。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> does not load files into the <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> context, and does not resolve dependencies using the load path, as the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method does.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> 不会加载文件到<ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>上下文，并且未解决依赖项使用的负载路径，作为<ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法执行。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> is useful in this limited scenario because <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> 此有限的情况下很有用因为<ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>不能用于加载程序集具有相同标识但不同的路径; 它将加载只有第一个此类程序集。</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> argument is not an absolute path.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 参数不是绝对路径。</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is an empty string ("") or does not exist.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 参数为空字符串 ("") 或不存在。</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="path" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="path" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> 不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>By default, legacy CAS policy is not enabled in the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>; when it is not enabled, <ph id="ph2">&lt;paramref name="securityEvidence" /&gt;</ph> must be <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">默认情况下，<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> 中未启用旧版 CAS 策略；如果未启用，则 <ph id="ph2">&lt;paramref name="securityEvidence" /&gt;</ph> 必须为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads an assembly.</source>
          <target state="translated">加载程序集。</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The name or path of the file that contains the manifest of the assembly.</source>
          <target state="translated">包含程序集清单的文件的名称或路径。</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Loads an assembly given its file name or path.</source>
          <target state="translated">已知程序集的文件名或路径，加载程序集。</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The <ph id="ph1">`assemblyFile`</ph> parameter must refer to a URI without escape characters.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph>参数必须引用未转义符的 URI。</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>This method supplies escape characters for all invalid characters in the URI.</source>
          <target state="translated">此方法提供 URI 中的所有无效字符的转义的字符。</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>File transfer protocol (FTP) is not supported.</source>
          <target state="translated">不支持文件传输协议 (FTP)。</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If the URI supplied for <ph id="ph1">`assemblyFile`</ph> is an FTP address, the assembly is not loaded.</source>
          <target state="translated">如果为 uri，该 URI 提供<ph id="ph1">`assemblyFile`</ph>是 FTP 地址，则不会加载程序集。</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>No exception is thrown.</source>
          <target state="translated">不引发异常。</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">`assemblyFile`</ph> may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph> 可能是绝对或相对于当前目录中，且程序集加载到调用方的域。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Assemblies can be loaded into one of three contexts, or can be loaded without context:</source>
          <target state="translated">程序集可以是加载到三个上下文中的一个，也可以是没有上下文的情况下加载：</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> of the application domain.</source>
          <target state="translated">加载上下文包含通过探测找到的程序集： 在 GAC 中，主机程序集中存储如果托管运行时，或在<ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph>的应用程序域。</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Most overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method load assemblies into this context.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> 方法的大多数重载都将程序集加载到此上下文中。</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</source>
          <target state="translated">加载源上下文包含程序集为其用户提供不包括在搜索通过探测的目录的路径。</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> are examples of methods that load by path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> 和 <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> 都是通过路径加载的方法的示例。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The reflection-only context contains assemblies loaded with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods; code in these contexts cannot be executed.</source>
          <target state="translated">仅限反射的上下文包含与加载的程序集<ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph>方法; 这些中的代码无法执行上下文。</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If the user generated or found the assembly, it is not in any context.</source>
          <target state="translated">如果用户生成或找到了程序集，它不在任何上下文中。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>This applies to assemblies loaded using overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</source>
          <target state="translated">这适用于使用的重载加载的程序集<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>指定字节数组，包含一个程序集，并创建使用反射的瞬态动态程序集发出和未保存到磁盘的方法。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</source>
          <target state="translated">加载源上下文允许从探测中, 未包括的路径加载程序集和尚未允许依赖项，该路径，以找出并加载，因为由上下文维护的路径信息。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method has the following disadvantages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法具有以下缺点。</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Consider using <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> instead.</source>
          <target state="translated">请考虑改用 <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If an assembly with the same identity is already loaded, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> returns the loaded assembly even if a different path was specified.</source>
          <target state="translated">如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> 仍返回已加载的程序集。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</source>
          <target state="translated">如果程序集的加载与<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>，以及更高版本的加载上下文中的程序集尝试加载按显示名称的同一个程序集，加载尝试将失败。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>This can occur when an assembly is de-serialized.</source>
          <target state="translated">这会反序列化程序集时。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and the probing path includes an assembly with the same identity but a different location, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, or other unexpected behavior can occur.</source>
          <target state="translated">如果程序集的加载与<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>，探测路径包括使用相同的标识，而另一个位置，为程序集和<ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>， <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>，否则会发生其他意外的行为。</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demands <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, on the specified path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> 需要对指定路径的 <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> 和 <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph> 或 <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>If a native image exists for <ph id="ph1">`assemblyFile`</ph>, it is not used.</source>
          <target state="translated">如果本机映像存在<ph id="ph1">`assemblyFile`</ph>，不使用它。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The assembly cannot be loaded as domain neutral.</source>
          <target state="translated">无法加载以非特定域的程序集。</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>In the .NET Framework version 1.0 and 1.1, policy is not applied.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 版中，不应用策略。</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The following example loads an assembly given its file name or path.</source>
          <target state="translated">下面的示例加载程序集文件名或路径。</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a filename extension.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph>，或者尝试加载的模块没有指定文件扩展名。</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集；例如，64 位进程中的 32 位程序集。</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>See the exception topic for more information.</source>
          <target state="translated">有关详细信息，请参阅异常主题。</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">在没有所需 <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> 的情况下，指定了不以“file://”开始的基本代码。</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 参数为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">程序集名称的长度超过 MAX_PATH 个字符。</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>for reading a URI that begins with "file://".</source>
          <target state="translated">用于读取开头"file://"的 URI。</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">用于读取一个 URI，不以"file://"开头。</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The name or path of the file that contains the manifest of the assembly.</source>
          <target state="translated">包含程序集清单的文件的名称或路径。</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">用于加载程序集的证据。</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Loads an assembly given its file name or path and supplying security evidence.</source>
          <target state="translated">在给定程序集的文件名或路径并提供安全证据的情况下，加载程序集。</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">`assemblyFile`</ph> parameter must refer to a URI without escape characters.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph>参数必须引用未转义符的 URI。</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>This method supplies escape characters for all invalid characters in the URI.</source>
          <target state="translated">此方法提供 URI 中的所有无效字符的转义的字符。</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>File transfer protocol (FTP) is not supported.</source>
          <target state="translated">不支持文件传输协议 (FTP)。</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If the URI supplied for <ph id="ph1">`assemblyFile`</ph> is an FTP address, the assembly is not loaded.</source>
          <target state="translated">如果为 uri，该 URI 提供<ph id="ph1">`assemblyFile`</ph>是 FTP 地址，则不会加载程序集。</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>No exception is thrown.</source>
          <target state="translated">不引发异常。</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">`assemblyFile`</ph> may be absolute or  relative to the current directory, and the assembly is loaded into the domain of the caller.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph> 可能是绝对或相对于当前目录中，且程序集加载到调用方的域。</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Assemblies can be loaded into one of three contexts, or can be loaded without context:</source>
          <target state="translated">程序集可以是加载到三个上下文中的一个，也可以是没有上下文的情况下加载：</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> of the application domain.</source>
          <target state="translated">加载上下文包含通过探测找到的程序集： 在 GAC 中，主机程序集中存储如果托管运行时，或在<ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph>的应用程序域。</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Most overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method load assemblies into this context.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> 方法的大多数重载都将程序集加载到此上下文中。</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</source>
          <target state="translated">加载源上下文包含程序集为其用户提供不包括在搜索通过探测的目录的路径。</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> are examples of methods that load by path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> 和 <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> 都是通过路径加载的方法的示例。</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The reflection-only context contains assemblies loaded with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods; code in these contexts cannot be executed.</source>
          <target state="translated">仅限反射的上下文包含与加载的程序集<ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph>方法; 这些中的代码无法执行上下文。</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If the user generated or found the assembly, it is not in any context.</source>
          <target state="translated">如果用户生成或找到了程序集，它不在任何上下文中。</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>This applies to assemblies loaded using overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</source>
          <target state="translated">这适用于使用的重载加载的程序集<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>指定字节数组，包含一个程序集，并创建使用反射的瞬态动态程序集发出和未保存到磁盘的方法。</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</source>
          <target state="translated">加载源上下文允许从探测中, 未包括的路径加载程序集和尚未允许依赖项，该路径，以找出并加载，因为由上下文维护的路径信息。</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method has the following disadvantages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法具有以下缺点。</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Consider using <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> instead.</source>
          <target state="translated">请考虑改用 <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If an assembly with the same identity is already loaded, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> returns the loaded assembly even if a different path was specified.</source>
          <target state="translated">如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> 仍返回已加载的程序集。</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</source>
          <target state="translated">如果程序集的加载与<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>，以及更高版本的加载上下文中的程序集尝试加载按显示名称的同一个程序集，加载尝试将失败。</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>This can occur when an assembly is deserialized.</source>
          <target state="translated">对程序集进行反序列化时，可能发生这种情况。</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and the probing path includes an assembly with the same identity but a different location, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, or other unexpected behavior can occur.</source>
          <target state="translated">如果程序集的加载与<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>，探测路径包括使用相同的标识，而另一个位置，为程序集和<ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>， <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>，否则会发生其他意外的行为。</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demands <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, on the specified path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> 需要对指定路径的 <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> 和 <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph> 或 <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If a native image exists for <ph id="ph1">`assemblyFile`</ph>, it is not used.</source>
          <target state="translated">如果本机映像存在<ph id="ph1">`assemblyFile`</ph>，不使用它。</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The assembly cannot be loaded as domain neutral.</source>
          <target state="translated">无法加载以非特定域的程序集。</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>In the .NET Framework version 1.0 and 1.1, policy is not applied.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 版中，不应用策略。</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">是否将特定的权限授予程序集是基于证据的。</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">程序集和安全证据的合并的规则如下所示：</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法没有<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>参数，则与加载程序提供的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法替换<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>合并参数，证据。</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">作为参数提供的证据<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法取代加载程序提供的证据。</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> because the equality and integrity of the different evidence specifications cannot be determined.</source>
          <target state="translated">如果在同一程序集但不同的证据指定不止一次调用此方法，公共语言运行时不会引发<ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph>因为无法确定相等性和不同的证据规范的完整性。</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The evidence that first succeeds is the evidence that is used.</source>
          <target state="translated">第一次成功的证据是使用的证据。</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is combined.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法替换<ph id="ph2">`Byte[]`</ph>参数加载通用对象文件格式 (COFF) 图像，证据结合。</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph><ph id="ph2">`Url`</ph>和<ph id="ph3">`Site`</ph>从调用程序集，继承和<ph id="ph4">`Hash`</ph>和<ph id="ph5">`StrongName`</ph>摘自 COFF 程序集。</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法替换<ph id="ph2">`Byte[]`</ph>参数和<ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph>若要加载的 COFF 映像，请使用提供的证据。</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">调用程序集的证据和 COFF 图像的证据将被忽略。</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a filename extension.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph>，或者尝试加载的模块没有指定文件扩展名。</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> is not ambiguous and is determined to be invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> 是明确的，但确定为无效。</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集；例如，64 位进程中的 32 位程序集。</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>See the exception topic for more information.</source>
          <target state="translated">有关详细信息，请参阅异常主题。</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">在没有所需 <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> 的情况下，指定了不以“file://”开始的基本代码。</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 参数为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">程序集名称的长度超过 MAX_PATH 个字符。</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>for reading a URI that begins with "file://".</source>
          <target state="translated">用于读取开头"file://"的 URI。</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">用于读取一个 URI，不以"file://"开头。</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name or path of the file that contains the manifest of the assembly.</source>
          <target state="translated">包含程序集清单的文件的名称或路径。</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The value of the computed hash code.</source>
          <target state="translated">计算所得的哈希代码的值。</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The hash algorithm used for hashing files and for generating the strong name.</source>
          <target state="translated">用于对文件进行哈希处理并生成强名称的哈希算法。</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Loads an assembly given its file name or path, hash value, and hash algorithm.</source>
          <target state="translated">通过给定程序集文件名或路径、哈希值及哈希算法来加载程序集。</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">`assemblyFile`</ph> parameter must refer to a URI without escape characters.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph>参数必须引用未转义符的 URI。</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method supplies escape characters for all invalid characters in the URI.</source>
          <target state="translated">此方法提供 URI 中的所有无效字符的转义的字符。</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>File transfer protocol (FTP) is not supported.</source>
          <target state="translated">不支持文件传输协议 (FTP)。</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If the URI supplied for <ph id="ph1">`assemblyFile`</ph> is an FTP address, the assembly is not loaded.</source>
          <target state="translated">如果为 uri，该 URI 提供<ph id="ph1">`assemblyFile`</ph>是 FTP 地址，则不会加载程序集。</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>No exception is thrown.</source>
          <target state="translated">不引发异常。</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">`assemblyFile`</ph> may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph> 可能是绝对或相对于当前目录中，且程序集加载到调用方的域。</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Assemblies can be loaded into one of three contexts, or can be loaded without context:</source>
          <target state="translated">程序集可以是加载到三个上下文中的一个，也可以是没有上下文的情况下加载：</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load context contains assemblies found by probing: in the global assembly cache, in a host assembly store if the runtime is hosted, or in the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> of the application domain.</source>
          <target state="translated">加载上下文包含通过探测找到的程序集： 在全局程序集缓存中，主机程序集中存储如果托管运行时，或在<ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph>的应用程序域。</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Most overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method load assemblies into this context.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> 方法的大多数重载都将程序集加载到此上下文中。</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load-from context contains assemblies for which the user provided a path that is not included in probing.</source>
          <target state="translated">加载源上下文包含程序集为其用户提供探测中未包括的路径。</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> are examples of methods that load by path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> 和 <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> 都是通过路径加载的方法的示例。</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The reflection-only context contains assemblies loaded with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods; code in these contexts cannot be executed.</source>
          <target state="translated">仅限反射的上下文包含与加载的程序集<ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph>方法; 这些中的代码无法执行上下文。</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If the user generated or found the assembly, it is not in any context.</source>
          <target state="translated">如果用户生成或找到了程序集，它不在任何上下文中。</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This applies to assemblies loaded using overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</source>
          <target state="translated">这适用于使用的重载加载的程序集<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>指定字节数组，包含一个程序集，并创建使用反射的瞬态动态程序集发出和未保存到磁盘的方法。</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load-from context allows an assembly to be loaded from a path that is not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</source>
          <target state="translated">加载源上下文允许从路径未包含在探测，加载程序集和尚未允许依赖项，该路径，以找出并加载，因为由上下文维护的路径信息。</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method has the following disadvantages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法具有以下缺点。</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Consider using <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> instead.</source>
          <target state="translated">请考虑改用 <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly with the same identity is already loaded, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> returns the loaded assembly even if a different path was specified.</source>
          <target state="translated">如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> 仍返回已加载的程序集。</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</source>
          <target state="translated">如果程序集的加载与<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>，以及更高版本的加载上下文中的程序集尝试加载按显示名称的同一个程序集，加载尝试将失败。</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This can occur when an assembly is deserialized.</source>
          <target state="translated">对程序集进行反序列化时，可能发生这种情况。</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and the probing path includes an assembly with the same identity but a different location, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, or other unexpected behavior can occur.</source>
          <target state="translated">如果程序集的加载与<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>，探测路径包括使用相同的标识，而另一个位置，为程序集和<ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>， <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>，否则会发生其他意外的行为。</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demands <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, on the specified path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> 需要对指定路径的 <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> 和 <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph> 或 <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If a native image exists for <ph id="ph1">`assemblyFile`</ph>, it is not used.</source>
          <target state="translated">如果本机映像存在<ph id="ph1">`assemblyFile`</ph>，不使用它。</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly cannot be loaded as domain-neutral.</source>
          <target state="translated">程序集不能以非特定于域的方式加载。</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">程序集将会加载与加载程序提供的证据。</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a file name extension.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph>，或者你正在试图加载的模块未指定文件扩展名。</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集；例如，64 位进程中的 32 位程序集。</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>See the exception topic for more information.</source>
          <target state="translated">有关详细信息，请参阅异常主题。</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 使用高于当前所加载版本的公共语言运行时版本编译而成。</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">在没有所需 <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> 的情况下，指定了不以“file://”开始的基本代码。</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 参数为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">程序集名称的长度超过 MAX_PATH 个字符。</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that begins with "file://".</source>
          <target state="translated">用于读取开头"file://"的 URI。</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">用于读取一个 URI，不以"file://"开头。</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name or path of the file that contains the manifest of the assembly.</source>
          <target state="translated">包含程序集清单的文件的名称或路径。</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">用于加载程序集的证据。</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The value of the computed hash code.</source>
          <target state="translated">计算所得的哈希代码的值。</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The hash algorithm used for hashing files and for generating the strong name.</source>
          <target state="translated">用于对文件进行哈希处理并生成强名称的哈希算法。</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Loads an assembly given its file name or path, security evidence, hash value, and hash algorithm.</source>
          <target state="translated">通过给定程序集文件名或路径、安全证据、哈希值及哈希算法来加载程序集。</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">`assemblyFile`</ph> parameter must refer to a URI without escape characters.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph>参数必须引用未转义符的 URI。</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method supplies escape characters for all invalid characters in the URI.</source>
          <target state="translated">此方法提供 URI 中的所有无效字符的转义的字符。</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>File transfer protocol (FTP) is not supported.</source>
          <target state="translated">不支持文件传输协议 (FTP)。</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If the URI supplied for <ph id="ph1">`assemblyFile`</ph> is an FTP address, the assembly is not loaded.</source>
          <target state="translated">如果为 uri，该 URI 提供<ph id="ph1">`assemblyFile`</ph>是 FTP 地址，则不会加载程序集。</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>No exception is thrown.</source>
          <target state="translated">不引发异常。</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">`assemblyFile`</ph> may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph> 可能是绝对或相对于当前目录中，且程序集加载到调用方的域。</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Assemblies can be loaded into one of three contexts, or can be loaded without context:</source>
          <target state="translated">程序集可以是加载到三个上下文中的一个，也可以是没有上下文的情况下加载：</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph> of the application domain.</source>
          <target state="translated">加载上下文包含通过探测找到的程序集： 在 GAC 中，主机程序集中存储如果托管运行时，或在<ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A&gt;</ph>的应用程序域。</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Most overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method load assemblies into this context.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> 方法的大多数重载都将程序集加载到此上下文中。</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</source>
          <target state="translated">加载源上下文包含程序集为其用户提供不包括在搜索通过探测的目录的路径。</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> are examples of methods that load by path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> 和 <ph id="ph3">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> 都是通过路径加载的方法的示例。</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The reflection-only context contains assemblies loaded with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph> methods; code in these contexts cannot be executed.</source>
          <target state="translated">仅限反射的上下文包含与加载的程序集<ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A&gt;</ph>方法; 这些中的代码无法执行上下文。</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If the user generated or found the assembly, it is not in any context.</source>
          <target state="translated">如果用户生成或找到了程序集，它不在任何上下文中。</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This applies to assemblies loaded using overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</source>
          <target state="translated">这适用于使用的重载加载的程序集<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>指定字节数组，包含一个程序集，并创建使用反射的瞬态动态程序集发出和未保存到磁盘的方法。</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</source>
          <target state="translated">加载源上下文允许从探测中, 未包括的路径加载程序集和尚未允许依赖项，该路径，以找出并加载，因为由上下文维护的路径信息。</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method has the following disadvantages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法具有以下缺点。</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Consider using <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> instead.</source>
          <target state="translated">请考虑改用 <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly with the same identity is already loaded, <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> returns the loaded assembly even if a different path was specified.</source>
          <target state="translated">如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> 仍返回已加载的程序集。</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</source>
          <target state="translated">如果程序集的加载与<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>，以及更高版本的加载上下文中的程序集尝试加载按显示名称的同一个程序集，加载尝试将失败。</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This can occur when an assembly is deserialized.</source>
          <target state="translated">对程序集进行反序列化时，可能发生这种情况。</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If an assembly is loaded with <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>, and the probing path includes an assembly with the same identity but a different location, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>, <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>, or other unexpected behavior can occur.</source>
          <target state="translated">如果程序集的加载与<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>，探测路径包括使用相同的标识，而另一个位置，为程序集和<ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>， <ph id="ph3">&lt;xref:System.MissingMethodException&gt;</ph>，否则会发生其他意外的行为。</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> demands <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>, on the specified path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> 需要对指定路径的 <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType&gt;</ph> 和 <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType&gt;</ph> 或 <ph id="ph4">&lt;xref:System.Net.WebPermission&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If a native image exists for <ph id="ph1">`assemblyFile`</ph>, it is not used.</source>
          <target state="translated">如果本机映像存在<ph id="ph1">`assemblyFile`</ph>，不使用它。</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly cannot be loaded as domain neutral.</source>
          <target state="translated">无法加载以非特定域的程序集。</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>In the .NET Framework version 1.0 and 1.1, policy is not applied.</source>
          <target state="translated">在.NET Framework 1.0 和 1.1 版中，不应用策略。</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">是否将特定的权限授予程序集是基于证据的。</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">程序集和安全证据的合并的规则如下所示：</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with no <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, the assembly is loaded with the evidence that the loader supplies.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法没有<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>参数，则与加载程序提供的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法替换<ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph>合并参数，证据。</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">作为参数提供的证据<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法取代加载程序提供的证据。</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> because the equality and integrity of the different evidence specifications cannot be determined.</source>
          <target state="translated">如果在同一程序集但不同的证据指定不止一次调用此方法，公共语言运行时不会引发<ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph>因为无法确定相等性和不同的证据规范的完整性。</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The evidence that first succeeds is the evidence that is used.</source>
          <target state="translated">第一次成功的证据是使用的证据。</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter to load a common object file format (COFF) image, evidence is combined.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法替换<ph id="ph2">`Byte[]`</ph>参数加载通用对象文件格式 (COFF) 图像，证据结合。</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">`Zone`</ph>, <ph id="ph2">`Url`</ph> and <ph id="ph3">`Site`</ph> are inherited from the calling assembly, and <ph id="ph4">`Hash`</ph> and <ph id="ph5">`StrongName`</ph> are taken from the COFF assembly.</source>
          <target state="translated"><ph id="ph1">`Zone`</ph><ph id="ph2">`Url`</ph>和<ph id="ph3">`Site`</ph>从调用程序集，继承和<ph id="ph4">`Hash`</ph>和<ph id="ph5">`StrongName`</ph>摘自 COFF 程序集。</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>When you use a <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method with a <ph id="ph2">`Byte[]`</ph> parameter and <ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph> to load a COFF image, only the supplied evidence is used.</source>
          <target state="translated">当你使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法替换<ph id="ph2">`Byte[]`</ph>参数和<ph id="ph3">&lt;xref:System.Security.Policy.Evidence&gt;</ph>若要加载的 COFF 映像，请使用提供的证据。</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Evidence of the calling assembly and evidence of the COFF image is ignored.</source>
          <target state="translated">调用程序集的证据和 COFF 图像的证据将被忽略。</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a filename extension.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph>，或者尝试加载的模块没有指定文件扩展名。</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> is not ambiguous and is determined to be invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> 是明确的，但确定为无效。</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集；例如，64 位进程中的 32 位程序集。</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>See the exception topic for more information.</source>
          <target state="translated">有关详细信息，请参阅异常主题。</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">在没有所需 <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> 的情况下，指定了不以“file://”开始的基本代码。</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 参数为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">程序集名称的长度超过 MAX_PATH 个字符。</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">若要使用的证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that begins with "file://".</source>
          <target state="translated">用于读取开头"file://"的 URI。</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">用于读取一个 URI，不以"file://"开头。</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads the module internal to this assembly.</source>
          <target state="translated">加载此程序集的内部模块。</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>The name of the module.</source>
          <target state="translated">模块的名称。</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>This string must correspond to a file name in this assembly's manifest.</source>
          <target state="translated">此字符串必须与程序集清单中的文件名对应。</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>A byte array that is a COFF-based image containing an emitted module, or a resource.</source>
          <target state="translated">基于 COFF 映像的字节数组，该数组包含发送的模块或资源。</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</source>
          <target state="translated">加载带有基于通用对象文件格式 (COFF) 的映像（包含已发出的模块）或资源文件的模块（该模块相对于此程序集是内部的）。</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>The loaded module.</source>
          <target state="translated">加载的模块。</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="rawModule" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="rawModule" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> does not match a file entry in this assembly's manifest.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> 与此程序集清单中的文件项不匹配。</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawModule" /&gt;</ph> is not a valid module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawModule" /&gt;</ph> 不是有效模块。</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>to provide evidence.</source>
          <target state="translated">若要提供的证据。</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>The name of the module.</source>
          <target state="translated">模块的名称。</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>This string must correspond to a file name in this assembly's manifest.</source>
          <target state="translated">此字符串必须与程序集清单中的文件名对应。</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>A byte array that is a COFF-based image containing an emitted module, or a resource.</source>
          <target state="translated">基于 COFF 映像的字节数组，该数组包含发送的模块或资源。</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>A byte array containing the raw bytes representing the symbols for the module.</source>
          <target state="translated">一个字节数组，包含表示模块符号的原始字节。</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>Must be <ph id="ph1">&lt;see langword="null" /&gt;</ph> if this is a resource file.</source>
          <target state="translated">如果这是一个资源文件，则必须为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</source>
          <target state="translated">加载带有基于通用对象文件格式 (COFF) 的映像（包含已发出的模块）或资源文件的模块（该模块相对于此程序集是内部的）。</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>The raw bytes representing the symbols for the module are also loaded.</source>
          <target state="translated">还加载表示此模块的符号的原始字节。</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>The loaded module.</source>
          <target state="translated">加载的模块。</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="rawModule" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="rawModule" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> does not match a file entry in this assembly's manifest.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="moduleName" /&gt;</ph> 与此程序集清单中的文件项不匹配。</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawModule" /&gt;</ph> is not a valid module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawModule" /&gt;</ph> 不是有效模块。</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>to provide evidence.</source>
          <target state="translated">若要提供的证据。</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads an assembly from the application directory or from the global assembly cache using a partial name.</source>
          <target state="translated">使用部分名称从应用程序目录或从全局程序集缓存加载程序集。</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType&gt;</ph> method are obsolete and have been retained for backward compatibility.</source>
          <target state="translated">重载<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType&gt;</ph>方法已过时，并已保留用于向后兼容。</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Assembly">
          <source>The non-obsolete alternative is <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">未过时的替代项为 <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>Loads an assembly from the application directory or from the global assembly cache using a partial name.</source>
          <target state="translated">使用部分名称从应用程序目录或从全局程序集缓存加载程序集。</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> is not found, this method returns <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果未找到 <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph>，此方法将返回 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29&gt;</ph> method is obsolete and has been retained for backward compatibility.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29&gt;</ph>方法已过时，已被保留用于向后兼容。</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>The non-obsolete alternative is <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">未过时的替代项为 <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>Applications that load assemblies with this method will be affected by upgrades of those assemblies.</source>
          <target state="translated">此方法加载程序集的应用程序将受这些程序集的升级。</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>Therefore, do not use this method; redesign the application to use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29&gt;</ph> method overload or the <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%28System.String%29&gt;</ph> method overload.</source>
          <target state="translated">因此，不使用此方法。重新设计应用程序使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29&gt;</ph>方法重载或<ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%28System.String%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>This method first calls <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>.</source>
          <target state="translated">此方法首先调用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</source>
          <target state="translated">如果未找到程序集，此方法将返回从全局程序集缓存中具有相同的简单名称和最高版本号的程序集。</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">程序集的显示名称。</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">用于加载程序集的证据。</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Loads an assembly from the application directory or from the global assembly cache using a partial name.</source>
          <target state="translated">使用部分名称从应用程序目录或从全局程序集缓存加载程序集。</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The assembly is loaded into the domain of the caller using the supplied evidence.</source>
          <target state="translated">使用提供的证据将该程序集加载到调用方的域中。</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>If <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> is not found, this method returns <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果未找到 <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph>，此方法将返回 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29&gt;</ph> method is obsolete and has been retained for backward compatibility.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29&gt;</ph>方法已过时，已被保留用于向后兼容。</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The non-obsolete alternative is <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">未过时的替代项为 <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</source>
          <target state="translated">证据是输入安全策略决策的一组信息（如代码可授予哪些权限）。</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Applications that load assemblies with this method will be affected by upgrades of those assemblies.</source>
          <target state="translated">此方法加载程序集的应用程序将受这些程序集的升级。</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Therefore, do not use this method; redesign the application to use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph> method.</source>
          <target state="translated">因此，不使用此方法。重新设计应用程序使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法或<ph id="ph2">&lt;xref:System.Reflection.Assembly.LoadFrom%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>This method first calls <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>.</source>
          <target state="translated">此方法首先调用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</source>
          <target state="translated">如果未找到程序集，此方法将返回从全局程序集缓存中具有相同的简单名称和最高版本号的程序集。</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different sets of evidence.</source>
          <target state="translated">一个程序集或模块用两个不同的证据集加载了两次。</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="partialName" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>for calling unmanaged code and to load an assembly with evidence.</source>
          <target state="translated">用于调用非托管的代码和证据加载程序集。</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.Location">
          <source>Gets the full path or UNC location of the loaded file that contains the manifest.</source>
          <target state="translated">获取包含清单的已加载文件的完整路径或 UNC 位置。</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>The location of the loaded file that contains the manifest.</source>
          <target state="translated">包含清单的已加载文件的位置。</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>If the loaded file was shadow-copied, the location is that of the file after being shadow-copied.</source>
          <target state="translated">如果已加载文件使用了影像复制，则该位置是该文件被影像复制后的位置。</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>If the assembly is loaded from a byte array, such as when using the <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /&gt;</ph> method overload, the value returned is an empty string ("").</source>
          <target state="translated">如果从字节数组加载程序集（如使用 <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /&gt;</ph> 方法重载时），则返回值为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>To get the location before the file has been shadow-copied, use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph> property.</source>
          <target state="translated">若要获取的位置，该文件已被卷影复制之前，使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.CodeBase%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>The following example displays the location of the loaded file that contains the manifest.</source>
          <target state="translated">下面的示例显示包含清单的已加载文件的位置。</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.Location">
          <source>The current assembly is a dynamic assembly, represented by an <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph> object.</source>
          <target state="translated">当前的程序集是动态程序集，由 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.AssemblyBuilder" /&gt;</ph> 对象表示。</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>for access to the path.</source>
          <target state="translated">用于访问路径。</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Location">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.ManifestModule">
          <source>Gets the module that contains the manifest for the current assembly.</source>
          <target state="translated">获取包含当前程序集清单的模块。</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ManifestModule">
          <source>The module that contains the manifest for the assembly.</source>
          <target state="translated">包含程序集清单的模块。</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="E:System.Reflection.Assembly.ModuleResolve">
          <source>Occurs when the common language runtime class loader cannot resolve a reference to an internal module of an assembly through normal means.</source>
          <target state="translated">当公共语言运行时类加载程序不能通过正常方法解析对程序集的内部模块的引用时发生。</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Reflection.Assembly.ModuleResolve">
          <source>This event gives the callback a chance to find and load the module itself and return it.</source>
          <target state="translated">此事件为回调提供了机会查找和加载模块本身并将其返回。</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Reflection.Assembly.ModuleResolve">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Reflection.Assembly.ModuleResolve">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.Modules">
          <source>Gets a collection that contains the modules in this assembly.</source>
          <target state="translated">获取包含此程序集中模块的集合。</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.Modules">
          <source>A collection that contains the modules in this assembly.</source>
          <target state="translated">包含此程序集中模块的集合。</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>The assembly to compare to <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">要与 <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept> 进行比较的程序集。</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>The assembly to compare to <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">要与 <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept> 进行比较的程序集。</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> objects are equal.</source>
          <target state="translated">指示两个 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> 对象是否相等。</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 等于 <ph id="ph2">&lt;paramref name="left" /&gt;</ph>，则为 <ph id="ph3">&lt;paramref name="right" /&gt;</ph>；否则为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>The assembly to compare to <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">要与 <bpt id="p1">&lt;c&gt;</bpt>right<ept id="p1">&lt;/c&gt;</ept> 进行比较的程序集。</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>The assembly to compare to <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">要与 <bpt id="p1">&lt;c&gt;</bpt>left<ept id="p1">&lt;/c&gt;</ept> 进行比较的程序集。</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> objects are not equal.</source>
          <target state="translated">指示两个 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> 对象是否不相等。</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 不等于 <ph id="ph2">&lt;paramref name="left" /&gt;</ph>，则为 <ph id="ph3">&lt;paramref name="right" /&gt;</ph>；否则为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.PermissionSet">
          <source>Gets the grant set of the current assembly.</source>
          <target state="translated">获取当前程序集的授予集。</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.PermissionSet">
          <source>The grant set of the current assembly.</source>
          <target state="translated">当前程序集的授予集。</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.PermissionSet">
          <source><ph id="ph1">&lt;xref:System.Security.PermissionSet&gt;</ph> objects can contain sensitive information such as paths.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.PermissionSet&gt;</ph> 对象可以包含敏感信息，例如路径。</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.PermissionSet">
          <source>Therefore, full trust is required to access these objects.</source>
          <target state="translated">因此，完全信任需要访问这些对象。</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.PermissionSet">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.PermissionSet">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.ReflectionOnly">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value indicating whether this assembly was loaded into the reflection-only context.</source>
          <target state="translated">获取 <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> 值，该值指示此程序集是否被加载到只反射上下文中。</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ReflectionOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the assembly was loaded into the reflection-only context, rather than the execution context; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果程序集被加载到只反射上下文而不是执行上下文中，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ReflectionOnly">
          <source>If an assembly has been loaded into the reflection-only context, using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> method, you cannot execute code in the assembly.</source>
          <target state="translated">如果程序集已加载到只反射上下文，使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph>方法，不能在程序集中执行代码。</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.ReflectionOnly">
          <source>To execute code, the assembly must be loaded into the execution context.</source>
          <target state="translated">若要执行代码，程序集必须加载到执行上下文。</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" uid="T:System.Reflection.Assembly">
          <source>Loads an assembly into the reflection-only context, where it can be examined but not executed.</source>
          <target state="translated">将程序集加载到只反射上下文中，在只反射上下文中可以检查但不能执行程序集。</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>A byte array that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">字节数组，它是包含已发出程序集的基于 COFF 的映像。</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>Loads the assembly from a common object file format (COFF)-based image containing an emitted assembly.</source>
          <target state="translated">加载来自基于通用对象文件格式 (COFF) 的映像的程序集，该映像包含已发出的程序集。</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>The assembly is loaded into the reflection-only context of the caller's application domain.</source>
          <target state="translated">程序集被加载到调用方的应用程序域的只反射上下文中。</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>You cannot execute code from an assembly loaded into the reflection-only context.</source>
          <target state="translated">无法从程序集加载到只反射上下文中执行代码。</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>To execute code, the assembly must be loaded into the execution context as well, using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">若要执行代码，程序集必须加载到执行上下文，使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>The reflection-only context is no different from other contexts.</source>
          <target state="translated">仅限反射的上下文是与其他上下文没有什么不同。</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</source>
          <target state="translated">可只能通过卸载应用程序域来卸载加载到上下文的程序集。</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> cannot be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> 不能被加载。</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>The display name of the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Reflection.AssemblyName.FullName" /&gt;</ph> property.</source>
          <target state="translated">程序集的显示名称，由 <ph id="ph1">&lt;see cref="P:System.Reflection.AssemblyName.FullName" /&gt;</ph> 属性返回。</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Loads an assembly into the reflection-only context, given its display name.</source>
          <target state="translated">将给定显示名称的程序集加载到只反射上下文中。</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Dependencies are not automatically loaded into the reflection-only context.</source>
          <target state="translated">依赖项不会自动加载到只反射上下文。</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>You cannot execute code from an assembly loaded into the reflection-only context.</source>
          <target state="translated">无法从程序集加载到只反射上下文中执行代码。</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>To execute code, the assembly must be loaded into the execution context as well, using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">若要执行代码，程序集必须加载到执行上下文，使用<ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Whether certain permissions are granted or not granted to an assembly is based on evidence.</source>
          <target state="translated">是否将特定的权限授予程序集是基于证据的。</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>The rules for assembly and security evidence merging are as follows:</source>
          <target state="translated">程序集和安全证据的合并的规则如下所示：</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Reflecting on executable files compiled in C++ might throw a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph>.</source>
          <target state="translated">在 c + + 中编译的可执行文件上进行反射可能会引发<ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file.</source>
          <target state="translated">这很可能是由于 c + + 编译器的重定位地址或.reloc 节从可执行文件所引起。</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>To preserve the .reloc address, specify <ph id="ph1">`/fixed:no`</ph> when you are linking.</source>
          <target state="translated">若要保留.reloc 地址，请指定<ph id="ph1">`/fixed:no`</ph>在链接时。</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>The reflection-only context is no different from other contexts.</source>
          <target state="translated">仅限反射的上下文是与其他上下文没有什么不同。</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</source>
          <target state="translated">可只能通过卸载应用程序域来卸载加载到上下文的程序集。</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 未找到。</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is found, but cannot be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 已找到，但是不能加载。</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The path of the file that contains the manifest of the assembly.</source>
          <target state="translated">包含程序集清单的文件的路径。</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>Loads an assembly into the reflection-only context, given its path.</source>
          <target state="translated">将给定路径的程序集加载到只反射上下文中。</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>Dependencies are not automatically loaded into the reflection-only context.</source>
          <target state="translated">依赖项不会自动加载到只反射上下文。</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>To automatically load dependencies, handle the <ph id="ph1">&lt;xref:System.AppDomain.ReflectionOnlyAssemblyResolve&gt;</ph> event and load the dependency in the event handler.</source>
          <target state="translated">若要自动加载依赖关系，处理<ph id="ph1">&lt;xref:System.AppDomain.ReflectionOnlyAssemblyResolve&gt;</ph>事件和负载中的事件处理程序的依赖关系。</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>You cannot execute code from an assembly that has been loaded into the reflection-only context.</source>
          <target state="translated">无法从已加载到只反射上下文的程序集执行代码。</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>To execute the code, load the assembly with the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">若要执行该代码，加载的程序集中<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The <ph id="ph1">`assemblyFile`</ph> parameter must refer to a URI without escape characters.</source>
          <target state="translated"><ph id="ph1">`assemblyFile`</ph>参数必须引用未转义符的 URI。</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>This method supplies escape characters for all invalid characters in the URI.</source>
          <target state="translated">此方法提供 URI 中的所有无效字符的转义的字符。</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The path specified for <ph id="ph1">`assemblyFile`</ph> is relative to the current directory.</source>
          <target state="translated">为指定的路径<ph id="ph1">`assemblyFile`</ph>相对于当前目录。</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The assembly is loaded into the domain of the caller.</source>
          <target state="translated">程序集被加载到调用方的域。</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The reflection-only context is no different from other contexts.</source>
          <target state="translated">仅限反射的上下文是与其他上下文没有什么不同。</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</source>
          <target state="translated">可只能通过卸载应用程序域来卸载加载到上下文的程序集。</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a file name extension.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph>，或者你正在试图加载的模块未指定文件扩展名。</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is found, but could not be loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 已找到，但是未能加载。</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">当前加载的是公共语言运行时 2.0 版或更高版本，而 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 是用更高的版本编译的。</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">在没有所需 <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> 的情况下，指定了不以“file://”开始的基本代码。</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">程序集名称的长度超过 MAX_PATH 个字符。</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>for reading a URI that begins with "file://".</source>
          <target state="translated">用于读取开头"file://"的 URI。</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">用于读取一个 URI，不以"file://"开头。</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="P:System.Reflection.Assembly.SecurityRuleSet">
          <source>Gets a value that indicates which set of security rules the common language runtime (CLR) enforces for this assembly.</source>
          <target state="translated">获取一个值，该值指示公共语言运行时 (CLR) 对此程序集强制执行的安全规则集。</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.SecurityRuleSet">
          <source>The security rule set that the CLR enforces for this assembly.</source>
          <target state="translated">CLR 对此程序集强制执行的安全规则集。</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.SecurityRuleSet">
          <source>By default, assemblies that you compile with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> have  transparency, although you can explicitly make them  instead.</source>
          <target state="translated">默认情况下，使用编译的程序集<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>具有透明度，尽管您明确可以改为使它们。</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.SecurityRuleSet">
          <source>Assemblies that were compiled with earlier versions of the .NET Framework have level 1 transparency.</source>
          <target state="translated">与早期版本的.NET Framework 编译的程序集具有 1 级透明度。</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Assembly.SecurityRuleSet">
          <source>See <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">请参阅<bpt id="p1">[</bpt>安全更改<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType">
          <source>Returns the type of the current instance.</source>
          <target state="translated">返回当前实例的类型。</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType">
          <source>An object that represents the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> type.</source>
          <target state="translated">表示 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> 类型的对象。</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ToString">
          <source>Returns the full name of the assembly, also known as the display name.</source>
          <target state="translated">返回程序集的全名，即所谓的显示名称。</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.ToString">
          <source>The full name of the assembly, or the class name if the full name of the assembly cannot be determined.</source>
          <target state="translated">程序集的全名；如果不能确定程序集的全名，则为类名。</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>The name or path of the file that contains the manifest of the assembly.</source>
          <target state="translated">包含程序集清单的文件的名称或路径。</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>Loads an assembly into the load-from context, bypassing some security checks.</source>
          <target state="translated">绕过某些安全检查，将程序集加载到加载源上下文中。</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">加载的程序集。</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>Use this method to load a local assembly that the operating system has flagged as having been loaded from the Web (for example, a temporary file that was downloaded from the Internet or intranet).</source>
          <target state="translated">此方法用于加载操作系统标记为从 Web （例如，从 Internet 或 intranet 下载的临时文件） 的本地程序集。</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>Before the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, such assemblies were automatically loaded into a sandboxed application domain.</source>
          <target state="translated">之前<ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>，这样的程序集已自动加载到沙盒应用程序域。</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, they are loaded with full trust.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>，它们是以完全信任方式加载。</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>As an alternative to using this method, you can apply the <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>NetFx40_LegacySecurityPolicy<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)</ept> in your application configuration file.</source>
          <target state="translated">作为使用此方法的替代方法，你可以将应用<bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>NetFx40_LegacySecurityPolicy<ph id="ph2">&amp;gt;</ph>元素<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)</ept>应用程序配置文件中。</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>This causes the common language runtime to revert to the security policy of the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>.</source>
          <target state="translated">这将导致公共语言运行时，若要还原到的安全策略<ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>If you use either of these solutions, you must be certain that it is safe to load <ph id="ph1">`assemblyFile`</ph> with full trust.</source>
          <target state="translated">如果你使用任一解决方案，你必须是确定它是否安全加载<ph id="ph1">`assemblyFile`</ph>以完全信任。</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>For a discussion of load contexts, including the load-from context, see the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%28System.String%29&gt;</ph> method overload.</source>
          <target state="translated">讨论的加载上下文，包括加载源上下文中，请参阅<ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%28System.String%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found, or the module you are trying to load does not specify a filename extension.</source>
          <target state="translated">未找到 <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph>，或者尝试加载的模块没有指定文件扩展名。</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>A file that was found could not be loaded.</source>
          <target state="translated">无法加载已找到的文件。</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 不是有效的程序集。</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 使用高于当前所加载版本的公共语言运行时版本编译而成。</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>A codebase that does not start with "file://" was specified without the required <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph>.</source>
          <target state="translated">在没有所需 <ph id="ph1">&lt;see cref="T:System.Net.WebPermission" /&gt;</ph> 的情况下，指定了不以“file://”开始的基本代码。</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> parameter is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> 参数为空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>The assembly name is longer than MAX_PATH characters.</source>
          <target state="translated">程序集名称的长度超过 MAX_PATH 个字符。</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>