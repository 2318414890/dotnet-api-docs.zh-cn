<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d3d5877ccfca1ad46bc974cf9102a85adaba2a32" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30481491" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示一个程序集，它是一个可重用、无版本冲突并且可自我描述的公共语言运行时应用程序构建基块。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Reflection.Assembly>类加载程序集，若要浏览的元数据和构成部分的程序集，以便发现的类型包含在程序集中，从而创建这些类型的实例。  
  
 若要获取的数组<xref:System.Reflection.Assembly>对象当前表示程序集加载到应用程序域 （例如，默认应用程序域的一个简单的项目），使用<xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType>方法。  
  
 动态，加载程序集<xref:System.Reflection.Assembly>类提供的以下静态方法 (`Shared`在 Visual Basic 中的方法)。 程序集是加载到加载操作的出现位置的应用程序域。  
  
-   加载程序集的建议的方法是使用<xref:System.AppDomain.Load%2A>方法，它标识要按其显示名称加载的程序集 (例如，"System.Windows.Forms，Version = 2.0.0.0，区域性 = neutral，PublicKeyToken = b77a5c561934e089")。 程序集搜索将遵循中所述的规则[运行时如何定位程序集](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)。  
  
-   <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法使你能够加载为反射，但不是为执行程序集。 例如，可以通过在 32 位平台运行的代码将检查面向 64 位平台程序集。  
  
-   <xref:System.Reflection.Assembly.LoadFile%2A>和<xref:System.Reflection.Assembly.LoadFrom%2A>方法为在其中必须由路径标识程序集的极少数情况下提供。  
  
 若要获取<xref:System.Reflection.Assembly>对于当前正在执行的程序集，使用对象<xref:System.Reflection.Assembly.GetExecutingAssembly%2A>方法。  
  
 许多成员<xref:System.Reflection.Assembly>类提供有关程序集的信息。 例如:  
  
-   <xref:System.Reflection.Assembly.GetName%2A>方法返回<xref:System.Reflection.AssemblyName>提供各部分的程序集显示名称的访问的对象。  
  
-   <xref:System.Reflection.Assembly.GetCustomAttributes%2A>方法列出应用于程序集的特性。  
  
-   <xref:System.Reflection.Assembly.GetFiles%2A>方法提供对程序集清单中的文件的访问。  
  
-   <xref:System.Reflection.Assembly.GetManifestResourceNames%2A>方法提供的程序集清单中的资源的名称。  
  
 <xref:System.Reflection.Assembly.GetTypes%2A>方法列举程序集中的所有类型。 <xref:System.Reflection.Assembly.GetExportedTypes%2A>方法列出对调用方的程序集外部可见的类型。 <xref:System.Reflection.Assembly.GetType%2A>方法可以用于搜索的程序集中的特定类型。 <xref:System.Reflection.Assembly.CreateInstance%2A>方法可以用于搜索并在程序集中创建类型的实例。  
  
 程序集的详细信息，请参阅中的"应用程序域和程序集"部分[应用程序域](~/docs/framework/app-domains/application-domains.md)主题。  
  
   
  
## Examples  
 下面的代码示例演示如何获取当前正在执行的程序集，创建包含该程序集中，类型的实例并调用与后期绑定的类型的方法之一。 为此目的，下面的代码示例定义一个名为`Example`，使用一个名为方法`SampleMethod`。 类的构造函数接受一个整数，用于计算的方法的返回值。  
  
 代码示例还演示了利用<xref:System.Reflection.Assembly.GetName%2A>方法来获取<xref:System.Reflection.AssemblyName>可以用于分析的程序集的完整名称的对象。 该示例显示的程序集的版本号<xref:System.Reflection.Assembly.CodeBase%2A>属性，与<xref:System.Reflection.Assembly.EntryPoint%2A>属性。  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">对继承者的完全信任。 此类不能由部分受信任的代码继承。</permission>
    <threadsafe>此类型是线程安全的。</threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Reflection.Assembly" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数由派生类调用的构造过程<xref:System.Reflection.Assembly>对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取最初指定的程序集的位置，例如，在 <see cref="T:System.Reflection.AssemblyName" /> 对象中指定的位置。</summary>
        <value>程序集的位置（按照最初的指定）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取的清单包含已加载文件的绝对路径，请使用<xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType>属性改为。  
  
 如果程序集被加载作为字节数组，使用的重载<xref:System.Reflection.Assembly.Load%2A>采用的字节数组的方法，此属性返回的方法，而不加载的程序集的位置的调用方的位置。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Reflection.Assembly.CodeBase%2A>属性。  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从此程序集中查找某个类型，然后使用系统激活器创建它的实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">要查找类型的 <see cref="P:System.Type.FullName" />。</param>
        <summary>使用区分大小写的搜索，从此程序集中查找指定的类型，然后使用系统激活器创建它的实例。</summary>
        <returns>使用默认构造函数创建的指定类型的实例；如果未找到 <see langword="null" /> 则为 <paramref name="typeName" />。 该类型使用默认联编程序解析，而无需指定区域性或激活属性，并将 <see cref="T:System.Reflection.BindingFlags" /> 设置为 <see langword="Public" /> 或 <see langword="Instance" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果运行时找不到`typeName`中<xref:System.Reflection.Assembly>实例，它将返回`null`而不是引发异常。 这可能是因为：  
  
-   你还没有指定类型的完全限定的名称。  
  
-   你指定的完全限定的类型名称，但其大小写不匹配的类型的大小写<xref:System.Type.FullName%2A?displayProperty=nameWithType>属性。 有关不区分大小写的比较`typeName`使用该类型的全名，调用<xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29>重载并指定`true`为`ignoreCase`自变量。  
  
-   类型不存在于当前<xref:System.Reflection.Assembly>实例。  
  
   
  
## Examples  
 下面的示例定义`Person`类和调用<xref:System.Reflection.Assembly.CreateInstance%28System.String%29>其进行实例化的方法。  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> 为空字符串 ("") 或以空字符开头的字符串。  
  
 或  
  
 当前程序集已加载到仅反射上下文中。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的构造函数。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> 所需的从属程序集无法找到。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> 所需的从属程序集已找到，但无法加载。  
  
 或  
  
 当前程序集被加载到仅反射上下文中，并且 <paramref name="typeName" /> 所需的从属程序集未预先加载。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> 需要一个从属程序集，但该文件不是有效的程序集。  
  
 或  
  
 <paramref name="typeName" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">调用时后期绑定通过机制如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要查找类型的 <see cref="P:System.Type.FullName" />。</param>
        <param name="ignoreCase">
          如果为 <see langword="true" />，则忽略类型名的大小写；否则，为 <see langword="false" />。</param>
        <summary>使用可选的区分大小写搜索，从此程序集中查找指定的类型，然后使用系统激活器创建它的实例。</summary>
        <returns>使用默认构造函数创建的指定类型的实例；如果未找到 <see langword="null" /> 则为 <paramref name="typeName" />。 该类型使用默认联编程序解析，而无需指定区域性或激活属性，并将 <see cref="T:System.Reflection.BindingFlags" /> 设置为 <see langword="Public" /> 或 <see langword="Instance" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果运行时找不到`typeName`中<xref:System.Reflection.Assembly>实例，它将返回`null`而不是引发异常。 这可能是因为：  
  
-   你还没有指定类型的完全限定的名称。  
  
-   类型不存在于当前<xref:System.Reflection.Assembly>实例。  
  
   
  
## Examples  
 下面的示例定义`Person`类。 然后，它调用<xref:System.Reflection.Assembly.CreateInstance%28System.String%29>方法可实例化，但是，由于的大小写`typeName`自变量不匹配的类型的<xref:System.Type.FullName%2A>属性，该方法返回`null`。 当示例将传递到相同的字符串<xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29>重载，并指定比较应区分大小写，`Person`找到该类，和一个`Person`成功实例化对象。  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> 为空字符串 ("") 或以空字符开头的字符串。  
  
 或  
  
 当前程序集已加载到仅反射上下文中。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的构造函数。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> 所需的从属程序集无法找到。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> 所需的从属程序集已找到，但无法加载。  
  
 或  
  
 当前程序集被加载到仅反射上下文中，并且 <paramref name="typeName" /> 所需的从属程序集未预先加载。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> 需要一个从属程序集，但该文件不是有效的程序集。  
  
 或  
  
 <paramref name="typeName" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">调用时后期绑定通过机制如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">要查找类型的 <see cref="P:System.Type.FullName" />。</param>
        <param name="ignoreCase">
          如果为 <see langword="true" />，则忽略类型名的大小写；否则，为 <see langword="false" />。</param>
        <param name="bindingAttr">影响执行搜索的方式的位掩码。 此值是 <see cref="T:System.Reflection.BindingFlags" /> 中的位标志的组合。</param>
        <param name="binder">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <see langword="MemberInfo" /> 对象的检索。 如果 <c>binder</c> 为 <see langword="null" />，则使用默认活页夹。</param>
        <param name="args">包含要传递给构造函数的自变量的数组。 此自变量数组在数量、顺序和类型方面必须与要调用的构造函数的参数匹配。 如果需要默认的构造函数，则 <c>args</c> 必须是空数组或 <see langword="null" />。</param>
        <param name="culture">用于控制类型强制的 <see langword="CultureInfo" /> 的实例。 如果这是 <see langword="null" />，则使用当前线程的 <see langword="CultureInfo" />。 （例如，这对于将表示 1000 的 <see langword="String" /> 转换为 <see langword="Double" /> 值是必需的，因为不同的区域性以不同的方式表示 1000。）</param>
        <param name="activationAttributes">包含一个或多个可以参与激活的特性的数组。 通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。  此参数与客户端激活的对象相关。 客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。 应改用 Windows Communication Foundation 来开发分布式应用程序。</param>
        <summary>使用可选的区分大小写搜索并具有指定的区域性、自变量和绑定及激活特性，从此程序集中查找指定的类型，并使用系统激活器创建它的实例。</summary>
        <returns>如果未找到 <see langword="null" />，则为指定的类型实例或 <paramref name="typeName" />。 所提供的自变量用于解析类型，以及绑定用于创建实例的构造函数。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> 为空字符串 ("") 或以空字符开头的字符串。  
  
 或  
  
 当前程序集已加载到仅反射上下文中。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的构造函数。</exception>
        <exception cref="T:System.NotSupportedException">向非继承自 <see cref="T:System.MarshalByRefObject" /> 的类型传递非空的激活特性数组。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> 所需的从属程序集无法找到。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> 所需的从属程序集已找到，但无法加载。  
  
 或  
  
 当前程序集被加载到仅反射上下文中，并且 <paramref name="typeName" /> 所需的从属程序集未预先加载。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> 需要一个从属程序集，但该文件不是有效的程序集。  
  
 或  
  
 <paramref name="typeName" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">调用时后期绑定通过机制如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要创建委托的一个实例。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">程序集的显示名称。</param>
        <param name="typeName">类型的全名。</param>
        <summary>创建由类型的程序集的显示名称限定的类型的名称。</summary>
        <returns>由程序集的显示名称限定的类型的完整名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回字符串的格式为：  
  
 \<FullTypeName>, \<AssemblyDisplayName>  
  
 请参阅<xref:System.Reflection.AssemblyName>有关程序集的显示名称的格式的说明。  
  
 若要适应的公共语言运行时版本中的更改，请使用此方法，而不是无需自行构造的限定的名称。  有关限定的程序集名称的信息，请参阅<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含此程序集自定义属性的集合。</summary>
        <value>包含此程序集自定义属性的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取定义在此程序集中的类型的集合。</summary>
        <value>定义在此程序集中的类型的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.DefinedTypes%2A>属性相当于<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>方法，只不过<xref:System.Reflection.Assembly.DefinedTypes%2A>属性返回的集合<xref:System.Reflection.TypeInfo>对象，与<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>方法返回的数组<xref:System.Type>对象。  
  
 返回的数组包含嵌套的类型。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此程序集的入口点。</summary>
        <value>表示此程序集入口点的对象。 如果没有找到入口点（例如，此程序集是一个 DLL），则返回 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">与该实例进行比较的对象。</param>
        <summary>确定此程序集和指定的对象是否相等。</summary>
        <returns>
          如果 <paramref name="o" /> 等于此实例，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.Equals%2A>方法执行测试引用相等性来确定是否当前的实例和`o`是否相等。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 URI，包括表示基本代码的转义符。</summary>
        <value>带有转义符的 URI。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此程序集的证据。</summary>
        <value>此程序集的证据。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 证据是输入安全策略决策的一组信息（如代码可授予哪些权限）。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此程序集中定义的公共类型的集合，这些公共类型在程序集外可见。</summary>
        <value>此程序集中定义的公共类型的集合，这些公共类型在程序集外可见。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取程序集的显示名称。</summary>
        <value>程序集的显示名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请参阅<xref:System.Reflection.AssemblyName>有关程序集的显示名称的格式的说明。  
  
> [!NOTE]
>  不建议编写你自己的代码来分析显示名称。 相反，将传递到的显示名称<xref:System.Reflection.AssemblyName.%23ctor%2A>构造函数，也不能对其进行分析将填充新的相应字段<xref:System.Reflection.AssemblyName>。  
  
 在.NET Framework 2.0 版中，处理器体系结构添加到程序集标识，并且可以指定为程序集名称字符串的一部分。 但是，不包括在返回的字符串<xref:System.Reflection.Assembly.FullName%2A>属性，出于兼容性原因。 请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 以下示例检索的当前正在执行的程序集的显示名称和包含的程序集的显示名称<xref:System.Int32>类型 (`int`在 C# 中，`Integer`在 Visual Basic 中)。  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">一个对象，该对象表示将返回的程序集中的类型。</param>
        <summary>获取在其中定义指定类型的当前加载的程序集。</summary>
        <returns>在其中定义指定类型的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法相当于检索的值的<xref:System.Type.Assembly?displayProperty=nameWithType>属性。 但是，<xref:System.Type.Assembly?displayProperty=nameWithType>属性通常提供优异的性能。  
  
 若要调用此方法，您必须<xref:System.Type>对象，这意味着，在其中定义类的程序集必须已经是加载。  
  
   
  
## Examples  
 下面的示例检索包含的程序集<xref:System.Int32>键入并显示其名称和文件的位置。  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">调用时后期绑定通过机制如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回方法（该方法调用当前正在执行的方法）的 <see cref="T:System.Reflection.Assembly" />。</summary>
        <returns>方法（该方法调用当前正在执行的方法）的 <see langword="Assembly" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该方法的调用<xref:System.Reflection.Assembly.GetCallingAssembly%2A>方法是内联展开的由实时 (JIT) 编译器，或者如果其调用方是内联展开的该程序集，则返回<xref:System.Reflection.Assembly.GetCallingAssembly%2A>可能会发生异常。 例如，考虑以下方法和程序集：  
  
-   方法`M1`集中`A1`调用<xref:System.Reflection.Assembly.GetCallingAssembly%2A>。  
  
-   方法`M2`集中`A2`调用`M1`。  
  
-   方法`M3`集中`A3`调用`M2`。  
  
 当`M1`不是内联，<xref:System.Reflection.Assembly.GetCallingAssembly%2A>返回`A2`。 当`M1`是内联，<xref:System.Reflection.Assembly.GetCallingAssembly%2A>返回`A3`。 同样，当`M2`不是内联，<xref:System.Reflection.Assembly.GetCallingAssembly%2A>返回`A2`。 当`M2`是内联，<xref:System.Reflection.Assembly.GetCallingAssembly%2A>返回`A3`。  
  
 这种效果也会发生时`M1`作为尾调用从执行`M2`，或当`M2`作为尾调用从执行`M3`。 你可以阻止从 JIT 编译器内联调用的方法<xref:System.Reflection.Assembly.GetCallingAssembly%2A>，通过应用<xref:System.Runtime.CompilerServices.MethodImplAttribute>特性与<xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType>标志，但没有任何类似机制来防止尾调用。  
  
   
  
## Examples  
 下面的示例获取当前方法的调用程序集。  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取此程序集的自定义属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">对于 <see cref="T:System.Reflection.Assembly" /> 类型的对象，将忽略此参数。</param>
        <summary>获取此程序集的所有自定义属性。</summary>
        <returns>包含此程序集自定义属性的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法实现相应<xref:System.Reflection.ICustomAttributeProvider>接口方法。 因此，`inherit`必须指定参数，即使它将被忽略。  
  
 伪属性指示该属性为存在时必须设置的核心元数据位。 不同于扩展类型的元数据并保存与类型的自定义属性，一个伪属性修改类型的元数据，并则将被丢弃。 无法使用现有的反射 Api 访问某些生成的数据位。  
  
 下表总结了不同的伪属性和可用于反射的位的访问。  
  
|Pseudo-Attribute|元数据位|反射访问器|  
|-----------------------|-------------------|-------------------------|  
|Sub|CorPInvokeMap<br /><br /> DLL 名称|有关 PInvokeMap 普通方法/全局方法属性没有访问器。<br /><br /> DLL 的名称没有访问器。|  
|GuidAttribute|存储的实际的自定义特性。|访问的实际的自定义特性。|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|各种位。|没有访问器。|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> 类封装。|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> 没有访问器。|  
|FieldOffsetAttribute|字段的偏移量。|没有访问器。|  
|AssemblyLoadAttribute|CorAssemblyFlags|没有访问器或枚举器。|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">调用时后期绑定通过机制如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">要为其返回自定义属性的类型。</param>
        <param name="inherit">对于 <see cref="T:System.Reflection.Assembly" /> 类型的对象，将忽略此参数。</param>
        <summary>获取按类型指定的此程序集的自定义属性。</summary>
        <returns>一个数组，它包含由 <paramref name="attributeType" /> 指定的此程序集的自定义属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法实现相应<xref:System.Reflection.ICustomAttributeProvider>接口方法。 因此，`inherit`必须指定参数，即使它将被忽略。  
  
 伪属性指示该属性为存在时必须设置的核心元数据位。 不同于扩展类型的元数据并保存与类型的自定义属性，一个伪属性修改类型的元数据，并则将被丢弃。 无法使用现有的反射 Api 访问某些生成的数据位。  
  
 下表总结了不同的伪属性和可用于反射的位的访问。  
  
|Pseudo-Attribute|元数据位|反射访问器|  
|-----------------------|-------------------|-------------------------|  
|Sub|CorPInvokeMap<br /><br /> DLL 名称|有关 PInvokeMap 普通方法/全局方法属性没有访问器。<br /><br /> DLL 的名称没有访问器。|  
|GuidAttribute|存储的实际的自定义特性。|访问的实际的自定义特性。|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|各种位。|没有访问器。|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> 类封装。|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> 没有访问器。|  
|FieldOffsetAttribute|字段的偏移量。|没有访问器。|  
|AssemblyLoadAttribute|CorAssemblyFlags|没有访问器或枚举器。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> 不是运行时类型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">调用时后期绑定通过机制如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回有关已应用于当前 <see cref="T:System.Reflection.Assembly" />（表示为 <see cref="T:System.Reflection.CustomAttributeData" /> 对象）的特性的信息。</summary>
        <returns>
          <see cref="T:System.Reflection.CustomAttributeData" /> 对象的泛型列表，这些对象表示有关已应用于当前程序集的特性的数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于检查要在其中加载到只反射上下文的代码中定义的自定义属性本身的情况下的仅限反射上下文中的代码的自定义属性。 等方法<xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType>和<xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType>不能在这种情况下，因为它们创建实例的属性。 仅反射上下文中的代码不能执行。 有关详细信息和有关示例代码，请参阅<xref:System.Reflection.CustomAttributeData>类。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取默认应用程序域中的进程可执行文件。 在其他的应用程序域中，这是由 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> 执行的第一个可执行文件。</summary>
        <returns>程序集是默认应用程序域中的进程可执行文件，或是由 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> 执行的第一个可执行文件。 当从非托管代码调用时可返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.GetEntryAssembly%2A>方法可以返回`null`托管程序集已从非托管应用程序加载。 例如，如果非托管应用程序创建的编写 C# 中，调用的 COM 组件实例<xref:System.Reflection.Assembly.GetEntryAssembly%2A>从 C# 组件的方法将返回 null，因为该过程的入口点非托管的代码而不是托管程序集。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取包含当前执行的代码的程序集。</summary>
        <returns>包含当前执行的代码的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 出于性能原因，你应仅当你不知道在设计时当前正在执行哪些程序集时才调用此方法。 检索的建议的方法<xref:System.Reflection.Assembly>对象，表示当前程序集是使用<xref:System.Type.Assembly%2A?displayProperty=nameWithType>如下面的示例所示，在程序集中，找到的一种类型的属性。  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 若要获取包含调用当前正在执行代码的方法的程序集，请使用<xref:System.Reflection.Assembly.GetCallingAssembly%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Type.Assembly%2A?displayProperty=nameWithType>要获取当前正在执行的程序集属性基于该程序集中所包含的类型。 它还会调用<xref:System.Reflection.Assembly.GetExecutingAssembly%2A>方法来显示它返回<xref:System.Reflection.Assembly>表示相同的程序集的对象。  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取此程序集中定义的公共类型，这些公共类型在程序集外可见。</summary>
        <returns>一个数组，表示此程序集中定义并在程序集外可见的类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 程序集外部可见的唯一类型是公共类型和嵌套在其他公共类型的公共类型。  
  
   
  
## Examples  
 下面的代码示例定义了多个类使用各种访问级别和调用<xref:System.Reflection.Assembly.GetExportedTypes%2A>以显示在程序集外部可见的。  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">程序集是动态程序集。</exception>
        <exception cref="T:System.IO.FileNotFoundException">无法加载从属程序集。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">指定文件的名称。 不包括文件的路径。</param>
        <summary>获取此程序集清单的文件表中指定文件的 <see cref="T:System.IO.FileStream" />。</summary>
        <returns>包含指定文件的流，如果找不到文件则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法对这两个公共和私有资源文件起作用。  
  
 `name`不应包含文件的路径。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          未找到 <paramref name="name" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> 不是有效的程序集。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">访问路径，用于读取指定的文件。 关联的枚举：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取程序集清单文件表中的文件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取程序集清单文件表中的文件。</summary>
        <returns>包含这些文件的流数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法对公共和私有资源文件起作用。  
  
 此重载是等效于调用<xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29>重载并指定`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件。</exception>
        <exception cref="T:System.BadImageFormatException">文件不是有效的程序集。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> 则包括资源模块；否则，为 <see langword="false" />。</param>
        <summary>获取程序集清单的文件表中的文件，指定是否包括资源模块。</summary>
        <returns>包含这些文件的流数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法对公共和私有资源文件起作用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件。</exception>
        <exception cref="T:System.BadImageFormatException">文件不是有效的程序集。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此实例的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取作为此程序集的一部分的所有加载模块。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取作为此程序集的一部分的所有加载模块。</summary>
        <returns>模块的数组。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> 则包括资源模块；否则，为 <see langword="false" />。</param>
        <summary>获取属于此程序集的所有已加载模块，同时指定是否包括资源模块。</summary>
        <returns>模块的数组。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">区分大小写的资源名称。</param>
        <summary>返回关于给定资源如何保持的信息。</summary>
        <returns>用关于资源拓扑的信息填充的对象；如果未找到资源，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅当资源对调用方可见或调用方具有返回资源信息<xref:System.Security.Permissions.ReflectionPermission>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceName" /> 参数为空字符串 ("")。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">调用时后期绑定通过机制如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此程序集中的所有资源的名称。</summary>
        <returns>包含所有资源名称的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此方法，如下所示的数组中，可以使用每个资源名称：  
  
-   你可以将传递到的资源名称<xref:System.Reflection.Assembly.GetManifestResourceInfo%2A>方法以获取有关资源的其他信息。  
  
-   如果该名称标识的二进制.resources 文件，你可以删除其.resources 文件扩展名，然后将其传递到<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType>构造函数实例化的资源管理器。  
  
-   你可以将传递到的资源名称<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>方法来检索<xref:System.IO.Stream>对象，然后你可以将其传递给<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType>构造函数。  
  
-   你可以将传递到的资源名称<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>方法来检索<xref:System.IO.Stream>对象，然后你可以将其传递给<xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType>构造函数。  
  
 仅当资源对调用方可见或调用方具有返回资源信息<xref:System.Security.Permissions.ReflectionPermission>。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">调用时后期绑定通过机制如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从此程序集加载指定的清单资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">所请求的清单资源的名称（区分大小写）。</param>
        <summary>从此程序集加载指定的清单资源。</summary>
        <returns>如果在编译期间没有指定任何资源，或者资源对调用方不可见，则为清单资源或者为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 清单资源是嵌入在编译时程序集中的某个资源 （例如图像文件）。 有关清单资源的详细信息，请参阅[Microsoft.NET Framework 资源基础知识](http://go.microsoft.com/fwlink/?LinkId=204554)MSDN 库中。  
  
 仅当资源对调用方可见或调用方具有返回资源信息<xref:System.Security.Permissions.ReflectionPermission>。  
  
> [!NOTE]
>  此方法返回`null`如果访问另一个程序集中的私有资源并且调用方没有<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>标志。  
  
 如果程序集清单列出的资源文件，<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>返回<xref:System.IO.Stream>对象即使资源文件不能在时找到磁盘上。 如果找不到资源文件，则传递生成<xref:System.IO.Stream>对象传递给<xref:System.Resources.ResourceReader>构造函数导致<xref:System.ArgumentException>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 在[适用于 Windows 应用商店应用的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或[可移植类库](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 无法加载已找到的文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          未找到 <paramref name="name" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> 不是有效的程序集。</exception>
        <exception cref="T:System.NotImplementedException">资源的长度大于 <see cref="F:System.Int64.MaxValue" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">调用时后期绑定通过机制如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">其命名空间用于确定清单资源名的范围的类型。</param>
        <param name="name">所请求的清单资源的名称（区分大小写）。</param>
        <summary>从此程序集加载指定清单资源，清单资源的范围由指定类型的命名空间确定。</summary>
        <returns>如果在编译期间没有指定任何资源，或者资源对调用方不可见，则为清单资源或者为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，如果为指定的完整名称`type`是"MyNameSpace.MyClasses"和`name`是"Net"，此方法重载搜索名为"MyNameSpace.Net"的资源。  
  
 清单资源是嵌入在编译时程序集中的某个资源 （例如图像文件）。 有关清单资源的详细信息，请参阅[Microsoft.NET Framework 资源基础知识](http://go.microsoft.com/fwlink/?LinkId=204554)MSDN 库中。  
  
 仅当资源对调用方可见或调用方具有返回资源信息<xref:System.Security.Permissions.ReflectionPermission>。  
  
> [!NOTE]
>  此方法返回`null`如果访问另一个程序集中的私有资源并且调用方没有<xref:System.Security.Permissions.ReflectionPermission>与<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>标志。  
  
 如果程序集清单列出的资源文件，<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>返回<xref:System.IO.Stream>对象即使资源文件不能在时找到磁盘上。 如果找不到资源文件，则传递生成<xref:System.IO.Stream>对象传递给<xref:System.Resources.ResourceReader>构造函数导致<xref:System.ArgumentException>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          未找到 <paramref name="name" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> 不是有效的程序集。</exception>
        <exception cref="T:System.NotImplementedException">资源的长度大于 <see cref="F:System.Int64.MaxValue" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">调用时后期绑定通过机制如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。 关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">请求的模块的名称。</param>
        <summary>获取此程序集中的指定模块。</summary>
        <returns>所请求的模块，若未找到该模块则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法适用于文件的名称。  
  
 中的类`Reflection.Emit`命名空间发出的动态模块的范围名称。 可以通过确定作用域名称<xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType>属性。 传递到所需的模块类型`Assembly.GetModule`。 例如，如果你想包含程序集清单的模块，传递到模块作用域名称`GetModule`。 否则，将传递该模块的文件名。 程序集加载的之一`Load`具有 byte [] 参数的方法具有只有一个模块，并且这是清单的模块。 始终查找这些模块使用该作用域名称。  
  
 一种类型可检索特定模块使用<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>。 调用`Module.GetType`模块包含清单将不会发起的整个程序集搜索。 若要从一个程序集，无论是哪个模块什么会在中，检索类型必须调用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          未找到 <paramref name="name" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> 不是有效的程序集。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取作为此程序集的一部分的所有模块。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取作为此程序集的一部分的所有模块。</summary>
        <returns>模块的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法对公共和私有资源文件起作用。  
  
> [!NOTE]
>  模块必须发出具有文件扩展名。  
  
   
  
## Examples  
 下面的示例显示返回的数组，其中包含程序集清单的模块的名称。  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">要加载的模块未指定文件扩展名。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> 则包括资源模块；否则，为 <see langword="false" />。</param>
        <summary>获取属于此程序集的所有模块，同时指定是否包括资源模块。</summary>
        <returns>模块的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法对公共和私有资源文件起作用。  
  
> [!NOTE]
>  模块必须发出具有文件扩展名。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取此程序集的 <see cref="T:System.Reflection.AssemblyName" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取此程序集的 <see cref="T:System.Reflection.AssemblyName" />。</summary>
        <returns>包含此程序集的完全分析的显示名称的对象。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问程序集的路径。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">
          如果为 <see langword="true" />，则将 <see cref="P:System.Reflection.Assembly.CodeBase" /> 设置为程序集被影像复制后的位置；如果为 <see langword="false" />，则将 <see cref="P:System.Reflection.Assembly.CodeBase" /> 设置为原位置。</param>
        <summary>获取此程序集的 <see cref="T:System.Reflection.AssemblyName" />，并按 <paramref name="copiedName" /> 指定的那样设置基本代码。</summary>
        <returns>包含此程序集的完全分析的显示名称的对象。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问程序集的路径。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">用序列化信息填充的对象。</param>
        <param name="context">序列化的目标上下文。</param>
        <summary>获取序列化信息，其中包含重新实例化此程序集所需的所有数据。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取此程序集引用的所有程序集的 <see cref="T:System.Reflection.AssemblyName" /> 对象。</summary>
        <returns>包含此程序集引用的所有程序集的完全分析的显示名称的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  从开始[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>属性<xref:System.Reflection.AssemblyName>此方法返回的对象是<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType>如果没有引用的程序集，哈希算法或引用的程序集的哈希算法不是由标识<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType>枚举。 在以前版本的.NET Framework 中，<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>属性返回<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType>在此情况下。  
  
   
  
## Examples  
 下面的代码示例演示如何调用<xref:System.Reflection.Assembly.GetReferencedAssemblies%2A>方法。 此代码示例摘自更大的示例为提供<xref:System.Reflection.Assembly>类。  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取附属程序集。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">指定的区域性。</param>
        <summary>获取指定区域性的附属程序集。</summary>
        <returns>指定的附属程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附属程序集包含本地化的资源，不同于主应用程序程序集，其中包含非本地化可执行代码和单个区域性用作默认或非特定区域性的资源。  
  
 调用此方法以使用您当前的程序集版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到此程序集。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了具有匹配文件名的附属程序集，但 <see langword="CultureInfo" /> 与所指定的不匹配。</exception>
        <exception cref="T:System.BadImageFormatException">附属程序集不是有效的程序集。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">指定的区域性。</param>
        <param name="version">附属程序集的版本。</param>
        <summary>获取指定区域性的附属程序集的指定版本。</summary>
        <returns>指定的附属程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附属程序集包含本地化的资源，不同于主应用程序程序集，其中包含非本地化可执行代码和单个区域性用作默认或非特定区域性的资源。  
  
 调用<xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29>重载以使用你当前的程序集版本。  
  
 如果`version`是`null`，如果资源和主程序集进行签名，则使用当前的程序集版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了具有匹配的文件名的附属程序集，但 <see langword="CultureInfo" /> 或版本与所指定的不匹配。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到该程序集。</exception>
        <exception cref="T:System.BadImageFormatException">附属程序集不是有效的程序集。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取表示指定类型的 <see cref="T:System.Type" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">类型的全名。</param>
        <summary>获取程序集实例中具有指定名称的 <see cref="T:System.Type" /> 对象。</summary>
        <returns>表示指定类的对象，若未找到该类则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅搜索当前程序集实例。 `name`参数包含命名空间而不是程序集。 若要搜索的一种类型的其他程序集，请使用<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>方法重载，它可以选择性地包含程序集显示名称作为类型名称的一部分。  
  
> [!NOTE]
>  如果类型已被转发给另一个程序集，它仍将返回此方法。 类型转发的信息，请参阅[公共语言运行时中的类型转发](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
   
  
## Examples  
 下面的示例定义一个抽象`MeansOfTransportation`类`Transportation`命名空间。 它调用<xref:System.Reflection.Assembly.GetType%28System.String%29>方法来检索其<xref:System.Type>对象、 调用<xref:System.Type.GetProperties%2A?displayProperty=nameWithType>方法以获取数组的<xref:System.Reflection.PropertyInfo>对象，表示该类型的属性，然后将信息显示在该类型的抽象属性。 请注意，调用<xref:System.Reflection.Assembly.GetType%28System.String%29>方法使用该类型的完全限定的名称 （即，其类型名称以及其命名空间）。  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 无效。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> 所需的从属程序集无法找到。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 在[适用于 Windows 应用商店应用的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或[可移植类库](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>
          <paramref name="name" /> 所需的从属程序集已找到，但无法加载。  
  
 或  
  
 当前程序集被加载到仅反射上下文中，并且 <paramref name="name" /> 所需的从属程序集未预先加载。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> 需要一个从属程序集，但该文件不是有效的程序集。  
  
 或  
  
 <paramref name="name" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">类型的全名。</param>
        <param name="throwOnError">
          <see langword="true" /> 表示在找不到该类型时引发异常；<see langword="false" /> 则表示返回 <see langword="null" />。</param>
        <summary>获取程序集实例中具有指定名称的 <see cref="T:System.Type" /> 对象，并选择在找不到该类型时引发异常。</summary>
        <returns>表示指定类的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅搜索当前程序集实例。 `name`参数包含命名空间而不是程序集。 若要搜索的一种类型的其他程序集，请使用<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>方法重载，它可以选择性地包含程序集显示名称作为类型名称的一部分。  
  
> [!NOTE]
>  如果类型已被转发给另一个程序集，它仍将返回此方法。 类型转发的信息，请参阅[公共语言运行时中的类型转发](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
 `throwOnError`参数仅影响找不到类型时，会发生什么情况。 它不会影响任何其他可能引发的异常。 具体而言，如果找到的类型，但不能加载，<xref:System.TypeLoadException>可以引发即使`throwOnError`是`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 无效。  
  
 或  
  
 <paramref name="name" /> 的长度超过 1024 个字符。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 为 <see langword="true" />，且找不到此类型。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> 所需的从属程序集无法找到。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> 所需的从属程序集已找到，但无法加载。  
  
 或  
  
 当前程序集被加载到仅反射上下文中，并且 <paramref name="name" /> 所需的从属程序集未预先加载。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> 需要一个从属程序集，但该文件不是有效的程序集。  
  
 或  
  
 <paramref name="name" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">类型的全名。</param>
        <param name="throwOnError">
          <see langword="true" /> 表示在找不到该类型时引发异常；<see langword="false" /> 则表示返回 <see langword="null" />。</param>
        <param name="ignoreCase">
          如果为 <see langword="true" />，则忽略类型名的大小写；否则，为 <see langword="false" />。</param>
        <summary>获取程序集实例中具有指定名称的 <see cref="T:System.Type" /> 对象，带有忽略大小写和在找不到该类型时引发异常的选项。</summary>
        <returns>表示指定类的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅搜索当前程序集实例。 `name`参数包含命名空间而不是程序集。 若要搜索的一种类型的其他程序集，请使用<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>方法重载，它可以选择性地包含程序集显示名称作为类型名称的一部分。  
  
> [!NOTE]
>  如果类型已被转发给另一个程序集，它仍将返回此方法。 类型转发的信息，请参阅[公共语言运行时中的类型转发](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
 `throwOnError`参数仅影响找不到类型时，会发生什么情况。 它不会影响任何其他可能引发的异常。 具体而言，如果找到的类型，但不能加载，<xref:System.TypeLoadException>可以引发即使`throwOnError`是`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 无效。  
  
 或  
  
 <paramref name="name" /> 的长度超过 1024 个字符。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> 为 <see langword="true" />，且找不到此类型。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> 所需的从属程序集无法找到。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> 所需的从属程序集已找到，但无法加载。  
  
 或  
  
 当前程序集被加载到仅反射上下文中，并且 <paramref name="name" /> 所需的从属程序集未预先加载。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> 需要一个从属程序集，但该文件不是有效的程序集。  
  
 或  
  
 <paramref name="name" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取此程序集中定义的类型。</summary>
        <returns>一个数组，包含此程序集中定义的所有类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的数组包含嵌套的类型。  
  
 如果<xref:System.Reflection.Assembly.GetTypes%2A>对程序集和类型调用方法，该程序集中依赖于尚未加载 （例如，如果它派生于第二个程序集中的类型），程序集中的类型<xref:System.Reflection.ReflectionTypeLoadException>引发。 例如，可能的原因是第一个程序集被加载与<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>或<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法和第二个程序集未加载。 它也可能会导致与使用加载的程序集<xref:System.Reflection.Assembly.Load%2A>和<xref:System.Reflection.Assembly.LoadFile%2A>方法如果第二个程序集不能定位时<xref:System.Reflection.Assembly.GetTypes%2A>调用方法。  
  
> [!NOTE]
>  如果类型已被转发给另一个程序集，它不是包括在返回的数组。 类型转发的信息，请参阅[公共语言运行时中的类型转发](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
 若要检索的集合<xref:System.Reflection.TypeInfo>对象而不是数组的<xref:System.Type>对象，请使用<xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType>属性。  
  
   
  
## Examples  
 下面的示例显示在指定的程序集中的类型上的一种方法的参数。  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">该程序集包含一个或多个无法加载的类型。 此异常的 <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> 属性返回的数组针对已加载的每个类型包含一个 <see cref="T:System.Type" /> 对象，针对无法加载的每个类型包含一个 <see langword="null" />，而 <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> 属性针对无法加载的每个类型包含一个异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示程序集是否是从全局程序集缓存加载的。</summary>
        <value>
          如果程序集是从全局程序集缓存加载的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于加载程序集的主机上下文。</summary>
        <value>一个 <see cref="T:System.Int64" /> 值，指示用于加载程序集的主机上下文（如果有）。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取表示公共语言运行时 (CLR) 的版本的字符串，该信息保存在包含清单的文件中。</summary>
        <value>CLR 版本的文件夹名。 这不是完整路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如，.NET Framework 1.1 版的值将 v1.1.4322。 该版本的二进制文件将位于路径 %windir%\microsoft.net\framework\v1.1.4322。  
  
 默认情况下，<xref:System.Reflection.Assembly.ImageRuntimeVersion%2A>已设置为用于生成程序集的 clr 版本。 但是，它可能已设置为其他值在编译时。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">要为此程序集检查的属性类型。</param>
        <param name="inherit">对于该类型的对象，将忽略此自变量。</param>
        <summary>指示指定的属性是否已应用于该程序集。</summary>
        <returns>
          如果已将该属性应用于程序集，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例适用<xref:System.Reflection.AssemblyTitleAttribute>属性设置为程序集，然后使用<xref:System.Reflection.Assembly.IsDefined%2A>以指示它是否已应用。 它还会测试未应用的属性。  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> 使用的类型无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前程序集是否是通过使用反射发出在当前进程中动态生成的。</summary>
        <value>
          如果当前程序集是在当前进程中动态生成的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由派生类表示动态程序集<xref:System.Reflection.Emit.AssemblyBuilder>。  
  
 当动态程序集保存到磁盘，已保存的程序集不是动态的。 如果已保存的程序集加载到另一个应用程序域或进程，<xref:System.Reflection.Assembly.IsDynamic%2A>属性返回`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前程序集是否是以完全信任方式加载的。</summary>
        <value>
          如果当前程序集是以完全信任方式加载的，则为 <see langword="true" />，否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加载程序集。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">字节数组，它是包含已发出程序集的基于 COFF 的映像。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的映像的程序集，该映像包含已发出的程序集。 此程序集将会加载到调用方的应用程序域中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法加载程序集的信任级别操作调用程序集的信任级别相同。 若要从应用程序域的信任级别的字节数组加载程序集，使用<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29>方法重载。 有关使用的具有重载的证据的详细信息<xref:System.Reflection.Assembly.Load%2A>方法采用字节数组，请参阅<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29>方法重载。  
  
 在 c + + 可执行文件上进行反射可能会引发<xref:System.BadImageFormatException>。 这很可能是由 c + + 编译器去除的重定位地址或`.reloc`从可执行文件的部分。 若要保留`.reloc`c + + 可执行文件的地址，指定`/fixed:no`在链接时。  
  
 请注意此方法重载始终创建一个新<xref:System.Reflection.Assembly>具有其自己的映射对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的程序集。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高的版本编译的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">描述要加载的程序集的对象。</param>
        <summary>在给定程序集的 <see cref="T:System.Reflection.AssemblyName" /> 的情况下，加载程序集。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> 如果引发`assemblyRef`指定完整的程序集名称和匹配的简单名称的第一个程序集具有不同的版本、 区域性或公钥标记。 加载程序将无法继续探测的其他程序集的简单名称匹配。  
  
> [!NOTE]
>  不要使用<xref:System.Reflection.AssemblyName>并且仅带有<xref:System.Reflection.AssemblyName.CodeBase%2A>属性集。 <xref:System.Reflection.AssemblyName.CodeBase%2A>属性不提供任何元素 （如名称或版本） 的程序集标识，因此加载不会发生根据负载通过标识规则，如你所料从<xref:System.Reflection.Assembly.Load%2A>方法。 相反，使用负载从规则加载的程序集。 有关使用加载源上下文的缺点的信息，请参阅<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>方法重载或[用于程序集加载的最佳实践](~/docs/framework/deployment/best-practices-for-assembly-loading.md)。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据的合并的规则如下所示：  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法没有<xref:System.Security.Policy.Evidence>参数，则与加载程序提供的证据加载程序集。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法替换<xref:System.Security.Policy.Evidence>合并参数，证据。 作为参数提供的证据<xref:System.Reflection.Assembly.Load%2A>方法取代加载程序提供的证据。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法重载`Byte[]`从调用的程序集继承参数，以加载通用对象文件格式 (COFF) 图像，证据。 这适用于.NET Framework 1.1 版 Service Pack 1 (SP1) 和后续版本。  
  
    > [!NOTE]
    >  在.NET Framework 1.0 版，而无需 SP1 中，如果你使用的版本 1.1 中<xref:System.Reflection.Assembly.Load%2A>方法重载`Byte[]`参数加载 COFF 映像，证据结合。 `Zone``Url`和`Site`从调用程序集，继承和`Hash`和`StrongName`摘自 COFF 程序集。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法替换`Byte[]`参数和<xref:System.Security.Policy.Evidence>若要加载的 COFF 映像，请使用提供的证据。 调用程序集的证据和 COFF 图像的证据将被忽略。  
  
 在 c + + 可执行文件上进行反射可能会引发<xref:System.BadImageFormatException>。 这很可能是由 c + + 编译器去除的重定位地址或`.reloc`从可执行文件的部分。 若要保留`.reloc`c + + 可执行文件的地址，指定`/fixed:no`在链接时。  
  
> [!NOTE]
>  如果这两个<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>属性和<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>属性设置，在首次尝试加载程序集使用的显示名称 (包括版本、 区域性和等等，返回为<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>属性)。 如果未找到该文件，<xref:System.Reflection.AssemblyName.CodeBase%2A>用于搜索程序集。 如果使用找到的程序集<xref:System.Reflection.AssemblyName.CodeBase%2A>，与程序集匹配的显示名称。 如果匹配失败，<xref:System.IO.FileLoadException>引发。  
  
   
  
## Examples  
 下面的示例实例化<xref:System.Reflection.AssemblyName>对象并使用它来加载`sysglobal.dll`程序集。 此示例然后显示程序集的公共类型的完整名称。  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> 未找到。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 在[适用于 Windows 应用商店应用的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或[可移植类库](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 无法加载已找到的文件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> 不是有效的程序集。 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyRef" /> 是用更高的版本编译的。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">用于读取一个 URI，不以"file://"开头。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">程序集名称的长格式。</param>
        <summary>通过给定程序集的长格式名称加载程序集。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 程序集名称的长格式由其 （如"系统"System.dll 程序集） 以及其版本、 区域性、 公钥标记和 （可选） 及其处理器体系结构的简单名称组成。 它对应于程序集的<xref:System.Reflection.Assembly.FullName%2A>属性。 下面的示例演示如何使用以加载.NET Framework 4 的 System.dll 程序集的名称太长。  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException> 如果引发`assemblyString`指定完整的程序集名称，并与简单名称匹配的第一个程序集具有不同的版本、 区域性或公钥标记。 加载程序将无法继续探测的其他程序集的简单名称匹配。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据的合并的规则如下所示：  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法没有<xref:System.Security.Policy.Evidence>参数，则与加载程序提供的证据加载程序集。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法替换<xref:System.Security.Policy.Evidence>合并参数，证据。 作为参数提供的证据<xref:System.Reflection.Assembly.Load%2A>方法取代加载程序提供的证据。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法重载`Byte[]`从调用的程序集继承参数，以加载通用对象文件格式 (COFF) 图像，证据。 这适用于.NET Framework 1.1 版 Service Pack 1 (SP1) 和后续版本。  
  
    > [!NOTE]
    >  在.NET Framework 1.0 版，而无需 SP1 中，如果你使用的版本 1.1 中<xref:System.Reflection.Assembly.Load%2A>方法重载`Byte[]`参数加载 COFF 映像，证据结合。 `Zone``Url`和`Site`从调用程序集，继承和`Hash`和`StrongName`摘自 COFF 程序集。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法替换`Byte[]`参数和<xref:System.Security.Policy.Evidence>若要加载的 COFF 映像，请使用提供的证据。 调用程序集的证据和 COFF 图像的证据将被忽略。  
  
 在 c + + 可执行文件上进行反射可能会引发<xref:System.BadImageFormatException>。 这很可能是由 c + + 编译器去除的重定位地址或`.reloc`从可执行文件的部分。 若要保留`.reloc`c + + 可执行文件的地址，指定`/fixed:no`在链接时。  
  
 在.NET Framework 2.0 版中，处理器体系结构添加到程序集标识，并且可以指定为程序集名称字符串的一部分。 例如，"ProcessorArchitecture = msil"。 但是，若要指定程序集名称的建议的方法是创建<xref:System.Reflection.AssemblyName>对象，并将其传递给适当的重载<xref:System.Reflection.Assembly.Load%2A>方法。 请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例给定其完全限定的名称，加载程序集，并列出所有包含在指定的程序集中的类型。 若要运行此代码示例，你必须提供完全限定程序集名称。 有关如何获取完全限定程序集名称的信息，请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> 是一个长度为零的字符串。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> 未找到。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> 不是有效的程序集。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyString" /> 是用更高的版本编译的。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">字节数组，它是包含已发出程序集的基于 COFF 的映像。</param>
        <param name="rawSymbolStore">包含表示程序集符号的原始字节的字节数组。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的映像的程序集，此映像包含一个已发出的程序集，并且还可以选择包括程序集的符号。 此程序集将会加载到调用方的应用程序域中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法加载程序集的信任级别操作调用程序集的信任级别相同。 若要从应用程序域的信任级别的字节数组加载程序集，使用<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29>方法重载。 有关使用的具有重载的证据的详细信息<xref:System.Reflection.Assembly.Load%2A>方法采用字节数组，请参阅<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29>方法重载。  
  
 在 c + + 可执行文件上进行反射可能会引发<xref:System.BadImageFormatException>。 这很可能是由 c + + 编译器去除的重定位地址或`.reloc`从可执行文件的部分。 若要保留`.reloc`c + + 可执行文件的地址，指定`/fixed:no`在链接时。  
  
 请注意此方法重载始终创建一个新<xref:System.Reflection.Assembly>具有其自己的映射对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的程序集。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高的版本编译的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">描述要加载的程序集的对象。</param>
        <param name="assemblySecurity">用于加载程序集的证据。</param>
        <summary>在给定程序集的 <see cref="T:System.Reflection.AssemblyName" /> 的情况下，加载程序集。 使用提供的证据将该程序集加载到调用方的域中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> 如果引发`assemblyRef`指定完整的程序集名称，并与简单名称匹配的第一个程序集具有不同的版本、 区域性或公钥标记。 加载程序将无法继续探测的其他程序集的简单名称匹配。  
  
> [!NOTE]
>  不要使用<xref:System.Reflection.AssemblyName>并且仅带有<xref:System.Reflection.AssemblyName.CodeBase%2A>属性集。 <xref:System.Reflection.AssemblyName.CodeBase%2A>属性不提供任何元素 （如名称或版本） 的程序集标识，因此加载不会发生根据负载通过标识规则，如你所料从<xref:System.Reflection.Assembly.Load%2A>方法。 相反，使用负载从规则加载的程序集。 有关使用加载源上下文的缺点的信息，请参阅<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>方法重载或[用于程序集加载的最佳实践](~/docs/framework/deployment/best-practices-for-assembly-loading.md)。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据的合并的规则如下所示：  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法没有<xref:System.Security.Policy.Evidence>参数，则与加载程序提供的证据加载程序集。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法替换<xref:System.Security.Policy.Evidence>合并参数，证据。 作为参数提供的证据<xref:System.Reflection.Assembly.Load%2A>方法取代加载程序提供的证据。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法重载`Byte[]`从调用的程序集继承参数，以加载通用对象文件格式 (COFF) 图像，证据。 这适用于.NET Framework 1.1 版 Service Pack 1 (SP1) 和后续版本。  
  
    > [!NOTE]
    >  在.NET Framework 1.0 版，而无需 SP1 中，如果你使用的版本 1.1 中<xref:System.Reflection.Assembly.Load%2A>方法重载`Byte[]`参数加载 COFF 映像，证据结合。 `Zone``Url`和`Site`从调用程序集，继承和`Hash`和`StrongName`摘自 COFF 程序集。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法替换`Byte[]`参数和<xref:System.Security.Policy.Evidence>若要加载的 COFF 映像，请使用提供的证据。 调用程序集的证据和 COFF 图像的证据将被忽略。  
  
 在 c + + 可执行文件上进行反射可能会引发<xref:System.BadImageFormatException>。 这很可能是由 c + + 编译器去除的重定位地址或`.reloc`从可执行文件的部分。 若要保留`.reloc`c + + 可执行文件的地址，指定`/fixed:no`在链接时。  
  
> [!NOTE]
>  如果这两个<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>属性和<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>属性设置，在首次尝试加载程序集使用的显示名称 (包括版本、 区域性和等等，返回为<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>属性)。 如果未找到该文件，<xref:System.Reflection.AssemblyName.CodeBase%2A>用于搜索程序集。 如果使用找到的程序集<xref:System.Reflection.AssemblyName.CodeBase%2A>，与程序集匹配的显示名称。 如果匹配失败，<xref:System.IO.FileLoadException>引发。  
  
 如果调用<xref:System.Reflection.Assembly.Load%2A>方法超过一次在同一个程序集，但与指定不同的证据，公共语言运行时不会引发<xref:System.IO.FileLoadException>因为相等性和不同的证据规范完整性不能为确定。 第一次成功的证据是使用的证据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> 未找到。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> 不是有效的程序集。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyRef" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">用于读取一个 URI，不以"file://"开头。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">程序集的显示名称。</param>
        <param name="assemblySecurity">用于加载程序集的证据。</param>
        <summary>通过给定的程序集的显示名称来加载程序集，使用提供的证据将程序集加载到调用方的域中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> 如果引发`assemblyString`指定完整的程序集名称，并与简单名称匹配的第一个程序集具有不同的版本、 区域性或公钥标记。 加载程序将无法继续探测的其他程序集的简单名称匹配。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据的合并的规则如下所示：  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法没有<xref:System.Security.Policy.Evidence>参数，则与加载程序提供的证据加载程序集。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法替换<xref:System.Security.Policy.Evidence>合并参数，证据。 作为参数提供的证据<xref:System.Reflection.Assembly.Load%2A>方法取代加载程序提供的证据。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法重载`Byte[]`从调用的程序集继承参数，以加载通用对象文件格式 (COFF) 图像，证据。 这适用于.NET Framework 1.1 版 Service Pack 1 (SP1) 和后续版本。  
  
    > [!NOTE]
    >  在.NET Framework 1.0 版，而无需 SP1 中，如果你使用的版本 1.1 中<xref:System.Reflection.Assembly.Load%2A>方法重载`Byte[]`参数加载 COFF 映像，证据结合。 `Zone``Url`和`Site`从调用程序集，继承和`Hash`和`StrongName`摘自 COFF 程序集。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法替换`Byte[]`参数和<xref:System.Security.Policy.Evidence>若要加载的 COFF 映像，请使用提供的证据。 调用程序集的证据和 COFF 图像的证据将被忽略。  
  
 在 c + + 可执行文件上进行反射可能会引发<xref:System.BadImageFormatException>。 这很可能是由 c + + 编译器去除的重定位地址或`.reloc`从可执行文件的部分。 若要保留`.reloc`c + + 可执行文件的地址，指定`/fixed:no`在链接时。  
  
 如果在同一程序集但不同的证据指定不止一次调用此方法，公共语言运行时不会引发<xref:System.IO.FileLoadException>因为无法确定相等性和不同的证据规范的完整性。 第一次成功的证据是使用的证据。  
  
 在.NET Framework 2.0 版中，处理器体系结构添加到程序集标识，并且可以指定为程序集名称字符串的一部分。 例如，"ProcessorArchitecture = msil"。 但是，若要指定程序集名称的建议的方法是创建<xref:System.Reflection.AssemblyName>对象，并将其传递给适当的重载<xref:System.Reflection.Assembly.Load%2A>方法。 请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> 未找到。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> 不是有效的程序集。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyString" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。  
  
 或  
  
 一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">字节数组，它是包含已发出程序集的基于 COFF 的映像。</param>
        <param name="rawSymbolStore">包含表示程序集符号的原始字节的字节数组。</param>
        <param name="securityEvidence">用于加载程序集的证据。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的映像的程序集，此映像包含一个已发出的程序集，并且还可选择包括程序集的符号和证据。 此程序集将会加载到调用方的应用程序域中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用提供的证据将该程序集加载到调用方的域中。 此外加载表示程序集符号的原始字节。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据的合并的规则如下所示：  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法没有<xref:System.Security.Policy.Evidence>参数，则与加载程序提供的证据加载程序集。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法替换<xref:System.Security.Policy.Evidence>合并参数，证据。 作为参数提供的证据<xref:System.Reflection.Assembly.Load%2A>方法取代加载程序提供的证据。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法重载`Byte[]`从调用的程序集继承参数，以加载 COFF 图像，证据。 这适用于.NET Framework 1.1 版 Service Pack 1 (SP1) 和后续版本。  
  
    > [!NOTE]
    >  在.NET Framework 1.0 版，而无需 SP1 中，如果你使用的版本 1.1 中<xref:System.Reflection.Assembly.Load%2A>方法重载`Byte[]`参数加载 COFF 映像，证据结合。 `Zone``Url`和`Site`从调用程序集，继承和`Hash`和`StrongName`摘自 COFF 程序集。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A>方法替换`Byte[]`参数和<xref:System.Security.Policy.Evidence>若要加载的 COFF 映像，请使用提供的证据。 忽略调用程序集的证据和 COFF 图像的证据。  
  
 在 c + + 可执行文件上进行反射可能会引发<xref:System.BadImageFormatException>。 这很可能是由 c + + 编译器去除的重定位地址或`.reloc`从可执行文件的部分。 若要保留`.reloc`c + + 可执行文件的地址，指定`/fixed:no`在链接时。  
  
 如果调用 [\]，字节\<xref:System.Reflection.Assembly.Load%2A > 方法超过一次在同一个程序集，但与指定不同的证据，公共语言运行时不会引发<xref:System.IO.FileLoadException>因为无法确定相等性和不同的证据规范的完整性。 第一次成功的证据是使用的证据。  
  
 请注意此方法重载始终创建一个新<xref:System.Reflection.Assembly>具有其自己的映射对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的程序集。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> 不是 <see langword="null" />。  默认情况下，[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 中未启用旧版 CAS 策略；如果未启用，则 <paramref name="securityEvidence" /> 必须为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供证据的功能。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。 安全操作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">字节数组，它是包含已发出程序集的基于 COFF 的映像。</param>
        <param name="rawSymbolStore">包含表示程序集符号的原始字节的字节数组。</param>
        <param name="securityContextSource">安全上下文的源。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的映像的程序集，此映像包含一个已发出的程序集，并且还可选择包括符号和指定安全上下文的源。 此程序集将会加载到调用方的应用程序域中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 程序集被加载到调用方的安全上下文中使用指定的源的应用程序域。 如果`rawSymbolStore`已指定，还加载表示程序集符号的原始字节。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的程序集。  
  
 或  
  
 <paramref name="rawAssembly" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="securityContextSource" /> 的值为枚举值之一。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加载程序集文件的内容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要加载的文件的完全限定路径。</param>
        <summary>加载指定路径上的程序集文件的内容。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Reflection.Assembly.LoadFile%2A>方法来加载和检查程序集具有相同的标识，但位于不同的路径。<xref:System.Reflection.Assembly.LoadFile%2A> 不会将文件加载到加载源上下文中，并且未解决依赖项使用的负载路径，作为<xref:System.Reflection.Assembly.LoadFrom%2A>方法执行。 <xref:System.Reflection.Assembly.LoadFile%2A> 此有限的情况下很有用因为<xref:System.Reflection.Assembly.LoadFrom%2A>不能用于加载程序集具有相同标识但不同的路径; 它将加载只有第一个此类程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 参数不是绝对路径。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> 参数为空字符串 ("") 或不存在。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> 不是有效的程序集。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="path" /> 是用更高的版本编译的。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">程序集文件的完全限定路径。</param>
        <param name="securityEvidence">用于加载程序集的证据。</param>
        <summary>通过给定的程序集的路径来加载程序集，使用提供的证据将程序集加载到调用方的域中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Reflection.Assembly.LoadFile%2A>方法来加载和检查程序集具有相同的标识，但位于不同的路径。 <xref:System.Reflection.Assembly.LoadFile%2A> 不会加载文件到<xref:System.Reflection.Assembly.LoadFrom%2A>上下文，并且未解决依赖项使用的负载路径，作为<xref:System.Reflection.Assembly.LoadFrom%2A>方法执行。 <xref:System.Reflection.Assembly.LoadFile%2A> 此有限的情况下很有用因为<xref:System.Reflection.Assembly.LoadFrom%2A>不能用于加载程序集具有相同标识但不同的路径; 它将加载只有第一个此类程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 参数不是绝对路径。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> 参数为空字符串 ("") 或不存在。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> 不是有效的程序集。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="path" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> 不是 <see langword="null" />。 默认情况下，[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 中未启用旧版 CAS 策略；如果未启用，则 <paramref name="securityEvidence" /> 必须为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取从文件或目录，以及用于访问路径本身中的信息的访问。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加载程序集。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含程序集清单的文件的名称或路径。</param>
        <summary>已知程序集的文件名或路径，加载程序集。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`参数必须引用未转义符的 URI。 此方法提供 URI 中的所有无效字符的转义的字符。  
  
> [!NOTE]
>  不支持文件传输协议 (FTP)。 如果为 uri，该 URI 提供`assemblyFile`是 FTP 地址，则不会加载程序集。 不引发异常。  
  
 `assemblyFile` 可能是绝对或相对于当前目录中，且程序集加载到调用方的域。  
  
 程序集可以是加载到三个上下文中的一个，也可以是没有上下文的情况下加载：  
  
-   加载上下文包含通过探测找到的程序集： 在 GAC 中，主机程序集中存储如果托管运行时，或在<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>的应用程序域。 <xref:System.Reflection.Assembly.Load%2A> 方法的大多数重载都将程序集加载到此上下文中。  
  
-   加载源上下文包含程序集为其用户提供不包括在搜索通过探测的目录的路径。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 都是通过路径加载的方法的示例。  
  
-   仅限反射的上下文包含与加载的程序集<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法; 这些中的代码无法执行上下文。  
  
-   如果用户生成或找到了程序集，它不在任何上下文中。 这适用于使用的重载加载的程序集<xref:System.Reflection.Assembly.Load%2A>指定字节数组，包含一个程序集，并创建使用反射的瞬态动态程序集发出和未保存到磁盘的方法。  
  
 加载源上下文允许从探测中, 未包括的路径加载程序集和尚未允许依赖项，该路径，以找出并加载，因为由上下文维护的路径信息。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>方法具有以下缺点。 请考虑改用 <xref:System.Reflection.Assembly.Load%2A>。  
  
-   如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<xref:System.Reflection.Assembly.LoadFrom%2A> 仍返回已加载的程序集。  
  
-   如果程序集的加载与<xref:System.Reflection.Assembly.LoadFrom%2A>，以及更高版本的加载上下文中的程序集尝试加载按显示名称的同一个程序集，加载尝试将失败。 这会反序列化程序集时。  
  
-   如果程序集的加载与<xref:System.Reflection.Assembly.LoadFrom%2A>，探测路径包括使用相同的标识，而另一个位置，为程序集和<xref:System.InvalidCastException>， <xref:System.MissingMethodException>，否则会发生其他意外的行为。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 需要对指定路径的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。  
  
-   如果本机映像存在`assemblyFile`，不使用它。 无法加载以非特定域的程序集。  
  
-   在.NET Framework 1.0 和 1.1 版中，不应用策略。  
  
   
  
## Examples  
 下面的示例加载程序集文件名或路径。  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          未找到 <paramref name="assemblyFile" />，或者尝试加载的模块没有指定文件扩展名。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集；例如，64 位进程中的 32 位程序集。 有关详细信息，请参阅异常主题。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.Security.SecurityException">在没有所需 <see cref="T:System.Net.WebPermission" /> 的情况下，指定了不以“file://”开始的基本代码。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">程序集名称的长度超过 MAX_PATH 个字符。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取开头"file://"的 URI。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">用于读取一个 URI，不以"file://"开头。</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含程序集清单的文件的名称或路径。</param>
        <param name="securityEvidence">用于加载程序集的证据。</param>
        <summary>在给定程序集的文件名或路径并提供安全证据的情况下，加载程序集。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`参数必须引用未转义符的 URI。 此方法提供 URI 中的所有无效字符的转义的字符。  
  
> [!NOTE]
>  不支持文件传输协议 (FTP)。 如果为 uri，该 URI 提供`assemblyFile`是 FTP 地址，则不会加载程序集。 不引发异常。  
  
 `assemblyFile` 可能是绝对或相对于当前目录中，且程序集加载到调用方的域。  
  
 程序集可以是加载到三个上下文中的一个，也可以是没有上下文的情况下加载：  
  
-   加载上下文包含通过探测找到的程序集： 在 GAC 中，主机程序集中存储如果托管运行时，或在<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>的应用程序域。 <xref:System.Reflection.Assembly.Load%2A> 方法的大多数重载都将程序集加载到此上下文中。  
  
-   加载源上下文包含程序集为其用户提供不包括在搜索通过探测的目录的路径。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 都是通过路径加载的方法的示例。  
  
-   仅限反射的上下文包含与加载的程序集<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法; 这些中的代码无法执行上下文。  
  
-   如果用户生成或找到了程序集，它不在任何上下文中。 这适用于使用的重载加载的程序集<xref:System.Reflection.Assembly.Load%2A>指定字节数组，包含一个程序集，并创建使用反射的瞬态动态程序集发出和未保存到磁盘的方法。  
  
 加载源上下文允许从探测中, 未包括的路径加载程序集和尚未允许依赖项，该路径，以找出并加载，因为由上下文维护的路径信息。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>方法具有以下缺点。 请考虑改用 <xref:System.Reflection.Assembly.Load%2A>。  
  
-   如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<xref:System.Reflection.Assembly.LoadFrom%2A> 仍返回已加载的程序集。  
  
-   如果程序集的加载与<xref:System.Reflection.Assembly.LoadFrom%2A>，以及更高版本的加载上下文中的程序集尝试加载按显示名称的同一个程序集，加载尝试将失败。 对程序集进行反序列化时，可能发生这种情况。  
  
-   如果程序集的加载与<xref:System.Reflection.Assembly.LoadFrom%2A>，探测路径包括使用相同的标识，而另一个位置，为程序集和<xref:System.InvalidCastException>， <xref:System.MissingMethodException>，否则会发生其他意外的行为。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 需要对指定路径的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。  
  
-   如果本机映像存在`assemblyFile`，不使用它。 无法加载以非特定域的程序集。  
  
-   在.NET Framework 1.0 和 1.1 版中，不应用策略。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据的合并的规则如下所示：  
  
-   当你使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法没有<xref:System.Security.Policy.Evidence>参数，则与加载程序提供的证据加载程序集。  
  
-   当你使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法替换<xref:System.Security.Policy.Evidence>合并参数，证据。 作为参数提供的证据<xref:System.Reflection.Assembly.LoadFrom%2A>方法取代加载程序提供的证据。  
  
-   如果在同一程序集但不同的证据指定不止一次调用此方法，公共语言运行时不会引发<xref:System.IO.FileLoadException>因为无法确定相等性和不同的证据规范的完整性。 第一次成功的证据是使用的证据。  
  
-   当你使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法替换`Byte[]`参数加载通用对象文件格式 (COFF) 图像，证据结合。 `Zone``Url`和`Site`从调用程序集，继承和`Hash`和`StrongName`摘自 COFF 程序集。  
  
-   当你使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法替换`Byte[]`参数和<xref:System.Security.Policy.Evidence>若要加载的 COFF 映像，请使用提供的证据。 调用程序集的证据和 COFF 图像的证据将被忽略。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          未找到 <paramref name="assemblyFile" />，或者尝试加载的模块没有指定文件扩展名。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。  
  
 或  
  
 <paramref name="securityEvidence" /> 是明确的，但确定为无效。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集；例如，64 位进程中的 32 位程序集。 有关详细信息，请参阅异常主题。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.Security.SecurityException">在没有所需 <see cref="T:System.Net.WebPermission" /> 的情况下，指定了不以“file://”开始的基本代码。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">程序集名称的长度超过 MAX_PATH 个字符。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取开头"file://"的 URI。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">用于读取一个 URI，不以"file://"开头。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含程序集清单的文件的名称或路径。</param>
        <param name="hashValue">计算所得的哈希代码的值。</param>
        <param name="hashAlgorithm">用于对文件进行哈希处理并生成强名称的哈希算法。</param>
        <summary>通过给定程序集文件名或路径、哈希值及哈希算法来加载程序集。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`参数必须引用未转义符的 URI。 此方法提供 URI 中的所有无效字符的转义的字符。  
  
> [!NOTE]
>  不支持文件传输协议 (FTP)。 如果为 uri，该 URI 提供`assemblyFile`是 FTP 地址，则不会加载程序集。 不引发异常。  
  
 `assemblyFile` 可能是绝对或相对于当前目录中，且程序集加载到调用方的域。  
  
 程序集可以是加载到三个上下文中的一个，也可以是没有上下文的情况下加载：  
  
-   加载上下文包含通过探测找到的程序集： 在全局程序集缓存中，主机程序集中存储如果托管运行时，或在<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>的应用程序域。 <xref:System.Reflection.Assembly.Load%2A> 方法的大多数重载都将程序集加载到此上下文中。  
  
-   加载源上下文包含程序集为其用户提供探测中未包括的路径。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 都是通过路径加载的方法的示例。  
  
-   仅限反射的上下文包含与加载的程序集<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法; 这些中的代码无法执行上下文。  
  
-   如果用户生成或找到了程序集，它不在任何上下文中。 这适用于使用的重载加载的程序集<xref:System.Reflection.Assembly.Load%2A>指定字节数组，包含一个程序集，并创建使用反射的瞬态动态程序集发出和未保存到磁盘的方法。  
  
 加载源上下文允许从路径未包含在探测，加载程序集和尚未允许依赖项，该路径，以找出并加载，因为由上下文维护的路径信息。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>方法具有以下缺点。 请考虑改用 <xref:System.Reflection.Assembly.Load%2A>。  
  
-   如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<xref:System.Reflection.Assembly.LoadFrom%2A> 仍返回已加载的程序集。  
  
-   如果程序集的加载与<xref:System.Reflection.Assembly.LoadFrom%2A>，以及更高版本的加载上下文中的程序集尝试加载按显示名称的同一个程序集，加载尝试将失败。 对程序集进行反序列化时，可能发生这种情况。  
  
-   如果程序集的加载与<xref:System.Reflection.Assembly.LoadFrom%2A>，探测路径包括使用相同的标识，而另一个位置，为程序集和<xref:System.InvalidCastException>， <xref:System.MissingMethodException>，否则会发生其他意外的行为。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 需要对指定路径的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。  
  
-   如果本机映像存在`assemblyFile`，不使用它。 程序集不能以非特定于域的方式加载。  
  
 程序集将会加载与加载程序提供的证据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          未找到 <paramref name="assemblyFile" />，或者你正在试图加载的模块未指定文件扩展名。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集；例如，64 位进程中的 32 位程序集。 有关详细信息，请参阅异常主题。  
  
 或  
  
 <paramref name="assemblyFile" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <exception cref="T:System.Security.SecurityException">在没有所需 <see cref="T:System.Net.WebPermission" /> 的情况下，指定了不以“file://”开始的基本代码。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">程序集名称的长度超过 MAX_PATH 个字符。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取开头"file://"的 URI。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">用于读取一个 URI，不以"file://"开头。</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含程序集清单的文件的名称或路径。</param>
        <param name="securityEvidence">用于加载程序集的证据。</param>
        <param name="hashValue">计算所得的哈希代码的值。</param>
        <param name="hashAlgorithm">用于对文件进行哈希处理并生成强名称的哈希算法。</param>
        <summary>通过给定程序集文件名或路径、安全证据、哈希值及哈希算法来加载程序集。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`参数必须引用未转义符的 URI。 此方法提供 URI 中的所有无效字符的转义的字符。  
  
> [!NOTE]
>  不支持文件传输协议 (FTP)。 如果为 uri，该 URI 提供`assemblyFile`是 FTP 地址，则不会加载程序集。 不引发异常。  
  
 `assemblyFile` 可能是绝对或相对于当前目录中，且程序集加载到调用方的域。  
  
 程序集可以是加载到三个上下文中的一个，也可以是没有上下文的情况下加载：  
  
-   加载上下文包含通过探测找到的程序集： 在 GAC 中，主机程序集中存储如果托管运行时，或在<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>的应用程序域。 <xref:System.Reflection.Assembly.Load%2A> 方法的大多数重载都将程序集加载到此上下文中。  
  
-   加载源上下文包含程序集为其用户提供不包括在搜索通过探测的目录的路径。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 都是通过路径加载的方法的示例。  
  
-   仅限反射的上下文包含与加载的程序集<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法; 这些中的代码无法执行上下文。  
  
-   如果用户生成或找到了程序集，它不在任何上下文中。 这适用于使用的重载加载的程序集<xref:System.Reflection.Assembly.Load%2A>指定字节数组，包含一个程序集，并创建使用反射的瞬态动态程序集发出和未保存到磁盘的方法。  
  
 加载源上下文允许从探测中, 未包括的路径加载程序集和尚未允许依赖项，该路径，以找出并加载，因为由上下文维护的路径信息。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>方法具有以下缺点。 请考虑改用 <xref:System.Reflection.Assembly.Load%2A>。  
  
-   如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<xref:System.Reflection.Assembly.LoadFrom%2A> 仍返回已加载的程序集。  
  
-   如果程序集的加载与<xref:System.Reflection.Assembly.LoadFrom%2A>，以及更高版本的加载上下文中的程序集尝试加载按显示名称的同一个程序集，加载尝试将失败。 对程序集进行反序列化时，可能发生这种情况。  
  
-   如果程序集的加载与<xref:System.Reflection.Assembly.LoadFrom%2A>，探测路径包括使用相同的标识，而另一个位置，为程序集和<xref:System.InvalidCastException>， <xref:System.MissingMethodException>，否则会发生其他意外的行为。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 需要对指定路径的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。  
  
-   如果本机映像存在`assemblyFile`，不使用它。 无法加载以非特定域的程序集。  
  
-   在.NET Framework 1.0 和 1.1 版中，不应用策略。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据的合并的规则如下所示：  
  
-   当你使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法没有<xref:System.Security.Policy.Evidence>参数，则与加载程序提供的证据加载程序集。  
  
-   当你使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法替换<xref:System.Security.Policy.Evidence>合并参数，证据。 作为参数提供的证据<xref:System.Reflection.Assembly.LoadFrom%2A>方法取代加载程序提供的证据。  
  
-   如果在同一程序集但不同的证据指定不止一次调用此方法，公共语言运行时不会引发<xref:System.IO.FileLoadException>因为无法确定相等性和不同的证据规范的完整性。 第一次成功的证据是使用的证据。  
  
-   当你使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法替换`Byte[]`参数加载通用对象文件格式 (COFF) 图像，证据结合。 `Zone``Url`和`Site`从调用程序集，继承和`Hash`和`StrongName`摘自 COFF 程序集。  
  
-   当你使用<xref:System.Reflection.Assembly.LoadFrom%2A>方法替换`Byte[]`参数和<xref:System.Security.Policy.Evidence>若要加载的 COFF 映像，请使用提供的证据。 调用程序集的证据和 COFF 图像的证据将被忽略。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          未找到 <paramref name="assemblyFile" />，或者尝试加载的模块没有指定文件扩展名。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。  
  
 或  
  
 <paramref name="securityEvidence" /> 是明确的，但确定为无效。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集；例如，64 位进程中的 32 位程序集。 有关详细信息，请参阅异常主题。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.Security.SecurityException">在没有所需 <see cref="T:System.Net.WebPermission" /> 的情况下，指定了不以“file://”开始的基本代码。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">程序集名称的长度超过 MAX_PATH 个字符。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要使用的证据加载程序集。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取开头"file://"的 URI。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">用于读取一个 URI，不以"file://"开头。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加载此程序集的内部模块。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">模块的名称。 此字符串必须与程序集清单中的文件名对应。</param>
        <param name="rawModule">基于 COFF 映像的字节数组，该数组包含发送的模块或资源。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的映像（包含已发出的模块）或资源文件的模块（该模块相对于此程序集是内部的）。</summary>
        <returns>加载的模块。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> 或 <paramref name="rawModule" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> 与此程序集清单中的文件项不匹配。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> 不是有效模块。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供的证据。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">模块的名称。 此字符串必须与程序集清单中的文件名对应。</param>
        <param name="rawModule">基于 COFF 映像的字节数组，该数组包含发送的模块或资源。</param>
        <param name="rawSymbolStore">一个字节数组，包含表示模块符号的原始字节。 如果这是一个资源文件，则必须为 <see langword="null" />。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的映像（包含已发出的模块）或资源文件的模块（该模块相对于此程序集是内部的）。 还加载表示此模块的符号的原始字节。</summary>
        <returns>加载的模块。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> 或 <paramref name="rawModule" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> 与此程序集清单中的文件项不匹配。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> 不是有效模块。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要提供的证据。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用部分名称从应用程序目录或从全局程序集缓存加载程序集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  重载<xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>方法已过时，并已保留用于向后兼容。 未过时的替代项为 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">程序集的显示名称。</param>
        <summary>使用部分名称从应用程序目录或从全局程序集缓存加载程序集。</summary>
        <returns>加载的程序集。 如果未找到 <paramref name="partialName" />，此方法将返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29>方法已过时，已被保留用于向后兼容。 未过时的替代项为 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。  
  
 此方法加载程序集的应用程序将受这些程序集的升级。 因此，不使用此方法。重新设计应用程序使用<xref:System.Reflection.Assembly.Load%28System.String%29>方法重载或<xref:System.Reflection.Assembly.LoadFrom%28System.String%29>方法重载。  
  
 此方法首先调用<xref:System.Reflection.Assembly.Load%2A>。 如果未找到程序集，此方法将返回从全局程序集缓存中具有相同的简单名称和最高版本号的程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="partialName" /> 是用更高的版本编译的。</exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">程序集的显示名称。</param>
        <param name="securityEvidence">用于加载程序集的证据。</param>
        <summary>使用部分名称从应用程序目录或从全局程序集缓存加载程序集。 使用提供的证据将该程序集加载到调用方的域中。</summary>
        <returns>加载的程序集。 如果未找到 <paramref name="partialName" />，此方法将返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29>方法已过时，已被保留用于向后兼容。 未过时的替代项为 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。  
  
 证据是输入安全策略决策的一组信息（如代码可授予哪些权限）。  
  
 此方法加载程序集的应用程序将受这些程序集的升级。 因此，不使用此方法。重新设计应用程序使用<xref:System.Reflection.Assembly.Load%2A>方法或<xref:System.Reflection.Assembly.LoadFrom%2A>方法。  
  
 此方法首先调用<xref:System.Reflection.Assembly.Load%2A>。 如果未找到程序集，此方法将返回从全局程序集缓存中具有相同的简单名称和最高版本号的程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据集加载了两次。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="partialName" /> 是用更高的版本编译的。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于调用非托管的代码和证据加载程序集。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含清单的已加载文件的完整路径或 UNC 位置。</summary>
        <value>包含清单的已加载文件的位置。 如果已加载文件使用了影像复制，则该位置是该文件被影像复制后的位置。 如果从字节数组加载程序集（如使用 <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> 方法重载时），则返回值为空字符串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取的位置，该文件已被卷影复制之前，使用<xref:System.Reflection.Assembly.CodeBase%2A>属性。  
  
   
  
## Examples  
 下面的示例显示包含清单的已加载文件的位置。  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">当前的程序集是动态程序集，由 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 对象表示。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含当前程序集清单的模块。</summary>
        <value>包含程序集清单的模块。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当公共语言运行时类加载程序不能通过正常方法解析对程序集的内部模块的引用时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件为回调提供了机会查找和加载模块本身并将其返回。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含此程序集中模块的集合。</summary>
        <value>包含此程序集中模块的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">要与 <c>right</c> 进行比较的程序集。</param>
        <param name="right">要与 <c>left</c> 进行比较的程序集。</param>
        <summary>指示两个 <see cref="T:System.Reflection.Assembly" /> 对象是否相等。</summary>
        <returns>
          如果 <see langword="true" /> 等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">要与 <c>right</c> 进行比较的程序集。</param>
        <param name="right">要与 <c>left</c> 进行比较的程序集。</param>
        <summary>指示两个 <see cref="T:System.Reflection.Assembly" /> 对象是否不相等。</summary>
        <returns>
          如果 <see langword="true" /> 不等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前程序集的授予集。</summary>
        <value>当前程序集的授予集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> 对象可以包含敏感信息，例如路径。 因此，完全信任需要访问这些对象。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Boolean" /> 值，该值指示此程序集是否被加载到只反射上下文中。</summary>
        <value>
          如果程序集被加载到只反射上下文而不是执行上下文中，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果程序集已加载到只反射上下文，使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>方法，不能在程序集中执行代码。 若要执行代码，程序集必须加载到执行上下文。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将程序集加载到只反射上下文中，在只反射上下文中可以检查但不能执行程序集。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">字节数组，它是包含已发出程序集的基于 COFF 的映像。</param>
        <summary>加载来自基于通用对象文件格式 (COFF) 的映像的程序集，该映像包含已发出的程序集。 程序集被加载到调用方的应用程序域的只反射上下文中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 无法从程序集加载到只反射上下文中执行代码。 若要执行代码，程序集必须加载到执行上下文，使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
 仅限反射的上下文是与其他上下文没有什么不同。 可只能通过卸载应用程序域来卸载加载到上下文的程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> 不是有效的程序集。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="rawAssembly" /> 不能被加载。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">程序集的显示名称，由 <see cref="P:System.Reflection.AssemblyName.FullName" /> 属性返回。</param>
        <summary>将给定显示名称的程序集加载到只反射上下文中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依赖项不会自动加载到只反射上下文。  
  
 无法从程序集加载到只反射上下文中执行代码。 若要执行代码，程序集必须加载到执行上下文，使用<xref:System.Reflection.Assembly.Load%2A>方法。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据的合并的规则如下所示：  
  
> [!NOTE]
>  在 c + + 中编译的可执行文件上进行反射可能会引发<xref:System.IO.FileLoadException>。 这很可能是由于 c + + 编译器的重定位地址或.reloc 节从可执行文件所引起。 若要保留.reloc 地址，请指定`/fixed:no`在链接时。  
  
 仅限反射的上下文是与其他上下文没有什么不同。 可只能通过卸载应用程序域来卸载加载到上下文的程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> 为空字符串 ("")。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> 未找到。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyString" /> 已找到，但是不能加载。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> 不是有效的程序集。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyString" /> 是用更高的版本编译的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含程序集清单的文件的路径。</param>
        <summary>将给定路径的程序集加载到只反射上下文中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依赖项不会自动加载到只反射上下文。 若要自动加载依赖关系，处理<xref:System.AppDomain.ReflectionOnlyAssemblyResolve>事件和负载中的事件处理程序的依赖关系。  
  
 无法从已加载到只反射上下文的程序集执行代码。 若要执行该代码，加载的程序集中<xref:System.Reflection.Assembly.LoadFile%2A>方法。  
  
 `assemblyFile`参数必须引用未转义符的 URI。 此方法提供 URI 中的所有无效字符的转义的字符。  
  
 为指定的路径`assemblyFile`相对于当前目录。 程序集被加载到调用方的域。  
  
 仅限反射的上下文是与其他上下文没有什么不同。 可只能通过卸载应用程序域来卸载加载到上下文的程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          未找到 <paramref name="assemblyFile" />，或者你正在试图加载的模块未指定文件扩展名。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyFile" /> 已找到，但是未能加载。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.Security.SecurityException">在没有所需 <see cref="T:System.Net.WebPermission" /> 的情况下，指定了不以“file://”开始的基本代码。</exception>
        <exception cref="T:System.IO.PathTooLongException">程序集名称的长度超过 MAX_PATH 个字符。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 为空字符串 ("")。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取开头"file://"的 URI。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">用于读取一个 URI，不以"file://"开头。</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示公共语言运行时 (CLR) 对此程序集强制执行的安全规则集。</summary>
        <value>CLR 对此程序集强制执行的安全规则集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，使用编译的程序集[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]具有透明度，尽管您明确可以改为使它们。 与早期版本的.NET Framework 编译的程序集具有 1 级透明度。  
  
 请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前实例的类型。</summary>
        <returns>表示 <see cref="T:System.Reflection.Assembly" /> 类型的对象。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回程序集的全名，即所谓的显示名称。</summary>
        <returns>程序集的全名；如果不能确定程序集的全名，则为类名。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含程序集清单的文件的名称或路径。</param>
        <summary>绕过某些安全检查，将程序集加载到加载源上下文中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于加载操作系统标记为从 Web （例如，从 Internet 或 intranet 下载的临时文件） 的本地程序集。 之前[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，这样的程序集已自动加载到沙盒应用程序域。 从开始[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，它们是以完全信任方式加载。  
  
 作为使用此方法的替代方法，你可以将应用[ &lt;NetFx40_LegacySecurityPolicy&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)应用程序配置文件中。 这将导致公共语言运行时，若要还原到的安全策略[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]。  
  
> [!CAUTION]
>  如果你使用任一解决方案，你必须是确定它是否安全加载`assemblyFile`以完全信任。  
  
 讨论的加载上下文，包括加载源上下文中，请参阅<xref:System.Reflection.Assembly.LoadFrom%28System.String%29>方法重载。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          未找到 <paramref name="assemblyFile" />，或者尝试加载的模块没有指定文件扩展名。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> 不是有效的程序集。  
  
 或  
  
 <paramref name="assemblyFile" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <exception cref="T:System.Security.SecurityException">在没有所需 <see cref="T:System.Net.WebPermission" /> 的情况下，指定了不以“file://”开始的基本代码。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">程序集名称的长度超过 MAX_PATH 个字符。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
  </Members>
</Type>