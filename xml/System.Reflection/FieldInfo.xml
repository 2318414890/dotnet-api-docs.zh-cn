<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FieldInfo.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5eaf3da8149c7beea481d56464ce8b739bcbe0488.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">eaf3da8149c7beea481d56464ce8b739bcbe0488</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.FieldInfo">
          <source>Discovers the attributes of a field and provides access to field metadata.</source>
          <target state="translated">发现字段的属性并提供对字段元数据的访问权限。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.FieldInfo">
          <source>The field information is obtained from metadata.</source>
          <target state="translated">从元数据中获取字段信息。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.FieldInfo">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> class does not have a public constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph>类没有公共构造函数。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.FieldInfo">
          <source><ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects are obtained by calling either the <ph id="ph2">&lt;xref:System.Type.GetFields%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Type.GetField%2A&gt;</ph> method of a <ph id="ph4">`Type`</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> 通过调用获取对象<ph id="ph2">&lt;xref:System.Type.GetFields%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Type.GetField%2A&gt;</ph>方法<ph id="ph4">`Type`</ph>对象。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.FieldInfo">
          <source>Fields are variables defined in the class.</source>
          <target state="translated">字段是在类中定义的变量。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.FieldInfo">
          <source><ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> provides access to the metadata for a field within a class and provides dynamic set and get functionality for the field.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> 提供一个类中的字段的元数据的访问并为该字段提供动态设置和 get 功能。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.FieldInfo">
          <source>The class is not loaded into memory until invoke or get is called on the object.</source>
          <target state="translated">类不会加载到内存之前调用，或在对象上调用 get。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.FieldInfo">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.GetFields%2A?displayProperty=nameWithType&gt;</ph> method to get the field-related information from the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> class, and then displays field attributes.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Type.GetFields%2A?displayProperty=nameWithType&gt;</ph>方法以获取从与字段相关的信息<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>类，然后显示字段特性。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.FieldInfo">
          <source>for full trust for inheritors.</source>
          <target state="translated">对继承者的完全信任。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.FieldInfo">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">此类不能由部分受信任的代码继承。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.FieldInfo">
          <source>This type is thread safe.</source>
          <target state="translated">此类型是线程安全的。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.FieldInfo">
          <source>When you inherit from <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, you must override the following members: <ph id="ph2">&lt;see cref="M:System.Reflection.FieldInfo.GetValue(System.Object)" /&gt;</ph> and <ph id="ph3">&lt;see cref="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)" /&gt;</ph>.</source>
          <target state="translated">当从 <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> 继承时，必须重写下面的成员：<ph id="ph2">&lt;see cref="M:System.Reflection.FieldInfo.GetValue(System.Object)" /&gt;</ph> 和 <ph id="ph3">&lt;see cref="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.#ctor">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.#ctor">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.Attributes">
          <source>Gets the attributes associated with this field.</source>
          <target state="translated">获取与此字段关联的特性。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.Attributes">
          <source>The <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph> for this field.</source>
          <target state="translated">此字段的 <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.Attributes">
          <source>All members have a set of attributes, which are defined in relation to the specific type of member.</source>
          <target state="translated">所有成员都具有一组属性，定义相对于特定类型的成员。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.Attributes">
          <source><ph id="ph1">`FieldAttributes`</ph> informs the user whether this field is the private field, a static field, and so on.</source>
          <target state="translated"><ph id="ph1">`FieldAttributes`</ph> 将通知用户此字段是私有字段，静态字段中，依次类推。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.Attributes">
          <source>To get the <ph id="ph1">`Attributes`</ph> property, first get the class <ph id="ph2">`Type`</ph>.</source>
          <target state="translated">若要获取<ph id="ph1">`Attributes`</ph>属性，首先需要获取类<ph id="ph2">`Type`</ph>。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.Attributes">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`FieldInfo`</ph>.</source>
          <target state="translated">从<ph id="ph1">`Type`</ph>，获取<ph id="ph2">`FieldInfo`</ph>。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.Attributes">
          <source>From the <ph id="ph1">`FieldInfo`</ph>, get the <ph id="ph2">`Attributes`</ph>.</source>
          <target state="translated">从<ph id="ph1">`FieldInfo`</ph>，获取<ph id="ph2">`Attributes`</ph>。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.Attributes">
          <source>The following code example builds three fields and displays their field attributes.</source>
          <target state="translated">下面的代码示例生成三个字段，并显示其字段特性。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.Attributes">
          <source>A <ph id="ph1">`FieldAttributes`</ph> value can contain more than one attribute, such as both <ph id="ph2">`Public`</ph> and <ph id="ph3">`Literal`</ph>, as shown in the third field.</source>
          <target state="translated">A<ph id="ph1">`FieldAttributes`</ph>值可以包含多个特性，如<ph id="ph2">`Public`</ph>和<ph id="ph3">`Literal`</ph>，如第三个字段中所示。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.Equals(System.Object)">
          <source>An object to compare with this instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">与此实例进行比较的对象，或为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.Equals(System.Object)">
          <source>Returns a value that indicates whether this instance is equal to a specified object.</source>
          <target state="translated">返回一个值，该值指示此实例是否与指定的对象相等。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> equals the type and value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 等于此实例的类型和值，则为 <ph id="ph2">&lt;paramref name="obj" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.FieldHandle">
          <source>Gets a <ph id="ph1">&lt;see langword="RuntimeFieldHandle" /&gt;</ph>, which is a handle to the internal metadata representation of a field.</source>
          <target state="translated">获取 <ph id="ph1">&lt;see langword="RuntimeFieldHandle" /&gt;</ph>，它是字段的内部元数据表示形式的句柄。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.FieldHandle">
          <source>A handle to the internal metadata representation of a field.</source>
          <target state="translated">某个字段的内部元数据表示形式的句柄。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.FieldHandle">
          <source>The handles are valid only in the appdomain in which they were obtained.</source>
          <target state="translated">句柄是仅在获取它们的 appdomain 中有效。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.FieldHandle">
          <source>The following example retrieves MyClass.MyField field information and displays the field associated with the field handle.</source>
          <target state="translated">下面的示例检索 MyClass.MyField 字段信息并显示与字段句柄关联的字段。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.FieldType">
          <source>Gets the type of this field object.</source>
          <target state="translated">获取此字段对象的类型。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.FieldType">
          <source>The type of this field object.</source>
          <target state="translated">此字段对象的类型。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.FieldType">
          <source>The type is some primitive data type, such as <ph id="ph1">`String`</ph>, <ph id="ph2">`Boolean`</ph>, or <ph id="ph3">`GUID`</ph>.</source>
          <target state="translated">类型为某个基元数据类型，如<ph id="ph1">`String`</ph>， <ph id="ph2">`Boolean`</ph>，或<ph id="ph3">`GUID`</ph>。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.FieldType">
          <source>To get the <ph id="ph1">`FieldType`</ph> property, first get the class <ph id="ph2">`Type`</ph>.</source>
          <target state="translated">若要获取<ph id="ph1">`FieldType`</ph>属性，首先需要获取类<ph id="ph2">`Type`</ph>。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.FieldType">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`FieldInfo`</ph>.</source>
          <target state="translated">从<ph id="ph1">`Type`</ph>，获取<ph id="ph2">`FieldInfo`</ph>。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.FieldType">
          <source>From the <ph id="ph1">`FieldInfo`</ph>, get the <ph id="ph2">`FieldType`</ph> value.</source>
          <target state="translated">从<ph id="ph1">`FieldInfo`</ph>，获取<ph id="ph2">`FieldType`</ph>值。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.FieldType">
          <source>The following example creates a field, gets its type and <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph>, and displays its <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.FieldType%2A&gt;</ph>.</source>
          <target state="translated">下面的示例创建一个字段，获取其类型和<ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph>，并显示其<ph id="ph2">&lt;xref:System.Reflection.FieldInfo.FieldType%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="T:System.Reflection.FieldInfo">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> for the field represented by a handle.</source>
          <target state="translated">获取由句柄表示的字段的 <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)">
          <source>A <ph id="ph1">&lt;see cref="T:System.RuntimeFieldHandle" /&gt;</ph> structure that contains the handle to the internal metadata representation of a field.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.RuntimeFieldHandle" /&gt;</ph> 结构，它包含字段的内部元数据表示形式的句柄。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> for the field represented by the specified handle.</source>
          <target state="translated">获取由指定句柄表示的字段的 <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field specified by <ph id="ph2">&lt;paramref name="handle" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> 对象，表示由 <ph id="ph2">&lt;paramref name="handle" /&gt;</ph> 指定的字段。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)">
          <source>Handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">句柄仅在获取它们的应用程序域中是有效的。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetFields%2A?displayProperty=nameWithType&gt;</ph> method to get <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects for the fields of a type, gets a <ph id="ph3">&lt;xref:System.RuntimeFieldHandle&gt;</ph> structure for each field, and then retrieves the <ph id="ph4">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects from the handles using this overload of the <ph id="ph5">&lt;xref:System.Reflection.FieldInfo.GetFieldFromHandle%2A&gt;</ph> method.</source>
          <target state="translated">下面的代码示例使用<ph id="ph1">&lt;xref:System.Type.GetFields%2A?displayProperty=nameWithType&gt;</ph>方法以获取<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>类型的字段的对象获取<ph id="ph3">&lt;xref:System.RuntimeFieldHandle&gt;</ph>结构每个字段，然后检索<ph id="ph4">&lt;xref:System.Reflection.FieldInfo&gt;</ph>从使用此重载句柄的对象<ph id="ph5">&lt;xref:System.Reflection.FieldInfo.GetFieldFromHandle%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)">
          <source><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>A <ph id="ph1">&lt;see cref="T:System.RuntimeFieldHandle" /&gt;</ph> structure that contains the handle to the internal metadata representation of a field.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.RuntimeFieldHandle" /&gt;</ph> 结构，它包含字段的内部元数据表示形式的句柄。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>A <ph id="ph1">&lt;see cref="T:System.RuntimeTypeHandle" /&gt;</ph> structure that contains the handle to the generic type that defines the field.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.RuntimeTypeHandle" /&gt;</ph> 结构，它包含定义该字段的泛型类型的句柄。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> for the field represented by the specified handle, for the specified generic type.</source>
          <target state="translated">获取由指定句柄表示的指定泛型类型字段的 <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field specified by <ph id="ph2">&lt;paramref name="handle" /&gt;</ph>, in the generic type specified by <ph id="ph3">&lt;paramref name="declaringType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> 对象，表示由 <ph id="ph2">&lt;paramref name="handle" /&gt;</ph> 指定的字段，该字段的类型为 <ph id="ph3">&lt;paramref name="declaringType" /&gt;</ph> 指定的泛型类型。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>Handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">句柄仅在获取它们的应用程序域中是有效的。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>The recommended practice is that <ph id="ph1">`declaringType`</ph> should always be the runtime type handle of the constructed type that <ph id="ph2">`handle`</ph> belongs to.</source>
          <target state="translated">建议的做法是<ph id="ph1">`declaringType`</ph>应始终为的构造的运行时类型句柄类型<ph id="ph2">`handle`</ph>属于。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>That is, if <ph id="ph1">`handle`</ph> is a runtime field handle for a field that belongs to <ph id="ph2">`MyType&lt;int&gt;`</ph> (<ph id="ph3">`MyType(Of Integer)`</ph> in Visual Basic), <ph id="ph4">`declaringType`</ph> is the runtime type handle for <ph id="ph5">`MyType&lt;int&gt;`</ph>.</source>
          <target state="translated">也就是说，如果<ph id="ph1">`handle`</ph>是所属的字段的运行时字段句柄<ph id="ph2">`MyType&lt;int&gt;`</ph>(<ph id="ph3">`MyType(Of Integer)`</ph>在 Visual Basic 中)，<ph id="ph4">`declaringType`</ph>是运行时类型句柄<ph id="ph5">`MyType&lt;int&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>Do not use the runtime type handle of the generic type definition, unless the runtime field handle represents a field on the generic type definition.</source>
          <target state="translated">不要使用泛型类型定义中，运行时类型句柄，除非运行时字段句柄表示的泛型类型定义的字段。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>Implementations are compatible in some cases.</source>
          <target state="translated">在某些情况下兼容了实现。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>For example, a single implementation is shared by all types that are constructed from a particular generic type definition by using reference types for the generic type arguments.</source>
          <target state="translated">例如，通过使用引用类型的泛型类型自变量从特定的泛型类型定义构造的所有类型由共享单个实现。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>For example, <ph id="ph1">`MyType&lt;string&gt;`</ph>, <ph id="ph2">`MyType&lt;object&gt;`</ph>, and <ph id="ph3">`MyType&lt;ArrayList&gt;`</ph> all share the same implementation.</source>
          <target state="translated">例如， <ph id="ph1">`MyType&lt;string&gt;`</ph>， <ph id="ph2">`MyType&lt;object&gt;`</ph>，和<ph id="ph3">`MyType&lt;ArrayList&gt;`</ph>所有共享相同的实现。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>In this situation, the <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object that is returned represents a field on the type that <ph id="ph2">`declaringType`</ph> specifies, regardless of the original source of <ph id="ph3">`handle`</ph>.</source>
          <target state="translated">在此情况下，<ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph>返回对象表示类型上的字段，<ph id="ph2">`declaringType`</ph>指定原始源无关<ph id="ph3">`handle`</ph>。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>This practice is not recommended, because it works only if the generic type arguments of the constructed type are reference types.</source>
          <target state="translated">不建议这样做，因为它的构造类型的泛型类型参数是引用类型的情况下，才有效。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>If a generic argument is a value type, the runtime type handle of the constructed type is not compatible with runtime field handles from constructions that have a reference type in the same generic parameter position, or that have a different value type in that position.</source>
          <target state="translated">如果泛型自变量是值类型的构造类型的运行时类型句柄不是从具有相同的泛型参数位置中，键入的引用或具有在该位置中键入一个不同值的构造的运行时字段句柄与兼容.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>In that case, the only way to use the <ph id="ph1">&lt;xref:System.Reflection.FieldInfo.GetFieldFromHandle%28System.RuntimeFieldHandle%2CSystem.RuntimeTypeHandle%29?displayProperty=nameWithType&gt;</ph> overload is to ensure that <ph id="ph2">`declaringType`</ph> is the runtime type handle for the constructed type that <ph id="ph3">`handle`</ph> belongs to.</source>
          <target state="translated">在这种情况下，使用的唯一办法<ph id="ph1">&lt;xref:System.Reflection.FieldInfo.GetFieldFromHandle%28System.RuntimeFieldHandle%2CSystem.RuntimeTypeHandle%29?displayProperty=nameWithType&gt;</ph>重载是确保<ph id="ph2">`declaringType`</ph>的构造类型是运行时类型句柄<ph id="ph3">`handle`</ph>属于。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>The following example shows how to retrieve <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects for fields on constructed generic classes.</source>
          <target state="translated">下面的示例演示如何检索<ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph>上构造的泛型类的字段的对象。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>The example defines the generic type <ph id="ph1">`Test&lt;T&gt;`</ph> (<ph id="ph2">`Test(Of T)`</ph> in Visual Basic) with a single field named <ph id="ph3">`TestField`</ph>, of type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">该示例定义的泛型类型<ph id="ph1">`Test&lt;T&gt;`</ph>(<ph id="ph2">`Test(Of T)`</ph>在 Visual Basic 中) 与名为的单个域<ph id="ph3">`TestField`</ph>，类型的<ph id="ph4">`T`</ph>。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>The example gets the <ph id="ph1">&lt;xref:System.RuntimeFieldHandle&gt;</ph> and <ph id="ph2">&lt;xref:System.RuntimeTypeHandle&gt;</ph> for the case where <ph id="ph3">`T`</ph> is <ph id="ph4">&lt;xref:System.String&gt;</ph>, and demonstrates the following:</source>
          <target state="translated">此示例获取<ph id="ph1">&lt;xref:System.RuntimeFieldHandle&gt;</ph>和<ph id="ph2">&lt;xref:System.RuntimeTypeHandle&gt;</ph>为用例其中<ph id="ph3">`T`</ph>是<ph id="ph4">&lt;xref:System.String&gt;</ph>，并演示以下：</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>An exception is thrown if the <ph id="ph1">&lt;xref:System.Reflection.FieldInfo.GetFieldFromHandle%28System.RuntimeFieldHandle%29&gt;</ph> method overload is used.</source>
          <target state="translated">如果引发异常<ph id="ph1">&lt;xref:System.Reflection.FieldInfo.GetFieldFromHandle%28System.RuntimeFieldHandle%29&gt;</ph>使用方法重载。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>This is true even if the field is not of type <ph id="ph1">`T`</ph>.</source>
          <target state="translated">这是 true，即使该字段的类型不是<ph id="ph1">`T`</ph>。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> is retrieved successfully if the runtime type handle is from the same construction as the runtime field handle, in this case <ph id="ph2">`Test&lt;string&gt;`</ph>.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph>如果运行时类型句柄来自同一个构造作为运行时字段句柄，在这种情况下成功检索<ph id="ph2">`Test&lt;string&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>If the runtime type handle is from a compatible construction, in this case <ph id="ph1">`Test&lt;object&gt;`</ph>, a <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> for the field on the compatible construction is retrieved.</source>
          <target state="translated">如果运行时类型句柄是从兼容的构造，在这种情况下<ph id="ph1">`Test&lt;object&gt;`</ph>、<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>检索上兼容的构造的字段。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>If the runtime type handle is not from a compatible construction, an exception is thrown.</source>
          <target state="translated">如果运行时类型句柄不是来自兼容的构造，则引发异常。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>In this case, a value type is specified for <ph id="ph1">`T`</ph>.</source>
          <target state="translated">在这种情况下，指定值类型<ph id="ph1">`T`</ph>。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source><ph id="ph1">&lt;paramref name="declaringType" /&gt;</ph> is not compatible with <ph id="ph2">&lt;paramref name="handle" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="declaringType" /&gt;</ph> 与 <ph id="ph2">&lt;paramref name="handle" /&gt;</ph> 不兼容。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>For example, <ph id="ph1">&lt;paramref name="declaringType" /&gt;</ph> is the runtime type handle of the generic type definition, and <ph id="ph2">&lt;paramref name="handle" /&gt;</ph> comes from a constructed type.</source>
          <target state="translated">例如，<ph id="ph1">&lt;paramref name="declaringType" /&gt;</ph> 是泛型类型定义的运行时类型句柄，且 <ph id="ph2">&lt;paramref name="handle" /&gt;</ph> 来自于构造类型。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">返回此实例的哈希代码。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">32 位有符号整数哈希代码。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetOptionalCustomModifiers">
          <source>Gets an array of types that identify the optional custom modifiers of the field.</source>
          <target state="translated">获取一个类型数组，这些类型标识字段的可选自定义修饰符。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetOptionalCustomModifiers">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that identify the optional custom modifiers of the current field, such as <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象的数组，这些对象标识当前字段的可选自定义修饰符（例如 <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>）。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetOptionalCustomModifiers">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.FieldInfo.GetOptionalCustomModifiers%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.GetRequiredCustomModifiers%2A&gt;</ph> methods are provided for designers of managed compilers.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldInfo.GetOptionalCustomModifiers%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Reflection.FieldInfo.GetRequiredCustomModifiers%2A&gt;</ph>托管编译器的设计器提供方法。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetOptionalCustomModifiers">
          <source>For more information on custom modifiers, see <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsBoxed&gt;</ph> and related classes in the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices&gt;</ph> namespace and the metadata specification in the ECMA Partition II documentation.</source>
          <target state="translated">有关自定义修饰符的详细信息，请参阅<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsBoxed&gt;</ph>和中的相关类<ph id="ph2">&lt;xref:System.Runtime.CompilerServices&gt;</ph>命名空间和 ECMA 第 ii 部分文档中的元数据规范。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetOptionalCustomModifiers">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">可联机获取该文档；请参阅 MSDN 上的 <bpt id="p1">[</bpt>ECMA C# 和公共语言基础结构标准<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>和 Ecma International 网站上的<bpt id="p2">[</bpt>标准 ECMA-335 - 公共语言基础结构 (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>Returns a literal value associated with the field by a compiler.</source>
          <target state="translated">由编译器返回与字段关联的文本值。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that contains the literal value associated with the field.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>，它包含与此字段关联的文本值。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>If the literal value is a class type with an element value of zero, the return value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果文本值是一个元素值为零的类类型，则返回值为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>This method is provided for designers of managed compilers and code analyzers.</source>
          <target state="translated">此方法是为设计器提供的托管的编译器和代码分析。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>This method can be used in both the execution context and the reflection-only context.</source>
          <target state="translated">执行上下文和仅限反射上下文中，可以使用此方法。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>In unmanaged metadata, the Constant table is used to store constant values for fields, parameters, and properties.</source>
          <target state="translated">在非托管元数据中的常数表用于存储的字段、 参数和属性的常数值。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>Constant information does not directly influence runtime behavior.</source>
          <target state="translated">常量的信息不会直接影响运行时行为。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>Compilers inspect this information, at compile time, when importing metadata.</source>
          <target state="translated">编译器检查此信息，请在编译时，导入元数据时。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>If used, the value of a constant is embedded in the Microsoft intermediate language (MSIL) stream the compiler emits.</source>
          <target state="translated">如果使用，则编译器将发出 Microsoft 中间语言 (MSIL) 流中嵌入常量的值。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>There are no MSIL instructions that can be used to access the Constant table at run time.</source>
          <target state="translated">有可用来在运行时访问的常数表没有 MSIL 指令。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>For more information on constant values and the Constant table, see the ECMA Partition II documentation.</source>
          <target state="translated">常量值和常量的表的详细信息，请参阅 ECMA 第 ii 部分文档。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">可联机获取该文档；请参阅 MSDN 上的 <bpt id="p1">[</bpt>ECMA C# 和公共语言基础结构标准<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>和 Ecma International 网站上的<bpt id="p2">[</bpt>标准 ECMA-335 - 公共语言基础结构 (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>The Constant table in unmanaged metadata does not contain a constant value for the current field.</source>
          <target state="translated">非托管元数据中的常数表不包含当前字段的常数值。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>The type of the value is not one of the types permitted by the Common Language Specification (CLS).</source>
          <target state="translated">值的类型不是公共语言规范 (CLS) 许可的类型。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>See the ECMA Partition II specification Metadata Logical Format: Other Structures, Element Types used in Signatures.</source>
          <target state="translated">请参阅 ECMA 第 II 部分规范，元数据逻辑格式：其他结构、签名中使用的元素类型。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetRawConstantValue">
          <source>The constant value for the field is not set.</source>
          <target state="translated">未设置该字段的常数值。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetRequiredCustomModifiers">
          <source>Gets an array of types that identify the required custom modifiers of the property.</source>
          <target state="translated">获取一个类型数组，这些类型标识属性所需的自定义修饰符。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetRequiredCustomModifiers">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that identify the required custom modifiers of the current property, such as <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象的数组，这些对象标识当前属性所必需的自定义修饰符（例如 <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> 或 <ph id="ph3">&lt;see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced" /&gt;</ph>）。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetRequiredCustomModifiers">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.FieldInfo.GetOptionalCustomModifiers%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.GetRequiredCustomModifiers%2A&gt;</ph> methods are provided for designers of managed compilers.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldInfo.GetOptionalCustomModifiers%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Reflection.FieldInfo.GetRequiredCustomModifiers%2A&gt;</ph>托管编译器的设计器提供方法。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetRequiredCustomModifiers">
          <source>For more information on custom modifiers, see <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsBoxed&gt;</ph> and related classes in the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices&gt;</ph> namespace and the metadata specification in the ECMA Partition II documentation.</source>
          <target state="translated">有关自定义修饰符的详细信息，请参阅<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsBoxed&gt;</ph>和中的相关类<ph id="ph2">&lt;xref:System.Runtime.CompilerServices&gt;</ph>命名空间和 ECMA 第 ii 部分文档中的元数据规范。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetRequiredCustomModifiers">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">可联机获取该文档；请参阅 MSDN 上的 <bpt id="p1">[</bpt>ECMA C# 和公共语言基础结构标准<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>和 Ecma International 网站上的<bpt id="p2">[</bpt>标准 ECMA-335 - 公共语言基础结构 (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>The object whose field value will be returned.</source>
          <target state="translated">将返回其字段值的对象。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>When overridden in a derived class, returns the value of a field supported by a given object.</source>
          <target state="translated">当在派生类中重写时，返回给定对象支持的字段的值。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>An object containing the value of the field reflected by this instance.</source>
          <target state="translated">一个对象，包含此实例反映的字段的值。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>If the field is static, <ph id="ph1">`obj`</ph> is ignored.</source>
          <target state="translated">如果此字段为静态，<ph id="ph1">`obj`</ph>将被忽略。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>For non-static fields, <ph id="ph1">`obj`</ph> should be an instance of a class that inherits or declares the field.</source>
          <target state="translated">对于非静态字段，<ph id="ph1">`obj`</ph>应是继承或声明该字段的类的实例。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>Note that the return type of <ph id="ph1">`GetValue`</ph> is <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">请注意的返回类型的<ph id="ph1">`GetValue`</ph>是<ph id="ph2">`Object`</ph>。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>For example, if the field holds a Boolean primitive value, an instance of <ph id="ph1">`Object`</ph> with the appropriate Boolean value is returned.</source>
          <target state="translated">例如，如果该字段将持有一个布尔值基元值，实例<ph id="ph1">`Object`</ph>带有相应 Boolean 返回值。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>Before returning the value, <ph id="ph1">`GetValue`</ph> checks to see if the user has access permission.</source>
          <target state="translated">在返回值之前,<ph id="ph1">`GetValue`</ph>检查以确定用户是否有访问权限。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>Access restrictions are ignored for fully trusted code.</source>
          <target state="translated">访问限制会忽略完全受信任的代码。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked through reflection whenever the code is fully trusted.</source>
          <target state="translated">也就是说，是在私有构造函数、 方法、 字段和属性访问而完全受信任代码时，通过反射调用。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，此方法可以用于访问非公共成员，如果调用方已被授予<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>与<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>标志，并且如果非公共成员的授予集限制为调用方的授予集或子集其中。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(请参阅<bpt id="p1">[</bpt>反射的安全注意事项<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用此功能，应用程序应为 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 或更高版本。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.FieldInfo.GetValue%2A&gt;</ph> method to retrieve the value of a static field.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Reflection.FieldInfo.GetValue%2A&gt;</ph>方法来检索某个静态字段的值。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>Note that the value of the <ph id="ph1">`obj`</ph> argument is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">请注意，值<ph id="ph1">`obj`</ph>自变量是<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>The following example retrieves an array of <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects that represents the fields of the <ph id="ph2">`FieldsClass`</ph> type, and then calls the <ph id="ph3">&lt;xref:System.Reflection.FieldInfo.GetValue%2A&gt;</ph> to display the value of each field for the <ph id="ph4">`fieldsInst`</ph> object.</source>
          <target state="translated">下面的示例检索的数组<ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph>表示的字段的对象<ph id="ph2">`FieldsClass`</ph>类型，然后调用<ph id="ph3">&lt;xref:System.Reflection.FieldInfo.GetValue%2A&gt;</ph>以显示有关每个字段的值<ph id="ph4">`fieldsInst`</ph>对象。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the Portable Class Library, catch <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> instead.</source>
          <target state="translated">在<bpt id="p1">[</bpt>适用于 Windows 应用商店应用的 .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> 或可移植类库中，改为捕获 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>The field is non-static and <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">该字段是非静态的，并且 <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>A field is marked literal, but the field does not have one of the accepted literal types.</source>
          <target state="translated">字段被标记为文本，但该字段不具有一个可被接受的文本类型。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the Portable Class Library, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.MemberAccessException" /&gt;</ph>, instead.</source>
          <target state="translated">在<bpt id="p1">[</bpt>适用于 Windows 应用商店应用的 .NET <ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> 或可移植类库中，改为捕获基类异常 <ph id="ph1">&lt;see cref="T:System.MemberAccessException" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>The caller does not have permission to access this field.</source>
          <target state="translated">调用方没有权限来访问此字段。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>The method is neither declared nor inherited by the class of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated">该方法既不由 <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 的类声明也不由其继承。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValue(System.Object)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetValueDirect(System.TypedReference)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph> structure that encapsulates a managed pointer to a location and a runtime representation of the type that might be stored at that location.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph> 结构，封装指向某个位置的托管指针和可能存储在该位置的类型的运行时表示形式。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetValueDirect(System.TypedReference)">
          <source>Returns the value of a field supported by a given object.</source>
          <target state="translated">返回给定对象所支持的字段的值。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetValueDirect(System.TypedReference)">
          <source>An <ph id="ph1">&lt;see langword="Object" /&gt;</ph> containing a field value.</source>
          <target state="translated">包含字段值的 <ph id="ph1">&lt;see langword="Object" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.GetValueDirect(System.TypedReference)">
          <source>The caller requires the Common Language Specification (CLS) alternative, but called this method instead.</source>
          <target state="translated">调用方需要公共语言规范 (CLS) 的替代项，但改为调用此方法。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValueDirect(System.TypedReference)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.GetValueDirect(System.TypedReference)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.IsAssembly">
          <source>Gets a value indicating whether the potential visibility of this field is described by <ph id="ph1">&lt;see cref="F:System.Reflection.FieldAttributes.Assembly" /&gt;</ph>; that is, the field is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</source>
          <target state="translated">获取一个值，该值指示此字段的潜在可见性是否由 <ph id="ph1">&lt;see cref="F:System.Reflection.FieldAttributes.Assembly" /&gt;</ph> 描述；也就是说，此字段只对同一程序集中的其他类型可见，而对该程序集以外的派生类型则不可见。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the visibility of this field is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.FieldAttributes.Assembly" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此字段的可见性由 <ph id="ph2">&lt;see cref="F:System.Reflection.FieldAttributes.Assembly" /&gt;</ph> 准确描述，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsAssembly">
          <source>The actual visibility of a field is limited by the visibility of its type.</source>
          <target state="translated">字段的实际可见受到其类型的可见性。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsAssembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsAssembly%2A&gt;</ph> property might be <ph id="ph2">`true`</ph> for a field, but if it is a field of a private nested type then the field is not visible outside the containing type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsAssembly%2A&gt;</ph>属性可能<ph id="ph2">`true`</ph>字段，但如果它可以是私有的嵌套类型的字段，则该字段不是包含类型外部可见。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsAssembly">
          <source>The visibility of a field is exactly described by <ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Assembly?displayProperty=nameWithType&gt;</ph> if the only visibility modifier is <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic).</source>
          <target state="translated">字段的可见性准确描述通过<ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Assembly?displayProperty=nameWithType&gt;</ph>唯一可见性修饰符是否<ph id="ph2">`internal`</ph>(<ph id="ph3">`Friend`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsAssembly">
          <source>This property is <ph id="ph1">`false`</ph> for fields that are <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++); use the <ph id="ph5">&lt;xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A&gt;</ph> property to identify such fields.</source>
          <target state="translated">此属性是<ph id="ph1">`false`</ph>为字段<ph id="ph2">`protected internal`</ph>C# 中 (<ph id="ph3">`Protected Friend`</ph>在 Visual Basic 中， <ph id="ph4">`protected public`</ph> c + + 中); 使用<ph id="ph5">&lt;xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A&gt;</ph>属性来标识此类字段。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsAssembly">
          <source>The following code example defines fields with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">下面的代码示例定义的字段具有不同级别的可见性，并显示的值，其<ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsAssembly%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.IsFamily%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsAssembly">
          <source>The Visual Basic and C# languages cannot define fields with <ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Visual Basic 和 C# 语言不能定义具有字段<ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph>可见性; 仅在 c + + 示例中出现访问级别。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.IsFamily">
          <source>Gets a value indicating whether the visibility of this field is described by <ph id="ph1">&lt;see cref="F:System.Reflection.FieldAttributes.Family" /&gt;</ph>; that is, the field is visible only within its class and derived classes.</source>
          <target state="translated">获取一个值，该值指示此字段的可见性是否由 <ph id="ph1">&lt;see cref="F:System.Reflection.FieldAttributes.Family" /&gt;</ph> 描述；也就是说，此字段仅在其类和派生类内可见。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamily">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this field is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.FieldAttributes.Family" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果对此字段的访问由 <ph id="ph2">&lt;see cref="F:System.Reflection.FieldAttributes.Family" /&gt;</ph> 准确描述，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamily">
          <source>The visibility of a field is exactly described by <ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Family?displayProperty=nameWithType&gt;</ph> if the only visibility modifier is <ph id="ph2">`protected`</ph>.</source>
          <target state="translated">字段的可见性准确描述通过<ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Family?displayProperty=nameWithType&gt;</ph>唯一可见性修饰符是否<ph id="ph2">`protected`</ph>。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamily">
          <source>This property is <ph id="ph1">`false`</ph> for fields that are <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++); use the <ph id="ph5">&lt;xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A&gt;</ph> property to identify such fields.</source>
          <target state="translated">此属性是<ph id="ph1">`false`</ph>为字段<ph id="ph2">`protected internal`</ph>C# 中 (<ph id="ph3">`Protected Friend`</ph>在 Visual Basic 中， <ph id="ph4">`protected public`</ph> c + + 中); 使用<ph id="ph5">&lt;xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A&gt;</ph>属性来标识此类字段。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamily">
          <source>The following code example defines fields with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">下面的代码示例定义的字段具有不同级别的可见性，并显示的值，其<ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsAssembly%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.IsFamily%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamily">
          <source>The Visual Basic and C# languages cannot define fields with <ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Visual Basic 和 C# 语言不能定义具有字段<ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph>可见性; 仅在 c + + 示例中出现访问级别。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.IsFamilyAndAssembly">
          <source>Gets a value indicating whether the visibility of this field is described by <ph id="ph1">&lt;see cref="F:System.Reflection.FieldAttributes.FamANDAssem" /&gt;</ph>; that is, the field can be accessed from derived classes, but only if they are in the same assembly.</source>
          <target state="translated">获取一个值，该值指示此字段的可见性是否由 <ph id="ph1">&lt;see cref="F:System.Reflection.FieldAttributes.FamANDAssem" /&gt;</ph> 描述；也就是说，可从派生类访问此字段，但仅当这些派生类在同一程序集中时。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamilyAndAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this field is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.FieldAttributes.FamANDAssem" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果对此字段的访问由 <ph id="ph2">&lt;see cref="F:System.Reflection.FieldAttributes.FamANDAssem" /&gt;</ph> 准确描述，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamilyAndAssembly">
          <source>If a field has <ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamANDAssem&gt;</ph> level visibility, it can be called from any member in a derived class that is also in the same assembly, but not from any other type.</source>
          <target state="translated">如果字段具有<ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamANDAssem&gt;</ph>级可见性，则可以调用它从同一程序集中，也是为派生类中任何成员，但不是与任何其他类型。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamilyAndAssembly">
          <source>The visibility of a field is exactly described by <ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> if the visibility modifier is <ph id="ph2">`protected private`</ph> in C++.</source>
          <target state="translated">字段的可见性准确描述通过<ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph>的可见性修饰符是否<ph id="ph2">`protected private`</ph>c + + 中。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamilyAndAssembly">
          <source>Fields with this visibility cannot be defined in Visual Basic or C#.</source>
          <target state="translated">无法在 Visual Basic 或 C# 中定义具有此可见性的字段。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamilyAndAssembly">
          <source>The following code example defines fields with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">下面的代码示例定义的字段具有不同级别的可见性，并显示的值，其<ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsAssembly%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.IsFamily%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamilyAndAssembly">
          <source>The Visual Basic and C# languages cannot define fields with <ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Visual Basic 和 C# 语言不能定义具有字段<ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph>可见性; 仅在 c + + 示例中出现访问级别。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.IsFamilyOrAssembly">
          <source>Gets a value indicating whether the potential visibility of this field is described by <ph id="ph1">&lt;see cref="F:System.Reflection.FieldAttributes.FamORAssem" /&gt;</ph>; that is, the field can be accessed by derived classes wherever they are, and by classes in the same assembly.</source>
          <target state="translated">获取一个值，该值指示此字段的潜在可见性是否由 <ph id="ph1">&lt;see cref="F:System.Reflection.FieldAttributes.FamORAssem" /&gt;</ph> 描述；也就是说，可通过派生类（无论其位置如何）和同一程序集中的类访问此字段。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamilyOrAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this field is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.FieldAttributes.FamORAssem" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果对此字段的访问由 <ph id="ph2">&lt;see cref="F:System.Reflection.FieldAttributes.FamORAssem" /&gt;</ph> 准确描述，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamilyOrAssembly">
          <source>If a field has <ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamORAssem&gt;</ph> level visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</source>
          <target state="translated">如果字段具有<ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamORAssem&gt;</ph>级可见性，则可以调用它从派生类中的任何成员或任何成员在同一程序集中，但不是与任何其他类型。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamilyOrAssembly">
          <source>The actual visibility of a field is limited by the visibility of its type.</source>
          <target state="translated">字段的实际可见受到其类型的可见性。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamilyOrAssembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A&gt;</ph> property might be <ph id="ph2">`true`</ph> for a field, but if it is a field of a private nested type then the field is not visible outside the containing type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A&gt;</ph>属性可能<ph id="ph2">`true`</ph>字段，但如果它可以是私有的嵌套类型的字段，则该字段不是包含类型外部可见。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamilyOrAssembly">
          <source>The visibility of a field is exactly described by <ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> if the visibility modifier is <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++).</source>
          <target state="translated">字段的可见性准确描述通过<ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph>的可见性修饰符是否<ph id="ph2">`protected internal`</ph>C# 中 (<ph id="ph3">`Protected Friend`</ph>在 Visual Basic 中， <ph id="ph4">`protected public`</ph> c + + 中)。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamilyOrAssembly">
          <source>The following code example defines fields with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">下面的代码示例定义的字段具有不同级别的可见性，并显示的值，其<ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsAssembly%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.IsFamily%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsFamilyOrAssembly">
          <source>The Visual Basic and C# languages cannot define fields with <ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Visual Basic 和 C# 语言不能定义具有字段<ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph>可见性; 仅在 c + + 示例中出现访问级别。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.IsInitOnly">
          <source>Gets a value indicating whether the field can only be set in the body of the constructor.</source>
          <target state="translated">获取一个值，通过该值指示此字段是否只能在构造函数的主体中设置。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsInitOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the field has the <ph id="ph2">&lt;see langword="InitOnly" /&gt;</ph> attribute set; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果字段设置了 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 属性，则为 <ph id="ph2">&lt;see langword="InitOnly" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsInitOnly">
          <source>If the returned value is <ph id="ph1">`true`</ph>, the field can only be initialized, and is read-only thereafter.</source>
          <target state="translated">如果返回的值是<ph id="ph1">`true`</ph>，该字段可以只初始化，因此，此后是只读的。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsInitOnly">
          <source>To get the <ph id="ph1">`IsInitOnly`</ph> property, first get the class <ph id="ph2">`Type`</ph>.</source>
          <target state="translated">若要获取<ph id="ph1">`IsInitOnly`</ph>属性，首先需要获取类<ph id="ph2">`Type`</ph>。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsInitOnly">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`FieldInfo`</ph>.</source>
          <target state="translated">从<ph id="ph1">`Type`</ph>，获取<ph id="ph2">`FieldInfo`</ph>。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsInitOnly">
          <source>From the <ph id="ph1">`FieldInfo`</ph>, get the <ph id="ph2">`IsInitOnly`</ph> property.</source>
          <target state="translated">从<ph id="ph1">`FieldInfo`</ph>，获取<ph id="ph2">`IsInitOnly`</ph>属性。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsInitOnly">
          <source>To access a non-public field, combine <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> with either or both of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> in the <ph id="ph4">`GetField`</ph> method.</source>
          <target state="translated">若要访问非公共字段，合并<ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>与这两个或其中任何一个<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>和<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>中<ph id="ph4">`GetField`</ph>方法。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsInitOnly">
          <source>The <ph id="ph1">`IsInitOnly`</ph> property is set when the <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes.InitOnly?displayProperty=nameWithType&gt;</ph> attribute is set.</source>
          <target state="translated"><ph id="ph1">`IsInitOnly`</ph>时设置属性<ph id="ph2">&lt;xref:System.Reflection.FieldAttributes.InitOnly?displayProperty=nameWithType&gt;</ph>属性设置。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsInitOnly">
          <source>In the following example, two fields are created.</source>
          <target state="translated">在以下示例中，创建了两个字段。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsInitOnly">
          <source>The second field is read-only, having no set accessor, and <ph id="ph1">`IsInitOnly`</ph> is set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">第二个字段是只读的具有没有 set 访问器中，和<ph id="ph1">`IsInitOnly`</ph>设置为<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsInitOnly">
          <source>This code produces the following output:</source>
          <target state="translated">此代码生成以下输出：</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsInitOnly">
          <source>Reflection.FieldInfo</source>
          <target state="translated">Reflection.FieldInfo</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsInitOnly">
          <source>Myfielda - A- modified, IsInitOnly = False</source>
          <target state="translated">Myfielda-A-修改，字个 = False</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsInitOnly">
          <source>Myfieldb - B readonly field, IsInitOnly = True</source>
          <target state="translated">Myfieldb-B 只读字段，字个 = True</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.IsLiteral">
          <source>Gets a value indicating whether the value is written at compile time and cannot be changed.</source>
          <target state="translated">获取一个值，通过该值指示该值是否在编译时写入并且不能更改。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsLiteral">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the field has the <ph id="ph2">&lt;see langword="Literal" /&gt;</ph> attribute set; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果字段设置了 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 属性，则为 <ph id="ph2">&lt;see langword="Literal" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsLiteral">
          <source>The <ph id="ph1">`IsLiteral`</ph> property is set when the <ph id="ph2">`FieldAttributes.Literal`</ph> attribute is set.</source>
          <target state="translated"><ph id="ph1">`IsLiteral`</ph>时设置属性<ph id="ph2">`FieldAttributes.Literal`</ph>属性设置。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsLiteral">
          <source>If this attribute is set, the field cannot be changed and is constant.</source>
          <target state="translated">如果设置此属性，该字段不能更改，并为常数。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.IsNotSerialized">
          <source>Gets a value indicating whether this field has the <ph id="ph1">&lt;see langword="NotSerialized" /&gt;</ph> attribute.</source>
          <target state="translated">获取一个值，通过该值指示此字段是否有 <ph id="ph1">&lt;see langword="NotSerialized" /&gt;</ph> 特性。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsNotSerialized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the field has the <ph id="ph2">&lt;see langword="NotSerialized" /&gt;</ph> attribute set; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果字段设置了 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 属性，则为 <ph id="ph2">&lt;see langword="NotSerialized" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsNotSerialized">
          <source>The <ph id="ph1">`IsNotSerialized`</ph> property returns <ph id="ph2">`true`</ph> when the field is marked with the <ph id="ph3">`FieldAttributes.NotSerialized`</ph> flag.</source>
          <target state="translated"><ph id="ph1">`IsNotSerialized`</ph>属性返回<ph id="ph2">`true`</ph>时将字段标记有<ph id="ph3">`FieldAttributes.NotSerialized`</ph>标志。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsNotSerialized">
          <source>When this flag is set on a field, it indicates that the field does not have to be serialized when the type is remoted.</source>
          <target state="translated">当此标志设置的字段上时，它指示该字段不需要扩展该类型时序列化。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsNotSerialized">
          <source>The following example gets the field information of the fields of MyClass, determines if the fields can be serialized, and displays the results.</source>
          <target state="translated">下面的示例获取 MyClass 的字段的字段信息，确定是否字段可以进行序列化，并显示结果。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.IsPinvokeImpl">
          <source>Gets a value indicating whether the corresponding <ph id="ph1">&lt;see langword="PinvokeImpl" /&gt;</ph> attribute is set in <ph id="ph2">&lt;see cref="T:System.Reflection.FieldAttributes" /&gt;</ph>.</source>
          <target state="translated">获取一个值，该值指示是否已在 <ph id="ph2">&lt;see cref="T:System.Reflection.FieldAttributes" /&gt;</ph> 中设置相应的 <ph id="ph1">&lt;see langword="PinvokeImpl" /&gt;</ph> 特性。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPinvokeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see langword="PinvokeImpl" /&gt;</ph> attribute is set in <ph id="ph3">&lt;see cref="T:System.Reflection.FieldAttributes" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果在 <ph id="ph3">&lt;see cref="T:System.Reflection.FieldAttributes" /&gt;</ph> 中设置了 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 特性，则为 <ph id="ph2">&lt;see langword="PinvokeImpl" /&gt;</ph>；否则为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPinvokeImpl">
          <source>The following example creates a class and displays the name, field and <ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsPinvokeImpl%2A&gt;</ph> property value of the field.</source>
          <target state="translated">下面的示例将创建一个类，并显示名称、 字段和<ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsPinvokeImpl%2A&gt;</ph>的字段的属性值。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.IsPrivate">
          <source>Gets a value indicating whether the field is private.</source>
          <target state="translated">获取一个值，通过该值指示此字段是否为私有字段。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPrivate">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the field is private; otherwise; <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此字段为私有字段，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPrivate">
          <source>Private fields are accessible only from member functions.</source>
          <target state="translated">私有字段都只能从成员函数可以访问。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPrivate">
          <source>The <ph id="ph1">`IsPrivate`</ph> property is set when the <ph id="ph2">`FieldAttributes.Private`</ph> attribute is set.</source>
          <target state="translated"><ph id="ph1">`IsPrivate`</ph>时设置属性<ph id="ph2">`FieldAttributes.Private`</ph>属性设置。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPrivate">
          <source>To get the <ph id="ph1">`IsPrivate`</ph> property, first get the class <ph id="ph2">`Type`</ph>.</source>
          <target state="translated">若要获取<ph id="ph1">`IsPrivate`</ph>属性，首先需要获取类<ph id="ph2">`Type`</ph>。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPrivate">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`FieldInfo`</ph>.</source>
          <target state="translated">从<ph id="ph1">`Type`</ph>，获取<ph id="ph2">`FieldInfo`</ph>。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPrivate">
          <source>From the <ph id="ph1">`FieldInfo`</ph>, get the <ph id="ph2">`IsPrivate`</ph> property.</source>
          <target state="translated">从<ph id="ph1">`FieldInfo`</ph>，获取<ph id="ph2">`IsPrivate`</ph>属性。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPrivate">
          <source>To access a non-public field, set the <ph id="ph1">`BindingFlags`</ph> to <ph id="ph2">`NonPublic`</ph>, and either <ph id="ph3">`Static`</ph> or <ph id="ph4">`Instance`</ph> in the <ph id="ph5">`GetField`</ph> method.</source>
          <target state="translated">若要访问非公共字段，设置<ph id="ph1">`BindingFlags`</ph>到<ph id="ph2">`NonPublic`</ph>，并且<ph id="ph3">`Static`</ph>或<ph id="ph4">`Instance`</ph>中<ph id="ph5">`GetField`</ph>方法。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPrivate">
          <source>The following example returns a value indicating whether or not the field of the class is private.</source>
          <target state="translated">下面的示例返回一个值，该值指示是私有的类的字段。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.IsPublic">
          <source>Gets a value indicating whether the field is public.</source>
          <target state="translated">获取一个值，通过该值指示此字段是否为公共字段。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this field is public; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此字段为公共字段，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPublic">
          <source>Public fields are accessible everywhere their corresponding classes are visible.</source>
          <target state="translated">公共字段都能访问无处不在其相应的类可见。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPublic">
          <source>The <ph id="ph1">`IsPublic`</ph> property is set when the <ph id="ph2">`FieldAttributes.Public`</ph> attribute is set.</source>
          <target state="translated"><ph id="ph1">`IsPublic`</ph>时设置属性<ph id="ph2">`FieldAttributes.Public`</ph>属性设置。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPublic">
          <source>To get the <ph id="ph1">`IsPublic`</ph> property, first get the class <ph id="ph2">`Type`</ph>.</source>
          <target state="translated">若要获取<ph id="ph1">`IsPublic`</ph>属性，首先需要获取类<ph id="ph2">`Type`</ph>。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPublic">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`FieldInfo`</ph>.</source>
          <target state="translated">从<ph id="ph1">`Type`</ph>，获取<ph id="ph2">`FieldInfo`</ph>。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPublic">
          <source>From the <ph id="ph1">`FieldInfo`</ph>, get the <ph id="ph2">`IsPublic`</ph> property.</source>
          <target state="translated">从<ph id="ph1">`FieldInfo`</ph>，获取<ph id="ph2">`IsPublic`</ph>属性。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPublic">
          <source>If the field is other than public, it is protected and cannot be readily accessed.</source>
          <target state="translated">如果该字段是公共以外，它会受到保护并且不能轻松访问。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPublic">
          <source>To access a nonpublic field, set the <ph id="ph1">`BindingFlags`</ph> to <ph id="ph2">`NonPublic`</ph>, specify either <ph id="ph3">`BindingFlags.Instance`</ph> or <ph id="ph4">`BindingFlags.Static`</ph>, and use this for the <ph id="ph5">`GetField`</ph> method.</source>
          <target state="translated">若要访问非公共字段，设置<ph id="ph1">`BindingFlags`</ph>到<ph id="ph2">`NonPublic`</ph>，指定<ph id="ph3">`BindingFlags.Instance`</ph>或<ph id="ph4">`BindingFlags.Static`</ph>，并将此用于<ph id="ph5">`GetField`</ph>方法。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsPublic">
          <source>The following example returns a value indicating whether or not the field of the class is public or private.</source>
          <target state="translated">下面的示例返回一个值，该值指示在类字段公共或私有。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>Gets a value that indicates whether the current field is security-critical or security-safe-critical at the current trust level.</source>
          <target state="translated">获取一个值，该值指示当前字段在当前信任级别上是安全关键的还是安全可靠关键的。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current field is security-critical or security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated">如果当前字段在当前信任级别上是安全关键的或安全可靠关键的，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；如果它是透明的，则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the field at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsSecurityCritical%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A&gt;</ph>属性报告其当前的信任级别，由公共语言运行时 (CLR) 处的字段的透明度级别。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">下表中显示的这些属性的组合：</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">安全级别</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">严重</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>Safe critical</source>
          <target state="translated">可靠关键</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">透明</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">使用这些属性是比检查程序集及其类型和成员的安全批注、 检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">对于部分信任程序集，此属性的值取决于程序集的当前信任级别。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">如果程序集加载到部分受信任的应用程序域中 （例如，到沙盒应用程序域中），运行时将忽略程序集的安全批注。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">程序集和其所有类型被视为透明。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">运行时才会注意到部分信任程序集的安全批注仅当该程序集加载到完全信任的应用程序域中 （例如，到桌面应用程序的默认应用程序域）。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">与此相反，受信任的程序集 （即，具有强名称程序集安装在全局程序集缓存），是始终以而不考虑应用程序域的信任级别的完全信任方式加载，因此其当前的信任级别始终是完全受信任。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">你可以使用来确定程序集和应用程序域的当前信任级别<ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">有关反射和透明度的详细信息，请参阅<bpt id="p1">[</bpt>反射的安全注意事项<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">透明度有关的信息，请参阅<bpt id="p1">[</bpt>安全更改<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current field is security-safe-critical at the current trust level.</source>
          <target state="translated">获取一个值，该值指示当前字段在当前信任级别上是否是安全可靠关键的。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current field is security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated">如果当前字段在当前信任级别上是安全可靠关键的，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；如果它是安全关键的或透明的，则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the field at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsSecurityCritical%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A&gt;</ph>属性报告其当前的信任级别，由公共语言运行时 (CLR) 处的字段的透明度级别。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">下表中显示的这些属性的组合：</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">安全级别</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">严重</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>Safe critical</source>
          <target state="translated">可靠关键</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">透明</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">使用这些属性是比检查程序集及其类型和成员的安全批注、 检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">对于部分信任程序集，此属性的值取决于程序集的当前信任级别。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">如果程序集加载到部分受信任的应用程序域中 （例如，到沙盒应用程序域中），运行时将忽略程序集的安全批注。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">程序集和其所有类型被视为透明。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">运行时才会注意到部分信任程序集的安全批注仅当该程序集加载到完全信任的应用程序域中 （例如，到桌面应用程序的默认应用程序域）。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">与此相反，受信任的程序集 （即，具有强名称程序集安装在全局程序集缓存），是始终以而不考虑应用程序域的信任级别的完全信任方式加载，因此其当前的信任级别始终是完全受信任。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">你可以使用来确定程序集和应用程序域的当前信任级别<ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">有关反射和透明度的详细信息，请参阅<bpt id="p1">[</bpt>反射的安全注意事项<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">透明度有关的信息，请参阅<bpt id="p1">[</bpt>安全更改<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current field is transparent at the current trust level.</source>
          <target state="translated">获取一个值，该值指示当前字段在当前信任级别上是否是透明的。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the field is security-transparent at the current trust level; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果该字段在当前信任级别上是安全透明的，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the field at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldInfo.IsSecurityCritical%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A&gt;</ph>属性报告其当前的信任级别，由公共语言运行时 (CLR) 处的字段的透明度级别。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">下表中显示的这些属性的组合：</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>Security level</source>
          <target state="translated">安全级别</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">严重</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>Safe critical</source>
          <target state="translated">可靠关键</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">透明</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">使用这些属性是比检查程序集及其类型和成员的安全批注、 检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">对于部分信任程序集，此属性的值取决于程序集的当前信任级别。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">如果程序集加载到部分受信任的应用程序域中 （例如，到沙盒应用程序域中），运行时将忽略程序集的安全批注。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">程序集和其所有类型被视为透明。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">运行时才会注意到部分信任程序集的安全批注仅当该程序集加载到完全信任的应用程序域中 （例如，到桌面应用程序的默认应用程序域）。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">与此相反，受信任的程序集 （即，具有强名称程序集安装在全局程序集缓存），是始终以而不考虑应用程序域的信任级别的完全信任方式加载，因此其当前的信任级别始终是完全受信任。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">你可以使用来确定程序集和应用程序域的当前信任级别<ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">有关反射和透明度的详细信息，请参阅<bpt id="p1">[</bpt>反射的安全注意事项<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">透明度有关的信息，请参阅<bpt id="p1">[</bpt>安全更改<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.IsSpecialName">
          <source>Gets a value indicating whether the corresponding <ph id="ph1">&lt;see langword="SpecialName" /&gt;</ph> attribute is set in the <ph id="ph2">&lt;see cref="T:System.Reflection.FieldAttributes" /&gt;</ph> enumerator.</source>
          <target state="translated">获取一个值，该值指示是否已在 <ph id="ph2">&lt;see cref="T:System.Reflection.FieldAttributes" /&gt;</ph> 枚举数中设置相应的 <ph id="ph1">&lt;see langword="SpecialName" /&gt;</ph> 特性。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSpecialName">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see langword="SpecialName" /&gt;</ph> attribute is set in <ph id="ph3">&lt;see cref="T:System.Reflection.FieldAttributes" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果在 <ph id="ph3">&lt;see cref="T:System.Reflection.FieldAttributes" /&gt;</ph> 中设置了 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 特性，则为 <ph id="ph2">&lt;see langword="SpecialName" /&gt;</ph>；否则为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSpecialName">
          <source>Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of names that might require special treatment by some compilers.</source>
          <target state="translated">可能需要特殊处理的某些编译器的名称的示例的开头或包含下划线字符 (_)、 属性访问器和运算符重载方法的名称。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsSpecialName">
          <source>The following example returns a value indicating whether or not the fields in the class contain a SpecialName attribute.</source>
          <target state="translated">下面的示例返回一个值，该值指示在类中的字段包含 SpecialName 属性。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.IsStatic">
          <source>Gets a value indicating whether the field is static.</source>
          <target state="translated">获取一个值，通过该值指示此字段是否为静态字段。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsStatic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this field is static; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此字段为静态字段，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsStatic">
          <source>When a field is static, one copy of the field is shared by all instances of the type.</source>
          <target state="translated">静态字段时，由类型的所有实例共享的字段的一个副本。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsStatic">
          <source>The <ph id="ph1">`IsStatic`</ph> property is set when the <ph id="ph2">`FieldAttributes.Static`</ph> attribute is set.</source>
          <target state="translated"><ph id="ph1">`IsStatic`</ph>时设置属性<ph id="ph2">`FieldAttributes.Static`</ph>属性设置。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsStatic">
          <source>To get the <ph id="ph1">`IsStatic`</ph> property, first get the class <ph id="ph2">`Type`</ph>.</source>
          <target state="translated">若要获取<ph id="ph1">`IsStatic`</ph>属性，首先需要获取类<ph id="ph2">`Type`</ph>。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsStatic">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`FieldInfo`</ph>.</source>
          <target state="translated">从<ph id="ph1">`Type`</ph>，获取<ph id="ph2">`FieldInfo`</ph>。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsStatic">
          <source>From the <ph id="ph1">`FieldInfo`</ph>, get the <ph id="ph2">`IsStatic`</ph> property.</source>
          <target state="translated">从<ph id="ph1">`FieldInfo`</ph>，获取<ph id="ph2">`IsStatic`</ph>属性。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsStatic">
          <source>To access a non-public field, set the <ph id="ph1">`BindingFlags`</ph> to <ph id="ph2">`NonPublic`</ph> in the <ph id="ph3">`GetField`</ph> method and set the accessibility to <ph id="ph4">`Instance`</ph> or <ph id="ph5">`Static`</ph>.</source>
          <target state="translated">若要访问非公共字段，设置<ph id="ph1">`BindingFlags`</ph>到<ph id="ph2">`NonPublic`</ph>中<ph id="ph3">`GetField`</ph>方法和设置可访问性为<ph id="ph4">`Instance`</ph>或<ph id="ph5">`Static`</ph>。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsStatic">
          <source>The following example determines whether the specified field is static and displays the result.</source>
          <target state="translated">下面的示例确定指定的字段是否为静态，并显示结果。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsStatic">
          <source>This code produces the following output:</source>
          <target state="translated">此代码生成以下输出：</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsStatic">
          <source>Reflection.FieldInfo</source>
          <target state="translated">Reflection.FieldInfo</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsStatic">
          <source>Myfielda - A private field; IsStatic - False</source>
          <target state="translated">Myfielda-私有字段;IsStatic-False</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.IsStatic">
          <source>Myfieldb - B static field; IsStatic - True</source>
          <target state="translated">Myfieldb - B static field; IsStatic - True</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="P:System.Reflection.FieldInfo.MemberType">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a field.</source>
          <target state="translated">获取 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> 值，该值指示此成员是字段。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.MemberType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a field.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> 值指示此成员是字段。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.MemberType">
          <source>This property overrides <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph>.</source>
          <target state="translated">此属性将替代<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.MemberType">
          <source>Therefore, when you examine a set of <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects — for example, the array returned by <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph> — the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> property returns <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.Field?displayProperty=nameWithType&gt;</ph> only when a given member is a field.</source>
          <target state="translated">因此，当检查一组<ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph>对象-例如，返回的数组<ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph>-<ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph>属性返回<ph id="ph4">&lt;xref:System.Reflection.MemberTypes.Field?displayProperty=nameWithType&gt;</ph>仅当给定的成员是一个字段。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.MemberType">
          <source>The following example determines whether the specified member is a field and displays the result.</source>
          <target state="translated">下面的示例确定指定的成员是否是一个字段，并显示结果。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.MemberType">
          <source>This code produces the following output:</source>
          <target state="translated">此代码生成以下输出：</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.MemberType">
          <source>Reflection.FieldInfo</source>
          <target state="translated">Reflection.FieldInfo</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.FieldInfo.MemberType">
          <source>Myfield.field - a private field; MemberType is a Field</source>
          <target state="translated">Myfield.field-私有字段;MemberType 是字段</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.op_Equality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)">
          <source>The first object to compare.</source>
          <target state="translated">要比较的第一个对象。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.op_Equality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)">
          <source>The second object to compare.</source>
          <target state="translated">要比较的第二个对象。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.op_Equality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects are equal.</source>
          <target state="translated">指示两个 <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> 对象是否相等。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.op_Equality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 等于 <ph id="ph2">&lt;paramref name="left" /&gt;</ph>，则为 <ph id="ph3">&lt;paramref name="right" /&gt;</ph>；否则为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.op_Inequality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)">
          <source>The first object to compare.</source>
          <target state="translated">要比较的第一个对象。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.op_Inequality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)">
          <source>The second object to compare.</source>
          <target state="translated">要比较的第二个对象。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.op_Inequality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects are not equal.</source>
          <target state="translated">指示两个 <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> 对象是否不相等。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.op_Inequality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 不等于 <ph id="ph2">&lt;paramref name="left" /&gt;</ph>，则为 <ph id="ph3">&lt;paramref name="right" /&gt;</ph>；否则为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="T:System.Reflection.FieldInfo">
          <source>Sets the value of the field for the given object to the given value.</source>
          <target state="translated">将给定对象的字段值设置为给定值。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>The object whose field value will be set.</source>
          <target state="translated">将设置其字段值的对象。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>The value to assign to the field.</source>
          <target state="translated">要分配给字段的值。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>Sets the value of the field supported by the given object.</source>
          <target state="translated">设置给定对象支持的字段的值。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>This method will assign <ph id="ph1">`value`</ph> to the field reflected by this instance on object <ph id="ph2">`obj`</ph>.</source>
          <target state="translated">此方法会将分配<ph id="ph1">`value`</ph>到此实例反映对象上的字段<ph id="ph2">`obj`</ph>。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>If the field is static, <ph id="ph1">`obj`</ph> will be ignored.</source>
          <target state="translated">如果此字段为静态，<ph id="ph1">`obj`</ph>将被忽略。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>For non-static fields, <ph id="ph1">`obj`</ph> should be an instance of a class that inherits or declares the field.</source>
          <target state="translated">对于非静态字段，<ph id="ph1">`obj`</ph>应是继承或声明该字段的类的实例。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>The new value is passed as an <ph id="ph1">`Object`</ph>.</source>
          <target state="translated">新值将传递作为<ph id="ph1">`Object`</ph>。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>For example, if the field's type is Boolean, an instance of <ph id="ph1">`Object`</ph> with the appropriate Boolean value is passed.</source>
          <target state="translated">例如，如果字段的类型为布尔值，实例<ph id="ph1">`Object`</ph>带有相应 Boolean 值被传递。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>Before setting the value, <ph id="ph1">`SetValue`</ph> checks to see if the user has access permission.</source>
          <target state="translated">在设置值前,<ph id="ph1">`SetValue`</ph>检查以确定用户是否有访问权限。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>This final method is a convenience method for calling the following <ph id="ph1">`SetValue`</ph> method.</source>
          <target state="translated">此最终的方法是调用以下的便捷方法<ph id="ph1">`SetValue`</ph>方法。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>Fully trusted code has the permissions that are needed to access and invoke private constructors, methods, fields, and properties using reflection.</source>
          <target state="translated">完全受信任的代码具有访问并调用的私有构造函数、 方法、 字段和属性使用反射所需的权限。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，此方法可以用于访问非公共成员，如果调用方已被授予<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>与<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>标志，并且如果非公共成员的授予集限制为调用方的授予集或子集其中。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(请参阅<bpt id="p1">[</bpt>反射的安全注意事项<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用此功能，应用程序应为 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 或更高版本。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>The following example sets the value of a field, gets and displays the value, modifies the field, and displays the result.</source>
          <target state="translated">下面的示例设置字段的值、 获取和显示的值、 修改字段，并显示结果。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.MemberAccessException" /&gt;</ph>, instead.</source>
          <target state="translated">在<bpt id="p1">[</bpt>适用于 Windows 应用商店应用的 .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> 或<bpt id="p2">[</bpt>可移植类库<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>中，改为捕获基类异常 <ph id="ph1">&lt;see cref="T:System.MemberAccessException" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>The caller does not have permission to access this field.</source>
          <target state="translated">调用方没有权限来访问此字段。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> instead.</source>
          <target state="translated">在<bpt id="p1">[</bpt>适用于 Windows 应用商店应用的 .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> 或<bpt id="p2">[</bpt>可移植类库<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>中，改为捕获 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and the field is an instance field.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 参数是 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 且该字段为实例字段。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>The field does not exist on the object.</source>
          <target state="translated">对象上不存在该字段。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter cannot be converted and stored in the field.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 参数不能转换且不能存储在字段中。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>for updating init-only fields.</source>
          <target state="translated">用于更新仅初始化的字段。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>The object whose field value will be set.</source>
          <target state="translated">将设置其字段值的对象。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>The value to assign to the field.</source>
          <target state="translated">要分配给字段的值。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>A field of <ph id="ph1">&lt;see langword="Binder" /&gt;</ph> that specifies the type of binding that is desired (for example, <ph id="ph2">&lt;see langword="Binder.CreateInstance" /&gt;</ph> or <ph id="ph3">&lt;see langword="Binder.ExactBinding" /&gt;</ph>).</source>
          <target state="translated">指定所需的绑定类型（例如，<ph id="ph2">&lt;see langword="Binder.CreateInstance" /&gt;</ph> 或 <ph id="ph3">&lt;see langword="Binder.ExactBinding" /&gt;</ph>）的 <ph id="ph1">&lt;see langword="Binder" /&gt;</ph> 的字段。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>A set of properties that enables the binding, coercion of argument types, and invocation of members through reflection.</source>
          <target state="translated">启用绑定、 强制自变量类型和成员通过反射调用的属性集。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, then <ph id="ph2">&lt;see langword="Binder.DefaultBinding" /&gt;</ph> is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用 <ph id="ph2">&lt;see langword="Binder.DefaultBinding" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>The software preferences of a particular culture.</source>
          <target state="translated">特定区域性的软件首选项。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>When overridden in a derived class, sets the value of the field supported by the given object.</source>
          <target state="translated">在派生类中被重写时，设置给定对象支持的字段的值。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>This method will assign <ph id="ph1">`value`</ph> to the field reflected by this instance on <ph id="ph2">`obj`</ph>.</source>
          <target state="translated">此方法会将分配<ph id="ph1">`value`</ph>到此实例反映的字段<ph id="ph2">`obj`</ph>。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>If the field is static, <ph id="ph1">`obj`</ph> will be ignored.</source>
          <target state="translated">如果此字段为静态，<ph id="ph1">`obj`</ph>将被忽略。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>For non-static fields, <ph id="ph1">`obj`</ph> should be an instance of a class that inherits or declares the field.</source>
          <target state="translated">对于非静态字段，<ph id="ph1">`obj`</ph>应是继承或声明该字段的类的实例。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>The new value is passed as an <ph id="ph1">`Object`</ph>.</source>
          <target state="translated">新值将传递作为<ph id="ph1">`Object`</ph>。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>For example, if the field's type is <ph id="ph1">`Boolean`</ph>, an instance of <ph id="ph2">`Object`</ph> with the appropriate Boolean value is passed.</source>
          <target state="translated">例如，如果字段的类型为<ph id="ph1">`Boolean`</ph>，实例<ph id="ph2">`Object`</ph>带有相应 Boolean 值被传递。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>Before setting the value, <ph id="ph1">`SetValue`</ph> checks to see if the user has access permission.</source>
          <target state="translated">在设置值前,<ph id="ph1">`SetValue`</ph>检查以确定用户是否有访问权限。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>Fully trusted code has the permissions that are needed to access and invoke private constructors, methods, fields, and properties using reflection.</source>
          <target state="translated">完全受信任的代码具有访问并调用的私有构造函数、 方法、 字段和属性使用反射所需的权限。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，此方法可以用于访问非公共成员，如果调用方已被授予<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>与<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>标志，并且如果非公共成员的授予集限制为调用方的授予集或子集其中。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(请参阅<bpt id="p1">[</bpt>反射的安全注意事项<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用此功能，应用程序应为 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 或更高版本。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>The caller does not have permission to access this field.</source>
          <target state="translated">调用方没有权限来访问此字段。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and the field is an instance field.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 参数是 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 且该字段为实例字段。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>The field does not exist on the object.</source>
          <target state="translated">对象上不存在该字段。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter cannot be converted and stored in the field.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> 参数不能转换且不能存储在字段中。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>for updating init-only fields.</source>
          <target state="translated">用于更新仅初始化的字段。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValueDirect(System.TypedReference,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph> structure that encapsulates a managed pointer to a location and a runtime representation of the type that can be stored at that location.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph> 结构，该结构封装指向某位置的托管指针以及该位置可存储的类型的运行时表示形式。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValueDirect(System.TypedReference,System.Object)">
          <source>The value to assign to the field.</source>
          <target state="translated">要分配给字段的值。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValueDirect(System.TypedReference,System.Object)">
          <source>Sets the value of the field supported by the given object.</source>
          <target state="translated">设置给定对象支持的字段的值。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValueDirect(System.TypedReference,System.Object)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，此方法可以用于访问非公共成员，如果调用方已被授予<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>与<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>标志，并且如果非公共成员的授予集限制为调用方的授予集或子集其中。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValueDirect(System.TypedReference,System.Object)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(请参阅<bpt id="p1">[</bpt>反射的安全注意事项<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValueDirect(System.TypedReference,System.Object)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用此功能，应用程序应为 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 或更高版本。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.SetValueDirect(System.TypedReference,System.Object)">
          <source>The caller requires the Common Language Specification (CLS) alternative, but called this method instead.</source>
          <target state="translated">调用方需要公共语言规范 (CLS) 的替代项，但改为调用此方法。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValueDirect(System.TypedReference,System.Object)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.SetValueDirect(System.TypedReference,System.Object)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">留待将来使用。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">必须为 IID_NULL。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">要映射的名称的传入数组。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">要映射的名称的计数。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">要在其中解释名称的区域设置上下文。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">调用方分配的数组，用于接收与名称对应的 ID。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">将一组名称映射为对应的一组调度标识符。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::GetIDsOfNames`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetType">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the <ph id="ph2">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> type.</source>
          <target state="translated">获取表示 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 类型的 <ph id="ph2">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the <ph id="ph2">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> type.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象，表示 <ph id="ph2">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> 类型。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">要返回的类型信息。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">类型信息的区域设置标识符。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">接收一个指针，指向请求的类型信息对象。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::GetTypeInfo`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">指向一个位置，该位置接收对象提供的类型信息接口的数量。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">检索对象提供的类型信息接口的数量（0 或 1）。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">标识成员。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">留待将来使用。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">必须为 IID_NULL。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">要在其中解释参数的区域设置上下文。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">描述调用的上下文的标志。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">指向一个结构的指针，该结构包含一个自变量数组、一个命名自变量的 DISPID 自变量数组和数组中元素数的计数。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">指向要存储结果的位置的指针。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">指向一个包含异常信息的结构的指针。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">第一个出错自变量的索引。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">提供对某一对象公开的属性和方法的访问。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::Invoke`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>