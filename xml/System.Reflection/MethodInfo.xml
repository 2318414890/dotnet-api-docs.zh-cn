<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MethodInfo.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-567ae5a" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3cf4df88-236b-4f49-aebe-6184303eadc31db341516e40895b598e4179337fa6c67cfc445c.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1db341516e40895b598e4179337fa6c67cfc445c</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1465f1a9bce3970cd9e95769eaa641b92a0a22d5</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/18/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodInfo">
          <source>Discovers the attributes of a method and provides access to method metadata.</source>
          <target state="translated">发现方法的属性并提供对方法元数据的访问。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class represents a method of a type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>类表示类型的方法。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can use a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object to obtain information about the method that the object represents and to invoke the method.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>获得有关该对象表示的方法的信息以及用于调用方法的对象。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>For example:</source>
          <target state="translated">例如:</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can determine the method's visibility by retrieving the values of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsPrivate%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> properties.</source>
          <target state="translated">你可以通过检索的值确定该方法的可见性<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsPrivate%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can discover what attributes are applied to the method by retrieving the value of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Attributes%2A&gt;</ph> property or calling the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A&gt;</ph> method.</source>
          <target state="translated">你可以发现哪些特性应用到该方法通过检索的值的<ph id="ph1">&lt;xref:System.Reflection.MethodBase.Attributes%2A&gt;</ph>属性或调用<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can determine whether the method is a generic method, an open constructed generic method, or a closed constructed generic method, by retrieving the values of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> properties.</source>
          <target state="translated">你可以确定是否该方法是泛型方法，打开构造泛型方法，或关闭通过检索值的构造泛型方法，<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can get information about the method's parameters and return type from the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.ReturnParameter%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> properties.</source>
          <target state="translated">你可以获取有关方法的参数的信息，并返回类型从<ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph>方法和<ph id="ph2">&lt;xref:System.Reflection.MethodInfo.ReturnParameter%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can execute a method on a class instance by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">你可以对类实例执行方法，通过调用<ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a constructed generic method from one that represents a generic method definition by calling the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method.</source>
          <target state="translated">可以实例化<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象，表示来自一个表示通过调用泛型方法定义构造的泛型方法<ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> instances by calling the <ph id="ph2">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Type.GetMethod%2A?displayProperty=nameWithType&gt;</ph> method, or by calling the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method of a <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition.</source>
          <target state="translated">可以实例化<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>实例通过调用<ph id="ph2">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph>或<ph id="ph3">&lt;xref:System.Type.GetMethod%2A?displayProperty=nameWithType&gt;</ph>方法，或通过调用<ph id="ph4">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph>方法<ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph>表示泛型方法定义的对象。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">有关特定于泛型方法的术语的固定条件的列表，请参阅<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">使用泛型反射中的其他术语的固定条件列表，请参阅<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>for full trust for inheritors.</source>
          <target state="translated">对继承者的完全信任。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">此类不能由部分受信任的代码继承。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>This type is thread safe.</source>
          <target state="translated">此类型是线程安全的。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>When you inherit from <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, you must override <ph id="ph2">&lt;see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" /&gt;</ph>, <ph id="ph3">&lt;see cref="P:System.Reflection.MethodInfo.ReturnType" /&gt;</ph>, <ph id="ph4">&lt;see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" /&gt;</ph>, <ph id="ph5">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph6">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph9">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph11">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph12">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph13">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph14">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph>, <ph id="ph15">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, and <ph id="ph16">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</source>
          <target state="translated">继承自<ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>，必须重写<ph id="ph2">&lt;see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" /&gt;</ph>， <ph id="ph3">&lt;see cref="P:System.Reflection.MethodInfo.ReturnType" /&gt;</ph>， <ph id="ph4">&lt;see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" /&gt;</ph>， <ph id="ph5">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>， <ph id="ph6">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>， <ph id="ph7">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>， <ph id="ph8">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>， <ph id="ph9">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>， <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>， <ph id="ph11">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>， <ph id="ph12">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>， <ph id="ph13">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>， <ph id="ph14">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph>， <ph id="ph15">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>，和<ph id="ph16">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodInfo">
          <source>Creates a delegate from this method.</source>
          <target state="translated">从此方法创建委托。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)">
          <source>The type of the delegate to create.</source>
          <target state="translated">要创建的委托的类型。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)">
          <source>Creates a delegate of the specified type from this method.</source>
          <target state="translated">从此方法创建指定类型的委托。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)">
          <source>The delegate for this method.</source>
          <target state="translated">此方法的委托。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>The type of the delegate to create.</source>
          <target state="translated">要创建的委托的类型。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>The object targeted by the delegate.</source>
          <target state="translated">由委托将其作为目标的对象。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>Creates a delegate of the specified type with the specified target from this method.</source>
          <target state="translated">从此方法创建具有指定目标的指定类型的委托。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>The delegate for this method.</source>
          <target state="translated">此方法的委托。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.Equals(System.Object)">
          <source>An object to compare with this instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">与此实例进行比较的对象，或为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.Equals(System.Object)">
          <source>Returns a value that indicates whether this instance is equal to a specified object.</source>
          <target state="translated">返回一个值，该值指示此实例是否与指定的对象相等。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> equals the type and value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 等于此实例的类型和值，则为 <ph id="ph2">&lt;paramref name="obj" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object for the method on the direct or indirect base class in which the method represented by this instance was first declared.</source>
          <target state="translated">当在派生类中被重写时，为直接或间接的基类（用该实例表示的方法首先在此类中声明）上的方法返回 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object for the first implementation of this method.</source>
          <target state="translated">表示此方法第一个实现的 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the first definition of the specified method in the class hierarchy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph>方法返回类层次结构中的指定方法的第一个定义。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>You can determine the type on which the first definition of the method is found by retrieving the value of the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">你可以确定在其的方法的第一个定义找到通过检索的值的类型<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph>属性对返回<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method behaves as follows:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph>方法的行为，如下所示：</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents an interface implementation, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the current <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">如果当前<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象表示接口实现，<ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph>方法返回当前<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents a method that overrides a virtual definition in a base class, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the virtual definition.</source>
          <target state="translated">如果当前<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象表示的方法重写基类中的虚拟定义<ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph>方法返回<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>表示虚拟定义的对象。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents a method that is specified with the <ph id="ph2">`new`</ph> keyword in C# or the <ph id="ph3">`Shadows`</ph> keyword in Visual Basic (as in <ph id="ph4">`newslot`</ph>, as described in <bpt id="p1">[</bpt>Common Type System<ept id="p1">](~/docs/standard/base-types/common-type-system.md)</ept>), the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the current <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">如果当前<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象表示使用指定的方法<ph id="ph2">`new`</ph>C# 中的关键字或<ph id="ph3">`Shadows`</ph>在 Visual Basic 中的关键字 (如<ph id="ph4">`newslot`</ph>中所述，<bpt id="p1">[</bpt>常规类型系统<ept id="p1">](~/docs/standard/base-types/common-type-system.md)</ept>)， <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph>方法返回当前<ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents an inherited method (that is, the current method does not provide its own implementation), the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the lowest method in the class hierarchy.</source>
          <target state="translated">如果当前<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象表示继承的方法 （即，当前方法不提供其自己的实现），<ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph>方法返回<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>表示类层次结构中的最低方法的对象。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>For example, if <ph id="ph1">`Base.ToString`</ph> overrides <ph id="ph2">`Object.ToString`</ph>, and <ph id="ph3">`Derived.ToString`</ph> overrides <ph id="ph4">`Base.ToString`</ph>, calling the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method on a <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph7">`Derived.ToString`</ph> returns a <ph id="ph8">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph9">`Object.ToString`</ph>.</source>
          <target state="translated">例如，如果<ph id="ph1">`Base.ToString`</ph>重写<ph id="ph2">`Object.ToString`</ph>，和<ph id="ph3">`Derived.ToString`</ph>重写<ph id="ph4">`Base.ToString`</ph>，则调用<ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph>方法<ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象，表示<ph id="ph7">`Derived.ToString`</ph>返回<ph id="ph8">&lt;xref:System.Reflection.MethodInfo&gt;</ph>表示的对象<ph id="ph9">`Object.ToString`</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents a method that is not present in any base class, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the current <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">如果当前<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象表示的方法，在任何基类中不存在<ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph>方法返回当前<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>You can determine whether the current method overrides a method in a base class by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method.</source>
          <target state="translated">你可以确定是否当前的方法重写的基类中的一个方法通过调用<ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The following example implements an <ph id="ph1">`IsOverride`</ph> method that does this.</source>
          <target state="translated">下面的示例实现<ph id="ph1">`IsOverride`</ph>可完成此方法。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>To call the <ph id="ph1">`GetBaseDefinition`</ph> method:</source>
          <target state="translated">若要调用<ph id="ph1">`GetBaseDefinition`</ph>方法：</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the type (the class or structure) that contains the property.</source>
          <target state="translated">获取<ph id="ph1">&lt;xref:System.Type&gt;</ph>表示包含属性的类型 （类或结构） 的对象。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If you are working with an object (an instance of a type), you can call its <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method.</source>
          <target state="translated">如果你正在使用的对象 （一种类型的实例），则可以调用其<ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Otherwise, you can use the C#  operator or the Visual Basic  operator, as the example illustrates.</source>
          <target state="translated">否则为你可以使用 C# 运算符或 Visual Basic 运算符，与示例图示。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Get a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the method in which you're interested.</source>
          <target state="translated">获取<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>表示你感兴趣的方法的对象。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>You can do this by getting an array of all methods from the <ph id="ph1">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph> method and then iterating the elements in the array, or you can retrieve the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the method directly by calling the <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType&gt;</ph> method and specifying the method name.</source>
          <target state="translated">你可以通过获取数组中的所有方法执行此<ph id="ph1">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph>方法，然后循环中的数组，或者，你的元素可以检索<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>直接通过调用表示的方法的对象<ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType&gt;</ph>方法并指定方法名称。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Call the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method to get the value of the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the base method definition.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph>方法以获取的值<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>表示基方法定义的对象。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The following example demonstrates the behavior of the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例演示的行为<ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">返回 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象的数组，这些对象表示泛型方法的类型实参或泛型方法定义的类型形参。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象的数组，这些对象表示泛型方法的类型变量或泛型方法定义的类型参数。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>Returns an empty array if the current method is not a generic method.</source>
          <target state="translated">如果当前方法不是泛型方法，则返回空数组。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</source>
          <target state="translated">返回的数组的元素将泛型方法的类型参数的列表中出现的顺序。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>If the current method is a closed constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic method definition.</source>
          <target state="translated">如果当前方法是封闭式的构造的方法 (即，<ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph>属性返回<ph id="ph2">`false`</ph>)，返回的数组<ph id="ph3">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph>方法包含已分配给泛型方法的泛型类型参数的类型定义。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>If the current method is a generic method definition, the array contains the type parameters.</source>
          <target state="translated">如果当前方法是泛型方法定义，该数组包含的类型参数。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>If the current method is an open constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</source>
          <target state="translated">如果当前方法是打开的构造的方法 (即，<ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph>属性返回<ph id="ph2">`true`</ph>) 中的特定类型已分配给某些类型参数和类型的封闭泛型类型参数已分配给其他类型参数，该数组包含两个类型和类型参数。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>属性来区分它们。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>For a demonstration of this scenario, see the code example for the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">有关此方案的演示，请参阅的代码示例<ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">有关特定于泛型方法的术语的固定条件的列表，请参阅<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">使用泛型反射中的其他术语的固定条件列表，请参阅<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>The following code example shows how to get the type arguments of a generic method and display them.</source>
          <target state="translated">下面的代码示例演示如何获取泛型方法的类型自变量，并显示它们。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>This example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method.</source>
          <target state="translated">此示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>This method is not supported.</source>
          <target state="translated">不支持此方法。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object that represents a generic method definition from which the current method can be constructed.</source>
          <target state="translated">返回一个 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 对象，该对象表示可从其构造当前方法的泛型方法定义。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object representing a generic method definition from which the current method can be constructed.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 对象，表示可从其构造当前方法的泛型方法定义。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>A generic method definition is a template from which methods can be constructed.</source>
          <target state="translated">泛型方法定义是可从其构造方法的模板。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For example, from the generic method definition <ph id="ph1">`T M&lt;T&gt;(T t)`</ph> (expressed in C# syntax; <ph id="ph2">`Function M(Of T)(ByVal tVal As T) As T`</ph> in Visual Basic) you can construct and invoke the method <ph id="ph3">`int M&lt;int&gt;(int t)`</ph> (<ph id="ph4">`Function M(Of Integer)(ByVal tVal As Integer) As Integer`</ph> in Visual Basic).</source>
          <target state="translated">例如，从泛型方法定义<ph id="ph1">`T M&lt;T&gt;(T t)`</ph>（用表示 C# 语法;<ph id="ph2">`Function M(Of T)(ByVal tVal As T) As T`</ph>在 Visual Basic 中) 可以构造和调用方法<ph id="ph3">`int M&lt;int&gt;(int t)`</ph>(<ph id="ph4">`Function M(Of Integer)(ByVal tVal As Integer) As Integer`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>Given a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object representing this constructed method, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> method returns the generic method definition.</source>
          <target state="translated">给定<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象表示此构造方法，<ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph>方法返回的泛型方法定义。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>If two constructed methods are created from the same generic method definition, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> method returns the same <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object for both methods.</source>
          <target state="translated">如果在相同的泛型方法定义中，创建两个构造的方法<ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph>方法返回相同<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>这两种方法的对象。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>If you call <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> on a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that already represents a generic method definition, it returns the current <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph>上<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>已表示泛型方法定义，它将返回当前<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type.</source>
          <target state="translated">如果泛型方法定义包括声明类型的泛型参数，将有一个泛型方法定义特定于每个构造的类型。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For example, consider the following C#, Visual Basic, and C++ code:</source>
          <target state="translated">例如，考虑下面的 C#、 Visual Basic 和 c + + 代码：</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the constructed type <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> in Visual Basic), the generic method <ph id="ph3">`M`</ph> returns <ph id="ph4">`B&lt;int, S&gt;`</ph>.</source>
          <target state="translated">构造类型中<ph id="ph1">`C&lt;int&gt;`</ph>(<ph id="ph2">`C(Of Integer)`</ph>在 Visual Basic 中)，泛型方法<ph id="ph3">`M`</ph>返回<ph id="ph4">`B&lt;int, S&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the open type <ph id="ph1">`C&lt;T&gt;`</ph>, <ph id="ph2">`M`</ph> returns <ph id="ph3">`B&lt;T, S&gt;`</ph>.</source>
          <target state="translated">在开放类型<ph id="ph1">`C&lt;T&gt;`</ph>，<ph id="ph2">`M`</ph>返回<ph id="ph3">`B&lt;T, S&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In both cases, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents <ph id="ph4">`M`</ph>, so <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> can be called on both <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects.</source>
          <target state="translated">在这两种情况下，<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph>属性返回<ph id="ph2">`true`</ph>为<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>表示<ph id="ph4">`M`</ph>，因此<ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph>上都可以调用<ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the case of the constructed type, the result of calling <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> is a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that can be invoked.</source>
          <target state="translated">对于构造类型，调用<ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph>是<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>能够被调用。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the case of the open type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> returned by <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> cannot be invoked.</source>
          <target state="translated">开放类型，对于<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>返回<ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph>不能调用。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">有关特定于泛型方法的术语的固定条件的列表，请参阅<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">使用泛型反射中的其他术语的固定条件列表，请参阅<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>The following code example shows a class with a generic method and the code required to obtain a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for the method, bind the method to type arguments, and get the original generic type definition back from the bound method.</source>
          <target state="translated">下面的代码示例演示具有泛型方法和获取所需的代码的类<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对于方法，将绑定的方法类型参数，并从绑定的方法重新获得原始的泛型类型定义。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>This example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method.</source>
          <target state="translated">此示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>The current method is not a generic method.</source>
          <target state="translated">当前方法不是泛型方法。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.IsGenericMethod" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">也就是说，<ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.IsGenericMethod" /&gt;</ph> 返回 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>This method is not supported.</source>
          <target state="translated">不支持此方法。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">返回此实例的哈希代码。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">32 位有符号整数哈希代码。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>An array of types to be substituted for the type parameters of the current generic method definition.</source>
          <target state="translated">要替换当前泛型方法定义的类型参数的类型数组。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic method definition, and returns a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object representing the resulting constructed method.</source>
          <target state="translated">用类型数组的元素替代当前泛型方法定义的类型参数，并返回表示结果构造方法的 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object that represents the constructed method formed by substituting the elements of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> for the type parameters of the current generic method definition.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 对象，表示通过将当前泛型方法定义的类型参数替换为 <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> 的元素生成的构造方法。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method allows you to write code that assigns specific types to the type parameters of a generic method definition, thus creating a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a particular constructed method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph>方法允许你编写代码，将特定类型分配给类型参数的泛型方法定义，从而形成<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>表示一个特定的构造的方法的对象。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property of this <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object returns <ph id="ph3">`true`</ph>, you can use it to invoke the method or to create a delegate to invoke the method.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph>此属性<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象返回<ph id="ph3">`true`</ph>，你可以使用它来调用的方法，或若要创建的委托来调用方法。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Methods constructed with the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method can be open, that is, some of their type arguments can be type parameters of enclosing generic types.</source>
          <target state="translated">方法用来构造<ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph>方法可以是开放式，即，其类型参数的一些可以是封闭泛型类型的类型参数。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>You might use such open constructed methods when you generate dynamic assemblies.</source>
          <target state="translated">当生成动态程序集时，你可以使用此类打开的构造的方法。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>For example, consider the following C#, Visual Basic, and C++ code.</source>
          <target state="translated">例如，考虑下面的 C#、 Visual Basic 和 c + + 代码。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The method body of <ph id="ph1">`M`</ph> contains a call to method <ph id="ph2">`N`</ph>, specifying the type parameter of <ph id="ph3">`M`</ph> and the type <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">方法体<ph id="ph1">`M`</ph>包含对方法的调用<ph id="ph2">`N`</ph>，指定的类型参数<ph id="ph3">`M`</ph>和类型<ph id="ph4">&lt;xref:System.Int32&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for method <ph id="ph3">`N&lt;V,int&gt;`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph>属性返回<ph id="ph2">`false`</ph>方法<ph id="ph3">`N&lt;V,int&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, so method <ph id="ph3">`N&lt;V,int&gt;`</ph> cannot be invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph>属性返回<ph id="ph2">`true`</ph>，因此方法<ph id="ph3">`N&lt;V,int&gt;`</ph>不能调用。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">有关特定于泛型方法的术语的固定条件的列表，请参阅<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">使用泛型反射中的其他术语的固定条件列表，请参阅<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The following code example demonstrates the properties and methods of <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that support the examination of generic methods.</source>
          <target state="translated">下面的代码示例演示的属性和方法<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>支持泛型方法的检查。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The example does the following:</source>
          <target state="translated">该示例执行以下任务：</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Defines a class that has a generic method.</source>
          <target state="translated">定义具有泛型方法的类。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Creates a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents the generic method.</source>
          <target state="translated">创建<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>表示泛型方法。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Displays properties of the generic method definition.</source>
          <target state="translated">显示泛型方法定义的属性。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Assigns type arguments to the type parameters of the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, and invokes the resulting constructed generic method.</source>
          <target state="translated">将类型自变量的类型参数的<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>，并调用生成的构造泛型方法。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Displays properties of the constructed generic method.</source>
          <target state="translated">显示构造的泛型方法的属性。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Retrieves the generic method definition from the constructed method and compares it to the original definition.</source>
          <target state="translated">检索从构造方法的泛型方法定义并将它与原始定义进行比较。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> does not represent a generic method definition.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 不表示一个泛型方法定义。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">也就是说，<ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /&gt;</ph> 返回 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> 的任意元素为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The number of elements in <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is not the same as the number of type parameters of the current generic method definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> 中的元素数与当前泛型方法定义的类型参数的数目不同。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> does not satisfy the constraints specified for the corresponding type parameter of the current generic method definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> 的元素不满足当前泛型方法定义的相应类型参数所指定的约束。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>This method is not supported.</source>
          <target state="translated">不支持此方法。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a method.</source>
          <target state="translated">获取一个 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> 值，该值指示此成员是方法。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a method.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> 值，指示此成员是方法。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>This property overrides <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">此属性将替代<ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>Therefore, when you examine a set of <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects — for example, the array returned by <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph> — the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> property returns <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType&gt;</ph> only when a given member is a method.</source>
          <target state="translated">因此，当检查一组<ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph>对象-例如，返回的数组<ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph>-<ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph>属性返回<ph id="ph4">&lt;xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType&gt;</ph>仅当给定的成员是一种方法。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>To get the <ph id="ph1">`MemberType`</ph> property, first get the class <ph id="ph2">`Type`</ph>.</source>
          <target state="translated">若要获取<ph id="ph1">`MemberType`</ph>属性，首先需要获取类<ph id="ph2">`Type`</ph>。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`MethodInfo`</ph>.</source>
          <target state="translated">从<ph id="ph1">`Type`</ph>，获取<ph id="ph2">`MethodInfo`</ph>。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>From the <ph id="ph1">`MethodInfo`</ph>, get the <ph id="ph2">`MemberType`</ph>.</source>
          <target state="translated">从<ph id="ph1">`MethodInfo`</ph>，获取<ph id="ph2">`MemberType`</ph>。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>The following example displays the type of the specified member.</source>
          <target state="translated">下面的示例显示了指定的成员的类型。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The first object to compare.</source>
          <target state="translated">要比较的第一个对象。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The second object to compare.</source>
          <target state="translated">要比较的第二个对象。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects are equal.</source>
          <target state="translated">指示两个 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 对象是否相等。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 等于 <ph id="ph2">&lt;paramref name="left" /&gt;</ph>，则为 <ph id="ph3">&lt;paramref name="right" /&gt;</ph>；否则为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The first object to compare.</source>
          <target state="translated">要比较的第一个对象。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The second object to compare.</source>
          <target state="translated">要比较的第二个对象。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects are not equal.</source>
          <target state="translated">指示两个 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 对象是否不相等。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 不等于 <ph id="ph2">&lt;paramref name="left" /&gt;</ph>，则为 <ph id="ph3">&lt;paramref name="right" /&gt;</ph>；否则为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</source>
          <target state="translated">获取一个 <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> 对象，该对象包含有关方法的返回类型的信息（例如返回类型是否具有自定义修饰符）。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> 对象，包含有关返回类型的信息。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>Compiler designers can use the <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> object returned by this property to discover whether custom modifiers, such as <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, have been applied to the return type.</source>
          <target state="translated">编译器设计人员可以使用<ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph>对象返回此属性来发现是否自定义修饰符，如<ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>，已应用于返回类型。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>This method is not implemented.</source>
          <target state="translated">未实现此方法。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>Gets the return type of this method.</source>
          <target state="translated">获取此方法的返回类型。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>The return type of this method.</source>
          <target state="translated">此方法的返回类型。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>To get the return type property, first get the class <ph id="ph1">`Type`</ph>.</source>
          <target state="translated">若要获取的返回类型属性，请先获取类<ph id="ph1">`Type`</ph>。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`MethodInfo`</ph>.</source>
          <target state="translated">从<ph id="ph1">`Type`</ph>，获取<ph id="ph2">`MethodInfo`</ph>。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>From the <ph id="ph1">`MethodInfo`</ph>, get the <ph id="ph2">`ReturnType`</ph>.</source>
          <target state="translated">从<ph id="ph1">`MethodInfo`</ph>，获取<ph id="ph2">`ReturnType`</ph>。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>The following example displays the return type of the specified method.</source>
          <target state="translated">下面的示例显示的指定方法的返回类型。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes">
          <source>Gets the custom attributes for the return type.</source>
          <target state="translated">获取返回类型的自定义属性。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes">
          <source>An <ph id="ph1">&lt;see langword="ICustomAttributeProvider" /&gt;</ph> object representing the custom attributes for the return type.</source>
          <target state="translated">表示返回类型自定义属性的 <ph id="ph1">&lt;see langword="ICustomAttributeProvider" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">留待将来使用。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">必须为 IID_NULL。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">要映射的名称的传入数组。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">要映射的名称的计数。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">要在其中解释名称的区域设置上下文。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array that receives the IDs corresponding to the names.</source>
          <target state="translated">调用方分配的数组，用于接收与名称对应的 ID。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">将一组名称映射为对应的一组调度标识符。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::GetIDsOfNames`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetType">
          <source>Provides access to the <ph id="ph1">&lt;see cref="M:System.Object.GetType" /&gt;</ph> method from COM.</source>
          <target state="translated">提供从 COM 对 <ph id="ph1">&lt;see cref="M:System.Object.GetType" /&gt;</ph> 方法的访问。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> type.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象，表示 <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 类型。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">要返回的类型信息。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">类型信息的区域设置标识符。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">接收一个指针，指向请求的类型信息对象。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can be used to get the type information for an interface.</source>
          <target state="translated">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::GetTypeInfo`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">指向一个位置，该位置接收对象提供的类型信息接口的数量。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">检索对象提供的类型信息接口的数量（0 或 1）。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">标识成员。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">留待将来使用。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">必须为 IID_NULL。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">要在其中解释参数的区域设置上下文。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">描述调用的上下文的标志。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">指向一个结构的指针，该结构包含一个自变量数组、一个命名自变量的 DISPID 自变量数组和数组中元素数的计数。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">指向要存储结果的位置的指针。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">指向一个包含异常信息的结构的指针。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">第一个出错自变量的索引。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">提供对某一对象公开的属性和方法的访问。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::Invoke`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>