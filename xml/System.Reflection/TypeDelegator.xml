<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TypeDelegator.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac53f1922063931e1db44dfd00544b163b8a8fb3913.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3f1922063931e1db44dfd00544b163b8a8fb3913</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.TypeDelegator">
          <source>Wraps a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object and delegates methods to that <ph id="ph2">&lt;see langword="Type" /&gt;</ph>.</source>
          <target state="translated">包装 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象并将所有方法委托给该 <ph id="ph2">&lt;see langword="Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>Derive from this type and override only those members you have to provide customization in, plus any members that are required by your program and not already implemented by <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>.</source>
          <target state="translated">从此类型派生，重写你必须提供自定义项中，这些成员加上所需的程序和由尚未实现的任意成员<ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> derives from <ph id="ph2">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> and implements most of the properties and methods of <ph id="ph3">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> 派生自<ph id="ph2">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph>并实现的大多数属性和方法的<ph id="ph3">&lt;xref:System.Type&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>For each member it implements, <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> automatically delegates to the corresponding member of an internal <ph id="ph2">&lt;xref:System.Type&gt;</ph> object, which is supplied as an argument to the constructor.</source>
          <target state="translated">每个成员实现，<ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>自动委托给内部的相应成员<ph id="ph2">&lt;xref:System.Type&gt;</ph>对象，它提供作为构造函数的自变量。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>This internal <ph id="ph1">&lt;xref:System.Type&gt;</ph> object is exposed to deriving classes by the <ph id="ph2">`protected`</ph><ph id="ph3">&lt;xref:System.Reflection.TypeDelegator.typeImpl&gt;</ph> field.</source>
          <target state="translated">此内部<ph id="ph1">&lt;xref:System.Type&gt;</ph>对象被公开到派生类<ph id="ph2">`protected`</ph><ph id="ph3">&lt;xref:System.Reflection.TypeDelegator.typeImpl&gt;</ph>字段。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>Some members of <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph> have implementations even though the members themselves are simply inherited from <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">某些成员<ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>具有实现，即使这些成员本身只是继承自<ph id="ph2">&lt;xref:System.Type&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>In these cases, the implementation is provided by an overridden <ph id="ph1">`protected`</ph> method that has a name that ends in "Impl".</source>
          <target state="translated">在这些情况下，提供了该实现通过被重写<ph id="ph1">`protected`</ph>具有以"以 Impl"结尾的名称的方法。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>For example, the implementation for all overloads of the <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.GetMethods%2A&gt;</ph> method is supplied by the overridden <ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.GetMethodImpl%2A&gt;</ph> method.</source>
          <target state="translated">例如，实现的所有重载<ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.GetMethods%2A&gt;</ph>提供方法通过重写<ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.GetMethodImpl%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>The implementation for inherited properties such as <ph id="ph1">&lt;xref:System.Type.IsPublic%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph> is provided by the overridden <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A&gt;</ph> method.</source>
          <target state="translated">实现继承属性，如<ph id="ph1">&lt;xref:System.Type.IsPublic%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph>提供通过重写<ph id="ph3">&lt;xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>Deriving classes can provide a public constructor that takes a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object as its parameter and simply passes that object to the <ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29&gt;</ph> constructor, or can set the internal <ph id="ph3">&lt;xref:System.Type&gt;</ph> object in some other way.</source>
          <target state="translated">派生类可以提供的公共构造函数的<ph id="ph1">&lt;xref:System.Type&gt;</ph>对象作为其参数并只需将该对象传递到<ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29&gt;</ph>构造函数，也可以设置内部<ph id="ph3">&lt;xref:System.Type&gt;</ph>以某种其他方式的对象。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>If a deriving class uses a member that is not implemented by <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>, it must override that member and provide an implementation.</source>
          <target state="translated">如果派生的类将使用未实现成员<ph id="ph1">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>，它必须重写该成员，并提供一个实现。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>The simplest implementation is to call the corresponding member on the internal <ph id="ph1">&lt;xref:System.Type&gt;</ph> object exposed by the <ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.typeImpl&gt;</ph> field, but you can provide any implementation your application requires.</source>
          <target state="translated">最简单的实现是在内部调用的对应成员<ph id="ph1">&lt;xref:System.Type&gt;</ph>由公开对象<ph id="ph2">&lt;xref:System.Reflection.TypeDelegator.typeImpl&gt;</ph>字段，但你可以提供你的应用程序要求任何实现。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>It is not necessary to override these members if they are not used by your application or by library functions your application calls (for example, by the <ph id="ph1">&lt;xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=nameWithType&gt;</ph> constructor).</source>
          <target state="translated">不需要重写这些成员，如果它们不由你的应用程序或库函数你应用程序的调用 (例如，通过<ph id="ph1">&lt;xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=nameWithType&gt;</ph>构造函数)。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>The following virtual methods (<ph id="ph1">`Overridable`</ph> methods in Visual Basic) of <ph id="ph2">&lt;xref:System.Type&gt;</ph> are not implemented by <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>: <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>, <ph id="ph9">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph>, <ph id="ph10">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>, <ph id="ph11">&lt;xref:System.Type.GetEnumNames%2A&gt;</ph>, <ph id="ph12">&lt;xref:System.Type.GetEnumValues%2A&gt;</ph>, <ph id="ph13">&lt;xref:System.Type.GetEnumUnderlyingType%2A&gt;</ph>, <ph id="ph14">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph>, <ph id="ph15">&lt;xref:System.Type.IsEnumDefined%2A&gt;</ph>, <ph id="ph16">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph>.</source>
          <target state="translated">以下虚拟方法 (<ph id="ph1">`Overridable`</ph>在 Visual Basic 中的方法) 的<ph id="ph2">&lt;xref:System.Type&gt;</ph>不由实现<ph id="ph3">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>: <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>， <ph id="ph5">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>， <ph id="ph6">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph>， <ph id="ph7">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph>， <ph id="ph8">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>， <ph id="ph9">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph>， <ph id="ph10">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>, <ph id="ph11">&lt;xref:System.Type.GetEnumNames%2A&gt;</ph>, <ph id="ph12">&lt;xref:System.Type.GetEnumValues%2A&gt;</ph>, <ph id="ph13">&lt;xref:System.Type.GetEnumUnderlyingType%2A&gt;</ph>, <ph id="ph14">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph>, <ph id="ph15">&lt;xref:System.Type.IsEnumDefined%2A&gt;</ph>, <ph id="ph16">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.TypeDelegator">
          <source>The following virtual properties (<ph id="ph1">`Overridable`</ph> properties in Visual Basic) of <ph id="ph2">&lt;xref:System.Type&gt;</ph> are not implemented by <ph id="ph3">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>: <ph id="ph4">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>, <ph id="ph9">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph>, <ph id="ph10">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>, <ph id="ph11">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph12">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, <ph id="ph13">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph>.</source>
          <target state="translated">以下虚拟属性 (<ph id="ph1">`Overridable`</ph>属性在 Visual Basic 中的) 的<ph id="ph2">&lt;xref:System.Type&gt;</ph>不由实现<ph id="ph3">&lt;xref:System.Reflection.TypeDelegator&gt;</ph>: <ph id="ph4">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>， <ph id="ph5">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>， <ph id="ph6">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>， <ph id="ph7">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>， <ph id="ph8">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph>， <ph id="ph9">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph>， <ph id="ph10">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph>, <ph id="ph11">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph12">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, <ph id="ph13">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="T:System.Reflection.TypeDelegator">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> class with default properties.</source>
          <target state="translated">使用默认属性初始化 <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.#ctor(System.Type)">
          <source>The instance of the class <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> that encapsulates the call to the method of an object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 类的实例，它封装对对象方法的调用。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.#ctor(System.Type)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> class specifying the encapsulating instance.</source>
          <target state="translated">在指定封装实例的情况下，初始化 <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.#ctor(System.Type)">
          <source>This constructor is called from a class to generate a delegate based upon the <ph id="ph1">`Type`</ph> object for the class defining the method.</source>
          <target state="translated">此构造函数调用从一个类来生成基于委托<ph id="ph1">`Type`</ph>为定义该方法的类的对象。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.#ctor(System.Type)">
          <source><ph id="ph1">&lt;paramref name="delegatingType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delegatingType" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.Assembly">
          <source>Gets the assembly of the implemented type.</source>
          <target state="translated">获取已实现类型的程序集。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Assembly">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> object representing the assembly of the implemented type.</source>
          <target state="translated">表示已实现类型的程序集的 <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Assembly">
          <source>Assemblies are the deployment units in the common language runtime.</source>
          <target state="translated">程序集是公共语言运行时中的部署单元。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Assembly">
          <source>Assemblies establish the namespace for resolving requests and determine which resources are exposed externally and which are accessible from within the assembly.</source>
          <target state="translated">程序集建立解析请求的命名空间，并确定哪些资源向外部公开，这是可从程序集内访问。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Assembly">
          <source>The common language runtime can determine and locate the assembly for any running object.</source>
          <target state="translated">公共语言运行时可以确定，并找到任何正在运行的对象的程序集。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.AssemblyQualifiedName">
          <source>Gets the assembly's fully qualified name.</source>
          <target state="translated">获取程序集的完全限定名。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.AssemblyQualifiedName">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing the assembly's fully qualified name.</source>
          <target state="translated">包含程序集的完全限定名的 <ph id="ph1">&lt;see langword="String" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.BaseType">
          <source>Gets the base type for the current type.</source>
          <target state="translated">获取当前类型的基类型。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.BaseType">
          <source>The base type for a type.</source>
          <target state="translated">类型的基类型。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.BaseType">
          <source>The base type is the type from which this type directly inherits.</source>
          <target state="translated">基类型是此类型直接从中继承的类型。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.BaseType">
          <source>Since the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class type is the ultimate base class of all the other types, it is the only type that does not have a base type.</source>
          <target state="translated">由于<ph id="ph1">&lt;xref:System.Object&gt;</ph>类类型是所有其他类型的最终基类，它是不具有基类型的唯一类型。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.BaseType">
          <source>In this case, <ph id="ph1">`null`</ph> is returned as the base type of the <ph id="ph2">`Object`</ph> type.</source>
          <target state="translated">在这种情况下，<ph id="ph1">`null`</ph>作为的基类型返回<ph id="ph2">`Object`</ph>类型。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.FullName">
          <source>Gets the fully qualified name of the implemented type.</source>
          <target state="translated">获取已实现类型的完全限定名。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.FullName">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing the type's fully qualified name.</source>
          <target state="translated">包含类型的完全限定名的 <ph id="ph1">&lt;see langword="String" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.FullName">
          <source>A string containing the fully qualified name of the current <ph id="ph1">`TypeDelegator`</ph>.</source>
          <target state="translated">包含当前的完全限定的名称的字符串<ph id="ph1">`TypeDelegator`</ph>。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetAttributeFlagsImpl">
          <source>Gets the attributes assigned to the <ph id="ph1">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">获取分配给 <ph id="ph1">&lt;see langword="TypeDelegator" /&gt;</ph> 的属性。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetAttributeFlagsImpl">
          <source>A <ph id="ph1">&lt;see langword="TypeAttributes" /&gt;</ph> object representing the implementation attribute flags.</source>
          <target state="translated">表示实现属性标志的 <ph id="ph1">&lt;see langword="TypeAttributes" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetAttributeFlagsImpl">
          <source>This method can be used to determine if the <ph id="ph1">`TypeDelegator`</ph> is abstract, public, and so on.</source>
          <target state="translated">此方法可以用于确定如果<ph id="ph1">`TypeDelegator`</ph>是抽象、 公共的等等。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">影响执行搜索的方式的位掩码。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">该值是零个或多个来自 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的位标志的组合。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> 对象的检索。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用默认活页夹。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling conventions.</source>
          <target state="translated">调用约定。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing a list of the parameter number, order, and types.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Type" /&gt;</ph> 类型的数组，包含参数数量、顺序和类型的列表。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Types cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>; use an appropriate <ph id="ph2">&lt;see langword="GetMethod" /&gt;</ph> method or an empty array to search for a method without parameters.</source>
          <target state="translated">类型不能为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>；使用相应的 <ph id="ph2">&lt;see langword="GetMethod" /&gt;</ph> 方法或空数组搜索不带参数的方法。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of type <ph id="ph1">&lt;see langword="ParameterModifier" /&gt;</ph> having the same length as the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array, whose elements represent the attributes associated with the parameters of the method to get.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="ParameterModifier" /&gt;</ph> 类型的数组，它与 <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> 数组的长度相同，其元素表示与要获取的方法的参数关联的属性。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Gets the constructor that implemented the <ph id="ph1">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">获取实现 <ph id="ph1">&lt;see langword="TypeDelegator" /&gt;</ph> 的构造函数。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see langword="ConstructorInfo" /&gt;</ph> object for the method that matches the specified criteria, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if a match cannot be found.</source>
          <target state="translated">此方法的匹配指定判据的 <ph id="ph1">&lt;see langword="ConstructorInfo" /&gt;</ph> 对象；如果无法找到匹配项，则为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">`callConvention`</ph> parameter indicates the calling convention for the entry point.</source>
          <target state="translated"><ph id="ph1">`callConvention`</ph>参数指示的入口点的调用约定。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If no calling convention is specified, a default <ph id="ph1">&lt;xref:System.Reflection.CallingConventions&gt;</ph> value of <ph id="ph2">`Standard`</ph> is used.</source>
          <target state="translated">如果指定不调用约定，则默认<ph id="ph1">&lt;xref:System.Reflection.CallingConventions&gt;</ph>值<ph id="ph2">`Standard`</ph>使用。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">影响执行搜索的方式的位掩码。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">该值是零个或多个来自 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的位标志的组合。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing constructors defined for the type wrapped by the current <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">返回 <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> 对象的数组，这些对象表示为当前 <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> 包装的类型定义的构造函数。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="ConstructorInfo" /&gt;</ph> containing the specified constructors defined for this class.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="ConstructorInfo" /&gt;</ph> 类型的数组，包含为此类定义的指定的构造函数。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>If no constructors are defined, an empty array is returned.</source>
          <target state="translated">如果未定义任何构造函数，则返回一个空数组。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>Depending on the value of a specified parameter, only public constructors or both public and non-public constructors will be returned.</source>
          <target state="translated">根据指定参数的值，只返回公共构造函数或同时返回公共和非公共构造函数。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)">
          <source>Class initializers are available only through <ph id="ph1">`GetMember`</ph>, <ph id="ph2">`GetMembers`</ph>, <ph id="ph3">`FindMembers`</ph>, and <ph id="ph4">`GetConstructors`</ph>.</source>
          <target state="translated">类初始值设定项是仅可通过提供<ph id="ph1">`GetMember`</ph>， <ph id="ph2">`GetMembers`</ph>， <ph id="ph3">`FindMembers`</ph>，和<ph id="ph4">`GetConstructors`</ph>。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="T:System.Reflection.TypeDelegator">
          <source>Returns all the custom attributes defined for this type.</source>
          <target state="translated">返回为此类型定义的所有自定义属性。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)">
          <source>Specifies whether to search this type's inheritance chain to find the attributes.</source>
          <target state="translated">指定是否搜索此类型的继承链以查找这些属性。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for this type, specifying whether to search the type's inheritance chain.</source>
          <target state="translated">返回为此类型定义的所有自定义属性，并指定是否搜索此类型的继承链。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)">
          <source>An array of objects containing all the custom attributes defined for this type.</source>
          <target state="translated">一个包含为此类型定义的所有自定义属性的对象数组。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)">
          <source>A custom attribute type cannot be loaded.</source>
          <target state="translated">无法加载自定义属性类型。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of custom attributes identified by type.</source>
          <target state="translated">由类型标识的自定义属性数组。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Specifies whether to search this type's inheritance chain to find the attributes.</source>
          <target state="translated">指定是否搜索此类型的继承链以查找这些属性。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns an array of custom attributes identified by type.</source>
          <target state="translated">返回由类型标识的自定义属性数组。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of objects containing the custom attributes defined in this type that match the <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> parameter, specifying whether to search the type's inheritance chain, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no custom attributes are defined on this type.</source>
          <target state="translated">一个对象数组，包含此类型中定义的与 <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> 参数匹配的自定义属性，并指定是否搜索此类型的继承链；如果在此类型上未定义自定义属性，则为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)">
          <source>A custom attribute type cannot be loaded.</source>
          <target state="translated">无法加载自定义属性类型。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetElementType">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer or ByRef.</source>
          <target state="translated">返回由当前数组、指针或 ByRef 包含或引用的对象的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetElementType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer or <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the current <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> is not an array, a pointer or a <ph id="ph5">&lt;see langword="ByRef" /&gt;</ph>.</source>
          <target state="translated">由当前数组、指针或 <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> 包含或引用的对象的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>；如果当前 <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> 不是数组、指针或 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，则为 <ph id="ph5">&lt;see langword="ByRef" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The name of the event to get.</source>
          <target state="translated">要获取的事件的名称。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">影响执行搜索的方式的位掩码。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">该值是零个或多个来自 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的位标志的组合。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Returns the specified event.</source>
          <target state="translated">返回指定事件。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the event declared or inherited by this type with the specified name.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> 对象，表示由此类型声明或继承的具有指定名称的事件。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>This method returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no such event is found.</source>
          <target state="translated">如果未找到此类事件，则此方法返回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>If <ph id="ph1">`bindingAttr`</ph> is <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.<ph id="ph3">`IgnoreCase`</ph>, the case of the <ph id="ph4">`name`</ph> parameter is ignored.</source>
          <target state="translated">如果<ph id="ph1">`bindingAttr`</ph>是<ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>。<ph id="ph3">`IgnoreCase`</ph>、 用例<ph id="ph4">`name`</ph>参数将被忽略。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="T:System.Reflection.TypeDelegator">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all the public events declared or inherited by the current <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">返回 <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> 对象的数组，这些对象表示由当前 <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> 声明或继承的所有公共事件。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all the public events declared or inherited by the current <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">返回 <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> 对象的数组，这些对象表示由当前 <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> 声明或继承的所有公共事件。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents">
          <source>Returns an array of type <ph id="ph1">&lt;see langword="EventInfo" /&gt;</ph> containing all the events declared or inherited by the current type.</source>
          <target state="translated">返回 <ph id="ph1">&lt;see langword="EventInfo" /&gt;</ph> 类型的数组，该数组包含由当前类型声明或继承的所有事件。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents">
          <source>If there are no events, an empty array is returned.</source>
          <target state="translated">如果没有事件，则返回空数组。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">影响执行搜索的方式的位掩码。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">该值是零个或多个来自 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的位标志的组合。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)">
          <source>Returns the events specified in <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph> that are declared or inherited by the current <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">返回 <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph> 中指定的由当前 <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> 声明或继承的事件。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="EventInfo" /&gt;</ph> containing the events specified in <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="EventInfo" /&gt;</ph> 类型的数组，包含 <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph> 中指定的事件。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)">
          <source>If there are no events, an empty array is returned.</source>
          <target state="translated">如果没有事件，则返回空数组。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The name of the field to find.</source>
          <target state="translated">要查找的字段的名称。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">影响执行搜索的方式的位掩码。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">该值是零个或多个来自 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的位标志的组合。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field with the specified name.</source>
          <target state="translated">返回 <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> 对象，该对象表示具有指定名称的字段。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> object representing the field declared or inherited by this <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> with the specified name.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> 对象，表示由此 <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> 声明或继承的具有指定名称的字段。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no such field is found.</source>
          <target state="translated">如果未找到这样的字段，则返回 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Use a <ph id="ph1">`bindingAttr`</ph> of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.NonPublic to return all public and nonpublic fields.</source>
          <target state="translated">使用<ph id="ph1">`bindingAttr`</ph>的<ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>。非公开返回所有的公共和非公共字段。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Use <ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of the fields, as the search is case-sensitive by default.</source>
          <target state="translated">使用<ph id="ph1">`BindingFlags.IgnoreCase`</ph>若要忽略的字段，这种情况，如搜索不区分大小写，默认情况下。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">影响执行搜索的方式的位掩码。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">该值是零个或多个来自 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的位标志的组合。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing the data fields defined for the type wrapped by the current <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">返回 <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> 对象的数组，这些对象表示为当前 <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> 包装的类型定义的数据字段。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> containing the fields declared or inherited by the current <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="FieldInfo" /&gt;</ph> 类型的数组，包含由当前 <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> 声明或继承的字段。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no matched fields.</source>
          <target state="translated">如果没有匹配的字段，则返回空数组。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.GetFields%2A&gt;</ph>方法不返回字段按特定的顺序，如按字母顺序排列或声明顺序排列。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">因为该顺序可能会变化，你的代码必须不依赖于字段的返回顺序。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)">
          <source>Use a <ph id="ph1">`bindingAttr`</ph> of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.NonPublic to return all public and nonpublic fields.</source>
          <target state="translated">使用<ph id="ph1">`bindingAttr`</ph>的<ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>。非公开返回所有的公共和非公共字段。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source>The fully qualified name of the interface implemented by the current class.</source>
          <target state="translated">由当前类实现的接口的完全限定名。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the case is to be ignored; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果忽略大小写，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source>Returns the specified interface implemented by the type wrapped by the current <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">返回由当前 <ph id="ph1">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> 包装的类型实现的指定接口。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object representing the interface implemented (directly or indirectly) by the current class with the fully qualified name matching the specified name.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Type" /&gt;</ph> 对象，表示由当前类（直接或间接）实现的具有匹配指定名称的完全限定名的接口。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source>If no interface that matches name is found, null is returned.</source>
          <target state="translated">如果未找到匹配名称的接口，则返回 null。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the interface to retrieve a mapping of.</source>
          <target state="translated">要检索其映射的接口的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)">
          <source>Returns an interface mapping for the specified interface type.</source>
          <target state="translated">返回指定接口类型的接口映射。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.InterfaceMapping" /&gt;</ph> object representing the interface mapping for <ph id="ph2">&lt;paramref name="interfaceType" /&gt;</ph>.</source>
          <target state="translated">表示 <ph id="ph2">&lt;paramref name="interfaceType" /&gt;</ph> 的接口映射的 <ph id="ph1">&lt;see cref="T:System.Reflection.InterfaceMapping" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)">
          <source>The interface map denotes how an interface is mapped into the actual methods on a class that implements that interface.</source>
          <target state="translated">接口映射表示接口到实现该接口的类上的实际方法的映射方式。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaces">
          <source>Returns all the interfaces implemented on the current class and its base classes.</source>
          <target state="translated">返回在当前类及其基类上实现的所有接口。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaces">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing all the interfaces implemented on the current class and its base classes.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Type" /&gt;</ph> 类型的数组，包含在当前类及其基类上实现的所有接口。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetInterfaces">
          <source>If none are defined, an empty array is returned.</source>
          <target state="translated">如果未定义任何内容，则返回一个空数组。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The name of the member to get.</source>
          <target state="translated">要获取的成员名称。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">影响执行搜索的方式的位掩码。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">该值是零个或多个来自 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的位标志的组合。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The type of members to get.</source>
          <target state="translated">要获取的成员类型。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Returns members (properties, methods, constructors, fields, events, and nested types) specified by the given <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="type" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="bindingAttr" /&gt;</ph>.</source>
          <target state="translated">返回由给定的 <ph id="ph1">&lt;paramref name="name" /&gt;</ph>、<ph id="ph2">&lt;paramref name="type" /&gt;</ph> 和 <ph id="ph3">&lt;paramref name="bindingAttr" /&gt;</ph> 指定的成员（属性、方法、构造函数、字段、事件和嵌套类型）。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> containing all the members of the current class and its base class meeting the specified criteria.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> 类型的数组，包含当前类及其基类的符合指定条件的所有成员。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If <ph id="ph1">`bindingAttr`</ph> is <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.NonPublic, all the members will be considered.</source>
          <target state="translated">如果<ph id="ph1">`bindingAttr`</ph>是<ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>。非公开的所有成员将被都视为。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If there are no matches, an empty array is returned.</source>
          <target state="translated">如果没有匹配项，则返回一个空数组。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">影响执行搜索的方式的位掩码。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">该值是零个或多个来自 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的位标志的组合。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>Returns members specified by <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph>.</source>
          <target state="translated">返回由 <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph> 指定的成员。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> containing all the members of the current class and its base classes that meet the <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph> filter.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> 类型的数组，包含当前类及其基类的符合 <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph> 筛选器的所有成员。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>If <ph id="ph1">`bindingAttr`</ph> is <ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>.NonPublic, all the members will be considered.</source>
          <target state="translated">如果<ph id="ph1">`bindingAttr`</ph>是<ph id="ph2">&lt;xref:System.Reflection.BindingFlags&gt;</ph>。非公开的所有成员将被都视为。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)">
          <source>If there are no matches, an empty array is returned.</source>
          <target state="translated">如果没有匹配项，则返回一个空数组。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The method name.</source>
          <target state="translated">方法名。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">影响执行搜索的方式的位掩码。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">该值是零个或多个来自 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的位标志的组合。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> 对象的检索。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用默认活页夹。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling conventions.</source>
          <target state="translated">调用约定。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing a list of the parameter number, order, and types.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Type" /&gt;</ph> 类型的数组，包含参数数量、顺序和类型的列表。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Types cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>; use an appropriate <ph id="ph2">&lt;see langword="GetMethod" /&gt;</ph> method or an empty array to search for a method without parameters.</source>
          <target state="translated">类型不能为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>；使用相应的 <ph id="ph2">&lt;see langword="GetMethod" /&gt;</ph> 方法或空数组搜索不带参数的方法。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of type <ph id="ph1">&lt;see langword="ParameterModifier" /&gt;</ph> having the same length as the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array, whose elements represent the attributes associated with the parameters of the method to get.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="ParameterModifier" /&gt;</ph> 类型的数组，它与 <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> 数组的长度相同，其元素表示与要获取的方法的参数关联的属性。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">用指定的绑定约束和指定的调用约定，搜索参数与指定的自变量类型及修饰符相匹配的指定方法。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see langword="MethodInfoInfo" /&gt;</ph> object for the implementation method that matches the specified criteria, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if a match cannot be found.</source>
          <target state="translated">匹配指定条件的实现方法的 <ph id="ph1">&lt;see langword="MethodInfoInfo" /&gt;</ph> 对象；如果无法找到匹配项，则为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">`callConvention`</ph> parameter indicates the calling convention for the entry point.</source>
          <target state="translated"><ph id="ph1">`callConvention`</ph>参数指示的入口点的调用约定。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If no <ph id="ph1">&lt;xref:System.Reflection.CallingConventions&gt;</ph> is specified, a default <ph id="ph2">`CallingConventions`</ph> value of <ph id="ph3">`Standard`</ph> is used.</source>
          <target state="translated">如果没有<ph id="ph1">&lt;xref:System.Reflection.CallingConventions&gt;</ph>指定，则默认<ph id="ph2">`CallingConventions`</ph>值<ph id="ph3">`Standard`</ph>使用。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">影响执行搜索的方式的位掩码。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">该值是零个或多个来自 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的位标志的组合。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing specified methods of the type wrapped by the current <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">返回 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 对象的数组，这些对象表示由当前 <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> 包装的类型的指定方法。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> objects representing the methods defined on this <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> 对象的数组，表示在此 <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> 上定义的方法。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The nested type's name.</source>
          <target state="translated">嵌套类型的名称。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">影响执行搜索的方式的位掩码。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">该值是零个或多个来自 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的位标志的组合。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Returns a nested type specified by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> and in <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph> that are declared or inherited by the type represented by the current <ph id="ph3">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">返回由 <ph id="ph1">&lt;paramref name="name" /&gt;</ph> 指定的嵌套类型，并且该嵌套类型是在 <ph id="ph2">&lt;paramref name="bindingAttr" /&gt;</ph> 中指定的、由当前 <ph id="ph3">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> 表示的类型来声明或继承。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object representing the nested type.</source>
          <target state="translated">表示嵌套类型的 <ph id="ph1">&lt;see langword="Type" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">影响执行搜索的方式的位掩码。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">该值是零个或多个来自 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的位标志的组合。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Returns the nested types specified in <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph> that are declared or inherited by the type wrapped by the current <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">返回嵌套类型，这些嵌套类型是在 <ph id="ph1">&lt;paramref name="bindingAttr" /&gt;</ph> 中指定的，并且由当前 <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> 包装的类型来声明或继承。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An array of type <ph id="ph1">&lt;see langword="Type" /&gt;</ph> containing the nested types.</source>
          <target state="translated">包含嵌套类型的 <ph id="ph1">&lt;see langword="Type" /&gt;</ph> 类型数组。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">影响执行搜索的方式的位掩码。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">该值是零个或多个来自 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的位标志的组合。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> objects representing properties of the type wrapped by the current <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph>.</source>
          <target state="translated">返回 <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> 对象的数组，这些对象表示由当前 <ph id="ph2">&lt;see cref="T:System.Reflection.TypeDelegator" /&gt;</ph> 包装的类型的属性。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph> objects representing properties defined on this <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph> 对象的数组，表示在此 <ph id="ph2">&lt;see langword="TypeDelegator" /&gt;</ph> 上定义的属性。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The property to get.</source>
          <target state="translated">要获取的属性。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask that affects the way in which the search is conducted.</source>
          <target state="translated">影响执行搜索的方式的位掩码。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The value is a combination of zero or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">该值是零个或多个来自 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的位标志的组合。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects via reflection.</source>
          <target state="translated">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> 对象的检索。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用默认活页夹。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">属性的返回类型。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A list of parameter types.</source>
          <target state="translated">参数类型的列表。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The list represents the number, order, and types of the parameters.</source>
          <target state="translated">此列表表示参数的数目、顺序和类型。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Types cannot be null; use an appropriate <ph id="ph1">&lt;see langword="GetMethod" /&gt;</ph> method or an empty array to search for a method without parameters.</source>
          <target state="translated">类型不能为 null；使用相应的 <ph id="ph1">&lt;see langword="GetMethod" /&gt;</ph> 方法或空数组搜索不带参数的方法。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of the same length as types with elements that represent the attributes associated with the parameters of the method to get.</source>
          <target state="translated">长度与 types 相同的数组，其元素表示与要获取的方法参数关联的属性。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">当在派生类中重写时，使用指定的绑定约束搜索其参数与指定的自变量类型和修饰符匹配的指定属性。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> object for the property that matches the specified criteria, or null if a match cannot be found.</source>
          <target state="translated">此属性的匹配指定条件的 <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> 对象；如果无法找到匹配，则为 null。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.GUID">
          <source>Gets the GUID (globally unique identifier) of the implemented type.</source>
          <target state="translated">获取已实现类型的 GUID（全局唯一标识符）。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.GUID">
          <source>A GUID.</source>
          <target state="translated">一个 GUID。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.GUID">
          <source>The GUID (globally unique identifier) is a 128-bit unique identification string used to identify a class or an interface.</source>
          <target state="translated">GUID （全局唯一标识符） 是用于标识类或接口的 128 位唯一标识字符串。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.GUID">
          <source>It is primarily useful for interoperability between the Microsoft .NET Framework and COM.</source>
          <target state="translated">它是主要适用于 Microsoft.NET Framework 和 COM 之间的互操作性</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.HasElementTypeImpl">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer or a ByRef.</source>
          <target state="translated">获取一个值，该值指示当前 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否包含或引用其他类型，即当前 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是数组、指针还是 ByRef。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.HasElementTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer or a ByRef; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是数组、指针或 ByRef，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The name of the member to invoke.</source>
          <target state="translated">要调用的成员的名称。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This may be a constructor, method, property, or field.</source>
          <target state="translated">这可能是一个构造函数、方法、属性或字段。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If an empty string ("") is passed, the default member is invoked.</source>
          <target state="translated">如果传递了空字符串 ("")，则调用默认成员。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The invocation attribute.</source>
          <target state="translated">调用属性。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This must be one of the following <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="Static" /&gt;</ph>, <ph id="ph5">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph7">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph8">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated">这必须是下列之一：<ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>、<ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>、<ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>、<ph id="ph4">&lt;see langword="Static" /&gt;</ph>、<ph id="ph5">&lt;see langword="GetField" /&gt;</ph>、<ph id="ph6">&lt;see langword="SetField" /&gt;</ph>、<ph id="ph7">&lt;see langword="GetProperty" /&gt;</ph> 或 <ph id="ph8">&lt;see langword="SetProperty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A suitable invocation attribute must be specified.</source>
          <target state="translated">必须指定合适的调用属性。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If a static member is to be invoked, the <ph id="ph1">&lt;see langword="Static" /&gt;</ph> flag must be set.</source>
          <target state="translated">如果要调用静态成员，则必须设置 <ph id="ph1">&lt;see langword="Static" /&gt;</ph> 标志。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects via reflection.</source>
          <target state="translated">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> 对象的检索。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用默认活页夹。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">请参阅 <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">对其调用指定成员的对象。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of type <ph id="ph1">&lt;see langword="Object" /&gt;</ph> that contains the number, order, and type of the parameters of the member to be invoked.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Object" /&gt;</ph> 类型的数组，包含要调用的成员参数的数目、顺序和类型。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> contains an uninitialized <ph id="ph1">&lt;see langword="Object" /&gt;</ph>, it is treated as empty, which, with the default binder, can be widened to 0, 0.0 or a string.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 包含未初始化的 <ph id="ph1">&lt;see langword="Object" /&gt;</ph>，则它被视为空，用默认联编程序可将它扩展为 0、0.0 或一个字符串。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of type <ph id="ph1">&lt;see langword="ParameterModifer" /&gt;</ph> that is the same length as <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>, with elements that represent the attributes associated with the arguments of the member to be invoked.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="ParameterModifer" /&gt;</ph> 类型的数组，其长度与 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 相同，其元素表示与要调用的成员参数关联的属性。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A parameter has attributes associated with it in the member's signature.</source>
          <target state="translated">参数在成员的签名中有与其关联的属性。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For ByRef, use <ph id="ph1">&lt;see langword="ParameterModifer.ByRef" /&gt;</ph>, and for none, use <ph id="ph2">&lt;see langword="ParameterModifer.None" /&gt;</ph>.</source>
          <target state="translated">对于 ByRef，请使用 <ph id="ph1">&lt;see langword="ParameterModifer.ByRef" /&gt;</ph>；对于空，请使用 <ph id="ph2">&lt;see langword="ParameterModifer.None" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder does exact matching on these.</source>
          <target state="translated">默认联编程序执行与这些内容的精确匹配。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Attributes such as <ph id="ph1">&lt;see langword="In" /&gt;</ph> and <ph id="ph2">&lt;see langword="InOut" /&gt;</ph> are not used in binding, and can be viewed using <ph id="ph3">&lt;see langword="ParameterInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="In" /&gt;</ph> 和 <ph id="ph2">&lt;see langword="InOut" /&gt;</ph> 这样的属性不用于绑定，可以使用 <ph id="ph3">&lt;see langword="ParameterInfo" /&gt;</ph> 查看它们。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">用于控制类型强制的 <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> 的实例。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This is necessary, for example, to convert a string that represents 1000 to a <ph id="ph1">&lt;see langword="Double" /&gt;</ph> value, since 1000 is represented differently by different cultures.</source>
          <target state="translated">类型强制在某些情况下是必要的，例如将表示 1000 的字符串转换为 <ph id="ph1">&lt;see langword="Double" /&gt;</ph> 值，因为不同的区域性表示 1000 的方式不同。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread's <ph id="ph3">&lt;see langword="CultureInfo" /&gt;</ph> is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则将 <ph id="ph3">&lt;see langword="CultureInfo" /&gt;</ph> 用于当前线程的 <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of type <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing parameter names that match up, starting at element zero, with the <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="String" /&gt;</ph> 类型的数组，包含与 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> 数组匹配的参数名（从元素零开始）。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>There must be no holes in the array.</source>
          <target state="translated">数组中不能有空缺。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;see langword="Length" /&gt;</ph> is greater than <bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Length" /&gt;</ph> 大于 <bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;see langword="Length" /&gt;</ph>, the remaining parameters are filled in order.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Length" /&gt;</ph>，则按顺序填充剩余的参数。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Invokes the specified member.</source>
          <target state="translated">调用指定的成员。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</source>
          <target state="translated">在指定的活页夹和调用属性的约束下，要调用的方法必须为可访问，并且提供与指定的自变量列表最具体的匹配。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An <ph id="ph1">&lt;see langword="Object" /&gt;</ph> representing the return value of the invoked member.</source>
          <target state="translated">表示被调用成员的返回值的 <ph id="ph1">&lt;see langword="Object" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A method will be invoked if both the following conditions are true:</source>
          <target state="translated">如果这两个以下条件为真，则将调用一个方法：</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The number of parameters in the method declaration equals the number of arguments in the specified argument list (unless default arguments are defined on the member).</source>
          <target state="translated">（除非成员上定义了默认自变量），方法声明中的参数的数目等于在指定的参数列表中的参数的数目。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The type of each arguments can be converted by the binder to the type of the parameter.</source>
          <target state="translated">每个自变量的类型可以转换由参数的类型联编程序。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The binder will find all the matching methods.</source>
          <target state="translated">联编程序将查找所有匹配的方法。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">`BindingFlags.MethodInvoke`</ph>, <ph id="ph2">`BindingFlags.GetProperties`</ph>, and so on).</source>
          <target state="translated">这些方法找到基于请求的绑定类型 (<ph id="ph1">`BindingFlags.MethodInvoke`</ph>， <ph id="ph2">`BindingFlags.GetProperties`</ph>，依次类推)。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">按名称、 数量的参数和一组绑定器中定义的搜索修饰符进行筛选的方法集。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>After the method is selected, it will be invoked.</source>
          <target state="translated">选择方法后，将调用它。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">此时，检查可访问性。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">搜索可能基于与该方法关联的可访问性属性来控制搜索哪些方法集。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method is responsible for selecting the method to be invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph>方法负责选择要调用的方法。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">默认的联编程序选择最精确的匹配。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Access restrictions are ignored for fully trusted code.</source>
          <target state="translated">访问限制会忽略完全受信任的代码。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked using reflection whenever the code is fully trusted.</source>
          <target state="translated">即私有构造函数、 方法、 字段和属性可以访问和使用反射，只要完全受信任代码调用。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Currently, <ph id="ph1">`InvokeMember`</ph> performs the Microsoft .NET Framework reflection semantics for every type of object.</source>
          <target state="translated">目前，<ph id="ph1">`InvokeMember`</ph>对 Microsoft.NET Framework 反射语义执行，其中每种类型的对象。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the member specified by name is an array and the <ph id="ph1">`BindingFlags.GetField`</ph> flag is set on <ph id="ph2">`invokeAttr`</ph>, the <ph id="ph3">`args`</ph> array specifies the elements whose values are to be returned.</source>
          <target state="translated">如果按名称指定的成员是一个数组和<ph id="ph1">`BindingFlags.GetField`</ph>上设置标志<ph id="ph2">`invokeAttr`</ph>、<ph id="ph3">`args`</ph>数组指定其值是要返回的元素。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, the following call through <ph id="ph1">`Type`</ph> object <ph id="ph2">`t`</ph> returns the value of the first element of the string array MyArray, which is a member of the calling object:</source>
          <target state="translated">例如，以下调用通过<ph id="ph1">`Type`</ph>对象<ph id="ph2">`t`</ph>返回的字符串数组 MyArray，这是调用对象的成员的第一个元素的值：</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can use <ph id="ph1">`InvokeMember`</ph> to set one or more elements of a member array.</source>
          <target state="translated">你可以使用<ph id="ph1">`InvokeMember`</ph>设置成员数组的一个或多个元素。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>All elements are set to the same value.</source>
          <target state="translated">所有元素都设置为相同的值。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">`args`</ph> array must be formatted as follows:</source>
          <target state="translated"><ph id="ph1">`args`</ph>数组必须进行格式设置，如下所示：</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, to set the first member of MyArray from the previous example, the syntax is as follows:</source>
          <target state="translated">例如，若要设置 MyArray 的第一个成员上一示例中，语法是，如下所示：</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsArrayImpl">
          <source>Returns a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is an array.</source>
          <target state="translated">返回一个值，该值指示 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否为数组。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsArrayImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 是数组，则为 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>The type to check.</source>
          <target state="translated">要检查的类型。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>Returns a value that indicates whether the specified type can be assigned to this type.</source>
          <target state="translated">返回一个值，该值指示指定类型是否可分配给此类型。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified type can be assigned to this type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果可以将指定类型分配给此类型，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsByRefImpl">
          <source>Returns a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference.</source>
          <target state="translated">返回指示 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否由引用传递的值。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsByRefImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 按引用传递，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsCOMObjectImpl">
          <source>Returns a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object.</source>
          <target state="translated">返回一个值，该值指示 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否为 COM 对象。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsCOMObjectImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 为 COM 对象，则为 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.IsConstructedGenericType">
          <source>Gets a value that indicates whether this object represents a constructed generic type.</source>
          <target state="translated">获取指示此对象是否表示构造的泛型类型的值。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.IsConstructedGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this object represents a constructed generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此对象表示构造泛型类型，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source>Specifies whether to search this type's inheritance chain to find the attributes.</source>
          <target state="translated">指定是否搜索此类型的继承链以查找这些属性。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source>An array of custom attributes identified by type.</source>
          <target state="translated">由类型标识的自定义属性数组。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source>Indicates whether a custom attribute identified by <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is defined.</source>
          <target state="translated">指示是否定义由 <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> 标识的自定义属性。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if a custom attribute identified by <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> is defined; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果定义由 <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> 标识的自定义属性，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)">
          <source>The custom attribute type cannot be loaded.</source>
          <target state="translated">无法加载自定义特性类型。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsPointerImpl">
          <source>Returns a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer.</source>
          <target state="translated">返回一个值，该值指示 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否为指针。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsPointerImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 是指针，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsPrimitiveImpl">
          <source>Returns a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types.</source>
          <target state="translated">返回一个值，该值指示 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 是否为基元类型之一。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsPrimitiveImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 为基元类型之一，则为 <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsValueTypeImpl">
          <source>Returns a value that indicates whether the type is a value type; that is, not a class or an interface.</source>
          <target state="translated">返回一个值，该值指示此类型是否为值类型（即不是类或接口）。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Reflection.TypeDelegator.IsValueTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type is a value type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果该类型是值类型，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.MetadataToken">
          <source>Gets a value that identifies this entity in metadata.</source>
          <target state="translated">获取一个标识元数据中的此实体的值。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.MetadataToken">
          <source>A value which, in combination with the module, uniquely identifies this entity in metadata.</source>
          <target state="translated">一个值，与模块一起来唯一标识元数据中的此实体。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.MetadataToken">
          <source>The tokens obtained using this property can be passed to the unmanaged reflection API.</source>
          <target state="translated">使用此属性获取的令牌可以传递到非托管的反射 API。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.MetadataToken">
          <source>For more information, see <bpt id="p1">[</bpt>Unmanaged Reflection API<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>非托管的反射 API<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.Module">
          <source>Gets the module that contains the implemented type.</source>
          <target state="translated">获取包含已实现类型的模块。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Module">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> object representing the module of the implemented type.</source>
          <target state="translated">表示已实现类型的模块的 <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Module">
          <source>A module is a loadable unit that can contain type declarations and implementations.</source>
          <target state="translated">模块是一个可加载的单元可以包含类型声明和实现。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Module">
          <source>Modules contain enough information to enable the common language runtime to locate all implementation bits when the module is loaded.</source>
          <target state="translated">模块包含足够的信息来启用公共语言运行时在模块加载时找到所有实现位。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.Name">
          <source>Gets the name of the implemented type, with the path removed.</source>
          <target state="translated">获取移除了路径的已实现类型的名称。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Name">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing the type's non-qualified name.</source>
          <target state="translated">包含类型的非限定名的 <ph id="ph1">&lt;see langword="String" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Name">
          <source>A string containing the name of the current <ph id="ph1">`TypeDelegator`</ph>.</source>
          <target state="translated">包含当前 <ph id="ph1">`TypeDelegator`</ph> 名称的字符串。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Name">
          <source>Only the simple name, not the fully qualified name, is returned.</source>
          <target state="translated">返回只是简单名称，不是完全限定名称。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Name">
          <source>To get the name and the path, use <ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.FullName%2A&gt;</ph>.</source>
          <target state="translated">若要获取的名称和路径，请使用<ph id="ph1">&lt;xref:System.Reflection.TypeDelegator.FullName%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.Namespace">
          <source>Gets the namespace of the implemented type.</source>
          <target state="translated">获取已实现类型的命名空间。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Namespace">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> containing the type's namespace.</source>
          <target state="translated">包含类型的命名空间的 <ph id="ph1">&lt;see langword="String" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Namespace">
          <source>This property gets a string containing the namespace of the current <ph id="ph1">`TypeDelegator`</ph>.</source>
          <target state="translated">此属性获取包含当前的命名空间的字符串<ph id="ph1">`TypeDelegator`</ph>。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.Namespace">
          <source>For example, if the <ph id="ph1">`TypeDelegator`</ph> is <ph id="ph2">&lt;xref:System.Reflection.TypeFilter&gt;</ph>, the returned namespace is <ph id="ph3">&lt;xref:System.Reflection&gt;</ph>.</source>
          <target state="translated">例如，如果<ph id="ph1">`TypeDelegator`</ph>是<ph id="ph2">&lt;xref:System.Reflection.TypeFilter&gt;</ph>，返回的命名空间是<ph id="ph3">&lt;xref:System.Reflection&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.TypeHandle">
          <source>Gets a handle to the internal metadata representation of an implemented type.</source>
          <target state="translated">获取已实现类型的内部元数据表示形式的句柄。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.TypeHandle">
          <source>A <ph id="ph1">&lt;see langword="RuntimeTypeHandle" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="RuntimeTypeHandle" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.TypeHandle">
          <source>A type handle is a unique integer value associated with each type.</source>
          <target state="translated">类型句柄是与每个类型相关联的唯一整数值。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.TypeHandle">
          <source>The handle is unique during the runtime.</source>
          <target state="translated">在运行时句柄是唯一的。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="F:System.Reflection.TypeDelegator.typeImpl">
          <source>A value indicating type information.</source>
          <target state="translated">一个指示类型信息的值。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="P:System.Reflection.TypeDelegator.UnderlyingSystemType">
          <source>Gets the underlying <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> that represents the implemented type.</source>
          <target state="translated">获取表示已实现类型的基础 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.TypeDelegator.UnderlyingSystemType">
          <source>The underlying type.</source>
          <target state="translated">基础类型。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>