<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MethodBase.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac55a27c711459e7ed675df80d23d28b658e1d7b113.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5a27c711459e7ed675df80d23d28b658e1d7b113</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodBase">
          <source>Provides information about methods and constructors.</source>
          <target state="translated">提供有关方法和构造函数的信息。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source><ph id="ph1">`MethodBase`</ph> is the base class of <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`MethodBase`</ph> 是的基类的<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>和<ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>for full trust for inheritors.</source>
          <target state="translated">对继承者的完全信任。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">此类不能由部分受信任的代码继承。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>This type is thread safe.</source>
          <target state="translated">此类型是线程安全的。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>When you inherit from <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>, you must override the following members: <ph id="ph2">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph5">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph6">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph9">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph11">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph>, <ph id="ph12">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, and <ph id="ph13">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</source>
          <target state="translated">继承自<ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>，必须重写以下成员： <ph id="ph2">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>， <ph id="ph3">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>， <ph id="ph4">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>， <ph id="ph5">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>， <ph id="ph6">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>， <ph id="ph7">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>， <ph id="ph8">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>， <ph id="ph9">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>， <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>， <ph id="ph11">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph><ph id="ph12">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>，和<ph id="ph13">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.#ctor">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.#ctor">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Gets the attributes associated with this method.</source>
          <target state="translated">获取与此方法关联的属性。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>All members have a set of attributes, which are defined in relation to the specific type of member.</source>
          <target state="translated">所有成员都具有一组属性，定义相对于特定类型的成员。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, first get the type.</source>
          <target state="translated">若要获取<ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>，首先要获取类型。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>From the type, get the method.</source>
          <target state="translated">从类型，get 方法。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>From the method, get the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>.</source>
          <target state="translated">从方法获取<ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>The following code example displays the attributes of the user-defined method Mymethod.</source>
          <target state="translated">下面的代码示例显示用户定义的方法 Mymethod 的属性。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>This code produces the following output:</source>
          <target state="translated">此代码生成以下输出：</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Reflection.MethodBase.Attributes Sample</source>
          <target state="translated">Reflection.MethodBase.Attributes 示例</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)</source>
          <target state="translated">Mymethodbase = Void Mymethod (Int32，System.String ByRef System.String ByRef)</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>PrivateScope</source>
          <target state="translated">PrivateScope</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>FamANDAssem</source>
          <target state="translated">FamANDAssem</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Family</source>
          <target state="translated">系列</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Public</source>
          <target state="translated">Public</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>HideBySig</source>
          <target state="translated">HideBySig</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>ReuseSlot</source>
          <target state="translated">ReuseSlot</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Use the <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph> property to determine whether a method is <ph id="ph2">&lt;see langword="public" /&gt;</ph>, <ph id="ph3">&lt;see langword="private" /&gt;</ph>, <ph id="ph4">&lt;see langword="final" /&gt;</ph>, <ph id="ph5">&lt;see langword="virtual" /&gt;</ph>, and so on.</source>
          <target state="translated">使用<ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>属性来确定方法是否是<ph id="ph2">&lt;see langword="public" /&gt;</ph>， <ph id="ph3">&lt;see langword="private" /&gt;</ph>， <ph id="ph4">&lt;see langword="final" /&gt;</ph>， <ph id="ph5">&lt;see langword="virtual" /&gt;</ph>，依次类推。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.CallingConvention">
          <source>Gets a value indicating the calling conventions for this method.</source>
          <target state="translated">获取一个值，该值指示此方法的调用约定。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.CallingConvention">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> for this method.</source>
          <target state="translated">此方法的 <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Gets a value indicating whether the generic method contains unassigned generic type parameters.</source>
          <target state="translated">获取一个值，该值指示泛型方法是否包含未赋值的泛型类型参数。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object represents a generic method that contains unassigned generic type parameters; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果当前 <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> 对象表示的泛型方法包含未赋值的泛型类型参数，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types.</source>
          <target state="translated">仅当没有任何泛型类型定义或开放式构造的类型或任何封闭类型中的方法本身的类型自变量，则可以调用一个泛型方法。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Because types can be arbitrarily complex, making this recursive determination is difficult.</source>
          <target state="translated">类型可以是任意复杂，因为在进行此递归决定会很困难。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For convenience, and to reduce the chance of error, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</source>
          <target state="translated">为方便起见，并减少错误的可能性<ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph>属性提供一种标准的方式来区分封闭构造的方法，可以调用和开放构造方法，不能。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, the method cannot be invoked.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph>属性返回<ph id="ph2">`true`</ph>，不能调用的方法。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property searches recursively for type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph>属性类型参数的以递归方式搜索。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For example, it returns <ph id="ph1">`true`</ph> for any method in an open type <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> in Visual Basic), even though the method itself is not generic.</source>
          <target state="translated">例如，它返回<ph id="ph1">`true`</ph>开放类型中的任何方法<ph id="ph2">`A&lt;T&gt;`</ph>(<ph id="ph3">`A(Of T)`</ph>在 Visual Basic 中)，即使该方法本身不是泛型。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Contrast this with the behavior of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property, which returns <ph id="ph2">`false`</ph> for such a method.</source>
          <target state="translated">与此相反的行为<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph>属性，它返回<ph id="ph2">`false`</ph>为这样的方法。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Similarly, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property parameter returns <ph id="ph2">`true`</ph> for any constructor in an open type, even though constructors cannot have type parameters of their own.</source>
          <target state="translated">同样， <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property 参数返回<ph id="ph2">`true`</ph>开放类型中的任何构造函数，即使构造函数不能有其自己的类型参数。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">有关特定于泛型方法的术语的固定条件的列表，请参阅<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">使用泛型反射中的其他术语的固定条件列表，请参阅<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Equals(System.Object)">
          <source>An object to compare with this instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">与此实例进行比较的对象，或为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Equals(System.Object)">
          <source>Returns a value that indicates whether this instance is equal to a specified object.</source>
          <target state="translated">返回一个值，该值指示此实例是否与指定的对象相等。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> equals the type and value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 等于此实例的类型和值，则为 <ph id="ph2">&lt;paramref name="obj" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Returns a <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> object representing the currently executing method.</source>
          <target state="translated">返回表示当前的执行方法的 <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /&gt;</ph> is a static method that is called from within an executing method and that returns information about that method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /&gt;</ph> 是一个静态方法，从一个执行方法中调用，且会返回有关该方法的信息。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>A <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> object representing the currently executing method.</source>
          <target state="translated">表示当前的执行方法的 <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>If the currently executing method is defined on a generic type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that is returned by <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> is obtained from the generic type definition (that is, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph> returns <ph id="ph4">`true`</ph>).</source>
          <target state="translated">如果当前正在执行的方法定义泛型类型上<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>返回<ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph>通过泛型类型定义 (即，<ph id="ph3">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph>返回<ph id="ph4">`true`</ph>)。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Therefore, it does not reflect the type arguments that were used when the method was called.</source>
          <target state="translated">因此，它不反映时调用该方法时所使用的类型自变量。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>For example, if a method <ph id="ph1">`M()`</ph> is defined on a generic type <ph id="ph2">`C&lt;T&gt;`</ph> (<ph id="ph3">`C(Of T)`</ph> in Visual Basic), and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> is called from <ph id="ph5">`C&lt;string&gt;.M()`</ph>, then <ph id="ph6">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> returns <ph id="ph7">`C&lt;T&gt;.M()`</ph> (<ph id="ph8">`C(Of T).M()`</ph> in Visual Basic).</source>
          <target state="translated">例如，如果方法<ph id="ph1">`M()`</ph>泛型类型上定义<ph id="ph2">`C&lt;T&gt;`</ph>(<ph id="ph3">`C(Of T)`</ph>在 Visual Basic 中)，和<ph id="ph4">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph>从调用<ph id="ph5">`C&lt;string&gt;.M()`</ph>，然后<ph id="ph6">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph>返回<ph id="ph7">`C&lt;T&gt;.M()`</ph>(<ph id="ph8">`C(Of T).M()`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>If the currently executing method is a generic method, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> returns the generic method definition.</source>
          <target state="translated">如果当前正在执行的方法是泛型方法，<ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph>返回泛型方法定义。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>If the generic method is defined on a generic type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is obtained from the generic type definition.</source>
          <target state="translated">如果在泛型类型上定义的泛型方法<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>从泛型类型定义中获取。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>The following example defines two types.</source>
          <target state="translated">下面的示例定义两种类型。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>The first is a non-generic class, <ph id="ph1">`TestClass`</ph>, includes a constructor, a method named <ph id="ph2">`GetValue`</ph>, and a read-write property named <ph id="ph3">`GetValue`</ph>.</source>
          <target state="translated">第一种是一个非泛型类， <ph id="ph1">`TestClass`</ph>，包括构造函数，一个名为方法<ph id="ph2">`GetValue`</ph>，和一个名为的读写属性<ph id="ph3">`GetValue`</ph>。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>The second is a generic class named <ph id="ph1">`TestClass&lt;T&gt;`</ph> that includes a constructor, a <ph id="ph2">`GetValue`</ph> method, and a generic method, <ph id="ph3">`ConvertValue&lt;Y&gt;`</ph>.</source>
          <target state="translated">第二个是名为一个泛型类<ph id="ph1">`TestClass&lt;T&gt;`</ph>，包含一个构造函数，<ph id="ph2">`GetValue`</ph>方法和泛型方法， <ph id="ph3">`ConvertValue&lt;Y&gt;`</ph>。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Each constructor, method, and property accessor includes a call to the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> method.</source>
          <target state="translated">每个构造函数、 方法和属性访问器包括对的调用<ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>This member was invoked with a late-binding mechanism.</source>
          <target state="translated">使用晚期绑定机制调用了此成员。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">返回 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象的数组，这些对象表示泛型方法的类型实参或泛型方法定义的类型形参。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象的数组，这些对象表示泛型方法的类型变量或泛型方法定义的类型参数。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Returns an empty array if the current method is not a generic method.</source>
          <target state="translated">如果当前方法不是泛型方法，则返回空数组。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</source>
          <target state="translated">返回的数组的元素将泛型方法的类型参数的列表中出现的顺序。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>If the current method is a closed constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic method definition.</source>
          <target state="translated">如果当前方法是封闭式的构造的方法 (即，<ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph>属性返回<ph id="ph2">`false`</ph>)，返回的数组<ph id="ph3">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph>方法包含已分配给泛型方法的泛型类型参数的类型定义。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>If the current method is a generic method definition, the array contains the type parameters.</source>
          <target state="translated">如果当前方法是泛型方法定义，该数组包含的类型参数。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>If the current method is an open constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</source>
          <target state="translated">如果当前方法是打开的构造的方法 (即，<ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph>属性返回<ph id="ph2">`true`</ph>) 中的特定类型已分配给某些类型参数和类型的封闭泛型类型参数已分配给其他类型参数，该数组包含两个类型和类型参数。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>属性来区分它们。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>For a demonstration of this scenario, see the code example provided for the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">这种情况的演示，请参阅为提供的代码示例<ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Generic constructors are not supported in the .NET Framework version 2.0.</source>
          <target state="translated">.NET Framework 2.0 版不支持泛型构造函数。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>This property throws <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> if not overridden in a derived class, so an exception is thrown if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">此属性将引发<ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph>如果未在派生类中重写，因此引发异常如果当前实例的类型是<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">有关特定于泛型方法的术语的固定条件的列表，请参阅<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">使用泛型反射中的其他术语的固定条件列表，请参阅<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>The current object is a <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>.</source>
          <target state="translated">当前对象是 <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Generic constructors are not supported in the .NET Framework version 2.0.</source>
          <target state="translated">.NET Framework 2.0 版不支持泛型构造函数。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>This exception is the default behavior if this method is not overridden in a derived class.</source>
          <target state="translated">如果派生类未重写此方法，此异常即为默认行为。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">返回此实例的哈希代码。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">32 位有符号整数哈希代码。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>When overridden in a derived class, gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</source>
          <target state="translated">在派生类中重写后，获取 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> 对象，该对象提供对 MSIL 流、局部变量和当前方法的异常的访问。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> 对象，提供对 MSIL 流、局部变量和当前方法的异常的访问。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>You do not have to override the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> in order to use it.</source>
          <target state="translated">无需重写<ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph>才能使用它。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>You can call the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> method on <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects, because the method is overridden in the runtime versions of these classes.</source>
          <target state="translated">你可以调用<ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph>方法<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>和<ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>对象，因为这些类的运行时版本中重写该方法。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>For example, the runtime version of the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class derives from the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class, which in turn derives from the <ph id="ph3">&lt;xref:System.Reflection.MethodBase&gt;</ph> class.</source>
          <target state="translated">例如，运行时版本<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>类派生自<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>类，该类又派生自<ph id="ph3">&lt;xref:System.Reflection.MethodBase&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The following code example defines a test method named <ph id="ph1">`MethodBodyExample`</ph> and displays its local variable information and exception-handling clauses.</source>
          <target state="translated">下面的代码示例定义一个名为的测试方法<ph id="ph1">`MethodBodyExample`</ph>并显示其本地变量的信息和异常处理子句。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType&gt;</ph> method is used to obtain a <ph id="ph2">&lt;xref:System.Reflection.MethodBody&gt;</ph> object for the test method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType&gt;</ph>方法用于获取<ph id="ph2">&lt;xref:System.Reflection.MethodBody&gt;</ph>为测试方法的对象。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBody.LocalVariables%2A&gt;</ph> property is used to obtain a list of <ph id="ph2">&lt;xref:System.Reflection.LocalVariableInfo&gt;</ph> objects and display their types and index order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBody.LocalVariables%2A&gt;</ph>属性用于获取的列表<ph id="ph2">&lt;xref:System.Reflection.LocalVariableInfo&gt;</ph>对象并显示它们的类型和索引顺序。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A&gt;</ph> property is used to obtain a list of exception-handling clauses.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A&gt;</ph>属性用于获取异常处理子句的列表。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>Not all computer languages can generate <ph id="ph1">&lt;xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType&gt;</ph> clauses.</source>
          <target state="translated">并非所有计算机语言都可以都生成<ph id="ph1">&lt;xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType&gt;</ph>子句。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The Visual Basic example shows a filter clause, using a Visual Basic <ph id="ph1">`When`</ph> expression, which is omitted from the examples for other languages.</source>
          <target state="translated">Visual Basic 示例演示如何使用 Visual Basic 的筛选器子句<ph id="ph1">`When`</ph>表达式，从其他语言的示例中省略。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>This method is invalid unless overridden in a derived class.</source>
          <target state="translated">除非在派生类中重写，否则此方法无效。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>for the access to metadata for members.</source>
          <target state="translated">用于成员的元数据访问。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>Permission value: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">权限值： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodBase">
          <source>Gets method information using the specified handle.</source>
          <target state="translated">使用指定句柄获取方法信息。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>The method's handle.</source>
          <target state="translated">方法的句柄。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>Gets method information by using the method's internal metadata representation (handle).</source>
          <target state="translated">通过使用方法的内部元数据表示形式（句柄）获取方法信息。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>A <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> containing information about the method.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>，包含方法的有关信息。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>Handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">句柄仅在获取它们的应用程序域中是有效的。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A handle to the internal metadata representation of a constructor or method.</source>
          <target state="translated">构造函数或方法的内部元数据表示形式的句柄。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A handle to the generic type that defines the constructor or method.</source>
          <target state="translated">定义构造函数或方法的泛型类型的句柄。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object for the constructor or method represented by the specified handle, for the specified generic type.</source>
          <target state="translated">以指定泛型类型，获取指定句柄所表示的构造函数或方法的 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method or constructor specified by <ph id="ph2">&lt;paramref name="handle" /&gt;</ph>, in the generic type specified by <ph id="ph3">&lt;paramref name="declaringType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> 对象，表示由 <ph id="ph2">&lt;paramref name="handle" /&gt;</ph> 指定的方法或构造函数，为由 <ph id="ph3">&lt;paramref name="declaringType" /&gt;</ph> 指定的泛型类型。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>Handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">句柄仅在获取它们的应用程序域中是有效的。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A <ph id="ph1">&lt;xref:System.RuntimeMethodHandle&gt;</ph> structure for a constructor or method of a generic type can represent different <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> objects, depending on the types specified for the type parameters of the generic type.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.RuntimeMethodHandle&gt;</ph>构造函数或方法的泛型类型的结构可以表示不同<ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph>对象，具体取决于指定的类型参数的泛型类型的类型。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>For example, if <ph id="ph1">`class G&lt;T&gt;`</ph> (<ph id="ph2">`class G(Of T)`</ph> in Visual Basic, <ph id="ph3">`generic &lt;T&gt; ref class G`</ph> in C++) has a method that returns type <ph id="ph4">`T`</ph>, the <ph id="ph5">&lt;xref:System.Reflection.MethodBase&gt;</ph> object for that method in a constructed class such as <ph id="ph6">`G&lt;int&gt;`</ph> is different from the <ph id="ph7">&lt;xref:System.Reflection.MethodBase&gt;</ph> object for that method in the generic type definition.</source>
          <target state="translated">例如，如果<ph id="ph1">`class G&lt;T&gt;`</ph>(<ph id="ph2">`class G(Of T)`</ph>在 Visual Basic 中， <ph id="ph3">`generic &lt;T&gt; ref class G`</ph> c + + 中) 具有返回类型的方法<ph id="ph4">`T`</ph>、<ph id="ph5">&lt;xref:System.Reflection.MethodBase&gt;</ph>如对象构造类中的方法<ph id="ph6">`G&lt;int&gt;`</ph>不同于<ph id="ph7">&lt;xref:System.Reflection.MethodBase&gt;</ph>中的泛型类型定义的方法的对象。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags.</source>
          <target state="translated">在派生的类中重写时，返回 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> 标志。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>The <ph id="ph1">&lt;see langword="MethodImplAttributes" /&gt;</ph> flags.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MethodImplAttributes" /&gt;</ph> 标志。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>The following example defines a constructor in a dynamic assembly and then uses the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> method to display the method implementation flags that are set by default.</source>
          <target state="translated">下面的示例中的动态程序集定义的构造函数，然后使用<ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph>方法以显示默认设置的方法实现标志。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>When overridden in a derived class, gets the parameters of the specified method or constructor.</source>
          <target state="translated">当在派生类中重写时，获取指定的方法或构造函数的参数。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>An array of type <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> containing information that matches the signature of the method (or constructor) reflected by this <ph id="ph2">&lt;see langword="MethodBase" /&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> 类型的数组，包含与此 <ph id="ph2">&lt;see langword="MethodBase" /&gt;</ph> 实例所反射的方法（或构造函数）的签名匹配的信息。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> method to retrieve the parameters of the <ph id="ph2">`Invoke`</ph> method of a delegate.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph>方法来检索其中的参数<ph id="ph2">`Invoke`</ph>方法的委托。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>The example defines a delegate named <ph id="ph1">`MyDelegate`</ph> and an event named <ph id="ph2">`ev`</ph> of type <ph id="ph3">`MyDelegate`</ph>.</source>
          <target state="translated">该示例定义了名为的委托<ph id="ph1">`MyDelegate`</ph>以及一个名为的事件<ph id="ph2">`ev`</ph>类型的<ph id="ph3">`MyDelegate`</ph>。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>The code in the <ph id="ph1">`Main`</ph> method discovers the event signature by getting the delegate type of the event, getting the <ph id="ph2">`Invoke`</ph> method of the delegate type, and then retrieving and displaying the parameters.</source>
          <target state="translated">中的代码<ph id="ph1">`Main`</ph>方法发现通过获取该事件的委托类型的事件签名获取<ph id="ph2">`Invoke`</ph>的委托类型，然后检索并显示参数的方法。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodBase">
          <source>Invokes the method or constructor reflected by this <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> instance.</source>
          <target state="translated">调用由此 <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> 实例反射的方法或构造函数。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The object on which to invoke the method or constructor.</source>
          <target state="translated">在其上调用方法或构造函数的对象。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a method is static, this argument is ignored.</source>
          <target state="translated">如果方法是静态的，则忽略此参数。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a constructor is static, this argument must be <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an instance of the class that defines the constructor.</source>
          <target state="translated">如果构造函数是静态的，则此参数必须是 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 或定义构造函数的类的实例。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>An argument list for the invoked method or constructor.</source>
          <target state="translated">调用方法或构造函数的参数列表。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</source>
          <target state="translated">此对象数组在数量、顺序和类型方面与要调用的方法或构造函数的参数相同。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If there are no parameters, <bpt id="p1">&lt;c&gt;</bpt>parameters<ept id="p1">&lt;/c&gt;</ept> should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果不存在任何参数，则参数<bpt id="p1">&lt;c&gt;</bpt><ept id="p1">&lt;/c&gt;</ept>应为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If the method or constructor represented by this instance takes a <ph id="ph1">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function.</source>
          <target state="translated">如果由此实例表示的方法或构造函数采用了 <ph id="ph1">&lt;see langword="ref" /&gt;</ph> 参数（在 Visual Basic 中为 <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>），那么此参数不需要特殊属性来通过此函数调用此方法或构造函数。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</source>
          <target state="translated">此数组中未使用值显式初始化的任何对象都将包含该对象类型的默认值。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>For reference-type elements, this value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">对于引用类型元素，此值为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>For value-type elements, this value is 0, 0.0, or <ph id="ph1">&lt;see langword="false" /&gt;</ph>, depending on the specific element type.</source>
          <target state="translated">对于值类型元素，此值为 0、0.0 或 <ph id="ph1">&lt;see langword="false" /&gt;</ph>，具体取决于特定的元素类型。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Invokes the method or constructor represented by the current instance, using the specified parameters.</source>
          <target state="translated">使用指定参数调用由当前实例表示的方法或构造函数。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>An object containing the return value of the invoked method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> in the case of a constructor.</source>
          <target state="translated">一个包含已调用方法的返回值或包含已调用构造函数的 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 的对象。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>This is a convenience method that calls the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> method overload, passing <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Default&gt;</ph> for <ph id="ph3">`invokeAttr`</ph> and <ph id="ph4">`null`</ph> for <ph id="ph5">`binder`</ph> and <ph id="ph6">`culture`</ph>.</source>
          <target state="translated">这是调用的便捷方法<ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph>方法重载，并传入<ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Default&gt;</ph>为<ph id="ph3">`invokeAttr`</ph>和<ph id="ph4">`null`</ph>为<ph id="ph5">`binder`</ph>和<ph id="ph6">`culture`</ph>。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If the invoked method throws an exception, the <ph id="ph1">&lt;xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType&gt;</ph> method returns the exception.</source>
          <target state="translated">如果调用的方法引发异常，<ph id="ph1">&lt;xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType&gt;</ph>方法返回的异常。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>To invoke a static method using its <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object, pass <ph id="ph2">`null`</ph> for <ph id="ph3">`obj`</ph>.</source>
          <target state="translated">若要调用静态方法使用其<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象，则传递<ph id="ph2">`null`</ph>为<ph id="ph3">`obj`</ph>。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If this method overload is used to invoke an instance constructor, the object supplied for <ph id="ph1">`obj`</ph> is reinitialized; that is, all instance initializers are executed.</source>
          <target state="translated">如果此方法重载用于调用实例构造函数，为提供的对象<ph id="ph1">`obj`</ph>重新初始化; 也就是说，执行所有实例初始值设定项。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">返回值为 <ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</source>
          <target state="translated">如果调用类构造函数，则重新初始化类;也就是说，将执行所有的类初始值设定项。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">返回值为 <ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，此方法可以用于访问非公共成员，如果调用方已被授予<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>与<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>标志，并且如果非公共成员的授予集限制为调用方的授予集或子集其中。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(请参阅<bpt id="p1">[</bpt>反射的安全注意事项<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用此功能，应用程序应为 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 或更高版本。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a parameter of the current method is a value type, and the corresponding argument in <ph id="ph1">`parameters`</ph> is <ph id="ph2">`null`</ph>, the runtime passes a zero-initialized instance of the value type.</source>
          <target state="translated">如果当前方法的一个参数是值类型，并且中的对应参数<ph id="ph1">`parameters`</ph>是<ph id="ph2">`null`</ph>，运行时将传递值类型的初始化为零的实例。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The following code example demonstrates dynamic method lookup using reflection.</source>
          <target state="translated">下面的代码示例演示如何使用反射动态方法查找。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Note that you cannot use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.</source>
          <target state="translated">请注意，不能使用<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>来调用在派生类中，重写的方法，因为后期绑定无法解析重写从基类的对象。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> instead.</source>
          <target state="translated">在<bpt id="p1">[</bpt>适用于 Windows 应用商店应用的 .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> 或<bpt id="p2">[</bpt>可移植类库<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>中，改为捕获 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and the method is not static.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，且此方法不是静态方法。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The method is not declared or inherited by the class of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated">该方法不由 <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 的类声明或继承。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>A static constructor is invoked, and <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is neither <ph id="ph2">&lt;see langword="null" /&gt;</ph> nor an instance of the class that declared the constructor.</source>
          <target state="translated">调用静态构造函数，<ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 既不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，也不是声明构造函数的类的实例。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The elements of the <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> array do not match the signature of the method or constructor reflected by this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> 数组的元素与此实例反映的方法或构造函数的签名不匹配。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The invoked method or constructor throws an exception.</source>
          <target state="translated">调用的方法或构造函数引发异常。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The current instance is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph> that contains unverifiable code.</source>
          <target state="translated">当前实例是包含无法验证的代码的 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>See the "Verification" section in Remarks for <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>.</source>
          <target state="translated">请参阅“验证”部分中的 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph> 注释。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> array does not have the correct number of arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> 数组的参数数量不正确。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.MemberAccessException" /&gt;</ph>, instead.</source>
          <target state="translated">在<bpt id="p1">[</bpt>适用于 Windows 应用商店应用的 .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> 或<bpt id="p2">[</bpt>可移植类库<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>中，改为捕获基类异常 <ph id="ph1">&lt;see cref="T:System.MemberAccessException" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The caller does not have permission to execute the method or constructor that is represented by the current instance.</source>
          <target state="translated">调用方没有执行由当前实例表示的方法或构造函数的权限。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The type that declares the method is an open generic type.</source>
          <target state="translated">声明该方法的类型为开放式泛型类型。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph> for the declaring type.</source>
          <target state="translated">也就是说，<ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> 属性为声明类型返回 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The current instance is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</source>
          <target state="translated">当前实例为 <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The object on which to invoke the method or constructor.</source>
          <target state="translated">在其上调用方法或构造函数的对象。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a method is static, this argument is ignored.</source>
          <target state="translated">如果方法是静态的，则忽略此参数。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a constructor is static, this argument must be <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an instance of the class that defines the constructor.</source>
          <target state="translated">如果构造函数是静态的，则此参数必须是 <ph id="ph1">&lt;see langword="null" /&gt;</ph> 或定义构造函数的类的实例。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A bitmask that is a combination of 0 or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">位屏蔽，它是 <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 的 0 个或多个位标志的组合。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this parameter is assigned the value <ph id="ph2">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>; thus, whatever you pass in is ignored.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则此参数赋值为 <ph id="ph2">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>；因此，传入的任何值都被忽略。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects via reflection.</source>
          <target state="translated">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> 对象的检索。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用默认活页夹。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An argument list for the invoked method or constructor.</source>
          <target state="translated">调用方法或构造函数的参数列表。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</source>
          <target state="translated">此对象数组在数量、顺序和类型方面与要调用的方法或构造函数的参数相同。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If there are no parameters, this should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果没有参数，则此应为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function.</source>
          <target state="translated">如果此实例表示的方法或构造函数采用 ByRef 参数，那么使用此函数调用该方法或构造函数时，对于该参数不需要特殊的特性。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</source>
          <target state="translated">此数组中未使用值显式初始化的任何对象都将包含该对象类型的默认值。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For reference-type elements, this value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">对于引用类型元素，此值为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For value-type elements, this value is 0, 0.0, or <ph id="ph1">&lt;see langword="false" /&gt;</ph>, depending on the specific element type.</source>
          <target state="translated">对于值类型元素，此值为 0、0.0 或 <ph id="ph1">&lt;see langword="false" /&gt;</ph>，具体取决于特定的元素类型。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">用于控制类型强制的 <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> 的实例。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">如果这是 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则使用当前线程的 <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>(This is necessary to convert a <ph id="ph1">&lt;see langword="String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see langword="Double" /&gt;</ph> value, for example, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">（例如，这对于将表示 1000 的 <ph id="ph1">&lt;see langword="String" /&gt;</ph> 转换为 <ph id="ph2">&lt;see langword="Double" /&gt;</ph> 值是必需的，因为不同的区域性以不同的方式表示 1000。）</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</source>
          <target state="translated">当在派生类中重写时，调用具有给定参数的反射的方法或构造函数。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An <ph id="ph1">&lt;see langword="Object" /&gt;</ph> containing the return value of the invoked method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> in the case of a constructor, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the method's return type is <ph id="ph4">&lt;see langword="void" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Object" /&gt;</ph>，包含被调用方法的返回值；如果调用的是构造函数，则为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>；如果方法的返回类型是 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，则为 <ph id="ph4">&lt;see langword="void" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Before calling the method or constructor, <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> checks to see if the user has access permission and verifies that the parameters are valid.</source>
          <target state="translated">在调用方法或构造函数之前，<ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> 检查用户是否有访问权限并验证参数是否有效。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Dynamically invokes the method reflected by this instance on <ph id="ph1">`obj`</ph>, and passes along the specified parameters.</source>
          <target state="translated">动态调用反射的此实例的方法<ph id="ph1">`obj`</ph>，并将指定的参数传递。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method is static, the <ph id="ph1">`obj`</ph> parameter is ignored.</source>
          <target state="translated">如果该方法是静态的<ph id="ph1">`obj`</ph>参数将被忽略。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For non-static methods, <ph id="ph1">`obj`</ph> should be an instance of a class that inherits or declares the method and must be the same type as this class.</source>
          <target state="translated">对于非静态方法，<ph id="ph1">`obj`</ph>应是继承或声明方法并且必须是与此类的类型相同的类的实例。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method has no parameters, the value of <ph id="ph1">`parameters`</ph> should be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">如果该方法不具有任何参数，值<ph id="ph1">`parameters`</ph>应<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Otherwise, the number, type, and order of elements in <ph id="ph1">`parameters`</ph> should be identical to the number, type, and order of parameters for the method reflected by this instance.</source>
          <target state="translated">否则为数量、 类型和中的元素顺序<ph id="ph1">`parameters`</ph>应的数量、 类型和此实例反射的方法参数的顺序相同。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>You may not omit optional parameters in calls to <ph id="ph1">`Invoke`</ph>.</source>
          <target state="translated">你不能省略对的调用中的可选参数<ph id="ph1">`Invoke`</ph>。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>To invoke a method omitting optional parameters, you should call <ph id="ph1">`Type.InvokeMember`</ph> instead.</source>
          <target state="translated">若要调用的方法省略可选参数，应调用<ph id="ph1">`Type.InvokeMember`</ph>相反。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this method overload is used to invoke an instance constructor, the object supplied for <ph id="ph1">`obj`</ph> is reinitialized; that is, all instance initializers are executed.</source>
          <target state="translated">如果此方法重载用于调用实例构造函数，为提供的对象<ph id="ph1">`obj`</ph>重新初始化; 也就是说，执行所有实例初始值设定项。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">返回值为 <ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</source>
          <target state="translated">如果调用类构造函数，则重新初始化类;也就是说，将执行所有的类初始值设定项。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">返回值为 <ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For pass-by-value primitive parameters, normal widening is performed (Int16 -&gt; Int32, for example).</source>
          <target state="translated">对于通过值传递基元参数，执行正常的扩展 （Int16-&gt; Int32，例如)。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type).</source>
          <target state="translated">对于通过值传递引用参数，正常的引用扩展允许 （派生的类到基类，以及为接口类型的基类）。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>However, for pass-by-reference primitive parameters, the types must match exactly.</source>
          <target state="translated">但是，对于按引用传递基元参数类型必须完全匹配。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For pass-by-reference reference parameters, the normal widening still applies.</source>
          <target state="translated">对于按引用传递引用参数，正常扩展仍然适用。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if the method reflected by this instance is declared as <ph id="ph1">`public boolean Compare(String a, String b)`</ph>, then <ph id="ph2">`parameters`</ph> should be an array of <ph id="ph3">`Objects`</ph> with length 2 such that <ph id="ph4">`parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`</ph>.</source>
          <target state="translated">例如，如果由反射的方法则此实例声明为<ph id="ph1">`public boolean Compare(String a, String b)`</ph>，然后<ph id="ph2">`parameters`</ph>应是数组的<ph id="ph3">`Objects`</ph>长度为 2 以便<ph id="ph4">`parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`</ph>。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a parameter of the current method is a value type, and the corresponding argument in <ph id="ph1">`parameters`</ph> is <ph id="ph2">`null`</ph>, the runtime passes a zero-initialized instance of the value type.</source>
          <target state="translated">如果当前方法的一个参数是值类型，并且中的对应参数<ph id="ph1">`parameters`</ph>是<ph id="ph2">`null`</ph>，运行时将传递值类型的初始化为零的实例。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Reflection uses dynamic method lookup when invoking virtual methods.</source>
          <target state="translated">反射调用虚方法时使用动态方法查找。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a <ph id="ph1">`MethodInfo`</ph> object that represents M on class A. If you use the <ph id="ph2">`Invoke`</ph> method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</source>
          <target state="translated">例如，假设类 B 从类 A 继承，并且两者都实现一个名为 M 的虚拟方法。现在，假设你有<ph id="ph1">`MethodInfo`</ph>对象，表示 M 对类 a。如果你使用<ph id="ph2">`Invoke`</ph>方法来调用 M 类型 B 的对象，则反射将使用由类 b。 提供的实现即使类型 B 的对象被强制转换为一个，使用由类 B 提供的实现 （请参阅下面的代码示例）。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the <ph id="ph1">`MethodInfo`</ph> was obtained, regardless of the type of the object passed as the target.</source>
          <target state="translated">另一方面，如果方法为非虚拟的则反射将使用类型提供从其实现<ph id="ph1">`MethodInfo`</ph>已获得，无论何种传递作为目标的对象类型。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully trusted code.</source>
          <target state="translated">访问限制会忽略完全受信任的代码。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</source>
          <target state="translated">也就是说，是在私有构造函数、 方法、 字段和属性访问而完全受信任代码时，通过反射调用。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the invoked method throws an exception, <ph id="ph1">`TargetInvocationException.GetException`</ph> returns the exception.</source>
          <target state="translated">如果调用的方法引发异常，<ph id="ph1">`TargetInvocationException.GetException`</ph>返回发生的异常。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This implementation throws a <ph id="ph1">`NotSupportedException`</ph>.</source>
          <target state="translated">此实现引发<ph id="ph1">`NotSupportedException`</ph>。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>，此方法可以用于访问非公共成员，如果调用方已被授予<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>与<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph>标志，并且如果非公共成员的授予集限制为调用方的授予集或子集其中。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(请参阅<bpt id="p1">[</bpt>反射的安全注意事项<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。)</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">若要使用此功能，应用程序应为 <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 或更高版本。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The following example demonstrates all members of the <ph id="ph1">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class using an overload of <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">下面的示例演示的所有成员<ph id="ph1">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph>类使用的重载<ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The private method <ph id="ph1">`CanConvertFrom`</ph> finds compatible types for a given type.</source>
          <target state="translated">私有方法<ph id="ph1">`CanConvertFrom`</ph>对于给定的类型查找兼容的类型。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For another example of invoking members in a custom binding scenario, see <bpt id="p1">[</bpt>Dynamically Loading and Using Types<ept id="p1">](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md)</ept>.</source>
          <target state="translated">在一个自定义绑定方案中调用成员的另一个示例，请参阅<bpt id="p1">[</bpt>动态加载和使用类型<ept id="p1">](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md)</ept>。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and the method is not static.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，且此方法不是静态方法。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The method is not declared or inherited by the class of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated">该方法不由 <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 的类声明或继承。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A static constructor is invoked, and <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is neither <ph id="ph2">&lt;see langword="null" /&gt;</ph> nor an instance of the class that declared the constructor.</source>
          <target state="translated">调用静态构造函数，<ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 既不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，也不是声明构造函数的类的实例。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of the <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> parameter does not match the signature of the method or constructor reflected by this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> 参数的类型与此实例所反射的方法或构造函数的签名不匹配。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> array does not have the correct number of arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> 数组的参数数量不正确。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The invoked method or constructor throws an exception.</source>
          <target state="translated">调用的方法或构造函数引发异常。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The caller does not have permission to execute the method or constructor that is represented by the current instance.</source>
          <target state="translated">调用方没有执行由当前实例表示的方法或构造函数的权限。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The type that declares the method is an open generic type.</source>
          <target state="translated">声明该方法的类型为开放式泛型类型。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph> for the declaring type.</source>
          <target state="translated">也就是说，<ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> 属性为声明类型返回 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">调用时后期绑定通过机制如<ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>Gets a value indicating whether the method is abstract.</source>
          <target state="translated">获取一个值，该值指示此方法是否为抽象方法。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method is abstract; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果该方法是抽象的，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>An abstract member is declared on a base class and has no implementation supplied.</source>
          <target state="translated">抽象成员声明基类和已没有实现提供。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, first get the type.</source>
          <target state="translated">若要获取<ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>，首先要获取类型。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>From the type, get the method.</source>
          <target state="translated">从类型，get 方法。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>From the method, get the <ph id="ph1">`MethodBase`</ph>.</source>
          <target state="translated">从方法获取<ph id="ph1">`MethodBase`</ph>。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>If the <ph id="ph1">`MethodBase`</ph> or constructor is other than public, it is protected and cannot be readily accessed.</source>
          <target state="translated">如果<ph id="ph1">`MethodBase`</ph>或构造函数是公共以外，它受到保护，而且不能轻松访问。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>To access a non-public method, set the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> mask to <ph id="ph2">`NonPublic`</ph> in <ph id="ph3">`GetMethod`</ph>.</source>
          <target state="translated">若要访问非公共方法，将设置<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>屏蔽到<ph id="ph2">`NonPublic`</ph>中<ph id="ph3">`GetMethod`</ph>。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>The following example determines whether specified the method is abstract and displays the result.</source>
          <target state="translated">下面的示例确定是否指定方法是抽象类，并显示结果。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>Gets a value indicating whether the potential visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</source>
          <target state="translated">获取一个值，该值指示此方法或构造函数的潜在可见性是否由 <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph> 描述；也就是说，此方法或构造函数只对同一程序集中的其他类型可见，而对该程序集以外的派生类型则不可见。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the visibility of this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此方法或构造函数的可见性由 <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph> 准确描述，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The actual visibility of a method is limited by the visibility of its type.</source>
          <target state="translated">一种方法的实际可见受到其类型的可见性。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph> property might be <ph id="ph2">`true`</ph> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>属性可能<ph id="ph2">`true`</ph>对于方法，但如果它可以是私有的嵌套类型的方法，则此方法不是包含类型外可见。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType&gt;</ph> if the only visibility modifier is <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic).</source>
          <target state="translated">方法或构造函数的可见性准确描述通过<ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType&gt;</ph>唯一可见性修饰符是否<ph id="ph2">`internal`</ph>(<ph id="ph3">`Friend`</ph>在 Visual Basic 中)。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>This property is <ph id="ph1">`false`</ph> for methods that are <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++); use the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property to identify such methods.</source>
          <target state="translated">此属性是<ph id="ph1">`false`</ph>方法<ph id="ph2">`protected internal`</ph>C# 中 (<ph id="ph3">`Protected Friend`</ph>在 Visual Basic 中， <ph id="ph4">`protected public`</ph> c + + 中); 使用<ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>属性来标识此类方法。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">下面的代码示例定义的方法具有不同级别的可见性，并显示的值，其<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Visual Basic 和 C# 语言不能定义具有方法<ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph>可见性; 仅在 c + + 示例中出现访问级别。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source>Gets a value indicating whether the method is a constructor.</source>
          <target state="translated">获取一个值，该值指示此方法是否为构造函数。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is a constructor represented by a <ph id="ph2">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object (see note in Remarks about <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph> objects); otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此方法是 <ph id="ph2">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> 对象（参见"备注"中有关 <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph> 对象的说明）所表示的构造函数，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsConstructor%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for a <ph id="ph3">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object in a dynamic type, unless the <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType&gt;</ph> flag was included in the <ph id="ph5">`attributes`</ph> parameter when the constructor was defined.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsConstructor%2A&gt;</ph>属性返回<ph id="ph2">`false`</ph>为<ph id="ph3">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>对象中的动态类型，除非<ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType&gt;</ph>标志已纳入<ph id="ph5">`attributes`</ph>参数当定义构造函数时。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source>Omitting the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph> flag does not affect the correctness of the emitted constructor.</source>
          <target state="translated">省略<ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph>标志不会影响发出构造函数的正确性。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>Gets a value indicating whether the visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>; that is, the method or constructor is visible only within its class and derived classes.</source>
          <target state="translated">获取一个值，该值指示此方法或构造函数的可见性是否由 <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph> 描述；也就是说，此方法或构造函数仅在其类和派生类内可见。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果对此方法或构造函数的访问由 <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph> 准确描述，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType&gt;</ph> if the only visibility modifier is <ph id="ph2">`protected`</ph>.</source>
          <target state="translated">方法或构造函数的可见性准确描述通过<ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType&gt;</ph>唯一可见性修饰符是否<ph id="ph2">`protected`</ph>。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>This property is <ph id="ph1">`false`</ph> for methods that are <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++); use the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property to identify such methods.</source>
          <target state="translated">此属性是<ph id="ph1">`false`</ph>方法<ph id="ph2">`protected internal`</ph>C# 中 (<ph id="ph3">`Protected Friend`</ph>在 Visual Basic 中， <ph id="ph4">`protected public`</ph> c + + 中); 使用<ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>属性来标识此类方法。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">下面的代码示例定义的方法具有不同级别的可见性，并显示的值，其<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Visual Basic 和 C# 语言不能定义具有方法<ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph>可见性; 仅在 c + + 示例中出现访问级别。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>Gets a value indicating whether the visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</source>
          <target state="translated">获取一个值，该值指示此方法或构造函数的可见性是否由 <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph> 描述；也就是说，此方法或构造函数可由派生类调用，但仅当这些派生类在同一程序集中时。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果对此方法或构造函数的访问由 <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph> 准确描述，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> if the visibility modifier is <ph id="ph2">`protected private`</ph> in C++.</source>
          <target state="translated">方法或构造函数的可见性准确描述通过<ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph>的可见性修饰符是否<ph id="ph2">`protected private`</ph>c + + 中。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>Methods with this visibility cannot be defined in Visual Basic or C#.</source>
          <target state="translated">无法在 Visual Basic 或 C# 中定义具有此可见性的方法。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">下面的代码示例定义的方法具有不同级别的可见性，并显示的值，其<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Visual Basic 和 C# 语言不能定义具有方法<ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph>可见性; 仅在 c + + 示例中出现访问级别。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>Gets a value indicating whether the potential visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</source>
          <target state="translated">获取一个值，该值指示此方法或构造函数的潜在可见性是否由 <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph> 描述；也就是说，此方法或构造函数可由派生类（无论其位置如何）和同一程序集中的类调用。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果对此方法或构造函数的访问由 <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph> 准确描述，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>If a type member has <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</source>
          <target state="translated">如果类型成员都有<ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph>可见性，则可以调用它从派生类中的任何成员或任何成员在同一程序集中，但不是与任何其他类型。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The actual visibility of a method is limited by the visibility of its type.</source>
          <target state="translated">一种方法的实际可见受到其类型的可见性。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property might be <ph id="ph2">`true`</ph> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>属性可能<ph id="ph2">`true`</ph>对于方法，但如果它可以是私有的嵌套类型的方法，则此方法不是包含类型外可见。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> if the visibility modifier is <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++).</source>
          <target state="translated">方法或构造函数的可见性准确描述通过<ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph>的可见性修饰符是否<ph id="ph2">`protected internal`</ph>C# 中 (<ph id="ph3">`Protected Friend`</ph>在 Visual Basic 中， <ph id="ph4">`protected public`</ph> c + + 中)。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">下面的代码示例定义的方法具有不同级别的可见性，并显示的值，其<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">Visual Basic 和 C# 语言不能定义具有方法<ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph>可见性; 仅在 c + + 示例中出现访问级别。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>Gets a value indicating whether this method is <ph id="ph1">&lt;see langword="final" /&gt;</ph>.</source>
          <target state="translated">获取一个值，该值指示此方法是否为 <ph id="ph1">&lt;see langword="final" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is <ph id="ph2">&lt;see langword="final" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果方法为 <ph id="ph2">&lt;see langword="final" /&gt;</ph>，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>To determine if a method is overridable, it is not sufficient to check that <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsVirtual%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">若要确定是否可重写一个方法，它是不足够检查是否<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsVirtual%2A&gt;</ph>是<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>For a method to be overridable, <ph id="ph1">`IsVirtual`</ph> must be <ph id="ph2">`true`</ph> and <ph id="ph3">`IsFinal`</ph> must be <ph id="ph4">`false`</ph>.</source>
          <target state="translated">为该方法将被重写，<ph id="ph1">`IsVirtual`</ph>必须<ph id="ph2">`true`</ph>和<ph id="ph3">`IsFinal`</ph>必须<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>For example, a method might be non-virtual, but it implements an interface method.</source>
          <target state="translated">例如，一种方法可能是非虚拟的但它实现接口方法。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>The common language runtime requires that all methods that implement interface members must be marked as <ph id="ph1">`virtual`</ph>; therefore, the compiler marks the method <ph id="ph2">`virtual final`</ph>.</source>
          <target state="translated">公共语言运行时需要实现接口成员的所有方法必须都标记为<ph id="ph1">`virtual`</ph>; 因此，编译器将方法标记<ph id="ph2">`virtual final`</ph>。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>So there are cases where a method is marked as <ph id="ph1">`virtual`</ph> but is still not overridable.</source>
          <target state="translated">因此，在将方法标记为的情况下<ph id="ph1">`virtual`</ph>但仍然不可重写。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>To establish with certainty whether a method is overridable, use code such as this:</source>
          <target state="translated">若要确定是否可重写一个方法就是，使用如下代码：</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>If <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`false`</ph> or <ph id="ph3">`IsFinal`</ph> is <ph id="ph4">`true`</ph>, then the method cannot be overridden.</source>
          <target state="translated">如果<ph id="ph1">`IsVirtual`</ph>是<ph id="ph2">`false`</ph>或<ph id="ph3">`IsFinal`</ph>是<ph id="ph4">`true`</ph>，则不重写方法。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>The following example displays <ph id="ph1">`false`</ph> for <ph id="ph2">`IsFinal`</ph>, which might lead you to think that MyMethod is overridable.</source>
          <target state="translated">下面的示例显示<ph id="ph1">`false`</ph>为<ph id="ph2">`IsFinal`</ph>，这可能导致你认为 MyMethod 是可重写。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>The code prints <ph id="ph1">`false`</ph> even though MyMethod is not marked <ph id="ph2">`virtual`</ph> and thus cannot be overridden.</source>
          <target state="translated">代码将打印<ph id="ph1">`false`</ph>即使未标记 MyMethod<ph id="ph2">`virtual`</ph>并因此不能重写。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Gets a value indicating whether the method is generic.</source>
          <target state="translated">获取一个值，该值指示方法是否为泛型方法。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> represents a generic method; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果当前 <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> 表示泛型方法，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> object represents a generic method.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph>属性来确定是否当前<ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph>对象表示泛型方法。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> object represents an open constructed method or a closed constructed method.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph>属性来确定是否当前<ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph>对象表示开放构造的方法或已关闭的构造的方法。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Generics are not supported by default; this property returns <ph id="ph1">`false`</ph> if not overridden in a derived class.</source>
          <target state="translated">默认情况下; 不支持这些泛型此属性返回<ph id="ph1">`false`</ph>如果未在派生类中重写。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <ph id="ph1">`false`</ph> if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">泛型构造函数中不支持.NET Framework 2.0 版中，因此此属性返回<ph id="ph1">`false`</ph>如果当前实例的类型是<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The following table summarizes the invariant conditions for terms specific to generic methods.</source>
          <target state="translated">下表总结了特定于泛型方法的术语的固定条件。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>For other terms used in generic reflection, such as <bpt id="p1">*</bpt>generic type parameter<ept id="p1">*</ept> and <bpt id="p2">*</bpt>generic type<ept id="p2">*</ept>, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">在泛型反射中，如使用的其他术语<bpt id="p1">*</bpt>泛型类型参数<ept id="p1">*</ept>和<bpt id="p2">*</bpt>泛型类型<ept id="p2">*</ept>，请参阅<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Term</source>
          <target state="translated">术语</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Invariant condition</source>
          <target state="translated">固定参数条件</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>generic method definition</source>
          <target state="translated">泛型方法定义</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition&gt;</ph> 属性为 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Defines a generic method.</source>
          <target state="translated">定义泛型方法。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>A constructed method is created by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition, and specifying an array of type arguments.</source>
          <target state="translated">通过调用创建一个构造的方法<ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph>方法<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>对象表示泛型方法定义，并指定一个类型参数的字符串数组。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method can be called only on generic method definitions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph>可以仅在泛型方法定义上调用方法。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Any generic method definition is a generic method, but the converse is not true.</source>
          <target state="translated">任何泛型方法定义是泛型方法，但反之不成立。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>generic method</source>
          <target state="translated">Generic Method — 泛型方法</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">`IsGenericMethod`</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">`IsGenericMethod`</ph> 属性为 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Can be a generic method definition, an open constructed method, or a closed constructed method.</source>
          <target state="translated">可以是泛型方法定义、 打开的构造的方法或已关闭的构造的方法。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>open constructed method</source>
          <target state="translated">打开构造的方法</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> 属性为 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>It is not possible to invoke an open constructed method.</source>
          <target state="translated">不能调用开放构造的方法。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>closed constructed method</source>
          <target state="translated">关闭的构造的方法</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> property is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> 属性为 <ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>When examined recursively, the method has no unassigned generic parameters.</source>
          <target state="translated">当检查以递归方式，该方法没有任何未分配的泛型参数。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The containing type has no generic type parameters, and none of the type arguments have generic type parameters.</source>
          <target state="translated">包含的类型不具有泛型类型参数，且没有任何类型自变量具有泛型类型参数。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The method can be invoked.</source>
          <target state="translated">可以调用的方法。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>Gets a value indicating whether the method is a generic method definition.</source>
          <target state="translated">获取一个值，该值指示方法是否为泛型方法定义。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object represents the definition of a generic method; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果当前 <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> 对象表示泛型方法的定义，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> represents a generic method definition, then:</source>
          <target state="translated">如果当前<ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>表示泛型方法定义，然后：</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> 属性为 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>For each <ph id="ph1">&lt;xref:System.Type&gt;</ph> object in the array returned by the <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> method:</source>
          <target state="translated">每个<ph id="ph1">&lt;xref:System.Type&gt;</ph>中返回的数组对象<ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph>方法：</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType&gt;</ph> 属性为 <ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType&gt;</ph> property returns the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType&gt;</ph>属性返回当前实例。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType&gt;</ph> property is the same as the position of the <ph id="ph2">&lt;xref:System.Type&gt;</ph> object in the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType&gt;</ph>属性是相同的位置<ph id="ph2">&lt;xref:System.Type&gt;</ph>数组中的对象。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>Generics are not supported by default; this property returns <ph id="ph1">`false`</ph> if not overridden in a derived class.</source>
          <target state="translated">默认情况下; 不支持这些泛型此属性返回<ph id="ph1">`false`</ph>如果未在派生类中重写。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <ph id="ph1">`false`</ph> if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">泛型构造函数中不支持.NET Framework 2.0 版中，因此此属性返回<ph id="ph1">`false`</ph>如果当前实例的类型是<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">有关特定于泛型方法的术语的固定条件的列表，请参阅<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">使用泛型反射中的其他术语的固定条件列表，请参阅<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</source>
          <target state="translated">获取一个值，该值指示是否只有一个签名完全相同的同一种类的成员在派生类中是隐藏的。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the member is hidden by signature; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此成员被签名隐藏，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>When a member in a derived class is declared with the C# <ph id="ph1">`new`</ph> modifier or the Visual Basic <ph id="ph2">`Shadows`</ph> modifier, it can hide a member of the same name in the base class.</source>
          <target state="translated">当派生类中的成员声明使用 C#<ph id="ph1">`new`</ph>修饰符或 Visual Basic<ph id="ph2">`Shadows`</ph>修饰符，它可以隐藏基类中同名的成员。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>C# hides base class members by signature.</source>
          <target state="translated">C# 按签名隐藏基类成员。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature.</source>
          <target state="translated">也就是说，如果基类成员具有多个重载，隐藏只有一个是具有相同签名的那个。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>By contrast, Visual Basic hides all the base class overloads.</source>
          <target state="translated">与此相反，Visual Basic 隐藏所有基类重载。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>Thus, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> returns <ph id="ph2">`false`</ph> on a member declared with the Visual Basic <ph id="ph3">`Shadows`</ph> modifier, and <ph id="ph4">`true`</ph> on a member declared with the C# <ph id="ph5">`new`</ph> modifier.</source>
          <target state="translated">因此，<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph>返回<ph id="ph2">`false`</ph>上使用 Visual Basic 中声明的成员<ph id="ph3">`Shadows`</ph>修饰符，和<ph id="ph4">`true`</ph>上使用 C# 声明的成员<ph id="ph5">`new`</ph>修饰符。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>This property does not determine whether a method has the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute.</source>
          <target state="translated">此属性不能决定的方法是否具有<ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>A method that is declared with either the <ph id="ph1">`new`</ph> or the <ph id="ph2">`Shadows`</ph> modifier will have the <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, but only methods declared with <ph id="ph4">`new`</ph> (that is, only C# methods) will have the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> property set to <ph id="ph6">`true`</ph>.</source>
          <target state="translated">使用声明的方法<ph id="ph1">`new`</ph>或<ph id="ph2">`Shadows`</ph>修饰符将具有<ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph>属性，但只有使用声明的方法<ph id="ph4">`new`</ph>（即，仅 C# 方法） 将具有<ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph>属性设置为<ph id="ph6">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>To determine whether a method has the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, use code similar to the following: <ph id="ph2">`if ((myMethodInfo.Attributes &amp; MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)`</ph> in C# or <ph id="ph3">`If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot`</ph> in Visual Basic.</source>
          <target state="translated">若要确定方法是否具有<ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph>特性，请使用类似于以下代码：<ph id="ph2">`if ((myMethodInfo.Attributes &amp; MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)`</ph>在 C# 或<ph id="ph3">`If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot`</ph>在 Visual Basic 中。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>Note, however, that although all methods declared with <ph id="ph1">`new`</ph> or <ph id="ph2">`Shadows`</ph> have the <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, not all methods that have the <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute are declared with <ph id="ph5">`new`</ph> or <ph id="ph6">`Shadows`</ph>.</source>
          <target state="translated">但请注意，，尽管使用的所有方法都声明<ph id="ph1">`new`</ph>或<ph id="ph2">`Shadows`</ph>具有<ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph>属性，并非所有的方法具有<ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph>属性都声明具有<ph id="ph5">`new`</ph>或<ph id="ph6">`Shadows`</ph>。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads.</source>
          <target state="translated">下面的代码示例包含具有重载方法、 的基类和派生的类隐藏了其中一个重载。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>In the Visual Basic version of the code example, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for the member in the derived class.</source>
          <target state="translated">在 Visual Basic 版本的代码示例中，<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph>属性返回<ph id="ph2">`false`</ph>派生类中的成员。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>In the C# version of the code sample, the property returns <ph id="ph1">`true`</ph> for the member in the derived class.</source>
          <target state="translated">在 C# 版本的代码示例，该属性返回<ph id="ph1">`true`</ph>派生类中的成员。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsPrivate">
          <source>Gets a value indicating whether this member is private.</source>
          <target state="translated">获取一个值，该值指示此成员是否是私有的。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPrivate">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method is restricted to other members of the class itself; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果对此方法的访问只限于该类本身的其他成员，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPrivate">
          <source>If a type member has <ph id="ph1">`Private`</ph> level visibility, it can be called from any member in the same class and no others.</source>
          <target state="translated">如果类型成员都有<ph id="ph1">`Private`</ph>级可见性，则可以调用它从在同一个类，但不适用于其他任何成员。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>Gets a value indicating whether this is a public method.</source>
          <target state="translated">获取一个值，该值指示这是否是一个公共方法。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is public; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此方法是公共的，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, first get the type.</source>
          <target state="translated">若要获取<ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>，首先要获取类型。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>From the type, get the method.</source>
          <target state="translated">从类型，get 方法。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>From the method, get the <ph id="ph1">`MethodBase`</ph>.</source>
          <target state="translated">从方法获取<ph id="ph1">`MethodBase`</ph>。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>If the <ph id="ph1">`MethodBase`</ph> or constructor is other than public, it is protected and cannot be readily accessed.</source>
          <target state="translated">如果<ph id="ph1">`MethodBase`</ph>或构造函数是公共以外，它受到保护，而且不能轻松访问。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>To access a non-public method, set the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> mask to <ph id="ph2">`NonPublic`</ph> in <ph id="ph3">`GetMethod`</ph>.</source>
          <target state="translated">若要访问非公共方法，将设置<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>屏蔽到<ph id="ph2">`NonPublic`</ph>中<ph id="ph3">`GetMethod`</ph>。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> property to display a message that indicates whether the specified method is public.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph>显示一条消息，该值指示指定的方法是否是公共的属性。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</source>
          <target state="translated">获取一个值，该值指示当前方法或构造函数在当前信任级别上是安全关键的还是安全可靠关键的，因此可以执行关键操作。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated">如果当前方法或构造函数在当前信任级别上是安全关键的或安全可靠关键的，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；如果它是透明的，则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph>属性报告的方法或在其当前的信任级别，由公共语言运行时 (CLR) 的构造函数的透明度级别。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">下表中显示的这些属性的组合：</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">安全级别</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">严重</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Safe critical</source>
          <target state="translated">可靠关键</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">透明</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">使用这些属性是比检查程序集及其类型和成员的安全批注、 检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">对于部分信任程序集，此属性的值取决于程序集的当前信任级别。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">如果程序集加载到部分受信任的应用程序域中 （例如，到沙盒应用程序域中），运行时将忽略程序集的安全批注。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">程序集和其所有类型被视为透明。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">运行时才会注意到部分信任程序集的安全批注仅当该程序集加载到完全信任的应用程序域中 （例如，到桌面应用程序的默认应用程序域）。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">与此相反，受信任的程序集 （即，具有强名称程序集安装在全局程序集缓存），是始终以而不考虑应用程序域的信任级别的完全信任方式加载，因此其当前的信任级别始终是完全受信任。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">你可以使用来确定程序集和应用程序域的当前信任级别<ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">有关反射和透明度的详细信息，请参阅<bpt id="p1">[</bpt>反射的安全注意事项<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">透明度有关的信息，请参阅<bpt id="p1">[</bpt>安全更改<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">获取一个值，该值指示当前方法或构造函数在当前信任级别上是安全可靠关键的；即它是否可以执行关键操作并可以由透明代码访问。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method or constructor is security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated">如果方法或构造函数在当前信任级别上是安全可靠关键的，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；如果它是安全关键的或透明的，则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph>属性报告的方法或在其当前的信任级别，由公共语言运行时 (CLR) 的构造函数的透明度级别。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">下表中显示的这些属性的组合：</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">安全级别</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">严重</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Safe critical</source>
          <target state="translated">可靠关键</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">透明</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">使用这些属性是比检查程序集及其类型和成员的安全批注、 检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">对于部分信任程序集，此属性的值取决于程序集的当前信任级别。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">如果程序集加载到部分受信任的应用程序域中 （例如，到沙盒应用程序域中），运行时将忽略程序集的安全批注。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">程序集和其所有类型被视为透明。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">运行时才会注意到部分信任程序集的安全批注仅当该程序集加载到完全信任的应用程序域中 （例如，到桌面应用程序的默认应用程序域）。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">与此相反，受信任的程序集 （即，具有强名称程序集安装在全局程序集缓存），是始终以而不考虑应用程序域的信任级别的完全信任方式加载，因此其当前的信任级别始终是完全受信任。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">你可以使用来确定程序集和应用程序域的当前信任级别<ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">有关反射和透明度的详细信息，请参阅<bpt id="p1">[</bpt>反射的安全注意事项<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">透明度有关的信息，请参阅<bpt id="p1">[</bpt>安全更改<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</source>
          <target state="translated">获取一个值，该值指示当前方法或构造函数在当前信任级别上是透明的，因此无法执行关键操作。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method or constructor is security-transparent at the current trust level; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果方法或构造函数在当前信任级别上是安全透明的，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>If this property returns <ph id="ph1">`true`</ph>, the <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> properties return <ph id="ph4">`false`</ph>.</source>
          <target state="translated">如果此属性返回<ph id="ph1">`true`</ph>、<ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>和<ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>属性返回<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph>属性报告的方法或在其当前的信任级别，由公共语言运行时 (CLR) 的构造函数的透明度级别。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">使用这些属性是比检查程序集及其类型和成员的安全批注、 检查当前的信任级别，以及尝试复制运行时的规则要简单得多。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">对于部分信任程序集，此属性的值取决于程序集的当前信任级别。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">如果程序集加载到部分受信任的应用程序域中 （例如，到沙盒应用程序域中），运行时将忽略程序集的安全批注。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">程序集和其所有类型被视为透明。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">运行时才会注意到部分信任程序集的安全批注仅当该程序集加载到完全信任的应用程序域中 （例如，到桌面应用程序的默认应用程序域）。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">与此相反，受信任的程序集 （即，具有强名称程序集安装在全局程序集缓存），是始终以而不考虑应用程序域的信任级别的完全信任方式加载，因此其当前的信任级别始终是完全受信任。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">你可以使用来确定程序集和应用程序域的当前信任级别<ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">有关反射和透明度的详细信息，请参阅<bpt id="p1">[</bpt>反射的安全注意事项<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">透明度有关的信息，请参阅<bpt id="p1">[</bpt>安全更改<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source>Gets a value indicating whether this method has a special name.</source>
          <target state="translated">获取一个值，该值指示此方法是否具有特殊名称。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method has a special name; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此方法具有特殊名称，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph>位设置为标志以特殊方式处理通过一些编译器 （如属性访问器和运算符重载方法） 的成员。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source>This example shows a use of <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSpecialName%2A&gt;</ph> to filter internal or private members out of a list.</source>
          <target state="translated">此示例演示使用<ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSpecialName%2A&gt;</ph>到筛选器内部或私有成员移出列表。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsStatic">
          <source>Gets a value indicating whether the method is <ph id="ph1">&lt;see langword="static" /&gt;</ph>.</source>
          <target state="translated">获取一个值，该值指示方法是否为 <ph id="ph1">&lt;see langword="static" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsStatic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is <ph id="ph2">&lt;see langword="static" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果方法为 <ph id="ph2">&lt;see langword="static" /&gt;</ph>，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsStatic">
          <source>A static member cannot implicitly reference instance data in a class.</source>
          <target state="translated">静态成员不能隐式引用类中的实例数据。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>Gets a value indicating whether the method is <ph id="ph1">&lt;see langword="virtual" /&gt;</ph>.</source>
          <target state="translated">获取一个值，该值指示方法是否为 <ph id="ph1">&lt;see langword="virtual" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is <ph id="ph2">&lt;see langword="virtual" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果方法为 <ph id="ph2">&lt;see langword="virtual" /&gt;</ph>，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>A virtual member may reference instance data in a class and must be referenced through an instance of the class.</source>
          <target state="translated">虚拟成员可以引用类中的实例数据，并且必须通过类的实例引用。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>To determine if a method is overridable, it is not sufficient to check that <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">若要确定是否可重写一个方法，它是不足够检查是否<ph id="ph1">`IsVirtual`</ph>是<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>For a method to be overridable, <ph id="ph1">`IsVirtual`</ph> must be <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFinal%2A&gt;</ph> must be <ph id="ph4">`false`</ph>.</source>
          <target state="translated">为该方法将被重写，<ph id="ph1">`IsVirtual`</ph>必须<ph id="ph2">`true`</ph>和<ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFinal%2A&gt;</ph>必须<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>For example, a method might be non-virtual, but it implements an interface method.</source>
          <target state="translated">例如，一种方法可能是非虚拟的但它实现接口方法。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The common language runtime requires that all methods that implement interface members must be marked as <ph id="ph1">`virtual`</ph>; therefore, the compiler marks the method <ph id="ph2">`virtual final`</ph>.</source>
          <target state="translated">公共语言运行时需要实现接口成员的所有方法必须都标记为<ph id="ph1">`virtual`</ph>; 因此，编译器将方法标记<ph id="ph2">`virtual final`</ph>。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>So there are cases where a method is marked as <ph id="ph1">`virtual`</ph> but is still not overridable.</source>
          <target state="translated">因此，在将方法标记为的情况下<ph id="ph1">`virtual`</ph>但仍然不可重写。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>To establish with certainty whether a method is overridable, use code such as this:</source>
          <target state="translated">若要确定是否可重写一个方法就是，使用如下代码：</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>If <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`false`</ph> or <ph id="ph3">`IsFinal`</ph> is <ph id="ph4">`true`</ph>, then the method cannot be overridden.</source>
          <target state="translated">如果<ph id="ph1">`IsVirtual`</ph>是<ph id="ph2">`false`</ph>或<ph id="ph3">`IsFinal`</ph>是<ph id="ph4">`true`</ph>，则不重写方法。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>You can determine whether the current method overrides a method in a base class by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">你可以确定是否当前的方法重写的基类中的一个方法通过调用<ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The following example implements an <ph id="ph1">`IsOverride`</ph> method that does this.</source>
          <target state="translated">下面的示例实现<ph id="ph1">`IsOverride`</ph>可完成此方法。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The following example displays <ph id="ph1">`false`</ph> for <ph id="ph2">`IsFinal`</ph>, which might lead you to think that <ph id="ph3">`MyMethod`</ph> is overridable.</source>
          <target state="translated">下面的示例显示<ph id="ph1">`false`</ph>为<ph id="ph2">`IsFinal`</ph>，这可能导致您认为<ph id="ph3">`MyMethod`</ph>是可重写。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The code prints <ph id="ph1">`false`</ph> even though <ph id="ph2">`MyMethod`</ph> is not marked <ph id="ph3">`virtual`</ph> and thus cannot be overridden.</source>
          <target state="translated">代码将打印<ph id="ph1">`false`</ph>即使<ph id="ph2">`MyMethod`</ph>未标记为<ph id="ph3">`virtual`</ph>并因此不能重写。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.MethodHandle">
          <source>Gets a handle to the internal metadata representation of a method.</source>
          <target state="translated">获取方法的内部元数据表示形式的句柄。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodHandle">
          <source>A <ph id="ph1">&lt;see cref="T:System.RuntimeMethodHandle" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.RuntimeMethodHandle" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodHandle">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">句柄仅在获取它们的应用程序域中是有效的。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.MethodImplementationFlags">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags that specify the attributes of a method implementation.</source>
          <target state="translated">获取指定方法实现特性的 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> 标志。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodImplementationFlags">
          <source>The method implementation flags.</source>
          <target state="translated">方法实现标志。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodImplementationFlags">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> method for more information.</source>
          <target state="translated">有关更多信息，请参阅 <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The first object to compare.</source>
          <target state="translated">要比较的第一个对象。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The second object to compare.</source>
          <target state="translated">要比较的第二个对象。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> objects are equal.</source>
          <target state="translated">指示两个 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> 对象是否相等。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 等于 <ph id="ph2">&lt;paramref name="left" /&gt;</ph>，则为 <ph id="ph3">&lt;paramref name="right" /&gt;</ph>；否则为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The first object to compare.</source>
          <target state="translated">要比较的第一个对象。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The second object to compare.</source>
          <target state="translated">要比较的第二个对象。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> objects are not equal.</source>
          <target state="translated">指示两个 <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> 对象是否不相等。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 不等于 <ph id="ph2">&lt;paramref name="left" /&gt;</ph>，则为 <ph id="ph3">&lt;paramref name="right" /&gt;</ph>；否则为 <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">留待将来使用。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">必须为 IID_NULL。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">要映射的名称的传入数组。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">要映射的名称的计数。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">要在其中解释名称的区域设置上下文。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">调用方分配的数组，用于接收与名称对应的 ID。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">将一组名称映射为对应的一组调度标识符。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::GetIDsOfNames`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">此成员是显式的接口成员实现。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">它只能在 <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> 实例强制转换为 <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> 接口时使用。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">要返回的类型信息。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">类型信息的区域设置标识符。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">接收一个指针，指向请求的类型信息对象。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::GetTypeInfo`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">指向一个位置，该位置接收对象提供的类型信息接口的数量。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">检索对象提供的类型信息接口的数量（0 或 1）。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">标识成员。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">留待将来使用。</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">必须为 IID_NULL。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">要在其中解释参数的区域设置上下文。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">描述调用的上下文的标志。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">指向一个结构的指针，该结构包含一个自变量数组、一个命名自变量的 DISPID 自变量数组和数组中元素数的计数。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">指向要存储结果的位置的指针。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">指向一个包含异常信息的结构的指针。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">第一个出错自变量的索引。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">提供对某一对象公开的属性和方法的访问。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">此方法用于访问托管类从非托管代码，不应从托管代码调用。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">有关详细信息<ph id="ph1">`IDispatch::Invoke`</ph>，请参阅 MSDN 库。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">不支持使用 COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> 接口的后期绑定访问。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">此成员是显式的接口成员实现。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">它只能在 <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> 实例强制转换为 <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> 接口时使用。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">此成员是显式的接口成员实现。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">它只能在 <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> 实例强制转换为 <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> 接口时使用。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">此成员是显式的接口成员实现。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">它只能在 <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> 实例强制转换为 <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> 接口时使用。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">此成员是显式的接口成员实现。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">它只能在 <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> 实例强制转换为 <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> 接口时使用。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">此成员是显式的接口成员实现。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">它只能在 <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> 实例强制转换为 <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> 接口时使用。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">此成员是显式的接口成员实现。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">它只能在 <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> 实例强制转换为 <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> 接口时使用。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">此成员是显式的接口成员实现。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">它只能在 <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> 实例强制转换为 <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> 接口时使用。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">此成员是显式的接口成员实现。</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">它只能在 <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> 实例强制转换为 <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> 接口时使用。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">此成员是显式的接口成员实现。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">它只能在 <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> 实例强制转换为 <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> 接口时使用。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">此成员是显式的接口成员实现。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">它只能在 <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> 实例强制转换为 <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> 接口时使用。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">此成员是显式的接口成员实现。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">它只能在 <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> 实例强制转换为 <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> 接口时使用。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">此成员是显式的接口成员实现。</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">它只能在 <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> 实例强制转换为 <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> 接口时使用。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</source>
          <target state="translated">有关此成员的说明，请参阅 <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">此成员是显式的接口成员实现。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">它只能在 <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> 实例强制转换为 <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> 接口时使用。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>