<Type Name="IPlaybackControl" FullName="System.EnterpriseServices.IPlaybackControl">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="642ac9e3f2ad478ab2e2f243b5892ce7ec311488" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39983156" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IPlaybackControl" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IPlaybackControl" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.IPlaybackControl" />
  <TypeSignature Language="VB.NET" Value="Public Interface IPlaybackControl" />
  <TypeSignature Language="C++ CLI" Value="public interface class IPlaybackControl" />
  <TypeSignature Language="F#" Value="type IPlaybackControl = interface" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.InteropServices.Guid("51372AFD-CAE7-11CF-BE81-00AA00A2FA25")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.InteropServices.InterfaceType</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.Runtime.InteropServices.InterfaceType(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="05140-101">“消息队列”传送机制的服务器端播放错误和客户端失败的异常处理中的“排队组件”中的函数。</span>
      <span class="sxs-lookup">
        <span data-stu-id="05140-101">Functions in Queued Components in the abnormal handling of server-side playback errors and client-side failures of the Message Queuing delivery mechanism.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="05140-102">为 COM + 目录中的组件同时实现定义的异常类<xref:System.EnterpriseServices.IPlaybackControl>用于原始类和接口。</span><span class="sxs-lookup"><span data-stu-id="05140-102">The exception class defined for the component in the COM+ catalog implements both <xref:System.EnterpriseServices.IPlaybackControl> and the interface for the original class.</span></span> <span data-ttu-id="05140-103">原始类接口的方法实现用于执行类本身中失败的方法处理的异常。</span><span class="sxs-lookup"><span data-stu-id="05140-103">The method implementations of the original class interface are used to perform the exception handling for the failed methods in the class itself.</span></span> <span data-ttu-id="05140-104">它们将在调用<xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A>或<xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A>来处理异常的最初调用的方法。</span><span class="sxs-lookup"><span data-stu-id="05140-104">They will be called after <xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A> or <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A> to process exceptions for the method originally called.</span></span>  
  
 <span data-ttu-id="05140-105">排入队列组件播放机调用的方法<xref:System.EnterpriseServices.IPlaybackControl>通知消息是要放置在最终的停留或死信队列上的异常处理程序对象。</span><span class="sxs-lookup"><span data-stu-id="05140-105">The Queued Components Player calls the methods of <xref:System.EnterpriseServices.IPlaybackControl> to inform the exception-handler object that a message is about to be placed on the final resting or dead letter queue.</span></span> <span data-ttu-id="05140-106">排入队列组件播放机然后调用原始方法调用中失败的异常处理程序对象中的相同方法。</span><span class="sxs-lookup"><span data-stu-id="05140-106">The Queued Components Player then calls the same method in the exception-handler object that had failed in the original method call.</span></span> <span data-ttu-id="05140-107">异常处理程序对象可以实现替代方法，例如，通过收集问题诊断信息，或生成的对象或将告知该问题的客户端的消息。</span><span class="sxs-lookup"><span data-stu-id="05140-107">The exception-handler object can implement an alternative, for example, by gathering problem diagnosis information or generating an object or message that informs the client of the problem.</span></span> <span data-ttu-id="05140-108">如果应用程序不实现<xref:System.EnterpriseServices.IPlaybackControl>，病毒消息位于最终停留或死信队列，当队列组件播放器用完所有重试时。</span><span class="sxs-lookup"><span data-stu-id="05140-108">If the application does not implement <xref:System.EnterpriseServices.IPlaybackControl>, the poison message is placed on the final resting or dead letter queue when the Queued Components Player exhausts all retries.</span></span>  
  
 <span data-ttu-id="05140-109">病毒消息是一条消息，而无法处理由于某种原因，可能是由于服务器或队列系统出现问题。</span><span class="sxs-lookup"><span data-stu-id="05140-109">A poison message is a message that cannot be processed for some reason, perhaps because of a problem with the server or queuing system.</span></span> <span data-ttu-id="05140-110">事务回滚后，和病毒消息将发送到队列的顶部。</span><span class="sxs-lookup"><span data-stu-id="05140-110">The transaction is rolled back, and the poison message goes to the top of the queue.</span></span> <span data-ttu-id="05140-111">消息的重新排队，当相同的条件。</span><span class="sxs-lookup"><span data-stu-id="05140-111">When the message is dequeued again, the same condition occurs.</span></span> <span data-ttu-id="05140-112">此消息可以继续循环，无限期之前执行某些操作以更正此问题。</span><span class="sxs-lookup"><span data-stu-id="05140-112">This message can continue looping indefinitely until something is done to correct the problem.</span></span> <span data-ttu-id="05140-113">队列组件服务通过使用一系列的重试处理有害消息。</span><span class="sxs-lookup"><span data-stu-id="05140-113">The Queued Components service handles the poison message by using a series of retries.</span></span> <span data-ttu-id="05140-114">多次失败尝试后消息移动到最终静止队列。</span><span class="sxs-lookup"><span data-stu-id="05140-114">After several unsuccessful retries, the message is moved to a final resting queue.</span></span> <span data-ttu-id="05140-115">有害消息保留在静止队列直到手动移动使用排队组件消息移动工具。</span><span class="sxs-lookup"><span data-stu-id="05140-115">Poison messages remain in the resting queue until manually moved by using the Queued Components Message Mover tool.</span></span>  
  
 <span data-ttu-id="05140-116">有害消息的情况，也可解决以编程方式，使用<xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A>方法，它会通知服务器端组件的作者： 播放推迟的激活的所有尝试都失败。</span><span class="sxs-lookup"><span data-stu-id="05140-116">The poison message situation can also be resolved programmatically, using the <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A> method, which informs the server-side component author that all attempts to play back the deferred activation have failed.</span></span>  
  
 <span data-ttu-id="05140-117">如果发现病毒消息，你可以快速解决问题的根本原因。</span><span class="sxs-lookup"><span data-stu-id="05140-117">If you discover a poison message, you might be able to solve the underlying cause of the problem quickly.</span></span> <span data-ttu-id="05140-118">例如，如果出于某种原因，在服务器处于脱机状态，你可以将服务器恢复联机状态。</span><span class="sxs-lookup"><span data-stu-id="05140-118">For example, if the server was offline for some reason, you can bring the server back online.</span></span> <span data-ttu-id="05140-119">如果你不能快速解决问题，可以自动生成通知请求程序在事务中未出现的另一个事务。</span><span class="sxs-lookup"><span data-stu-id="05140-119">If you cannot solve the problem quickly, you can automatically generate another transaction that notifies the requestor that the transaction did not occur.</span></span> <span data-ttu-id="05140-120">然后，请求程序可以使补偿事务，以撤消已提交的事务的效果。</span><span class="sxs-lookup"><span data-stu-id="05140-120">The requestor can then make a compensating transaction that reverses the effect of a transaction that has already committed.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="FinalClientRetry">
      <MemberSignature Language="C#" Value="public void FinalClientRetry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FinalClientRetry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.IPlaybackControl.FinalClientRetry" />
      <MemberSignature Language="VB.NET" Value="Public Sub FinalClientRetry ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FinalClientRetry();" />
      <MemberSignature Language="F#" Value="abstract member FinalClientRetry : unit -&gt; unit" Usage="iPlaybackControl.FinalClientRetry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="05140-121">通知客户端异常处理组件，消息队列将消息发送至服务器的所有尝试均被拒绝，消息终止于客户端的 Xact 死信队列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05140-121">Informs the client-side exception-handling component that all Message Queuing attempts to deliver the message to the server were rejected, and the message ended up on the client-side Xact Dead Letter queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="05140-122">当消息到达 Xact 死信队列中时，COM + 尝试调用与此通知传递的服务器类相关的客户端的异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="05140-122">As messages arrive in the Xact Dead Letter queue, COM+ attempts to invoke a client-side exception handler related to the server class to deliver this notification.</span></span> <span data-ttu-id="05140-123">它会通过首先调用<xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A>，然后调用异常处理程序对象中的失败的方法的异常处理版本。</span><span class="sxs-lookup"><span data-stu-id="05140-123">It does so by first calling <xref:System.EnterpriseServices.IPlaybackControl.FinalClientRetry%2A>, then calling the exception-handling version of the failed method in the exception-handler object.</span></span> <span data-ttu-id="05140-124">此异常方法然后可以采取异常操作，例如录制失败，将一封电子邮件发送给管理员，或执行客户端的补偿操作 （用于翻转效果的更早的事务）。</span><span class="sxs-lookup"><span data-stu-id="05140-124">This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction).</span></span> <span data-ttu-id="05140-125">如果异常方法失败，消息停留在 Xact 死信队列。</span><span class="sxs-lookup"><span data-stu-id="05140-125">If the exception method is not successful, the message is left on the Xact Dead Letter queue.</span></span>  
  
 <span data-ttu-id="05140-126">可以在 Microsoft 消息队列 (MSMQ) 资源管理器中查看 Xact 死信队列。</span><span class="sxs-lookup"><span data-stu-id="05140-126">The Xact Dead Letter queue can be viewed in the Microsoft Message Queue (MSMQ) Explorer.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FinalServerRetry">
      <MemberSignature Language="C#" Value="public void FinalServerRetry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FinalServerRetry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.IPlaybackControl.FinalServerRetry" />
      <MemberSignature Language="VB.NET" Value="Public Sub FinalServerRetry ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FinalServerRetry();" />
      <MemberSignature Language="F#" Value="abstract member FinalServerRetry : unit -&gt; unit" Usage="iPlaybackControl.FinalServerRetry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="05140-127">通知服务器端异常类实现，所有将被推迟的激活播放至服务器的尝试均已失败，该消息将被移至其最终静止队列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05140-127">Informs the server-side exception class implementation that all attempts to play back the deferred activation to the server have failed, and the message is about to be moved to its final resting queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="05140-128">当消息到达 Xact 死信队列，COM + 尝试调用与此通知传递的服务器类相关的服务器端异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="05140-128">As messages arrive on the Xact Dead Letter queue, COM+ attempts to invoke a server-side exception handler related to the server class to deliver this notification.</span></span> <span data-ttu-id="05140-129">它会通过首先调用<xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A>，然后调用异常处理的异常处理程序对象中失败的方法的版本。</span><span class="sxs-lookup"><span data-stu-id="05140-129">It does so by first calling <xref:System.EnterpriseServices.IPlaybackControl.FinalServerRetry%2A>, then calling the exception handling version of the failed method in the exception handler object.</span></span> <span data-ttu-id="05140-130">此异常方法然后可以采取异常操作，例如录制失败，将一封电子邮件发送给管理员，或执行客户端的补偿操作 （用于翻转效果的更早的事务）。</span><span class="sxs-lookup"><span data-stu-id="05140-130">This exception method can then take an exception action, such as recording the failure, sending a mail message to the administrator, or taking client-side compensating action (reversing the effect of an earlier transaction).</span></span> <span data-ttu-id="05140-131">服务器对象应尽力成功完成此事务。</span><span class="sxs-lookup"><span data-stu-id="05140-131">The server object should make every effort to complete this transaction successfully.</span></span> <span data-ttu-id="05140-132">否则，需要手动干预来重新处理该消息。</span><span class="sxs-lookup"><span data-stu-id="05140-132">Otherwise, manual intervention is required to reprocess the message.</span></span> <span data-ttu-id="05140-133">如果异常方法失败，消息将移到最终静止队列。</span><span class="sxs-lookup"><span data-stu-id="05140-133">If the exception method is not successful, the message is moved to the final resting queue.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>