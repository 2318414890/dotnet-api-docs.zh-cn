<Type Name="TextBlock" FullName="System.Windows.Controls.TextBlock">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="44ae141af3267dadfad710868e190bf288c9ffe7" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30620641" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextBlock : System.Windows.FrameworkElement, IServiceProvider, System.Windows.IContentHost" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi TextBlock extends System.Windows.FrameworkElement implements class System.IServiceProvider, class System.Windows.IContentHost, class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.TextBlock" />
  <TypeSignature Language="VB.NET" Value="Public Class TextBlock&#xA;Inherits FrameworkElement&#xA;Implements IContentHost, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextBlock : System::Windows::FrameworkElement, IServiceProvider, System::Windows::IContentHost" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IContentHost</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Text)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Inlines")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供一个轻型控件，用于显示少量流内容。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Controls.TextBlock>可以包含在字符串其<xref:System.Windows.Controls.TextBlock.Text%2A>属性或<xref:System.Windows.Documents.Inline>流内容元素，如<xref:System.Windows.Documents.Bold>， <xref:System.Windows.Documents.Hyperlink>，和<xref:System.Windows.Documents.InlineUIContainer>、 在其<xref:System.Windows.Controls.TextBlock.Inlines%2A>属性。  
  
 <xref:System.Windows.Controls.TextBlock> 设计为轻量的并且特别适用于将集成到的流内容的小部分[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。  <xref:System.Windows.Controls.TextBlock> 最适合的单行显示，并提供良好的性能，显示最多几行内容。  
  
 <xref:System.Windows.Controls.TextBlock> 没有为需要显示多个几行内容; 的方案进行优化对于此类方案中，<xref:System.Windows.Documents.FlowDocument>结合适当查看控件是更好的选择比<xref:System.Windows.Controls.TextBlock>，在性能方面。  后<xref:System.Windows.Controls.TextBlock>，<xref:System.Windows.Controls.FlowDocumentScrollViewer>是下一个最小权重控件用于显示流内容，只需提供极少的滚动内容区域[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。  <xref:System.Windows.Controls.FlowDocumentPageViewer> 是围绕流内容"页上的每一次的"查看模式进行了优化。  最后，<xref:System.Windows.Controls.FlowDocumentReader>支持丰富的一组功能用于查看流内容，但是相应地更大权重。  
  
 水平对齐文本内的<xref:System.Windows.Controls.TextBlock>，可使用<xref:System.Windows.Controls.TextBlock.TextAlignment%2A>属性。 对齐<xref:System.Windows.Controls.TextBlock>页的布局中，可使用<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>和<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>属性。  
  
   
  
## Examples  
 下面的示例演示如何使用 <xref:System.Windows.Controls.TextBlock> 元素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockSimpleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblocksimplexaml)]  
  
 下图显示了此示例的呈现效果。  
  
 ![屏幕快照： Textblock 和按钮](~/add/media/textblock-simple.png "屏幕快照： Textblock 和按钮")  
  
 下面的示例演示如何以显示如何实现类似结果以编程方式。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblocksimple)]
 [!code-vb[FlowDocumentSnippets#_TextBlockSimple](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblocksimple)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.Label" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Controls.TextBlock" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextBlock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Controls.TextBlock" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextBlock (System.Windows.Documents.Inline inline);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.Inline inline) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.#ctor(System.Windows.Documents.Inline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextBlock(System::Windows::Documents::Inline ^ inline);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="inline" Type="System.Windows.Documents.Inline" />
      </Parameters>
      <Docs>
        <param name="inline">要作为初始内容添加的、从 <see cref="T:System.Windows.Documents.Inline" /> 抽象类派生的对象。</param>
        <summary>初始化 <see cref="T:System.Windows.Controls.TextBlock" /> 类的一个新实例，将指定的 <see cref="T:System.Windows.Documents.Inline" /> 元素作为初始显示内容添加。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有效输入类型`inline`包括<xref:System.Windows.Documents.AnchoredBlock>， <xref:System.Windows.Documents.InlineUIContainer>， <xref:System.Windows.Documents.LineBreak>， <xref:System.Windows.Documents.Run>，和<xref:System.Windows.Documents.Span>。  
  
   
  
## Examples  
 下面的示例演示如何使用此构造函数。  在这种情况下，<xref:System.Windows.Controls.TextBlock>包含文本<xref:System.Windows.Documents.Run>。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockConstructorSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockconstructorsimple)]
 [!code-vb[FlowDocumentSnippets#_TextBlockConstructorSimple](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockconstructorsimple)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inline" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size ArrangeOverride (System.Windows.Size arrangeSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function ArrangeOverride (arrangeSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeSize">父承载元素内的 <see cref="T:System.Windows.Size" />，<see cref="T:System.Windows.Controls.TextBlock" /> 将使用它来排列自身及其子元素。 大小约束可能会影响所请求的此大小。</param>
        <summary>定位子元素并确定 <see cref="T:System.Windows.Controls.TextBlock" /> 的大小。</summary>
        <returns>用于排列元素的实际 <see cref="T:System.Windows.Size" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要用于填充内容区域背景的 <see cref="T:System.Windows.Media.Brush" />。</summary>
        <value>用于填充内容区域背景的画笔，或 <see langword="null" />（不使用背景画笔）。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何<xref:System.Windows.Controls.TextBlock.Background%2A>子元素上的设置重写此顶层的设置。  
  
 显示可用的预定义的画笔颜色样本的表，请参阅<xref:System.Windows.Media.Brushes>。  
  
<a name="dependencyPropertyInfo_Background"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.BackgroundProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.Background%2A>属性<xref:System.Windows.Controls.TextBlock>元素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.Background%2A>属性以编程方式。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.Background" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaselineOffset">
      <MemberSignature Language="C#" Value="public double BaselineOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 BaselineOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.BaselineOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property BaselineOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double BaselineOffset { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置文本的每个行相对于基线的偏移量。</summary>
        <value>文本的每个行相对于基线的偏移量，以与设备无关的像素为单位。 <see cref="F:System.Double.NaN" /> 指示根据当前的字体特征自动计算最佳基线偏移量。 默认值为 <see cref="F:System.Double.NaN" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基线是假想的水平线与其对齐文本的行中的每个字符的基数。  
  
 此依赖项属性还具有附加的属性的用法。 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，这种用法并`<`*对象* <xref:System.Windows.Controls.TextBlock.BaselineOffset%2A?displayProperty=nameWithType> `="` *double*`".../>`，其中*对象*是一个对象中包含的元素 （通常流元素） <xref:System.Windows.Controls.TextBlock>。 在代码中，附加的属性使用情况受<xref:System.Windows.Controls.TextBlock.GetBaselineOffset%2A>和<xref:System.Windows.Controls.TextBlock.SetBaselineOffset%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaselineOffsetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BaselineOffsetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BaselineOffsetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.BaselineOffsetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BaselineOffsetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BaselineOffsetProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BreakAfter">
      <MemberSignature Language="C#" Value="public System.Windows.LineBreakCondition BreakAfter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineBreakCondition BreakAfter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.BreakAfter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BreakAfter As LineBreakCondition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineBreakCondition BreakAfter { System::Windows::LineBreakCondition get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineBreakCondition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Windows.LineBreakCondition" />，它指示内容应当如何在当前元素之后进行分行。</summary>
        <value>在当前元素之后将内容分行的条件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性始终返回 <xref:System.Windows.LineBreakCondition.BreakDesired>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.BreakBefore" />
      </Docs>
    </Member>
    <Member MemberName="BreakBefore">
      <MemberSignature Language="C#" Value="public System.Windows.LineBreakCondition BreakBefore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineBreakCondition BreakBefore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.BreakBefore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BreakBefore As LineBreakCondition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineBreakCondition BreakBefore { System::Windows::LineBreakCondition get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineBreakCondition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Windows.LineBreakCondition" />，它指示内容应当如何在当前元素之前进行分行。</summary>
        <value>在当前元素之后将内容分行的条件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性始终返回 <xref:System.Windows.LineBreakCondition.BreakDesired>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.BreakAfter" />
      </Docs>
    </Member>
    <Member MemberName="ContentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer ContentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer ContentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.ContentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ ContentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个指向 <see cref="T:System.Windows.Documents.TextPointer" /> 中内容的末尾的 <see cref="T:System.Windows.Controls.TextBlock" />。</summary>
        <value>指向 <see cref="T:System.Windows.Documents.TextPointer" /> 中内容的末尾的 <see cref="T:System.Windows.Controls.TextBlock" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内容的末尾将其视为直接在最后一个字符后面的插入位置<xref:System.Windows.Controls.TextBlock>。  
  
 <xref:System.Windows.Documents.TextPointer>返回此属性始终具有其<xref:System.Windows.Documents.LogicalDirection>设置为<xref:System.Windows.Documents.LogicalDirection.Forward>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.ContentStart" />
      </Docs>
    </Member>
    <Member MemberName="ContentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer ContentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer ContentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.ContentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ ContentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个指向 <see cref="T:System.Windows.Documents.TextPointer" /> 中内容的开始位置的 <see cref="T:System.Windows.Controls.TextBlock" />。</summary>
        <value>指向 <see cref="T:System.Windows.Documents.TextPointer" /> 中内容的开始位置的 <see cref="T:System.Windows.Controls.TextBlock" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内容的开始位置将其视为直接前面中的第一个字符的插入位置<xref:System.Windows.Controls.TextBlock>。  
  
 <xref:System.Windows.Documents.TextPointer>返回此属性始终具有其<xref:System.Windows.Documents.LogicalDirection>设置为<xref:System.Windows.Documents.LogicalDirection.Backward>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.ContentEnd" />
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Controls.TextBlock" /> 的首选顶级字体系列。</summary>
        <value>一个 <see cref="T:System.Windows.Media.FontFamily" /> 对象，指定首选字体系列，或者指定一个主要首选字体系列并附带一个或多个备用字体系列。 默认字体是由 <see cref="P:System.Windows.SystemFonts.MessageFontFamily" /> 值确定的字体。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何<xref:System.Windows.Controls.TextBlock.FontFamily%2A>子元素上的设置重写此顶层的设置。  
  
 如果指定多个系列，第二个和后续的字体系列用作备用系列可以用于中的情况下，主字体系列不可用或不适用。  
  
 此属性指定的首选项。  如果指定的字体系列不可用，<xref:System.Windows.Controls.TextBlock>以无提示方式回退到由确定的字体<xref:System.Windows.SystemFonts.MessageFontFamily%2A>值。  
  
 此依赖项属性还具有附加的属性的用法。 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，这种用法并`<`*对象* <xref:System.Windows.Controls.TextBlock.FontFamily%2A?displayProperty=nameWithType> `="`*值*`".../>`，其中*对象*是对象元素（通常流元素） 中包含<xref:System.Windows.Controls.TextBlock>，和*值*XAML 值中所述是字符串格式值之一。 在代码中，附加的属性使用情况受<xref:System.Windows.Controls.TextBlock.GetFontFamily%2A>和<xref:System.Windows.Controls.TextBlock.SetFontFamily%2A>。 附加的属性使用情况并不常用，因为大多数元素，可以包含在<xref:System.Windows.Controls.TextBlock>支持一个类似非附加`FontFamily`属性，其中<xref:System.Windows.Controls.TextBlock>用于呈现。  
  
<a name="xamlAttributeUsage_FontFamily"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object FontFamily="fontFamilyName"/>  
- or -  
<object FontFamily="fontFamilyNamesList"/>  
- or -  
<object FontFamily="fontFamilyFolderReference"/>  
- or -  
<object FontFamily="fontFamilyUriReference"/>  
```  
  
<a name="xamlValues_FontFamily"></a>   
## <a name="xaml-values"></a>XAML 值  
 *fontFamilyName*  
 指定字体系列名称的字符串。  例如，`"Arial"` 或 `"Century Gothic"`。  
  
 *fontFamilyNamesList*  
 一个字符串，指定多个字体系列名称，每个的逗号分隔 （逗号后面的任何空白将被忽略）。  指定的第一个字体系列用作主要字体系列中;后续的字体系列用作备用系列可以用于中的情况下，主字体系列不可用或不适用。  例如，`"Arial, Century Gothic"`指定 Arial 作为主字体系列，并附带世纪歌特作为回退字体系列。  
  
 *fontFamilyFolderReference*  
 一个字符串，指定包含字体，以及字体系列名称的文件夹。  由 # 字符分隔的文件夹和字体系列名称。  文件夹引用可能是绝对的或相对。  例如 `"Custom Fonts\#My Custom Font"`。  
  
 *fontFamilyUriReference*  
 一个字符串，指定[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]字体，以及字体系列名称。  [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]和字体系列名称由 # 字符分隔。  例如 `"http://MyFontServer/Fonts/#My Custom Font"`。  
  
<a name="dependencyPropertyInfo_FontFamily"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.FontFamilyProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.FontFamily%2A>属性<xref:System.Windows.Controls.TextBlock>元素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.FontFamily%2A>属性以编程方式。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Controls.TextBlock" /> 的顶级字号。</summary>
        <value>希望使用的字号，以与设备无关的像素为单位。 默认值由 <see cref="P:System.Windows.SystemFonts.MessageFontSize" /> 值确定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何<xref:System.Windows.Controls.TextBlock.FontSize%2A>子元素上的设置重写此顶层的设置。  
  
 此依赖项属性还具有附加的属性的用法。 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，这种用法并`<`*对象* <xref:System.Windows.Controls.TextBlock.FontSize%2A?displayProperty=nameWithType> `="`*值*`".../>`，其中*对象*是对象元素（通常流元素） 中包含<xref:System.Windows.Controls.TextBlock>，和*值*XAML 值中所述是字符串格式值之一。 在代码中，附加的属性使用情况受<xref:System.Windows.Controls.TextBlock.GetFontSize%2A>和<xref:System.Windows.Controls.TextBlock.SetFontSize%2A>。 附加的属性使用情况并不常用，因为大多数元素，可以包含在<xref:System.Windows.Controls.TextBlock>支持一个类似非附加`FontSize`属性，其中<xref:System.Windows.Controls.TextBlock>用于呈现。  
  
<a name="xamlAttributeUsage_FontSize"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object FontSize="double"/>  
- or -  
<object FontSize="qualifiedDouble"/>  
```  
  
<a name="xamlValues_FontSize"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字符串表示形式<xref:System.Double>值等于或大于 0.0，但小于<xref:System.Double.PositiveInfinity>。 未限定的值，以设备无关的像素为单位。 字符串不需要显式包括位小数。  
  
 *qualifiedDouble*  
 A *double*值如上所述后, 跟一个的以下单元说明符： `px`， `in`， `cm`， `pt`。  
  
 `px` （默认值） 是 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` is centimeters; 1cm==(96/2.54) px  
  
 `pt` is points; 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_FontSize"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.FontSizeProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.FontSize%2A>属性<xref:System.Windows.Controls.TextBlock>元素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.FontSize%2A>属性以编程方式。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretch">
      <MemberSignature Language="C#" Value="public System.Windows.FontStretch FontStretch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStretch FontStretch" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontStretch" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStretch As FontStretch" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStretch FontStretch { System::Windows::FontStretch get(); void set(System::Windows::FontStretch value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStretch</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Controls.TextBlock" /> 的顶级字体拉伸特征。</summary>
        <value>
          <see cref="T:System.Windows.FontStretch" /> 类的一个成员，指定希望使用的字体拉伸特征。 默认值为 <see cref="P:System.Windows.FontStretches.Normal" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何<xref:System.Windows.Controls.TextBlock.FontStretch%2A>子元素上的设置重写此顶层的设置。  
  
 此依赖项属性还具有附加的属性的用法。 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，这种用法并`<`*对象* <xref:System.Windows.Controls.TextBlock.FontStretch%2A?displayProperty=nameWithType> `="`*值*`".../>`，其中*对象*是对象元素（通常流元素） 中包含<xref:System.Windows.Controls.TextBlock>，和*值*是字符串格式之一的属性名称<xref:System.Windows.FontStretch>类。 在代码中，附加的属性使用情况受<xref:System.Windows.Controls.TextBlock.GetFontStretch%2A>和<xref:System.Windows.Controls.TextBlock.SetFontStretch%2A>。 附加的属性使用情况并不常用，因为大多数元素，可以包含在<xref:System.Windows.Controls.TextBlock>支持一个类似非附加`FontStretch`属性，其中<xref:System.Windows.Controls.TextBlock>用于呈现。  
  
<a name="dependencyPropertyInfo_FontStretch"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.FontStretchProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.FontStretch%2A>属性<xref:System.Windows.Controls.TextBlock>元素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.FontStretch%2A>属性以编程方式。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretchProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStretchProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStretchProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontStretchProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStretchProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStretchProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyle">
      <MemberSignature Language="C#" Value="public System.Windows.FontStyle FontStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStyle FontStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStyle As FontStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStyle FontStyle { System::Windows::FontStyle get(); void set(System::Windows::FontStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Controls.TextBlock" /> 的顶级字形。</summary>
        <value>
          <see cref="T:System.Windows.FontStyles" /> 类的一个成员，指定要使用的字体样式。 默认值由 <see cref="P:System.Windows.SystemFonts.MessageFontStyle" /> 值确定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何<xref:System.Windows.Controls.TextBlock.FontStyle%2A>子元素上的设置重写此顶层的设置。  
  
 此依赖项属性还具有附加的属性的用法。 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，这种用法并`<`*对象* <xref:System.Windows.Controls.TextBlock.FontStyle%2A?displayProperty=nameWithType> `="`*值*`".../>`，其中*对象*是对象元素（通常流元素） 中包含<xref:System.Windows.Controls.TextBlock>，和*值*是字符串格式之一中的属性名称<xref:System.Windows.FontStyles>类。 在代码中，附加的属性使用情况受<xref:System.Windows.Controls.TextBlock.GetFontStyle%2A>和<xref:System.Windows.Controls.TextBlock.SetFontStyle%2A>。 附加的属性使用情况并不常用，因为大多数元素，可以包含在<xref:System.Windows.Controls.TextBlock>支持一个类似非附加`FontStyle`属性，其中<xref:System.Windows.Controls.TextBlock>用于呈现。  
  
<a name="dependencyPropertyInfo_FontStyle"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.FontStyleProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.FontStyle%2A>属性<xref:System.Windows.Controls.TextBlock>元素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.FontStyle%2A>属性以编程方式。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeight">
      <MemberSignature Language="C#" Value="public System.Windows.FontWeight FontWeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontWeight FontWeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontWeight" />
      <MemberSignature Language="VB.NET" Value="Public Property FontWeight As FontWeight" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontWeight FontWeight { System::Windows::FontWeight get(); void set(System::Windows::FontWeight value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontWeight</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Controls.TextBlock" /> 的顶级字体粗细。</summary>
        <value>
          <see cref="T:System.Windows.FontWeights" /> 类的一个成员，指定要使用的字体粗细。 默认值由 <see cref="P:System.Windows.SystemFonts.MessageFontWeight" /> 值确定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何<xref:System.Windows.Controls.TextBlock.FontWeight%2A>子元素上的设置重写此顶层的设置。  
  
 字体粗细的有效值的列表，请参阅<xref:System.Windows.FontWeights>类。  
  
 此依赖项属性还具有附加的属性的用法。 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，这种用法并`<`*对象* <xref:System.Windows.Controls.TextBlock.FontWeight%2A?displayProperty=nameWithType> `="`*值*`".../>`，其中*对象*是对象元素（通常流元素） 中包含<xref:System.Windows.Controls.TextBlock>，和*值*是字符串格式值的属性之一<xref:System.Windows.FontWeights>类。 在代码中，附加的属性使用情况受<xref:System.Windows.Controls.TextBlock.GetFontWeight%2A>和<xref:System.Windows.Controls.TextBlock.SetFontWeight%2A>。 附加的属性使用情况并不常用，因为大多数元素，可以包含在<xref:System.Windows.Controls.TextBlock>支持一个类似非附加`FontWeight`属性，其中<xref:System.Windows.Controls.TextBlock>用于呈现。  
  
<a name="dependencyPropertyInfo_FontWeight"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.FontWeightProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.FontWeight%2A>属性<xref:System.Windows.Controls.TextBlock>元素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.FontWeight%2A>属性以编程方式。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontWeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontWeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontWeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontWeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontWeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要应用于 <see cref="T:System.Windows.Media.Brush" /> 的文本内容的 <see cref="T:System.Windows.Controls.TextBlock" />。</summary>
        <value>要应用于文本内容的画笔。 默认值为 <see cref="P:System.Windows.Media.Brushes.Black" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 显示可用的预定义的画笔颜色样本的表，请参阅<xref:System.Windows.Media.Brushes>。  
  
 任何<xref:System.Windows.Controls.TextBlock.Foreground%2A>子元素上的设置重写此顶层的设置。  
  
 此依赖项属性还具有附加的属性的用法。 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，这种用法并`<`*对象* <xref:System.Windows.Controls.TextBlock.Foreground%2A?displayProperty=nameWithType> `="`*值*`".../>`，其中*对象*是对象元素（通常流元素） 中包含<xref:System.Windows.Controls.TextBlock>，和*值*是一个字符串，将解析为<xref:System.Windows.Media.Brush>实现值。 在代码中，附加的属性使用情况受<xref:System.Windows.Controls.TextBlock.GetForeground%2A>和<xref:System.Windows.Controls.TextBlock.SetForeground%2A>。 附加的属性使用情况并不常用，因为大多数元素，可以包含在<xref:System.Windows.Controls.TextBlock>支持一个类似非附加`Foreground`属性，其中<xref:System.Windows.Controls.TextBlock>用于呈现。  
  
<a name="dependencyPropertyInfo_Foreground"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.ForegroundProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.Foreground%2A>属性<xref:System.Windows.Controls.TextBlock>元素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.Foreground%2A>属性以编程方式。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaselineOffset">
      <MemberSignature Language="C#" Value="public static double GetBaselineOffset (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetBaselineOffset(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetBaselineOffset(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBaselineOffset (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetBaselineOffset(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">从中检索 <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> 附加属性值的依赖项对象。</param>
        <summary>返回指定的依赖对象的 <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> 附加属性值。</summary>
        <returns>指定依赖项对象的 <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> 附加属性的当前值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetBaselineOffset(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontFamily">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.FontFamily GetFontFamily (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Media.FontFamily GetFontFamily(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontFamily(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontFamily (element As DependencyObject) As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::FontFamily ^ GetFontFamily(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">从中检索 <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> 附加属性值的依赖项对象。</param>
        <summary>返回指定的依赖对象的 <see cref="F:System.Windows.Controls.TextBlock.FontFamilyProperty" /> 附加属性值。</summary>
        <returns>指定依赖项对象的 <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> 附加属性的当前值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontFamily(System.Windows.DependencyObject,System.Windows.Media.FontFamily)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontSize">
      <MemberSignature Language="C#" Value="public static double GetFontSize (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetFontSize(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontSize(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontSize (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetFontSize(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">从中检索 <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> 附加属性值的依赖项对象。</param>
        <summary>返回指定的依赖对象的 <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> 附加属性值。</summary>
        <returns>指定依赖项对象的 <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> 附加属性的当前值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontSize(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontStretch">
      <MemberSignature Language="C#" Value="public static System.Windows.FontStretch GetFontStretch (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FontStretch GetFontStretch(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontStretch(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontStretch (element As DependencyObject) As FontStretch" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FontStretch GetFontStretch(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStretch</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">从中检索 <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> 附加属性值的依赖项对象。</param>
        <summary>返回指定的依赖对象的 <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> 附加属性值。</summary>
        <returns>指定依赖项对象的 <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> 附加属性的当前值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontStretch(System.Windows.DependencyObject,System.Windows.FontStretch)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontStyle">
      <MemberSignature Language="C#" Value="public static System.Windows.FontStyle GetFontStyle (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FontStyle GetFontStyle(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontStyle(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontStyle (element As DependencyObject) As FontStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FontStyle GetFontStyle(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStyle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">从中检索 <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> 附加属性值的依赖项对象。</param>
        <summary>返回指定的依赖对象的 <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> 附加属性值。</summary>
        <returns>指定依赖项对象的 <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> 附加属性的当前值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontStyle(System.Windows.DependencyObject,System.Windows.FontStyle)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontWeight">
      <MemberSignature Language="C#" Value="public static System.Windows.FontWeight GetFontWeight (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FontWeight GetFontWeight(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontWeight(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontWeight (element As DependencyObject) As FontWeight" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FontWeight GetFontWeight(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontWeight</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">从中检索 <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> 附加属性值的依赖项对象。</param>
        <summary>返回指定的依赖对象的 <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> 附加属性值。</summary>
        <returns>指定依赖项对象的 <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> 附加属性的当前值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontWeight(System.Windows.DependencyObject,System.Windows.FontWeight)" />
      </Docs>
    </Member>
    <Member MemberName="GetForeground">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.Brush GetForeground (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Media.Brush GetForeground(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetForeground(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetForeground (element As DependencyObject) As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::Brush ^ GetForeground(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">从中检索 <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> 附加属性值的依赖项对象。</param>
        <summary>返回指定的依赖对象的 <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> 附加属性值。</summary>
        <returns>指定依赖项对象的 <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> 附加属性的当前值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetForeground(System.Windows.DependencyObject,System.Windows.Media.Brush)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineHeight">
      <MemberSignature Language="C#" Value="public static double GetLineHeight (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetLineHeight(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetLineHeight(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLineHeight (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetLineHeight(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">从中检索 <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> 附加属性值的依赖项对象。</param>
        <summary>返回指定的依赖对象的 <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> 附加属性值。</summary>
        <returns>指定依赖项对象的 <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> 附加属性的当前值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetLineHeight(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineStackingStrategy">
      <MemberSignature Language="C#" Value="public static System.Windows.LineStackingStrategy GetLineStackingStrategy (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.LineStackingStrategy GetLineStackingStrategy(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetLineStackingStrategy(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLineStackingStrategy (element As DependencyObject) As LineStackingStrategy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::LineStackingStrategy GetLineStackingStrategy(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineStackingStrategy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">从中检索 <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> 附加属性值的依赖项对象。</param>
        <summary>返回指定的依赖对象的 <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> 附加属性值。</summary>
        <returns>指定依赖项对象的 <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> 附加属性的当前值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetLineStackingStrategy(System.Windows.DependencyObject,System.Windows.LineStackingStrategy)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionFromPoint (System.Windows.Point point, bool snapToText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionFromPoint(valuetype System.Windows.Point point, bool snapToText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetPositionFromPoint(System.Windows.Point,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionFromPoint(System::Windows::Point point, bool snapToText);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="snapToText" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point">
          <see cref="T:System.Windows.Point" /> 的坐标空间中的一个 <see cref="T:System.Windows.Controls.TextBlock" />，将返回一个表示该点的 <see cref="T:System.Windows.Documents.TextPointer" />。</param>
        <param name="snapToText">
          如果为 <see langword="true" />，则返回一个指向最靠近<c>point</c> 的插入点的 <see cref="T:System.Windows.Documents.TextPointer" />，而不管 <c>point</c> 是否位于某个字符的边界框内；如果为 <see langword="false" />，则当 <c>point</c> 没有位于某个字符的边界框内时，返回 <see langword="null" />。</param>
        <summary>返回指向最靠近指定 <see cref="T:System.Windows.Documents.TextPointer" /> 的位置的 <see cref="T:System.Windows.Point" />。</summary>
        <returns>指向指定点的 <see cref="T:System.Windows.Documents.TextPointer" />；或者，如果 <paramref name="snapToText" /> 为 <see langword="null" /> 并且指定点没有位于 <see cref="T:System.Windows.Controls.TextBlock" /> 内容区域中的某个字符边界框内，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法始终返回一个有效<xref:System.Windows.Documents.TextPointer>时`snapToText`是`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该控件的有效布局信息目前不可用。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRectanglesCore">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt; GetRectanglesCore (System.Windows.ContentElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;valuetype System.Windows.Rect&gt; GetRectanglesCore(class System.Windows.ContentElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetRectanglesCore(System.Windows.ContentElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRectanglesCore (child As ContentElement) As ReadOnlyCollection(Of Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Rect&gt; ^ GetRectanglesCore(System::Windows::ContentElement ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.ContentElement" />
      </Parameters>
      <Docs>
        <param name="child">要为其生成并返回一个边框集合的 <see cref="T:System.Windows.ContentElement" />。</param>
        <summary>返回指定的 <see cref="T:System.Windows.ContentElement" /> 的边框的只读集合。</summary>
        <returns>指定的 <see cref="T:System.Windows.ContentElement" /> 的边框的只读集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 集合中的每个边界矩形对应的一行中的内容<xref:System.Windows.ContentElement>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="child" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTextAlignment">
      <MemberSignature Language="C#" Value="public static System.Windows.TextAlignment GetTextAlignment (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.TextAlignment GetTextAlignment(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetTextAlignment(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTextAlignment (element As DependencyObject) As TextAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::TextAlignment GetTextAlignment(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">从中检索 <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> 附加属性值的依赖项对象。</param>
        <summary>返回指定的依赖对象的 <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> 附加属性值。</summary>
        <returns>指定依赖项对象的 <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> 附加属性的当前值。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetTextAlignment(System.Windows.DependencyObject,System.Windows.TextAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">一个从零开始的索引，指定要返回的 <see cref="T:System.Windows.Media.Visual" /> 子项。  该值必须介于 0 和（<see cref="P:System.Windows.Controls.TextBlock.VisualChildrenCount" /> 减 1）之间。</param>
        <summary>返回指定索引位置处的 <see cref="T:System.Windows.Media.Visual" /> 子项。</summary>
        <returns>位于指定索引位置处的 <see cref="T:System.Windows.Media.Visual" /> 子项。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Windows.FrameworkElement.GetVisualChild%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 不在 0 和（<see cref="P:System.Windows.Controls.TextBlock.VisualChildrenCount" /> 减 1）之间。</exception>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function HitTestCore (hitTestParameters As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">一个 <see cref="T:System.Windows.Media.PointHitTestParameters" /> 对象，指定命中测试的参数。</param>
        <summary>返回指定 <see cref="T:System.Windows.Media.PointHitTestResult" /> 的 <see cref="T:System.Windows.Media.PointHitTestParameters" />。</summary>
        <returns>所指定命中测试参数的 <see cref="T:System.Windows.Media.PointHitTestResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法旨在启用呈现内容的精确命中测试。  
  
 此方法重写 <xref:System.Windows.UIElement.HitTestCore%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hitTestParameters" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="HostedElementsCore">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt; HostedElementsCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerator`1&lt;class System.Windows.IInputElement&gt; HostedElementsCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.HostedElementsCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property HostedElementsCore As IEnumerator(Of IInputElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ HostedElementsCore { System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个可用于迭代此 <see cref="T:System.Windows.Controls.TextBlock" /> 承载的元素的枚举数。</summary>
        <value>可用于迭代此 <see cref="T:System.Windows.Controls.TextBlock" /> 承载的元素的枚举数。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Inlines">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.InlineCollection Inlines { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.InlineCollection Inlines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Inlines" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Inlines As InlineCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::InlineCollection ^ Inlines { System::Windows::Documents::InlineCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.InlineCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Windows.Documents.InlineCollection" />，其中包含组成 <see cref="T:System.Windows.Documents.Inline" /> 内容的顶级 <see cref="T:System.Windows.Controls.TextBlock" /> 元素。</summary>
        <value>一个 <see cref="T:System.Windows.Documents.InlineCollection" />，其中包含组成 <see cref="T:System.Windows.Documents.Inline" /> 内容的 <see cref="T:System.Windows.Controls.TextBlock" /> 元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Windows.Documents.InlineCollection>此属性来枚举或操作的内容返回<xref:System.Windows.Controls.TextBlock>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputHitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.IInputElement InputHitTestCore (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.IInputElement InputHitTestCore(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.InputHitTestCore(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::IInputElement ^ InputHitTestCore(System::Windows::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">
          <see cref="T:System.Windows.Point" /> 的坐标空间中的一个 <see cref="T:System.Windows.Controls.TextBlock" />，将返回与它对应的 <see cref="T:System.Windows.IInputElement" />。</param>
        <summary>返回 <see cref="T:System.Windows.IInputElement" /> 内指定 <see cref="T:System.Windows.Point" /> 处的 <see cref="T:System.Windows.Controls.TextBlock" />。</summary>
        <returns>在指定点处找到的 <see cref="T:System.Windows.IInputElement" />；或者，如果无法找到这类 <see cref="T:System.Windows.IInputElement" />，则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHyphenationEnabled">
      <MemberSignature Language="C#" Value="public bool IsHyphenationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHyphenationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.IsHyphenationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsHyphenationEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHyphenationEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否启用文字的自动断字功能。</summary>
        <value>
          <see langword="true" /> 指示自动对文字进行断字和添加连字符；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 自动断字功能使<xref:System.Windows.Controls.TextBlock>以自动中断并添加连字符的单词，根据当前布局情况。  这使得较长的单词要开始在同一行并继续到下，从而更均匀地分布的两端对齐文本中的空白区域。  单词是损坏的根据标准的语法规则添加连字符。  
  
<a name="dependencyPropertyInfo_IsHyphenationEnabled"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.IsHyphenationEnabledProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.IsHyphenationEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsHyphenationEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsHyphenationEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsHyphenationEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.IsHyphenationEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsHyphenationEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsHyphenationEnabledProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.IsHyphenationEnabled" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineHeight">
      <MemberSignature Language="C#" Value="public double LineHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 LineHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.LineHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property LineHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double LineHeight { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置各行内容的高度。</summary>
        <value>行的高度范围为 0.0034 到 160000，以与设备无关的像素为单位。 值为<see cref="F:System.Double.NaN" />(等效于特性值的"<c>自动</c>") 指示行高度由当前字体特征自动确定。 默认值为 <see cref="F:System.Double.NaN" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 更改此值不会更改关联的文本; 的高度相反，它将更改包含文本行的高度。 若要更改的文本大小，使用<xref:System.Windows.Controls.TextBlock.FontSize%2A>属性。  
  
 除了此属性中的行的布局<xref:System.Windows.Controls.TextBlock>受其<xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A>属性。  
  
 此依赖项属性还具有附加的属性的用法。 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，这种用法并`<`*对象* <xref:System.Windows.Controls.TextBlock.LineHeight%2A?displayProperty=nameWithType> `="`*值*`".../>`，其中*对象*是对象元素（通常流元素） 中包含<xref:System.Windows.Controls.TextBlock>，和*值*是一个字符串，如 XAML 值中所述。 在代码中，附加的属性使用情况受<xref:System.Windows.Controls.TextBlock.GetLineHeight%2A>和<xref:System.Windows.Controls.TextBlock.SetLineHeight%2A>。 附加的属性使用情况不常见。  
  
<a name="xamlAttributeUsage_LineHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object LineHeight="double"/>  
- or -  
<object LineHeight="qualifiedDouble"/>  
- or -  
<object LineHeight="Auto"/>  
```  
  
<a name="xamlValues_LineHeight"></a>   
## <a name="xaml-values"></a>XAML 值  
 *double*  
 <xref:System.Double>  
  
 字符串表示形式<xref:System.Double>值等于或大于`0.0034`且等于或小于`160000`。 未限定的值，以设备无关的像素为单位。 字符串不需要显式包括位小数。  
  
 *qualifiedDouble*  
 A *double*值，上文所述 (除外`Auto`) 后跟一个以下单元说明符： `px`， `in`， `cm`， `pt`。  
  
 `px` （默认值） 是 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` is centimeters; 1cm==(96/2.54) px  
  
 `pt` is points; 1pt==(96/72) px  
  
 自动  
 使行高度由当前字体特征自动确定。  等效于属性值的<xref:System.Double.NaN?displayProperty=nameWithType>。  
  
<a name="dependencyPropertyInfo_LineHeight"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.LineHeightProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.LineHeight%2A>属性<xref:System.Windows.Controls.TextBlock>元素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.LineHeight%2A>属性以编程方式。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          将 <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> 设置为非正值。</exception>
        <altmember cref="P:System.Windows.Documents.FlowDocument.LineHeight" />
      </Docs>
    </Member>
    <Member MemberName="LineHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.LineHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineHeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategy">
      <MemberSignature Language="C#" Value="public System.Windows.LineStackingStrategy LineStackingStrategy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineStackingStrategy LineStackingStrategy" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.LineStackingStrategy" />
      <MemberSignature Language="VB.NET" Value="Public Property LineStackingStrategy As LineStackingStrategy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineStackingStrategy LineStackingStrategy { System::Windows::LineStackingStrategy get(); void set(System::Windows::LineStackingStrategy value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineStackingStrategy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置为 <see cref="T:System.Windows.Controls.TextBlock" /> 内的每行文本确定行框的机制。</summary>
        <value>一种机制，根据该机制来为 <see cref="T:System.Windows.Controls.TextBlock" /> 内的每一行文本确定一个行框。 默认值为 <see cref="F:System.Windows.LineStackingStrategy.MaxHeight" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此依赖项属性还具有附加的属性的用法。 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，这种用法并`<`*对象* <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A?displayProperty=nameWithType> `="`*值*`".../>`，其中*对象*是对象元素（通常流元素） 中包含<xref:System.Windows.Controls.TextBlock>，和*值*是一个字符串值的<xref:System.Windows.LineStackingStrategy>枚举。 在代码中，附加的属性使用情况受<xref:System.Windows.Controls.TextBlock.GetLineStackingStrategy%2A>和<xref:System.Windows.Controls.TextBlock.SetLineStackingStrategy%2A>。 附加的属性使用情况不常见。  
  
<a name="dependencyPropertyInfo_LineStackingStrategy"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.LineStackingStrategyProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A>属性来确定行框的文本行的创建方式<xref:System.Windows.Controls.TextBlock>。 第一个<xref:System.Windows.Controls.TextBlock>具有<xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A>值<xref:System.Windows.LineStackingStrategy.MaxHeight>和第二个<xref:System.Windows.Controls.TextBlock>的值为<xref:System.Windows.LineStackingStrategy.BlockLineHeight>。  
  
 [!code-xaml[FlowMiscSnippets_snip#LineStackingStrategyExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowMiscSnippets_snip/cs/linestackingstrategyexample.xaml#linestackingstrategyexamplewholepage)]  
  
 下图显示上述代码的结果。  
  
 ![屏幕快照： 比较 LineStackingStrategy 值](~/add/media/flow-linestackingstrategy.gif "屏幕快照： 比较 LineStackingStrategy 值")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineStackingStrategyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineStackingStrategyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.LineStackingStrategyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineStackingStrategyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineStackingStrategyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个可循环访问 <see cref="T:System.Windows.Controls.TextBlock" /> 的逻辑子级的枚举器。</summary>
        <value>用于逻辑子级的枚举数。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">一个 <see cref="T:System.Windows.Size" /> 结构，指定对 <see cref="T:System.Windows.Controls.TextBlock" /> 大小的任何约束。</param>
        <summary>调用以重新测量 <see cref="T:System.Windows.Controls.TextBlock" />。</summary>
        <returns>一个 <see cref="T:System.Windows.Size" /> 结构，指示 <see cref="T:System.Windows.Controls.TextBlock" /> 的新大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重写此方法以实现自定义调整大小行为。  
  
 此方法重写 <xref:System.Windows.FrameworkElement.MeasureOverride%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChildDesiredSizeChangedCore">
      <MemberSignature Language="C#" Value="protected virtual void OnChildDesiredSizeChangedCore (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChildDesiredSizeChangedCore(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnChildDesiredSizeChangedCore(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChildDesiredSizeChangedCore (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChildDesiredSizeChangedCore(System::Windows::UIElement ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">其 <see cref="T:System.Windows.UIElement" /> 发生改变的 <see cref="P:System.Windows.UIElement.DesiredSize" /> 子元素。</param>
        <summary>当派生自 <see cref="T:System.Windows.UIElement" /> 的子元素更改其 <see cref="P:System.Windows.UIElement.DesiredSize" /> 时调用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建并返回此 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 的 <see cref="T:System.Windows.Controls.TextBlock" /> 对象。</summary>
        <returns>此 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 的 <see cref="T:System.Windows.Controls.TextBlock" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override sealed void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">关联事件的自变量。</param>
        <summary>当一个或多个托管依赖属性的值发生更改时调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyChangedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnRender">
      <MemberSignature Language="C#" Value="protected override sealed void OnRender (System.Windows.Media.DrawingContext ctx);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnRender(class System.Windows.Media.DrawingContext ctx) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnRender(System.Windows.Media.DrawingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub OnRender (ctx As DrawingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnRender(System::Windows::Media::DrawingContext ^ ctx);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctx" Type="System.Windows.Media.DrawingContext" />
      </Parameters>
      <Docs>
        <param name="ctx">要在其上呈现该控件的 <see cref="T:System.Windows.Media.DrawingContext" />。</param>
        <summary>呈现 <see cref="T:System.Windows.Controls.TextBlock" /> 的内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法，该布局系统来呈现的内容<xref:System.Windows.Controls.TextBlock>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ctx" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Padding { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示内容区域的边界与 <see cref="T:System.Windows.Controls.TextBlock" /> 所显示内容之间的边距的宽度。</summary>
        <value>A<see cref="T:System.Windows.Thickness" />结构，它指定要应用，以设备独立像素为单位的填充量。 默认值为 <see cref="F:System.Double.NaN" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.TextBlock.Padding%2A> 被描述为所有方向的一致性 (`Padding="10"`)，或如四个不同值表示保留，排名靠前的、 右键，并底部独立填充 (`Padding="5,0,10,20"`)。  
  
 如果指定的填充厚度超过相应内容区域的尺寸 （例如，左、 右边距宽度的总和超出内容区域宽度） 的填充厚度按比例缩小以不能大于相关内容区域的尺寸。  
  
<a name="xamlAttributeUsage_Padding"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object Padding="uniformThickness"/>  
- or -  
<object Padding="independentThickness"/>  
- or -  
<object Padding="qualifiedUniformThickness"/>  
- or -  
<object Padding="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_Padding"></a>   
## <a name="xaml-values"></a>XAML 值  
 *uniformThickness*  
 单个的字符串表示形式<xref:System.Double>要统一应用于所有四个宽度尺寸值。  例如，值`"10"`等效于值为`"10,10,10,10"`。  未限定的值，以设备无关的像素为单位。 字符串不需要显式包括位小数。  
  
 *independentThickness*  
 四个有序的字符串表示形式<xref:System.Double>值对应于左侧、 顶部、 的独立粗细维度右键，和下，按此顺序。  必须用逗号; 分隔的四个值不允许有空格。  例如，"5,10,15,20"生成的 5 个像素的填充左侧的内容、 内容上方的填充的 10 个像素、 15 像素的内容，右侧的填充和 20 像素的以下内容的填充。  
  
 *qualifiedUniformThickness*  
 所描述的值*uniformThickness*后跟一个以下单元说明符： `px`， `in`。  
  
 `px` （默认值） 是 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 例如，`"1in"`提供的所有方向 1 英寸的统一填充。  
  
 *qualifiedIndependentThickness*  
 所描述的值*independentThickness*后, 跟一个以下单元说明符每个独立值： `px`， `in`。  
  
 `px` （默认值） 是 [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 例如 `"1.5in,0.8in,1.5in,0.8in"`。  可能混合或者一个或多个值中省略单元说明符。  
  
<a name="dependencyPropertyInfo_Padding"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.PaddingProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.Padding%2A>属性<xref:System.Windows.Controls.TextBlock>元素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.Padding%2A>属性以编程方式。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PaddingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PaddingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.PaddingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PaddingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PaddingProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.Padding" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBaselineOffset">
      <MemberSignature Language="C#" Value="public static void SetBaselineOffset (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBaselineOffset(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetBaselineOffset(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetBaselineOffset (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBaselineOffset(System::Windows::DependencyObject ^ element, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">要设置其 <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> 属性的值的依赖项对象。</param>
        <param name="value">要将此属性设为的新值。</param>
        <summary>设置指定的依赖对象上的 <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> 附加属性值。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetBaselineOffset(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontFamily">
      <MemberSignature Language="C#" Value="public static void SetFontFamily (System.Windows.DependencyObject element, System.Windows.Media.FontFamily value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontFamily(class System.Windows.DependencyObject element, class System.Windows.Media.FontFamily value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontFamily(System.Windows.DependencyObject,System.Windows.Media.FontFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontFamily (element As DependencyObject, value As FontFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontFamily(System::Windows::DependencyObject ^ element, System::Windows::Media::FontFamily ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.Media.FontFamily" />
      </Parameters>
      <Docs>
        <param name="element">要设置其 <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> 属性的值的依赖项对象。</param>
        <param name="value">要将此属性设为的新值。</param>
        <summary>设置指定的依赖对象上的 <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> 附加属性值。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontFamily(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontSize">
      <MemberSignature Language="C#" Value="public static void SetFontSize (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontSize(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontSize(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontSize (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontSize(System::Windows::DependencyObject ^ element, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">要设置其 <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> 属性的值的依赖项对象。</param>
        <param name="value">要将此属性设为的新值。</param>
        <summary>设置指定的依赖对象上的 <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> 附加属性值。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontSize(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontStretch">
      <MemberSignature Language="C#" Value="public static void SetFontStretch (System.Windows.DependencyObject element, System.Windows.FontStretch value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontStretch(class System.Windows.DependencyObject element, valuetype System.Windows.FontStretch value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontStretch(System.Windows.DependencyObject,System.Windows.FontStretch)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontStretch (element As DependencyObject, value As FontStretch)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontStretch(System::Windows::DependencyObject ^ element, System::Windows::FontStretch value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FontStretch" />
      </Parameters>
      <Docs>
        <param name="element">要设置其 <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> 属性的值的依赖项对象。</param>
        <param name="value">要将此属性设为的新值。</param>
        <summary>设置指定的依赖对象上的 <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> 附加属性值。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontStretch(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontStyle">
      <MemberSignature Language="C#" Value="public static void SetFontStyle (System.Windows.DependencyObject element, System.Windows.FontStyle value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontStyle(class System.Windows.DependencyObject element, valuetype System.Windows.FontStyle value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontStyle(System.Windows.DependencyObject,System.Windows.FontStyle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontStyle (element As DependencyObject, value As FontStyle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontStyle(System::Windows::DependencyObject ^ element, System::Windows::FontStyle value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FontStyle" />
      </Parameters>
      <Docs>
        <param name="element">要设置其 <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> 属性的值的依赖项对象。</param>
        <param name="value">要将此属性设为的新值。</param>
        <summary>设置指定的依赖对象上的 <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> 附加属性值。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontStyle(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontWeight">
      <MemberSignature Language="C#" Value="public static void SetFontWeight (System.Windows.DependencyObject element, System.Windows.FontWeight value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontWeight(class System.Windows.DependencyObject element, valuetype System.Windows.FontWeight value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontWeight(System.Windows.DependencyObject,System.Windows.FontWeight)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontWeight (element As DependencyObject, value As FontWeight)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontWeight(System::Windows::DependencyObject ^ element, System::Windows::FontWeight value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FontWeight" />
      </Parameters>
      <Docs>
        <param name="element">要设置其 <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> 属性的值的依赖项对象。</param>
        <param name="value">要将此属性设为的新值。</param>
        <summary>设置指定的依赖对象上的 <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> 附加属性值。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontWeight(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetForeground">
      <MemberSignature Language="C#" Value="public static void SetForeground (System.Windows.DependencyObject element, System.Windows.Media.Brush value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetForeground(class System.Windows.DependencyObject element, class System.Windows.Media.Brush value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetForeground(System.Windows.DependencyObject,System.Windows.Media.Brush)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetForeground (element As DependencyObject, value As Brush)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetForeground(System::Windows::DependencyObject ^ element, System::Windows::Media::Brush ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.Media.Brush" />
      </Parameters>
      <Docs>
        <param name="element">要设置其 <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> 属性的值的依赖项对象。</param>
        <param name="value">要将此属性设为的新值。</param>
        <summary>设置指定的依赖对象上的 <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> 附加属性值。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetForeground(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetLineHeight">
      <MemberSignature Language="C#" Value="public static void SetLineHeight (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLineHeight(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetLineHeight(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLineHeight (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLineHeight(System::Windows::DependencyObject ^ element, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">要设置其 <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> 属性的值的依赖项对象。</param>
        <param name="value">要将此属性设为的新值。</param>
        <summary>设置指定的依赖对象上的 <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> 附加属性值。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          将 <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> 设置为非正值。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetLineHeight(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetLineStackingStrategy">
      <MemberSignature Language="C#" Value="public static void SetLineStackingStrategy (System.Windows.DependencyObject element, System.Windows.LineStackingStrategy value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLineStackingStrategy(class System.Windows.DependencyObject element, valuetype System.Windows.LineStackingStrategy value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetLineStackingStrategy(System.Windows.DependencyObject,System.Windows.LineStackingStrategy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLineStackingStrategy (element As DependencyObject, value As LineStackingStrategy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLineStackingStrategy(System::Windows::DependencyObject ^ element, System::Windows::LineStackingStrategy value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.LineStackingStrategy" />
      </Parameters>
      <Docs>
        <param name="element">要设置其 <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> 属性的值的依赖项对象。</param>
        <param name="value">要将此属性设为的新值。</param>
        <summary>设置指定的依赖对象上的 <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> 附加属性值。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontSize(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetTextAlignment">
      <MemberSignature Language="C#" Value="public static void SetTextAlignment (System.Windows.DependencyObject element, System.Windows.TextAlignment value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTextAlignment(class System.Windows.DependencyObject element, valuetype System.Windows.TextAlignment value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetTextAlignment(System.Windows.DependencyObject,System.Windows.TextAlignment)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTextAlignment (element As DependencyObject, value As TextAlignment)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTextAlignment(System::Windows::DependencyObject ^ element, System::Windows::TextAlignment value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.TextAlignment" />
      </Parameters>
      <Docs>
        <param name="element">要设置其 <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> 属性的值的依赖项对象。</param>
        <param name="value">要将此属性设为的新值。</param>
        <summary>设置指定的依赖对象上的 <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> 附加属性值。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetTextAlignment(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeBaselineOffset">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeBaselineOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeBaselineOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ShouldSerializeBaselineOffset" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeBaselineOffset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeBaselineOffset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示在序列化 <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> 对象期间，是否应对 <see cref="T:System.Windows.Controls.TextBlock" /> 属性的有效值进行序列化。</summary>
        <returns>
          如果 <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> 属性应被序列化，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInlines">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInlines (System.Windows.Markup.XamlDesignerSerializationManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInlines(class System.Windows.Markup.XamlDesignerSerializationManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ShouldSerializeInlines(System.Windows.Markup.XamlDesignerSerializationManager)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInlines (manager As XamlDesignerSerializationManager) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInlines(System::Windows::Markup::XamlDesignerSerializationManager ^ manager);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.Windows.Markup.XamlDesignerSerializationManager" />
      </Parameters>
      <Docs>
        <param name="manager">此对象的序列化服务管理器对象。</param>
        <summary>返回一个值，该值指示在序列化 <see cref="P:System.Windows.Controls.TextBlock.Inlines" /> 对象期间，是否应对 <see cref="T:System.Windows.Controls.TextBlock" /> 属性的有效值进行序列化。</summary>
        <returns>
          如果 <see cref="P:System.Windows.Controls.TextBlock.Inlines" /> 属性应被序列化，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="manager" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeText">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ShouldSerializeText" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeText () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeText();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个值，该值指示在序列化 <see cref="P:System.Windows.Controls.TextBlock.Text" /> 对象期间，是否应对 <see cref="T:System.Windows.Controls.TextBlock" /> 属性的有效值进行序列化。</summary>
        <returns>
          如果 <see cref="P:System.Windows.Controls.TextBlock.Text" /> 属性应被序列化，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (serviceType As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ serviceType) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">一个对象，它指定要获取的服务对象的类型。</param>
        <summary>此方法支持 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基础结构，不能在代码中直接使用。</summary>
        <returns>
          <paramref name="serviceType" /> 类型的服务对象；如果没有 <paramref name="serviceType" /> 类型的服务对象，则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.GetRectangles">
      <MemberSignature Language="C#" Value="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt; IContentHost.GetRectangles (System.Windows.ContentElement child);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;valuetype System.Windows.Rect&gt; System.Windows.IContentHost.GetRectangles(class System.Windows.ContentElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#IContentHost#GetRectangles(System.Windows.ContentElement)" />
      <MemberSignature Language="VB.NET" Value="Function GetRectangles (child As ContentElement) As ReadOnlyCollection(Of Rect) Implements IContentHost.GetRectangles" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Rect&gt; ^ System.Windows.IContentHost.GetRectangles(System::Windows::ContentElement ^ child) = System::Windows::IContentHost::GetRectangles;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IContentHost.GetRectangles(System.Windows.ContentElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.ContentElement" />
      </Parameters>
      <Docs>
        <param name="child">要为其生成并返回一个边框集合的 <see cref="T:System.Windows.ContentElement" />。</param>
        <summary>此方法支持 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基础结构，不能在代码中直接使用。  改用类型安全的 <see cref="M:System.Windows.Controls.TextBlock.GetRectanglesCore(System.Windows.ContentElement)" /> 方法。</summary>
        <returns>指定的 <see cref="T:System.Windows.ContentElement" /> 的边框的只读集合。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.HostedElements">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt; System.Windows.IContentHost.HostedElements { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerator`1&lt;class System.Windows.IInputElement&gt; System.Windows.IContentHost.HostedElements" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.System#Windows#IContentHost#HostedElements" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HostedElements As IEnumerator(Of IInputElement) Implements IContentHost.HostedElements" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ System.Windows.IContentHost.HostedElements { System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IContentHost.HostedElements</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此类型或成员支持 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基础结构，但不可直接在代码中使用。  请改用类型安全的 <see cref="P:System.Windows.Controls.TextBlock.HostedElementsCore" /> 属性。</summary>
        <value>由内容宿主承载的元素。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.InputHitTest">
      <MemberSignature Language="C#" Value="System.Windows.IInputElement IContentHost.InputHitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Windows.IInputElement System.Windows.IContentHost.InputHitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#IContentHost#InputHitTest(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Windows::IInputElement ^ System.Windows.IContentHost.InputHitTest(System::Windows::Point point) = System::Windows::IContentHost::InputHitTest;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IContentHost.InputHitTest(System.Windows.Point)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">相对于内容宿主的鼠标坐标。</param>
        <summary>此方法支持 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基础结构，不能在代码中直接使用。  改用类型安全的 <see cref="M:System.Windows.Controls.TextBlock.InputHitTestCore(System.Windows.Point)" /> 方法。</summary>
        <returns>已命中的元素。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.OnChildDesiredSizeChanged">
      <MemberSignature Language="C#" Value="void IContentHost.OnChildDesiredSizeChanged (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.IContentHost.OnChildDesiredSizeChanged(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#IContentHost#OnChildDesiredSizeChanged(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Sub OnChildDesiredSizeChanged (child As UIElement) Implements IContentHost.OnChildDesiredSizeChanged" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.IContentHost.OnChildDesiredSizeChanged(System::Windows::UIElement ^ child) = System::Windows::IContentHost::OnChildDesiredSizeChanged;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IContentHost.OnChildDesiredSizeChanged(System.Windows.UIElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">其 <see cref="T:System.Windows.UIElement" /> 发生改变的 <see cref="P:System.Windows.UIElement.DesiredSize" /> 子元素。</param>
        <summary>此方法支持 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基础结构，不能在代码中直接使用。  改用类型安全的 <see cref="M:System.Windows.Controls.TextBlock.OnChildDesiredSizeChangedCore(System.Windows.UIElement)" /> 方法。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要作为子级添加的对象。</param>
        <summary>此成员支持 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基础结构，但不能在代码中直接使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">要添加到该对象的字符串。</param>
        <summary>此成员支持 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基础结构，但不能在代码中直接使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Text)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Controls.TextBlock" /> 的文本内容。</summary>
        <value>此 <see cref="T:System.Windows.Controls.TextBlock" /> 的文本内容。 注意，所有非文本内容将被剥除，从而获得 <see cref="T:System.Windows.Controls.TextBlock" /> 内容的纯文本表示。 默认值为 <see cref="F:System.String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你想要显示纯文本格式时使用此属性<xref:System.Windows.Controls.TextBlock>。  当你需要设置文本格式时，添加<xref:System.Windows.Documents.Inline>对象添加到<xref:System.Windows.Controls.TextBlock.Inlines%2A>属性。  
  
<a name="dependencyPropertyInfo_Text"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.TextProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.Text%2A>属性<xref:System.Windows.Controls.TextBlock>元素。  
  
 [!code-xaml[SpanSnippets#_TextBlock_Text1XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/SpanSnippets/CSharp/Window1.xaml#_textblock_text1xaml)]  
  
 或者，运行文本的内容可能只需包含通过<xref:System.Windows.Controls.TextBlock>元素标记。  
  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.Text%2A>属性以编程方式。  
  
 [!code-csharp[SpanSnippets#_TextBlock_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/SpanSnippets/CSharp/Window1.xaml.cs#_textblock_text)]
 [!code-vb[SpanSnippets#_TextBlock_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/SpanSnippets/visualbasic/window1.xaml.vb#_textblock_text)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.TextAlignment TextAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextAlignment TextAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property TextAlignment As TextAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextAlignment TextAlignment { System::Windows::TextAlignment get(); void set(System::Windows::TextAlignment value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示文本内容的水平对齐方式。</summary>
        <value>
          <see cref="T:System.Windows.TextAlignment" /> 值之一，它指定所需对齐方式。 默认值为 <see cref="F:System.Windows.TextAlignment.Left" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此依赖项属性还具有附加的属性的用法。 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，这种用法并`<`*对象* <xref:System.Windows.Controls.TextBlock.TextAlignment%2A?displayProperty=nameWithType> `="`*值*`".../>`，其中*对象*是对象元素（通常流元素） 中包含<xref:System.Windows.Controls.TextBlock>，和*值*是一个字符串值的<xref:System.Windows.TextAlignment>枚举。 在代码中，附加的属性使用情况受<xref:System.Windows.Controls.TextBlock.GetTextAlignment%2A>和<xref:System.Windows.Controls.TextBlock.SetTextAlignment%2A>。 附加的属性使用情况不常见。  
  
<a name="dependencyPropertyInfo_TextAlignment"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.TextAlignmentProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.TextAlignment%2A>属性<xref:System.Windows.Controls.TextBlock>元素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.TextAlignment%2A>属性以编程方式。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.TextAlignment" />
      </Docs>
    </Member>
    <Member MemberName="TextAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextAlignmentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextDecorations">
      <MemberSignature Language="C#" Value="public System.Windows.TextDecorationCollection TextDecorations { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TextDecorationCollection TextDecorations" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextDecorations" />
      <MemberSignature Language="VB.NET" Value="Public Property TextDecorations As TextDecorationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextDecorationCollection ^ TextDecorations { System::Windows::TextDecorationCollection ^ get(); void set(System::Windows::TextDecorationCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextDecorationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.TextDecorationCollection" />，它包含应用于 <see cref="T:System.Windows.Controls.TextBlock" /> 的文本的效果。</summary>
        <value>一个 <see cref="T:System.Windows.TextDecorationCollection" /> 集合，它包含应用于此元素的文本修饰。 默认值为 <see langword="null" />（不应用任何文本修饰）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.TextDecoration>对象是你可以将其添加到文本的视觉装饰。 文本修饰的四种类型： 下划线、 基线、 删除线和上划线。  文本修饰的详细信息，请参阅[如何： 创建文本效果](~/docs/framework/wpf/advanced/how-to-create-a-text-decoration.md)。  
  
 默认情况下，此属性设置为`null`，并且没有<xref:System.Windows.TextDecorationCollection>与之关联。  在添加任何文本效果之前, 创建一个新<xref:System.Windows.TextDecorationCollection>并将其分配给此属性。  
  
<a name="dependencyPropertyInfo_TextDecorations"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.TextDecorationsProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.TextDecorations%2A>属性。  
  
 [!code-xaml[InlineSnippets#_TextBlock_TextDecXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/InlineSnippets/CSharp/Window1.xaml#_textblock_textdecxaml)]  
  
 下图显示了此示例的呈现效果。  
  
 ![屏幕快照： 具有默认删除线效果的文本](~/add/media/inline-textdec-strike.png "屏幕快照： 具有默认删除线效果的文本")  
  
 下图显示了<xref:System.Windows.TextDecorations.OverLine%2A>， <xref:System.Windows.TextDecorations.Baseline%2A>，和<xref:System.Windows.TextDecorations.Underline%2A>修饰呈现，分别。  
  
 ![屏幕快照： 上划线划线 TextDecorator](~/add/media/inline-textdec-over.png "屏幕快照： 上划线划线 TextDecorator")  
  
 ![屏幕快照： 默认基线效果文本](~/add/media/inline-textdec-base.png "屏幕快照： 默认基线效果文本")  
  
 ![屏幕快照： 具有默认下划线效果的文本](~/add/media/inline-textdec-under.png "屏幕快照： 具有默认下划线效果的文本")  
  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.TextDecorations%2A>属性以编程方式。  
  
 [!code-csharp[InlineSnippets#_TextBlock_TextDec](~/samples/snippets/csharp/VS_Snippets_Wpf/InlineSnippets/CSharp/Window1.xaml.cs#_textblock_textdec)]
 [!code-vb[InlineSnippets#_TextBlock_TextDec](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InlineSnippets/visualbasic/window1.xaml.vb#_textblock_textdec)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextDecorationsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextDecorationsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextDecorationsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextDecorationsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextDecorationsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextDecorationsProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.TextDecorations" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextEffects">
      <MemberSignature Language="C#" Value="public System.Windows.Media.TextEffectCollection TextEffects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.TextEffectCollection TextEffects" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextEffects" />
      <MemberSignature Language="VB.NET" Value="Public Property TextEffects As TextEffectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::TextEffectCollection ^ TextEffects { System::Windows::Media::TextEffectCollection ^ get(); void set(System::Windows::Media::TextEffectCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextEffectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要应用于此元素中的文本内容的效果。</summary>
        <value>一个 <see cref="T:System.Windows.Media.TextEffectCollection" />，其中包含一个或多个 <see cref="T:System.Windows.Media.TextEffect" /> 对象，这些对象定义了要应用于 <see cref="T:System.Windows.Controls.TextBlock" /> 的文本的效果。 默认值为 <see langword="null" />（不应用任何效果）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，此属性设置为`null`，并且没有<xref:System.Windows.Media.TextEffectCollection>与之关联。  在添加任何文本效果之前, 创建一个新<xref:System.Windows.Media.TextEffectCollection>并将其分配给此属性。  
  
<a name="dependencyPropertyInfo_TextEffects"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.TextEffectsProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 下面的示例演示如何创建简单的文本效果并将其应用于文本的<xref:System.Windows.Controls.TextBlock>。  
  
 [!code-csharp[TextElementSnippets#_TextBlock_TextEffects](~/samples/snippets/csharp/VS_Snippets_Wpf/TextElementSnippets/CSharp/Window1.xaml.cs#_textblock_texteffects)]
 [!code-vb[TextElementSnippets#_TextBlock_TextEffects](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextElementSnippets/visualbasic/window1.xaml.vb#_textblock_texteffects)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextEffectsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextEffectsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextEffectsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextEffectsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextEffectsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextEffectsProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.TextEffects" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.Text" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextTrimming">
      <MemberSignature Language="C#" Value="public System.Windows.TextTrimming TextTrimming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextTrimming TextTrimming" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextTrimming" />
      <MemberSignature Language="VB.NET" Value="Public Property TextTrimming As TextTrimming" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextTrimming TextTrimming { System::Windows::TextTrimming get(); void set(System::Windows::TextTrimming value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextTrimming</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在内容超出内容区域时要采用的文本剪裁行为。</summary>
        <value>
          <see cref="T:System.Windows.TextTrimming" /> 值之一，它指定要采取的文本修整行为。 默认值为 <see cref="F:System.Windows.TextTrimming.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_TextTrimming"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.TextTrimmingProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextTrimmingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextTrimmingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextTrimmingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextTrimmingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextTrimmingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextTrimmingProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.TextTrimming" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextWrapping">
      <MemberSignature Language="C#" Value="public System.Windows.TextWrapping TextWrapping { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextWrapping TextWrapping" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextWrapping" />
      <MemberSignature Language="VB.NET" Value="Public Property TextWrapping As TextWrapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextWrapping TextWrapping { System::Windows::TextWrapping get(); void set(System::Windows::TextWrapping value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextWrapping</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Controls.TextBlock" /> 对文本进行换行的方式。</summary>
        <value>
          <see cref="T:System.Windows.TextWrapping" /> 值之一。 默认值为 <see cref="F:System.Windows.TextWrapping.NoWrap" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_TextWrapping"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Controls.TextBlock.TextWrappingProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.TextWrapping%2A>属性<xref:System.Windows.Controls.TextBlock>元素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.TextWrapping%2A>属性以编程方式。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextWrappingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextWrappingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextWrappingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextWrappingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextWrappingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextWrappingProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.Controls.TextBlock.TextWrapping" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Typography">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Typography Typography { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Typography Typography" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Typography" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Typography As Typography" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Typography ^ Typography { System::Windows::Documents::Typography ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Typography</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素的内容的当前有效版式变体。</summary>
        <value>一个 <see cref="T:System.Windows.Documents.Typography" /> 对象，它指定当前有效的版式变体。 有关默认版式值的列表，请参见 <see cref="T:System.Windows.Documents.Typography" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.TextBlock.Typography%2A>属性是仅适用于[!INCLUDE[TLA#tla_opentype](~/includes/tlasharptla-opentype-md.md)]字体。 版式变体不起上不支持该变体的字体。  本主题的详细信息，请参阅[WPF 中的版式](~/docs/framework/wpf/advanced/typography-in-wpf.md)。  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.Typography%2A>属性<xref:System.Windows.Controls.TextBlock>元素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 下面的示例演示如何设置<xref:System.Windows.Controls.TextBlock.Typography%2A>属性以编程方式。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.Typography" />
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Media.Visual" /> 所承载的 <see cref="T:System.Windows.Controls.TextBlock" /> 子项的数目。</summary>
        <value>
          <see cref="T:System.Windows.Controls.TextBlock" /> 承载的可视子项的数目。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>