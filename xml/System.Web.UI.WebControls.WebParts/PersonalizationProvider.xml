<Type Name="PersonalizationProvider" FullName="System.Web.UI.WebControls.WebParts.PersonalizationProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="083434882dd6feed8217a7a3faad5f4c2a6ffb8b" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53393766" /></Metadata><TypeSignature Language="C#" Value="public abstract class PersonalizationProvider : System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PersonalizationProvider extends System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PersonalizationProvider&#xA;Inherits ProviderBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationProvider abstract : System::Configuration::Provider::ProviderBase" />
  <TypeSignature Language="F#" Value="type PersonalizationProvider = class&#xA;    inherit ProviderBase" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.Provider.ProviderBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>实现个性化设置提供程序的基本功能。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是定义个性化设置提供程序所需的功能的抽象基类。 个性化设置提供程序加载和存储个性化设置数据代表的<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>实例。  
  
 该基类定义多个方法; 这些方法的标准行为专门处理与基础数据存储区的这些方法都标记为 abstract。 这允许开发人员编写的自定义提供程序以与特定的数据存储，而无需重新实现使用的标准功能<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>可以从派生<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />和为仅在此类中定义的抽象方法提供实现。 抽象方法处理专门与保存和加载到物理数据存储，数据和数据存储区管理。 自定义提供程序必须能够处理个性化设置信息的方式，用于区分<see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />中的数据<see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" />数据。 此外，提供程序必须由页以及应用程序细分个性化设置数据。  
  
实现<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />的实现与紧密耦合<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />因为一些个性化设置提供程序方法返回的实例<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />-派生的类。 为了便于开发自定义提供程序<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />基类包括个性化设置逻辑和序列化/反序列化逻辑，直接使用的默认实现<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />类。 因此，编写专门用于使用不同的数据存储区的自定义提供程序仅需要以下抽象方法的实现： 
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" /> -此方法需要能够提供的查询参数的数据库中的个性化设置数据的行数进行计数。  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" /> -在给定路径和用户的情况下，此方法从数据库中加载两个二进制大型对象 (Blob): 用于共享的数据，一个用于用户数据的一个 BLOB。 如果你提供的用户名称和路径，则不需要<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件，用于访问可提供用户名称/路径信息的页信息。  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" /> -在给定路径和用户的情况下，此方法删除数据库中的相应行。 如果你提供的用户名称和路径，则不需要<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件，用于访问可提供用户名称/路径信息的页信息。  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" /> -此方法在给定路径和用户的情况下，将提供的 BLOB 保存到数据库。 如果你提供的用户名称和路径，则不需要<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件，用于访问可提供用户名称/路径信息的页信息。  
  
在所有这些方法，如果只提供一个路径，指示正在操作页的共享的个性化数据。 如果用户名和路径传递到方法中，然后应时处理页面的用户个性化设置数据。 情况下<see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />，应始终加载指定的路径的共享的数据，并且可以选择路径的用户个性化设置数据应还加载如果用户名不是<see langword="null" />。  
  
其他所有抽象方法旨在仅用于管理应用程序，在运行时不使用由 Web 部件基础结构。 有关的个性化设置提供程序实现的示例，请参阅<see cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />类。</para></block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />
    <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Web 部件页</related>
    <related type="Article" href="https://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320">Web 部件个性化设置概述</related>
    <related type="Article" href="https://msdn.microsoft.com/library/a88d2bd5-4932-4ec1-b176-7d7da45f85d9">演练：使用用户控件的实现的 Web 部件个性化设置</related>
    <related type="Article" href="https://msdn.microsoft.com/library/7885563f-7bbe-45a0-b5e2-c6bf1bc2deaa">Web 部件个性化设置</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PersonalizationProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PersonalizationProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于这是一个抽象类的构造函数，必须重写此方法以创建从此类继承的类的实例。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public abstract string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取或设置为提供程序配置的应用程序的名称。</summary>
        <value>为个性化设置提供程序配置的应用程序。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在该配置文件中未指定应用程序名称[（ASP.NET 设置架构） webParts 的 personalization 的 providers 元素](https://msdn.microsoft.com/library/51363b49-eafa-4b9c-b9d0-80086b385195)属性，值为<xref:System.Web.Hosting.HostingEnvironment.ApplicationVirtualPath%2A>使用属性。  
  
> [!CAUTION]
>  因为服务的所有请求使用单个默认个性化设置提供程序实例<xref:System.Web.HttpApplication>对象，必须可以并发执行的每个尝试设置的多个请求<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>属性值。 <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>属性不是线程安全的多个写入操作，并更改<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>属性值可能会导致多个用户的应用程序的意外行为。 建议尽量不要允许用户设置的代码<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>属性所需除外。 设置<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>属性可能是必需的例如，在管理应用程序，用于管理多个应用程序的个性化设置数据。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSupportedUserCapabilities">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IList CreateSupportedUserCapabilities ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IList CreateSupportedUserCapabilities() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateSupportedUserCapabilities () As IList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IList ^ CreateSupportedUserCapabilities();" />
      <MemberSignature Language="F#" Value="abstract member CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList&#xA;override this.CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList" Usage="personalizationProvider.CreateSupportedUserCapabilities " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 对象的列表，这些对象表示 Web 部件控件集所使用的已知功能集。</summary>
        <returns>一个 <see cref="T:System.Collections.IList" />，它表示 Web 部件控件集所使用的已知功能集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前，此方法返回包含两个功能的列表：<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>和<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability>。 这些是可以在中定义的默认功能[（ASP.NET 设置架构） webParts 的 personalization 的 authorization 元素](https://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434)元素内的[(ASP.NET webparts 的 personalization 元素设置架构）](https://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09)的元素[webParts 元素 （ASP.NET 设置架构）](https://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c)配置节。 如果您选择实现自定义个性化设置基础结构，可以重写此方法，定义您自己的与授权相关的用户功能集。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineInitialScope">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, System.Web.UI.WebControls.WebParts.PersonalizationState loadedState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, class System.Web.UI.WebControls.WebParts.PersonalizationState loadedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineInitialScope(System.Web.UI.WebControls.WebParts.WebPartManager,System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationScope DetermineInitialScope(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::Web::UI::WebControls::WebParts::PersonalizationState ^ loadedState);" />
      <MemberSignature Language="F#" Value="abstract member DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope&#xA;override this.DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope" Usage="personalizationProvider.DetermineInitialScope (webPartManager, loadedState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="loadedState" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <param name="loadedState">个性化设置状态信息。</param>
        <summary>确定初始个性化设置范围应为 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 还是 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 范围。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />，它指示当前个性化设置范围是 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 还是 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法确定是否应为当前作用域<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>或<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>，根据给定引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制和个性化设置状态已加载从之前在个性化设置生命周期中的信息。 此信息由<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>后续与个性化设置相关的任务的实例。  
  
 以下规则用于确定个性化设置范围：  
  
-   作用域最初假定为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>。  
  
-   如果当前正在执行的用户帐户未经过身份验证，范围设置为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>。  
  
-   如果当前正在执行的用户帐户进行身份验证，额外的处理会按优先级顺序发生：  
  
    -   如果页是在回发模式下，页面请求包含来自以前呈现页面的作用域信息。 如果该作用域信息指明<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>时使用的作用域，则作用域的计算结果为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>。  
  
    -   如果当前正在执行的页必须从另一页传输到它的控件 (例如，如果调用，因此发生控制的转移<xref:System.Web.HttpServerUtility.Transfer%2A>方法; 请注意此特定检查不会为跨页面发送发生)，并且如果以前执行页面有<xref:System.Web.UI.WebControls.WebParts.WebPartManager>作用域设置为值的实例，`Personalization.Scope`属性从上一个<xref:System.Web.UI.WebControls.WebParts.WebPartManager>实例。  
  
    -   如果不满足以上条件，则作用域的计算结果为的值<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A>属性的当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 在进行的上一评估后，和作用域的计算结果为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>作用域，请进行以下处理：  
  
-   如果当前正在执行的用户帐户具有<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>功能，作用域将仍然设置为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>。  
  
-   如果当前正在执行的用户帐户不具有<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>功能，则作用域将重置为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>。  
  
-   如果所有以前的作用域计算结果为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>，此结果存储为当前正在执行的页的隐藏字段。 这是一个页面，由此可以重播在后续回发期间的作用域计算的机制。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">与 <paramref name="webPartManager" /> 关联的页为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DetermineUserCapabilities">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary DetermineUserCapabilities (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionary DetermineUserCapabilities(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineUserCapabilities(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionary ^ DetermineUserCapabilities(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary&#xA;override this.DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary" Usage="personalizationProvider.DetermineUserCapabilities webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <summary>返回一个包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 实例的字典，这些实例表示当前正在执行的用户帐户的与个性化设置相关的功能。</summary>
        <returns><see cref="T:System.Collections.IDictionary" />，如果用户帐户已经过身份验证，则包含零个或零个以上 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 实例，如果正在执行的用户帐户未经过身份验证，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现使用中的信息[（ASP.NET 设置架构） webParts 的 personalization 的 authorization 元素](https://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434)元素内的[个性化设置元素的web 部件 （ASP.NET 设置架构）](https://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09)的元素[webParts 元素 （ASP.NET 设置架构）](https://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c)配置节在 Machine.config 或 Web.config 文件，以确定用户的授权功能。  
  
 字典中的功能将成为成员<xref:System.Collections.IList>返回的对象<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities%2A>方法，它当前包括<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>功能和<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability>功能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">与 <paramref name="webPartManager" /> 关联的页为 <see langword="null" />。  
  
- 或 - 
与页关联的请求为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FindState">
      <MemberSignature Language="C#" Value="public abstract System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int pageIndex, int pageSize, out int totalRecords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int32 pageIndex, int32 pageSize, [out] int32&amp; totalRecords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.FindState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery,System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindState (scope As PersonalizationScope, query As PersonalizationStateQuery, pageIndex As Integer, pageSize As Integer, ByRef totalRecords As Integer) As PersonalizationStateInfoCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Web::UI::WebControls::WebParts::PersonalizationStateInfoCollection ^ FindState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query, int pageIndex, int pageSize, [Runtime::InteropServices::Out] int % totalRecords);" />
      <MemberSignature Language="F#" Value="abstract member FindState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery * int * int *  -&gt; System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" Usage="personalizationProvider.FindState (scope, query, pageIndex, pageSize, totalRecords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
        <Parameter Name="pageIndex" Type="System.Int32" />
        <Parameter Name="pageSize" Type="System.Int32" />
        <Parameter Name="totalRecords" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="scope">具有要查询的个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />。 此值不能为 <see langword="null" />。</param>
        <param name="query">包含查询的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />。 此值可为 <see langword="null" />。</param>
        <param name="pageIndex">查询的起始位置。</param>
        <param name="pageSize">要返回的记录数。</param>
        <param name="totalRecords">可用记录的总数。</param>
        <summary>在派生类中重写时，将根据范围和特定的查询参数返回一个集合，其中包含零个或零个以上 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 派生对象。</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />，包含零个或零个以上 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 派生对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是用于查询的个性化设置数据的管理方法的抽象定义。 派生的实现应遵循下面所述的逻辑。  
  
 受约束返回的项的一套`pageIndex`并`pageSize`参数，其中`pageSize`设置要返回的记录数和`pageIndex`设置要返回哪些记录。 例如，`pageIndex`为 0 和一个`pageSize`25 个，则会返回前 25 个匹配项，而`pageIndex`为 1 和`pageSize`25 个，则会返回匹配项 26 50。 如果你想要检索所有可用的记录，设置`pageIndex`为 0 和`pageSize`到<xref:System.Int32.MaxValue>。  
  
 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-按字母顺序返回并排序的组合来派生的对象及其<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A>和<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A>属性值，同时按升序排序。  
  
 此方法将查询通配符字符传递给基础数据存储区。 对通配符字符的支持是当前依赖于每个提供程序如何处理字符，如星号 （*）、 百分号 （%） 或下划线 (_)。  
  
 通常情况下，对于符合 SQL 数据存储，你可以执行通配符搜索分部路径上加上使其不显示在开头、 末尾或搜索字符串文本中的中间的通配符<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性。 例如，若要查找所有路径开头的"\~/vdir"，则<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性将设置为"\~/vdir%"。  
  
 同样，对部分用户名执行通配符搜索可以允许显示的文本字符串中的任意位置的通配符字符<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性。 例如，若要查找与"John"开头的所有用户名称<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>参数将如下所示"John %"。  
  
 下面的查询约束适用：  
  
-   如果只有`scope`提供，并`query`是`null`或上的所有属性`query`返回`null`或默认值，然后将匹配所指示的所有记录`scope`返回参数。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性不是`null`，返回的记录也是匹配的筛选根据的路径<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>值。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性不是`null`，返回的记录也是匹配的筛选基于的用户名称<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性值。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性不等于<xref:System.DateTime.MaxValue>，则返回的记录也将筛选以仅返回的记录与非活动用户关联。 比较内容包括记录其中<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A>属性小于或等于<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性。  
  
 请注意，此方法不会验证查询参数的组合。 例如，代码可以请求一的组与共享作用域中指定的用户名相关联的个性化设置状态记录。 由于用户名不是共享的信息关联，则返回的集合将为空。  
  
 有可能会返回非空集合的参数组合包括：  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 作用域结合<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性。  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> 结合使用的值的任何或所有作用域<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>， <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>，和<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCountOfState">
      <MemberSignature Language="C#" Value="public abstract int GetCountOfState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCountOfState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCountOfState (scope As PersonalizationScope, query As PersonalizationStateQuery) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCountOfState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query);" />
      <MemberSignature Language="F#" Value="abstract member GetCountOfState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery -&gt; int" Usage="personalizationProvider.GetCountOfState (scope, query)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
      </Parameters>
      <Docs>
        <param name="scope">要查询的个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />。 此值不能为 <see langword="null" />。</param>
        <param name="query">包含查询的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />。 此值可为 <see langword="null" />。</param>
        <summary>在派生类中重写时，返回基础数据存储区中存在于指定范围内的行数。</summary>
        <returns>针对指定 <paramref name="scope" /> 参数的基础数据存储区的行数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是一种管理方法来检索个性化设置数据的计数的抽象定义。 派生的实现应遵循下面所述的逻辑。  
  
 此方法将查询通配符字符传递给基础数据存储区。 对通配符字符的支持是当前依赖于每个提供程序如何处理字符，如星号 （*）、 百分号 （%） 或下划线 (_)。  
  
 通常情况下，对于符合 SQL 数据存储，你可以执行通配符搜索分部路径上加上使其不显示在开头、 末尾或搜索字符串文本中的中间的通配符<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性。 例如，若要查找所有路径开头的"\~/vdir"，则<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性将设置为"\~/vdir%"。  
  
 同样，对部分用户名执行通配符搜索可以允许显示的文本字符串中的任意位置的通配符字符<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性。 例如，若要查找与"John"开头的所有用户名称<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>参数将如下所示"John %"。  
  
 下面的查询约束适用：  
  
-   如果只有`scope`提供，并`query`是`null`或上的所有属性`query`返回`null`或默认值，然后将匹配所指示的所有记录`scope`参数进行计数。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性不是`null`，计数的记录也是匹配的筛选根据的路径<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>值。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性不是`null`，计数的记录也是匹配的筛选基于的用户名称<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性值。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性不等于<xref:System.DateTime.MaxValue>，则计数的记录也将筛选以仅返回的记录与非活动用户关联。 比较内容包括记录其中<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A>属性小于或等于<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性。  
  
 请注意，此方法不会验证查询参数的组合。 例如，代码可以请求与共享作用域中指定的用户名相关联的个性化设置状态记录的计数。 由于用户名不是共享的信息关联，则返回的计数将为零。  
  
 有可能会返回非零值计数的参数组合包括：  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 作用域结合<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性。  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> 结合使用的值的任何或所有作用域<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>， <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>，和<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationBlobs">
      <MemberSignature Language="C#" Value="protected abstract void LoadPersonalizationBlobs (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, ref byte[] sharedDataBlob, ref byte[] userDataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadPersonalizationBlobs(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[]&amp; sharedDataBlob, unsigned int8[]&amp; userDataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void LoadPersonalizationBlobs(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ % sharedDataBlob, cli::array &lt;System::Byte&gt; ^ % userDataBlob);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationBlobs : System.Web.UI.WebControls.WebParts.WebPartManager * string * string *  *  -&gt; unit" Usage="personalizationProvider.LoadPersonalizationBlobs (webPartManager, path, userName, sharedDataBlob, userDataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="sharedDataBlob" Type="System.Byte[]" RefType="ref" />
        <Parameter Name="userDataBlob" Type="System.Byte[]" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <param name="path">要用作检索关键字的个性化设置信息的路径。</param>
        <param name="userName">要用作检索关键字的个性化设置信息的用户名。</param>
        <param name="sharedDataBlob">为 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 范围返回的数据。</param>
        <param name="userDataBlob">为 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 范围返回的数据。</param>
        <summary>在派生类中重写时，从基础数据存储区加载原始个性化设置数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生的类<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider>，并应使用此方法的实现`webPartManager`， `path`，和`username`用作检索关键字的参数。 而不考虑数据的方式存储在数据存储中 （某些数据存储可能会执行某种类型的智能存储），必须返回数据的个性化设置为一组已打包的两个数组中的字节数。 返回的数据必须符合以下规则：  
  
-   数据<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>作用域必须始终以返回`sharedDataBlob`参数。  
  
-   根据键的值，<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>中返回数据`userDataBlob`参数。 非`null`值`userName`参数指示<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>还应检索数据。  
  
 个性化设置提供程序派生<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider>并实现此方法可以优化与自己的数据存储之间的交互通过检索一个往返行程中的所有个性化设置数据而不是检索<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>和<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>中两个数据单独的往返操作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationState ^ LoadPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState&#xA;override this.LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState" Usage="personalizationProvider.LoadPersonalizationState (webPartManager, ignoreCurrentUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="ignoreCurrentUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <param name="ignoreCurrentUser"><see cref="T:System.Boolean" />，指示是否应将用户名传递给个性化设置提供程序。</param>
        <summary>从基础数据存储区加载原始数据，并将该数据转换为 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> 对象。</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />，包含个性化设置数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是使用的主入口点<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类加载个性化设置数据。 默认实现从基础数据存储区加载原始数据 （派生的提供程序中实施功能），然后将转换到的原始数据<xref:System.Web.UI.WebControls.WebParts.PersonalizationState>实例。  
  
 如果`ignoreCurrentUser`参数是`true`，没有用户名称传递给<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs%2A>方法。 个性化设置提供程序可以选择将此视为这意味着使用该唯一个性化设置状态<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>作用域应检索从基础数据存储区。  
  
 当<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A>方法执行时，它调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState%2A>方法，并且有三种类型的状态为正在加载，因此可能出现的反序列化错误。 这些特定错误发生时，不引发任何异常，通过的运行状况监视功能而是记录错误事件 (运行状况监视和访问由它创建的日志的信息，请参阅[ASP.NET 运行状况监视概述](https://msdn.microsoft.com/library/e003f224-70fe-4cd8-a71a-2dc81e2d7e4c)). 以下三种方案导致反序列化要写入到日志的错误事件：  
  
-   反序列化使用中的字符串属性类型的尝试失败的<xref:System.ComponentModel.TypeConverter>。  
  
-   在尝试失败反序列化使用二进制序列化的属性类型。  
  
-   键入要反序列化属性的尝试失败，因为无法创建类型的实例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">与 <paramref name="webPartManager" /> 关联的页为 <see langword="null" />。  
  
- 或 - 
与页关联的请求为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void ResetPersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ResetPersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void ResetPersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string -&gt; unit" Usage="personalizationProvider.ResetPersonalizationBlob (webPartManager, path, userName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <param name="path">要用作数据存储区关键字的个性化设置信息的路径。</param>
        <param name="userName">要用作数据存储区关键字的个性化设置信息的用户名。</param>
        <summary>在派生类中重写时，从基础数据存储区删除原始个性化设置数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生的类<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider>，并应使用此方法的实现`webPartManager`， `path`，和`userName`参数作为存储密钥。 派生的实现必须修改数据存储区，以便有效地删除提供的存储区关键字的个性化设置数据。 负责派生的实现中关于如何它们以物理方式实现此目的。  
  
 派生的个性化设置提供程序必须能够区分基于每个页面的个性化设置数据。 此外，对于给定的页状态个性化设置提供程序必须能够区分<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>和<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>数据范围。 如果将非`null`提供的用户名称，然后重置操作适用于<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>作用域; 否则，重置操作应用于<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>作用域。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void ResetPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit&#xA;override this.ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit" Usage="personalizationProvider.ResetPersonalizationState webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <summary>将个性化设置数据重置到基础数据存储区。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是使用的主入口点<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类，以重置的个性化设置数据。 默认实现使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件来确定要重置的数据的路径和用户名称。 然后，默认实现调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPartManager" /> 不与页相关联。  
  
- 或 - 
页不与正在进行的 <see cref="T:System.Web.HttpRequest" /> 关联。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public abstract int ResetState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetState (scope As PersonalizationScope, paths As String(), usernames As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, cli::array &lt;System::String ^&gt; ^ paths, cli::array &lt;System::String ^&gt; ^ usernames);" />
      <MemberSignature Language="F#" Value="abstract member ResetState : System.Web.UI.WebControls.WebParts.PersonalizationScope * string[] * string[] -&gt; int" Usage="personalizationProvider.ResetState (scope, paths, usernames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="paths" Type="System.String[]" />
        <Parameter Name="usernames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="scope">要重置的个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />。 此值不能为 <see langword="null" />。</param>
        <param name="paths">要删除的个性化设置信息的路径。</param>
        <param name="usernames">要删除的个性化设置信息的用户名。</param>
        <summary>在派生类中重写时，根据指定的参数从基础数据存储区删除个性化设置状态。</summary>
        <returns>删除的行数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是用于删除个性化设置数据的管理方法的抽象定义。 派生的实现应遵循下面所述的逻辑。  
  
 此方法不支持任何通配符搜索。 如果个性化设置提供程序公开一个识别事务的数据存储区中的数据，则此方法应作为单个原子事务执行其操作。  
  
 允许仅以下参数的组合：  
  
-   `scope`参数设置，并且所有其他参数设置为`null`。 此组合中删除与所指示的个性化设置范围关联的所有 Web 部件个性化设置数据`scope`。  
  
-   `scope`参数设置，和`paths`参数包含至少一个值。 此组合中删除指定的路径或路径所指示的个性化设置范围中所有 Web 部件个性化设置数据`scope`。  
  
-   `scope`参数设置为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>，则`paths`参数已设置且只包含一个数值和`usernames`参数包含至少一个值。 此组合中删除所有用户个性化设置给定的路径或多个用户中包含与该键关联的 Web 部件数据`usernames`。  
  
-   `scope`参数设置为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>，则`paths`参数设置为`null`，和`usernames`参数包含至少一个值。 此组合中包含的用户与关联的所有路径在删除所有每用户个性化设置 Web 部件数据`usernames`。  
  
 任何其他参数值的组合无效，将引发<xref:System.ArgumentException>异常。 具体而言，不允许使用以下两个组合：  
  
-   `usernames`参数不能提供何时`scope`设置为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>。  
  
-   `paths`参数不能包含多个条目时`usernames`参数不是`null`。  
  
 任何`paths`和`usernames`包含在各自数组中的参数值必须满足以下验证规则。 如果任何验证规则失败以及参数数组的任何成员<xref:System.ArgumentException>引发异常。 验证规则是：  
  
-   `null` 不允许值。  
  
-   空字符串 ("") 不允许。 参数应在执行为空字符串检查之前进行修整。  
  
-   `usernames`参数不能包含逗号 （，）。  
  
-   长度`paths`参数不能超过 256 个字符的 SQL 数据库。  
  
-   长度`usernames`参数不能超过 256 个字符的 SQL 数据库。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetUserState">
      <MemberSignature Language="C#" Value="public abstract int ResetUserState (string path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetUserState(string path, valuetype System.DateTime userInactiveSinceDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetUserState(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetUserState (path As String, userInactiveSinceDate As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetUserState(System::String ^ path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="F#" Value="abstract member ResetUserState : string * DateTime -&gt; int" Usage="personalizationProvider.ResetUserState (path, userInactiveSinceDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userInactiveSinceDate" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">要删除的个性化设置数据的路径。 此值可以为 <see langword="null" />，但不能为空字符串 ("")。</param>
        <param name="userInactiveSinceDate">日期，指示网站用户上次更改个性化设置数据的时间。</param>
        <summary>在派生类中重写时，根据指定的参数从基础数据存储区删除 Web 部件个性化设置数据。</summary>
        <returns>从基础数据存储区中删除的行数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是用于删除个性化设置数据的管理方法的抽象定义。 请注意，此方法只影响用户个性化设置数据和非共享的数据。  
  
 派生的实现应遵循下面所述的逻辑：  
  
-   `path`参数不能包含通配符字符。  
  
-   如果提供程序公开一个识别事务的数据存储区中的数据，则此方法应在单个原子事务中执行其操作。  
  
-   如果`path`参数为非`null`，然后仅每用户个性化设置记录与关联`path`将被删除。  
  
-   与中指示的日期之后被视为处于非活动状态的用户相关联的仅每用户个性化设置记录`userInactiveSinceDate`参数将被删除。 具体而言，记录<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A>小于或等于<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>被删除。  
  
-   如果提供了两个参数，则将删除与这两个约束相匹配的记录。  
  
-   `path`参数可以是`null`。  
  
-   `path`参数不能为空字符串。 它应在执行此检查之前进行修整。  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> 属性不能为 `null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void SavePersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, byte[] dataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SavePersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[] dataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void SavePersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ dataBlob);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string * byte[] -&gt; unit" Usage="personalizationProvider.SavePersonalizationBlob (webPartManager, path, userName, dataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="dataBlob" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <param name="path">要用作数据存储区关键字的个性化设置信息的路径。</param>
        <param name="userName">要用作关键字的个性化设置信息的用户名。</param>
        <param name="dataBlob">要保存的数据的字节数组。</param>
        <summary>在派生类中重写时，将原始个性化设置数据保存到基础数据存储区中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是方法的用于将原始个性化设置数据保存到基础数据存储区的抽象定义。  
  
 派生的实现应使用`webPartManager`， `path`，和`userName`参数作为存储密钥。 派生的个性化设置提供程序必须能够区分基于每个页面的个性化设置数据。 此外，对于给定的页面的状态，该提供程序必须能够区分<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>和<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>作用域。 如果将非`null`提供用户名称，则`dataBlob`参数位于<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>作用域; 否则为`dataBlob`参数被假定为在<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>作用域。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void SavePersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SavePersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SavePersonalizationState (state As PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SavePersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationState ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit&#xA;override this.SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit" Usage="personalizationProvider.SavePersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="state"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />，包含要保存的个性化设置数据。</param>
        <summary>将个性化设置数据保存到数据存储区中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是使用的主入口点<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类，以保存个性化设置数据。  
  
 此方法的默认实现使用的内部实现的方法<xref:System.Web.UI.WebControls.WebParts.PersonalizationState>个性化设置数据打包到一个字节数组。 如果此打包的结果创建一个空字节数组 （因为属性提取不导致任何个性化设置数据），则默认实现调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A>方法。 否则，默认实现调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="state" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">正在保存的 <paramref name="state" /> 对象与 <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" /> 方法返回的 <paramref name="state" /> 对象类型不同。</exception>
      </Docs>
    </Member>
  </Members>
</Type>