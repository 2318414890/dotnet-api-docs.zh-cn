<Type Name="PersonalizationProvider" FullName="System.Web.UI.WebControls.WebParts.PersonalizationProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e6b4385b1e11acc80b4dbe543f5244ffb8f83df9" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30590991" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class PersonalizationProvider : System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PersonalizationProvider extends System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PersonalizationProvider&#xA;Inherits ProviderBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationProvider abstract : System::Configuration::Provider::ProviderBase" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.Provider.ProviderBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>实现个性化设置提供程序的基本功能。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是定义个性化设置提供程序所需的功能的抽象基类。 个性化设置提供程序加载和存储代表个性化数据<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>实例。  
  
 该基类定义大量的方法; 这些方法的标准行为专门处理与基础数据存储区的这些方法将标记为 abstract。 这允许开发人员编写一个自定义提供程序进行交互并将特定的数据存储区中，而无需重新实现使用的标准功能<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>你可以从派生<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />和提供仅在此类中定义的抽象方法的实现。 抽象方法处理专门与保存和加载到物理数据存储，数据和数据存储区管理。 自定义提供程序必须支持的操作区别开来的方式个性化信息<see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />数据从<see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" />数据。 此外，提供程序必须由页以及应用程序分段个性化数据。  
  
 实现<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />紧密耦合的实现<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />因为某些个性化设置提供程序方法返回的实例<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />-派生类。 为了便于开发的自定义提供程序，<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />基类包括个性化逻辑和直接通过使用的序列化/反序列化逻辑的默认实现<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />类。 因此，创作专门用于不同的数据存储使用自定义提供程序仅需要以下抽象方法实现：  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" /> -此方法需要能够提供的查询参数的数据库中的个性化数据的行数进行计数。  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" /> -在给定路径和用户名的情况下，此方法从数据库中加载两个二进制大型对象 (Blob): 用于共享的数据，一个用于用户数据的一个 BLOB。 如果你提供的用户名称和路径，则不需要<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件，用于访问可以提供的用户名称/路径信息的页信息。  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" /> -在给定路径和用户名的情况下，此方法删除数据库中的相应行。 如果你提供的用户名称和路径，则不需要<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件，用于访问可以提供的用户名称/路径信息的页信息。  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" /> -此方法在给定路径和用户名的情况下，将提供的 BLOB 保存到数据库。 如果你提供的用户名称和路径，则不需要<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件，用于访问可以提供的用户名称/路径信息的页信息。  
  
 在所有这些方法中，如果只提供路径，则指示正在操作页的共享的个性化数据。 如果路径和用户名将传递到方法中，页上的用户个性化数据应得到处理。 情况下<see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />，应始终加载指定的路径的共享的数据，并且 （可选） 用户个性化设置的路径应还将数据加载如果用户名不<see langword="null" />。  
  
 其他所有抽象方法用于仅在管理的应用程序中使用，并且不在运行时的 Web 部件基础结构使用。 个性化设置提供程序实现的示例，请参阅<see cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />类。</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PersonalizationProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PersonalizationProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于这是一个抽象类的构造函数，你必须重写此方法以创建从此类继承的类的实例。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public abstract string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取或设置为提供程序配置的应用程序的名称。</summary>
        <value>为个性化设置提供程序配置的应用程序。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果应用程序名称未指定在配置文件中使用[元素的提供程序的 web 部件 （ASP.NET 设置架构） 的个性化](http://msdn.microsoft.com/library/51363b49-eafa-4b9c-b9d0-80086b385195)属性的值<xref:System.Web.Hosting.HostingEnvironment.ApplicationVirtualPath%2A>使用属性。  
  
> [!CAUTION]
>  因为由提供服务的所有请求使用单个默认个性化设置提供程序实例<xref:System.Web.HttpApplication>对象，您可以有多个并发，执行每个正在尝试设置的请求<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>属性值。 <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>属性不是线程安全用于多个写操作，并更改<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>属性值可能会导致多个用户的应用程序的意外行为。 建议你避免允许用户设置的代码，<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>属性所需除外。 设置<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>属性可能是必需的例如，在管理应用程序，用于管理多个应用程序的个性化数据。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSupportedUserCapabilities">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IList CreateSupportedUserCapabilities ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IList CreateSupportedUserCapabilities() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateSupportedUserCapabilities () As IList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IList ^ CreateSupportedUserCapabilities();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 对象的列表，这些对象表示 Web 部件控件集所使用的已知功能集。</summary>
        <returns>一个 <see cref="T:System.Collections.IList" />，它表示 Web 部件控件集所使用的已知功能集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前，此方法返回包含两个功能的列表：<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>和<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability>。 这些是可以在中定义的默认功能[是为了个性化的 web 部件 （ASP.NET 设置架构） 的授权元素](http://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434)中的元素[个性化元素为 web 部件 (ASP.NET设置架构）](http://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09)元素[web 部件元素 （ASP.NET 设置架构）](http://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c)配置节。 如果你选择实现自定义个性化设置基础结构，你可以重写此方法，并定义自己的授权相关的用户功能集。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineInitialScope">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, System.Web.UI.WebControls.WebParts.PersonalizationState loadedState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, class System.Web.UI.WebControls.WebParts.PersonalizationState loadedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineInitialScope(System.Web.UI.WebControls.WebParts.WebPartManager,System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationScope DetermineInitialScope(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::Web::UI::WebControls::WebParts::PersonalizationState ^ loadedState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="loadedState" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <param name="loadedState">个性化设置状态信息。</param>
        <summary>确定初始个性化设置范围应为 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 还是 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 范围。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />，它指示当前个性化设置范围是 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 还是 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可确定是否应为当前作用域<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>或<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>，根据给定引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件和个性化设置的状态已加载从在个性化生命周期的前面部分中的信息。 通过使用此信息<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>后续个性化设置相关的任务的实例。  
  
 使用以下规则来确定个性化设置作用域：  
  
-   作用域最初假定为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>。  
  
-   如果当前正在执行的用户帐户不进行身份验证，将范围设置为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>。  
  
-   如果当前正在执行的用户帐户进行身份验证，额外的处理会按优先级顺序发生：  
  
    -   如果页是在回发的模式下，页面请求包含从页面的上一个呈现的作用域信息。 如果该作用域信息指示<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>所使用的作用域，则作用域的计算结果为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>。  
  
    -   如果当前正在执行的页发生从另一页传输到它的控件 (例如，如果因调用而发生控制的转移<xref:System.Web.HttpServerUtility.Transfer%2A>方法; 请注意此特定的检查不会为跨页发送发生)，并且如果以前执行页具有<xref:System.Web.UI.WebControls.WebParts.WebPartManager>实例，作用域设置的值为`Personalization.Scope`属性与上一<xref:System.Web.UI.WebControls.WebParts.WebPartManager>实例。  
  
    -   如果以前的条件未满足，则作用域的计算结果为的值<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A>属性当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 前面的计算之后，和作用域的计算结果为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>作用域，请包括以下进程：  
  
-   如果当前正在执行的用户帐户具有<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>功能，则范围保持设置为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>。  
  
-   如果当前正在执行的用户帐户不具有<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>功能，则作用域将重置为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>。  
  
-   如果前面所有范围计算结果为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>，此结果存储为当前正在执行的页上的隐藏字段。 这是凭此页可以重播在后续回发期间的作用域计算的机制。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">与 <paramref name="webPartManager" /> 关联的页为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DetermineUserCapabilities">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary DetermineUserCapabilities (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionary DetermineUserCapabilities(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineUserCapabilities(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionary ^ DetermineUserCapabilities(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <summary>返回一个包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 实例的字典，这些实例表示当前正在执行的用户帐户的与个性化设置相关的功能。</summary>
        <returns>
          <see cref="T:System.Collections.IDictionary" />，如果用户帐户已经过身份验证，则包含零个或零个以上 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 实例，如果正在执行的用户帐户未经过身份验证，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现使用中的信息[是为了个性化的 web 部件 （ASP.NET 设置架构） 的授权元素](http://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434)中的元素[个性化元素的web 部件 （ASP.NET 设置架构）](http://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09)元素[web 部件元素 （ASP.NET 设置架构）](http://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c)配置节在 Machine.config 或 Web.config 文件，以确定用户的授权功能。  
  
 字典中的功能将成为成员的<xref:System.Collections.IList>返回对象<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities%2A>方法，目前包括<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>功能和<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability>功能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">与 <paramref name="webPartManager" /> 关联的页为 <see langword="null" />。  
  
 \- 或 -  
  
 与页关联的请求为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FindState">
      <MemberSignature Language="C#" Value="public abstract System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int pageIndex, int pageSize, out int totalRecords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int32 pageIndex, int32 pageSize, [out] int32&amp; totalRecords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.FindState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery,System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindState (scope As PersonalizationScope, query As PersonalizationStateQuery, pageIndex As Integer, pageSize As Integer, ByRef totalRecords As Integer) As PersonalizationStateInfoCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Web::UI::WebControls::WebParts::PersonalizationStateInfoCollection ^ FindState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query, int pageIndex, int pageSize, [Runtime::InteropServices::Out] int % totalRecords);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
        <Parameter Name="pageIndex" Type="System.Int32" />
        <Parameter Name="pageSize" Type="System.Int32" />
        <Parameter Name="totalRecords" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="scope">具有要查询的个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />。 此值不能为 <see langword="null" />。</param>
        <param name="query">包含查询的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />。 此值可为 <see langword="null" />。</param>
        <param name="pageIndex">查询的起始位置。</param>
        <param name="pageSize">要返回的记录数。</param>
        <param name="totalRecords">可用记录的总数。</param>
        <summary>在派生类中重写时，将根据范围和特定的查询参数返回一个集合，其中包含零个或零个以上 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 派生对象。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />，包含零个或零个以上 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 派生对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是用于查询个性化数据的管理方法的抽象定义。 派生的实现应遵循下面所述的逻辑。  
  
 受约束的返回的项集`pageIndex`和`pageSize`参数，其中`pageSize`设置要返回的记录数和`pageIndex`设置要返回哪些记录。 例如，`pageIndex`为 0 和`pageSize`25 个，则将返回前 25 个匹配项，而`pageIndex`的 1 和`pageSize`25 个，则会返回匹配项 26-50。 如果你想要检索所有可用的记录，设置`pageIndex`为 0 和`pageSize`到<xref:System.Int32.MaxValue>。  
  
 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-派生的对象返回按字母顺序，并按的组合其<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A>和<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A>属性值，同时以升序。  
  
 此方法将查询通配符字符传递给基础数据存储区。 当前依赖于每个提供程序处理如星号 （*）、 百分号 （%） 或下划线 (_) 字符的方式是支持通配符。  
  
 通常情况下，对于符合 SQL 数据存储区中，你可以执行通配符搜索部分路径带有通配符字符开头，结束时，或在搜索字符串文本的中间显示<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性。 例如，若要查找以"~/vdir"开头的所有路径<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性将设置为"~/vdir%"。  
  
 同样，对部分用户名通配符搜索可以显示的文本字符串中的任意位置的通配符字符<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性。 例如，若要查找与"John"开头的所有用户名称<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>参数将如下所示"John %"。  
  
 以下查询限制也适用：  
  
-   如果仅`scope`提供，和`query`是`null`或上的所有属性`query`返回`null`或默认值，则指示匹配的所有记录`scope`返回参数。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性不是`null`，返回的记录也是匹配的筛选基于的路径<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>值。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性不是`null`，返回的记录也是匹配的筛选基于的用户名称<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性值。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性是否不等于<xref:System.DateTime.MaxValue>，则返回的记录还筛选以返回与非活动用户关联的那些记录。 比较包括记录其中<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A>属性小于或等于<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性。  
  
 请注意，此方法不会验证查询参数的组合。 例如，代码可以请求一组共享的范围中的特定用户名称与关联的个性化状态记录。 由于用户名不与共享信息相关联，则返回的集合将为空。  
  
 有可能会返回非空集合的参数组合包括：  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 与结合使用的作用域<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性。  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> 作用域中的任意或全部的值组合<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>， <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>，和<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCountOfState">
      <MemberSignature Language="C#" Value="public abstract int GetCountOfState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCountOfState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCountOfState (scope As PersonalizationScope, query As PersonalizationStateQuery) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCountOfState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
      </Parameters>
      <Docs>
        <param name="scope">要查询的个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />。 此值不能为 <see langword="null" />。</param>
        <param name="query">包含查询的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />。 此值可为 <see langword="null" />。</param>
        <summary>在派生类中重写时，返回基础数据存储区中存在于指定范围内的行数。</summary>
        <returns>针对指定 <paramref name="scope" /> 参数的基础数据存储区的行数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是用于检索个性化数据的计数的管理方法的抽象定义。 派生的实现应遵循下面所述的逻辑。  
  
 此方法将查询通配符字符传递给基础数据存储区。 当前依赖于每个提供程序处理如星号 （*）、 百分号 （%） 或下划线 (_) 字符的方式是支持通配符。  
  
 通常情况下，对于符合 SQL 数据存储区中，你可以执行通配符搜索部分路径带有通配符字符开头，结束时，或在搜索字符串文本的中间显示<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性。 例如，若要查找以"~/vdir"开头的所有路径<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性将设置为"~/vdir%"。  
  
 同样，对部分用户名通配符搜索可以显示的文本字符串中的任意位置的通配符字符<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性。 例如，若要查找与"John"开头的所有用户名称<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>参数将如下所示"John %"。  
  
 以下查询限制也适用：  
  
-   如果仅`scope`提供，和`query`是`null`或上的所有属性`query`返回`null`或默认值，则指示匹配的所有记录`scope`参数进行计数。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性不是`null`，计数的记录也是匹配的筛选基于的路径<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>值。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性不是`null`，计数的记录也是匹配的筛选基于的用户名称<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性值。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性是否不等于<xref:System.DateTime.MaxValue>，然后计数的记录还筛选以返回与非活动用户关联的那些记录。 比较包括记录其中<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A>属性小于或等于<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性。  
  
 请注意，此方法不会验证查询参数的组合。 例如，代码可以请求与共享的范围中的特定用户名称关联的个性化状态记录数。 由于用户名不与共享信息相关联，则返回的计数将为零。  
  
 有可能会返回非零计数的参数组合包括：  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> 与结合使用的作用域<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性。  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> 作用域中的任意或全部的值组合<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>， <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>，和<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationBlobs">
      <MemberSignature Language="C#" Value="protected abstract void LoadPersonalizationBlobs (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, ref byte[] sharedDataBlob, ref byte[] userDataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadPersonalizationBlobs(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[]&amp; sharedDataBlob, unsigned int8[]&amp; userDataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void LoadPersonalizationBlobs(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ % sharedDataBlob, cli::array &lt;System::Byte&gt; ^ % userDataBlob);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="sharedDataBlob" Type="System.Byte[]&amp;" RefType="ref" />
        <Parameter Name="userDataBlob" Type="System.Byte[]&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <param name="path">要用作检索关键字的个性化设置信息的路径。</param>
        <param name="userName">要用作检索关键字的个性化设置信息的用户名。</param>
        <param name="sharedDataBlob">为 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 范围返回的数据。</param>
        <param name="userDataBlob">为 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 范围返回的数据。</param>
        <summary>在派生类中重写时，从基础数据存储区加载原始个性化设置数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生自的类<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider>和实现此方法应使用`webPartManager`， `path`，和`username`参数作为检索关键字。 而不考虑如何将数据存储在数据存储中 （某些数据存储可能会执行某种类型的智能存储），必须返回数据的个性化设置为一组打包的两个数组中的字节数。 返回的数据必须符合以下规则：  
  
-   数据<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>作用域必须始终以返回`sharedDataBlob`参数。  
  
-   具体取决于键值，<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>中返回数据`userDataBlob`参数。 非`null`值`userName`参数指示<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>还检索数据。  
  
 派生自的个性化设置提供<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider>并实现此方法可以优化与其数据存储区的交互通过检索所有个性化数据在一个往返过程，而不是都检索<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>和<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>在两个数据分隔往返。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationState ^ LoadPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, bool ignoreCurrentUser);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="ignoreCurrentUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <param name="ignoreCurrentUser">
          <see cref="T:System.Boolean" />，指示是否应将用户名传递给个性化设置提供程序。</param>
        <summary>从基础数据存储区加载原始数据，并将该数据转换为 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> 对象。</summary>
        <returns>
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />，包含个性化设置数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是使用的主入口点<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类来加载个性化数据。 默认实现将从基础数据存储区中加载原始数据 （在派生的提供程序中实现功能），然后将转换到的原始数据<xref:System.Web.UI.WebControls.WebParts.PersonalizationState>实例。  
  
 如果`ignoreCurrentUser`参数是`true`，没有用户名称传递给<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs%2A>方法。 个性化设置提供程序可以选择将此解释为这意味着使用该唯一个性化状态<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>应从基础数据存储区检索作用域。  
  
 当<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A>方法执行时，它调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState%2A>方法，并且有三种类型的状态为正在加载时会出现的反序列化错误。 在这些特定错误发生时，不引发任何异常，并且运行状况监视功能而是记录错误事件 (运行状况监视和访问由它创建的日志的信息，请参阅[ASP.NET 运行状况监视概述](http://msdn.microsoft.com/library/e003f224-70fe-4cd8-a71a-2dc81e2d7e4c)). 以下三种方案原因反序列化错误事件写入日志：  
  
-   反序列化使用的字符串的属性类型的尝试失败的<xref:System.ComponentModel.TypeConverter>。  
  
-   进行反序列化使用二进制序列化的属性类型的失败的尝试。  
  
-   类型反序列化属性的尝试失败，因为无法创建类型的实例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">与 <paramref name="webPartManager" /> 关联的页为 <see langword="null" />。  
  
 \- 或 -  
  
 与页关联的请求为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void ResetPersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ResetPersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void ResetPersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <param name="path">要用作数据存储区关键字的个性化设置信息的路径。</param>
        <param name="userName">要用作数据存储区关键字的个性化设置信息的用户名。</param>
        <summary>在派生类中重写时，从基础数据存储区删除原始个性化设置数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生自的类<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider>和实现此方法应使用`webPartManager`， `path`，和`userName`参数作为存储密钥。 派生的实现必须修改数据存储，以便有效地删除提供的存储密钥的个性化数据。 负责派生的实现中有关如何它们以物理方式实现此目的。  
  
 派生的个性化设置提供程序必须能够将基于每个页的个性化数据区分开来。 此外，对于给定的页的状态，个性化设置提供程序必须能够区分<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>和<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>范围数据。 如果将非`null`提供用户名称，则重置操作都适用于<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>范围; 否则，重置操作应用于<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>作用域。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void ResetPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <summary>将个性化设置数据重置到基础数据存储区。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是使用的主入口点<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类，以重置个性化数据。 默认实现使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件以确定要重置的数据的路径和用户名称。 然后，默认实现调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPartManager" /> 不与页相关联。  
  
 \- 或 -  
  
 页不与正在进行的 <see cref="T:System.Web.HttpRequest" /> 关联。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public abstract int ResetState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetState (scope As PersonalizationScope, paths As String(), usernames As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, cli::array &lt;System::String ^&gt; ^ paths, cli::array &lt;System::String ^&gt; ^ usernames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="paths" Type="System.String[]" />
        <Parameter Name="usernames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="scope">要重置的个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />。 此值不能为 <see langword="null" />。</param>
        <param name="paths">要删除的个性化设置信息的路径。</param>
        <param name="usernames">要删除的个性化设置信息的用户名。</param>
        <summary>在派生类中重写时，根据指定的参数从基础数据存储区删除个性化设置状态。</summary>
        <returns>删除的行数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是删除个性化数据管理方法的抽象定义。 派生的实现应遵循下面所述的逻辑。  
  
 此方法不支持任何通配符搜索。 如果个性化设置提供程序公开识别事务的数据存储区中的数据，则此方法应作为单个原子事务执行其操作。  
  
 允许仅以下的参数组合：  
  
-   `scope`参数设置，并且所有其他参数设置为`null`。 此组合中删除与由个性化设置作用域关联的所有 Web 部件个性化数据`scope`。  
  
-   `scope`参数设置，和`paths`参数包含至少一个值。 此组合中删除指定的路径或中指示的个性化设置范围路径的所有 Web 部件个性化数据`scope`。  
  
-   `scope`参数设置为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>、`paths`参数已设置且只包含一个数值和`usernames`参数包含至少一个值。 此组合中删除所有用户个性化设置给定路径或多个用户中包含与该键关联的 Web 部件数据`usernames`。  
  
-   `scope`参数设置为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>、`paths`参数设置为`null`，和`usernames`参数包含至少一个值。 此组合跨所有路径或多个用户中包含与关联中删除所有的每个用户个性化 Web 部件数据`usernames`。  
  
 参数值的任何其他组合无效，将引发<xref:System.ArgumentException>异常。 具体而言，不允许使用以下两个组合：  
  
-   `usernames`参数不能提供时`scope`设置为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>。  
  
-   `paths`参数不能包含多个条目时`usernames`参数不是`null`。  
  
 任何`paths`和`usernames`各自的阵列中包含的参数值必须满足以下的验证规则。 如果任何验证规则失败的任何成员的参数数组中，<xref:System.ArgumentException>引发异常。 验证规则是：  
  
-   `null` 不允许值。  
  
-   空字符串 ("") 不允许。 在执行空字符串检查之前，应对剪裁参数。  
  
-   `usernames`参数不能包含逗号 （，）。  
  
-   长度`paths`参数不能大于 256 个字符，为 SQL 数据库。  
  
-   长度`usernames`参数不能大于 256 个字符，为 SQL 数据库。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetUserState">
      <MemberSignature Language="C#" Value="public abstract int ResetUserState (string path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetUserState(string path, valuetype System.DateTime userInactiveSinceDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetUserState(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetUserState (path As String, userInactiveSinceDate As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetUserState(System::String ^ path, DateTime userInactiveSinceDate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userInactiveSinceDate" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">要删除的个性化设置数据的路径。 此值可以为 <see langword="null" />，但不能为空字符串 ("")。</param>
        <param name="userInactiveSinceDate">日期，指示网站用户上次更改个性化设置数据的时间。</param>
        <summary>在派生类中重写时，根据指定的参数从基础数据存储区删除 Web 部件个性化设置数据。</summary>
        <returns>从基础数据存储区中删除的行数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是删除个性化数据管理方法的抽象定义。 请注意，此方法仅影响用户个性化设置数据和不共享的数据。  
  
 派生的实现应遵循下面所述的逻辑：  
  
-   `path`参数不能包含通配符字符。  
  
-   如果提供程序公开识别事务的数据存储区中的数据，则此方法应在单个原子事务中执行其操作。  
  
-   如果`path`参数为非`null`，然后仅每用户个性化设置记录与关联`path`将被删除。  
  
-   与所示的日期后被视为处于非活动状态的用户相关联的仅每用户个性化设置记录`userInactiveSinceDate`参数将被删除。 具体而言，记录<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A>小于或等于<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>将被删除。  
  
-   如果提供了两个参数，则不会删除这两个约束相匹配的记录。  
  
-   `path`参数可以为`null`。  
  
-   `path`参数不能为空字符串。 在执行此检查之前应剪裁它。  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> 属性不能为 `null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void SavePersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, byte[] dataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SavePersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[] dataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void SavePersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ dataBlob);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="dataBlob" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <param name="path">要用作数据存储区关键字的个性化设置信息的路径。</param>
        <param name="userName">要用作关键字的个性化设置信息的用户名。</param>
        <param name="dataBlob">要保存的数据的字节数组。</param>
        <summary>在派生类中重写时，将原始个性化设置数据保存到基础数据存储区中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是方法的用于将原始个性化数据保存到基础数据存储区的抽象定义。  
  
 派生的实现应使用`webPartManager`， `path`，和`userName`参数作为存储密钥。 派生的个性化设置提供程序必须能够将基于每个页的个性化数据区分开来。 此外，对于给定的页的状态，该提供程序必须能够区分<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>和<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>作用域。 如果将非`null`提供用户名称，则`dataBlob`参数处于<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>范围; 否则为`dataBlob`假定参数处于<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>作用域。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void SavePersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SavePersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SavePersonalizationState (state As PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SavePersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationState ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />，包含要保存的个性化设置数据。</param>
        <summary>将个性化设置数据保存到数据存储区中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是使用的主入口点<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类以保存个性化数据。  
  
 此方法的默认实现使用的内部实现的方法<xref:System.Web.UI.WebControls.WebParts.PersonalizationState>个性化设置数据打包到字节数组。 如果打包的结果创建一个空的字节数组 （因为属性提取不导致任何个性化数据），则默认实现调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A>方法。 否则，默认实现调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="state" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">正在保存的 <paramref name="state" /> 对象与 <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" /> 方法返回的 <paramref name="state" /> 对象类型不同。</exception>
      </Docs>
    </Member>
  </Members>
</Type>