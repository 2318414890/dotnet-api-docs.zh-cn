<Type Name="WebPartPersonalization" FullName="System.Web.UI.WebControls.WebParts.WebPartPersonalization">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b9225a4065a107241a4ecf7792267fabc5642a03" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30600511" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WebPartPersonalization" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartPersonalization extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartPersonalization" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartPersonalization" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Web.UI.WebControls.EmptyStringExpandableObjectConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>实现低级别个性化设置操作。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类实现执行较低级别个性化设置操作所需的逻辑。 尽管<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类管理个性化高级生命周期，它是<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>负责实际实现所必需执行特定的个性化设置操作的物理步骤的类。 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类又依赖于实现<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider>与个性化设置信息的基础数据存储进行通信。  
  
 如果你使用的默认实现<xref:System.Web.UI.WebControls.WebParts.WebPartManager>，它创建的实例<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>可以通过引用使用的类<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性。 例如，若要访问<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A>属性，则会指定`WebPartManager.Personalization.InitialScope`。  
  
   
  
## Examples  
 下面的代码示例演示如何<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>使用类时，以及提供个性化设置作用域将如何影响个性化设置属性的结果的示例。 此示例具有五个文件：  
  
-   一个.aspx 页面，以声明方式创建两个 Web 部件区域中，每个都有一个控件。  
  
-   用户控件调用`Color.ascx`，它允许用户更改应用基于用户的授权权限来修改状态信息以及进入共享的范围文本背景色的个性化设置的属性。  
  
-   用户控件调用`Persmode.ascx`，该值指示当前的页范围是且何种权限当前用户有输入共享的作用域或修改数据; 它还提供了两个按钮; 另一个用于更改作用域，另一个用于重置当前的用户个性化设置信息。  
  
-   一个用于授权用户的登录控件。  
  
-   具有一节提供了一种授权用户修改个性化设置状态并输入共享的范围的 Web.config 文件。  
  
 下面的代码创建的 aspx 页<xref:System.Web.UI.WebControls.WebParts.WebPartManager>和两个 Web 部件区域中并显示`Color.ascx`和`Persmode.ascx`控件。 用于获取当前的用户信息的登录页加载页面。 使用 ASP.NET 网站管理工具中[!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]若要创建用户访问页。 请参阅授予配置文件中的授权用户，可以更改作用域和修改状态信息的示例的 Web.config 文件。  
  
 [!code-aspx-csharp[WebParts_WebPartPersonalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/Defaultcs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartPersonalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/Defaultvb.aspx#1)]  
  
 下面的代码示例创建一个登录页面。 成功登录后它重定向到主 aspx 页。  
  
> [!IMPORTANT]
>  此示例具有一个接受用户输入的文本框，这是一个潜在的安全威胁。 默认情况下，ASP.NET 网页验证用户输入是否不包含脚本或 HTML 元素。 有关详细信息，请参阅[脚本侵入概述](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)。  
  
 [!code-aspx-csharp[WebParts_WebPartPersonalization#5](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/login.aspx#5)]
 [!code-aspx-vb[WebParts_WebPartPersonalization#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/login.aspx#5)]  
  
 下面的示例代码是此应用程序的 Web.config 文件的一部分。 本部分说明如何在这种情况下"user2"中设置的用户授权，输入共享个性化设置作用域以及如何修改个性化状态信息。 它还显示在此情况下"admin"，可用来允许用户在"管理员"角色中输入共享个性化设置范围和修改个性化设置状态信息的角色的一个示例。  
  
 [!code-aspx-csharp[WebParts_WebPartPersonalization#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/web.config#2)]
 [!code-aspx-vb[WebParts_WebPartPersonalization#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/web.config#2)]
  
 下面的代码示例创建一个用户控件，称为`Color.ascx`，，它允许用户更改的个性化设置的属性，在此情况下两个文本框中，根据当前的个性化设置范围和用户的授权权限的背景色.  
  
> [!IMPORTANT]
>  此示例具有一个接受用户输入的文本框，这是一个潜在的安全威胁。 默认情况下，ASP.NET 网页验证用户输入是否不包含脚本或 HTML 元素。 有关详细信息，请参阅[脚本侵入概述](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)。  
  
 [!code-aspx-csharp[WebParts_WebPartPersonalization#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/color.ascx#3)]
 [!code-aspx-vb[WebParts_WebPartPersonalization#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/color.ascx#3)]  
  
 下面的代码示例创建一个用户控件，称为`Persmode.ascx`、 显示当前的个性化设置范围和用户的权限修改状态和输入共享的作用域。 它还具有用于重置当前的个性化状态重置按钮。  
  
 [!code-aspx-csharp[WebParts_WebPartPersonalization#4](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/persMode.ascx#4)]
 [!code-aspx-vb[WebParts_WebPartPersonalization#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/persMode.ascx#4)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />与紧密合作类<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控制和个性化基础结构的其余部分。 个性化设置的默认实现是应满足您的个性化需要十分可靠子系统。 在大多数情况下，如果你想要自定义个性化设置，你可以创建的数据提供程序使用如个性化设置提供程序创建一个类继承自<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />。  
  
 如果你想要创建个性化子系统明显不同于所提供的<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />和<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类，应创建自定义<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />由派生自实现<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />并添加自己的自定义逻辑。 然后创建自定义<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />由派生自实现<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />，添加您自己的自定义逻辑，并重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />方法以返回您的自定义<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />实现。 因为<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控制通过个性化基础结构向发出请求<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />实例，<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件不是直接与交互或保留对引用<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />实现。</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartPersonalization (System.Web.UI.WebControls.WebParts.WebPartManager owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.UI.WebControls.WebParts.WebPartManager owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.#ctor(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (owner As WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartPersonalization(System::Web::UI::WebControls::WebParts::WebPartManager ^ owner);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="owner" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="owner">用于管理个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /></param>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数初始化此类的实例，并将其与关联<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的名义<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>个性化设置操作将执行实例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owner" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyPersonalizationState">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将个性化设置数据应用于与 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 实例关联的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 控件，或应用于特定 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyPersonalizationState">
      <MemberSignature Language="C#" Value="protected internal virtual void ApplyPersonalizationState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ApplyPersonalizationState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ApplyPersonalizationState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ApplyPersonalizationState ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ApplyPersonalizationState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将个性化设置数据应用于父 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled%2A>属性设置为`true`，此方法调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationState.ApplyWebPartPersonalization%2A>方法<xref:System.Web.UI.WebControls.WebParts.PersonalizationState>实例将应用于提供的 Web 部件控件的个性化设置状态。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在从基础数据存储区加载状态之前，进行了应用个性化设置状态的尝试。  
  
 \- 或 -  
  
 从数据存储区返回的个性化设置状态为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Docs>
    </Member>
    <Member MemberName="ApplyPersonalizationState">
      <MemberSignature Language="C#" Value="protected internal virtual void ApplyPersonalizationState (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ApplyPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ApplyPersonalizationState(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ApplyPersonalizationState(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要对其应用个性化设置数据的 Web 部件控件。</param>
        <summary>当父 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件请求将个性化设置数据应用于指定的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件时，按照其请求执行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法将个性化数据应用于单个<xref:System.Web.UI.WebControls.WebParts.WebPart>-派生类请求为此，则父级时<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 如果<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled%2A>属性设置为`true`，此方法调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationState.ApplyWebPartPersonalization%2A>方法<xref:System.Web.UI.WebControls.WebParts.PersonalizationState>实例将应用于提供的 Web 部件控件的个性化设置状态。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">进行了将个性化设置状态应用于不受父 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 管理的 Web 部件控件的尝试。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在从基础数据存储区加载状态之前，进行了应用个性化设置状态的尝试。  
  
 \- 或 -  
  
 从数据存储区返回的个性化设置状态为 <see langword="null" />。  
  
 \- 或 -  
  
 进行了将个性化设置数据应用于同一个 Web 部件控件的多次尝试。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Docs>
    </Member>
    <Member MemberName="CanEnterSharedScope">
      <MemberSignature Language="C#" Value="public bool CanEnterSharedScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnterSharedScope" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CanEnterSharedScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanEnterSharedScope As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanEnterSharedScope { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回一个值，该值指示用户是否已授权可以进入 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 范围。</summary>
        <value>
          如果用户已授权可以进入 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 范围，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回`true`如果用户授权中<xref:System.Web.UI.WebControls.WebParts.WebPartUserCapability>输入<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>作用域。  
  
 第一次调用该属性，它将确定用户的右输入<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>作用域，缓存信息。 如果<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.UserCapabilities%2A>字典之后修改第一次此属性被调用时，更改不会显示在对此属性的后续调用。  
  
   
  
## Examples  
 下面的代码演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CanEnterSharedScope%2A>属性。 此代码是在中找到一个更大的代码示例的一部分<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类的说明。  
  
 [!code-csharp[WebParts_WebPartPersonalization#7](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/persMode.ascx#7)]
 [!code-vb[WebParts_WebPartPersonalization#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/persMode.ascx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeScope">
      <MemberSignature Language="C#" Value="protected virtual void ChangeScope (System.Web.UI.WebControls.WebParts.PersonalizationScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ChangeScope(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ChangeScope(System.Web.UI.WebControls.WebParts.PersonalizationScope)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ChangeScope (scope As PersonalizationScope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ChangeScope(System::Web::UI::WebControls::WebParts::PersonalizationScope scope);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
      </Parameters>
      <Docs>
        <param name="scope">当前页的新个性化设置范围。</param>
        <summary>将当前页的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> 实例更改为指定的范围。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由指定的新作用域更改当前正在执行页的个性化设置范围`newScope`参数。 此方法是调用由公共受保护的帮助器方法<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>方法。 此受保护的方法存在是为了处理未来的扩展性，如果有多个两个可能的作用域之间进行切换。  
  
 如果当前作用域和`newScope`都是相同的值，则此方法不执行任何操作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">如果尝试从 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 范围切换到 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 范围，则当前用户不具有进入 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 范围的用户功能。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="scope" /> 不是 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> 枚举的有效成员。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="CopyPersonalizationState">
      <MemberSignature Language="C#" Value="protected internal virtual void CopyPersonalizationState (System.Web.UI.WebControls.WebParts.WebPart webPartA, System.Web.UI.WebControls.WebParts.WebPart webPartB);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CopyPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPart webPartA, class System.Web.UI.WebControls.WebParts.WebPart webPartB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CopyPersonalizationState (webPartA As WebPart, webPartB As WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CopyPersonalizationState(System::Web::UI::WebControls::WebParts::WebPart ^ webPartA, System::Web::UI::WebControls::WebParts::WebPart ^ webPartB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartA" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="webPartB" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPartA">提供个性化设置数据的 Web 部件控件。</param>
        <param name="webPartB">接收个性化设置数据的 Web 部件控件。</param>
        <summary>从一个 Web 部件控件提取个性化设置状态，并将它应用于另一个 Web 部件控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法提取个性化状态从`webPartA`和将其应用于`webPartB`。 此方法假定`webPartA`和`webPartB`具有相同的类型。 如果 Web 部件控件<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件，则该方法会将个性化状态复制从包装中的子控件`webPartA`给子控件包装在`webPartB`。  
  
 作为复制操作的一部分`webPartB`被标记为"脏"。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartA" /> 或 <paramref name="webPartB" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPartA" /> 和 <paramref name="webPartB" /> 不是同一种 <see cref="T:System.Type" />。  
  
 \- 或 -  
  
 <paramref name="webPartA" /> 和 <paramref name="webPartB" /> 是 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控件，但其中一个（或两个都）缺少子控件。  
  
 \- 或 -  
  
 <paramref name="webPartA" /> 和 <paramref name="webPartB" /> 是 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控件，但它们的子控件不是同一种 <see cref="T:System.Type" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public virtual bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Enabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回一个值，该值指示是否请求启用关联 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的个性化设置。</summary>
        <value>
          如果启用个性化设置，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性指示是否请求个性化若要启用父<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 请注意，这是细微但重要的意图的区别<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsInitialized%2A>。  
  
 此属性仅在完成之前设置<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A>方法。 在实践中，这意味着，<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Enabled%2A>属性必须在设置中的页标记<xref:System.Web.UI.WebControls.WebParts.WebPartManager>元素是否应该禁用个性化设置。 或者，可以将此属性设置期间`PreInit`阶段<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在完成关联 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" /> 方法之后，进行了设置此属性值的尝试。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureEnabled">
      <MemberSignature Language="C#" Value="public void EnsureEnabled (bool ensureModifiable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnsureEnabled(bool ensureModifiable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnsureEnabled(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnsureEnabled (ensureModifiable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnsureEnabled(bool ensureModifiable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ensureModifiable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ensureModifiable">布尔值，指示应进行哪种类型的检查。</param>
        <summary>确保 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 实例已完成初始化或当前用户具有修改个性化设置状态的权限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是帮助器方法，用于在几<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>方法以确保两个操作之一：  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>实例已完成初始化 (例如，<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A>方法已调用并已成功完成)。 如果进行此检查`ensureModifiable`参数等于`false`。  
  
     \- 或 -  
  
-   当前用户有权修改个性化设置状态。 如果进行此检查`ensureModifiable`等于`true`。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件还会在许多情况下调用此方法：  
  
-   若要切换为正常以外的项目的显示模式。 当前用户必须具有的权限修改个性化设置状态。  
  
-   若要添加，删除或移动 Web 部件控件。 当前用户必须具有的权限修改个性化设置状态。  
  
-   若要连接，断开连接，并编辑 Web 部件控件。 当前用户必须具有的权限修改个性化设置状态。  
  
-   若要导出页上的 Web 部件控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>实例必须已完成初始化。  
  
-   若要导入 Web 部件控件。 当前用户必须具有的权限修改个性化设置状态。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前用户不具有修改个性化设置信息的权限，或其他检查失败。  
  
 \- 或 -  
  
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled" /> 返回 <see langword="false" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Docs>
    </Member>
    <Member MemberName="EnterSharedScopeUserCapability">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartUserCapability EnterSharedScopeUserCapability;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartUserCapability EnterSharedScopeUserCapability" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EnterSharedScopeUserCapability As WebPartUserCapability " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartUserCapability ^ EnterSharedScopeUserCapability;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartUserCapability</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示进入 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 范围的用户授权的 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已将用户权限由字符串"enterSharedScope"表示在<xref:System.Web.UI.WebControls.WebParts.WebPartUserCapability>实例。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ExtractPersonalizationState">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从父 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件中提取个性化设置数据。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExtractPersonalizationState">
      <MemberSignature Language="C#" Value="protected internal virtual void ExtractPersonalizationState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ExtractPersonalizationState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ExtractPersonalizationState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ExtractPersonalizationState ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ExtractPersonalizationState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从父 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件中提取个性化设置数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled%2A>属性设置为`true`，和个性化设置状态将不重置在页请求期间 (例如，当<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ShouldResetPersonalizationState%2A>属性是`false`)，则此方法从父提取个性化数据<xref:System.Web.UI.WebControls.WebParts.WebPartManager>期间控制其<xref:System.Web.UI.Page.SaveStateComplete>事件。  
  
 此方法调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationState.ExtractWebPartManagerPersonalization%2A>方法<xref:System.Web.UI.WebControls.WebParts.PersonalizationState>实例从父提取个性化设置状态<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在从基础数据存储区加载状态之前，进行了提取个性化设置状态的尝试。  
  
 \- 或 -  
  
 尚未应用个性化设置状态。  
  
 \- 或 -  
  
 自应用个性化设置数据以来，<see cref="P:System.Web.UI.Control.ID" /> 的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 已更改。  
  
 \- 或 -  
  
 从数据存储区返回的个性化设置状态为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Docs>
    </Member>
    <Member MemberName="ExtractPersonalizationState">
      <MemberSignature Language="C#" Value="protected internal virtual void ExtractPersonalizationState (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ExtractPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ExtractPersonalizationState(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ExtractPersonalizationState(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">包含要提取的个性化设置数据的 Web 部件控件。</param>
        <summary>当父 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件请求从 Web 部件控件提取个性化设置数据时，按照其请求执行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled%2A>属性设置为`true`，和个性化设置状态将不重置在页请求期间 (例如，当<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ShouldResetPersonalizationState%2A>属性是`false`)，则此方法从 Web 部件控件提取个性化数据指定的`webPart`。 此方法调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationState.ExtractWebPartPersonalization%2A>方法<xref:System.Web.UI.WebControls.WebParts.PersonalizationState>实例从提供的 Web 部件控件提取个性化设置状态。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">进行了从不受父 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 管理的 Web 部件控件提取个性化设置状态的尝试。</exception>
        <exception cref="T:System.InvalidOperationException">在从基础数据存储区加载状态之前，进行了提取个性化设置状态的尝试。  
  
 \- 或 -  
  
 尚未应用个性化设置状态。  
  
 \- 或 -  
  
 自应用个性化设置数据以来，<see cref="P:System.Web.UI.Control.ID" /> 的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 已更改。  
  
 \- 或 -  
  
 从数据存储区返回的个性化设置状态为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Docs>
    </Member>
    <Member MemberName="GetAuthorizationFilter">
      <MemberSignature Language="C#" Value="protected internal virtual string GetAuthorizationFilter (string webPartID);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetAuthorizationFilter(string webPartID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.GetAuthorizationFilter(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetAuthorizationFilter (webPartID As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetAuthorizationFilter(System::String ^ webPartID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="webPartID">与要检索的筛选器关联的 Web 部件控件的 ID。</param>
        <summary>检索与指定的 Web 部件控件关联的授权筛选器（如果有）。</summary>
        <returns>指定的 Web 部件控件的授权筛选器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法检索的授权筛选器，如果任何，与标识的 Web 部件控件相关联`webPartID`。 序列化并由个性化设置的每个 Web 部件控件与`webPartID`参数。 在运行时，页面<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件可以筛选显示在页上通过确定是否授权每个 Web 部件控件的控件。 此授权信息作为字符串中与每个 Web 部件控件关联的数据存储。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled" /> 为 <see langword="false" /> 的情况下，在页的生命周期中，过早地通过调用此方法进行了检索授权筛选器的尝试。  
  
 \- 或 -  
  
 进行了检索授权筛选器的尝试，但是尚未加载任何个性化设置状态。  
  
 \- 或  
  
 从数据存储区返回的个性化设置状态为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPartID" /> 为 <see langword="null" /> 或空字符串 ("")。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="HasPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual bool HasPersonalizationState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasPersonalizationState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.HasPersonalizationState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasPersonalizationState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasPersonalizationState { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回一个值，该值指示当前页和个性化设置范围是否具有关联个性化设置数据。</summary>
        <value>
          如果页具有与之关联的个性化设置数据，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是用于确定当前页和范围的组合是否具有与之关联的个性化数据的简便方法。 在内部，该方法调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState%2A>上要确定数据是否存在的提供程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 实例关联的个性化设置提供程序。 如果在关联 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" /> 方法完成之前访问该属性，则会发生这种情况。  
  
 \- 或 -  
  
 关联的 <see cref="P:System.Web.UI.Control.Page" /> 的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 属性值为 <see langword="null" />。  
  
 \- 或 -  
  
 <see cref="P:System.Web.UI.Page.Request" /> 控件的关联 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 实例的 <see cref="T:System.Web.UI.Page" /> 属性的值是 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="InitialScope">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationScope InitialScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope InitialScope" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property InitialScope As PersonalizationScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::PersonalizationScope InitialScope { System::Web::UI::WebControls::WebParts::PersonalizationScope get(); void set(System::Web::UI::WebControls::WebParts::PersonalizationScope value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置默认个性化设置范围。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />，指示关联 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 的默认个性化设置范围。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性表示应用于父的默认个性化设置范围<xref:System.Web.UI.WebControls.WebParts.WebPartManager>以前了解适当的作用域没有的控件。 如果未显式设置此属性，则默认为返回<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>作用域。  
  
 此属性仅在完成之前设置<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A>方法。 在实践中，这意味着<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A>必须在设置中的页标记<xref:System.Web.UI.WebControls.WebParts.WebPartManager>元素。 或者，可以将此属性设置期间`PreInit`阶段<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在完成关联 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" /> 方法之后，进行了将此属性设置为当前值以外的值的尝试。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">尝试为不是 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope" /> 枚举成员的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> 设置一个值。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否启用了个性化设置，以及是否为 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 类的这一实例成功加载了个性化设置数据。</summary>
        <value>
          如果为当前的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 实例启用了个性化设置且成功加载了个性化设置数据，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 之前加载个性化数据，此属性始终返回`false`。 例如，此属性将返回`false`期间`PreInit`阶段。 在关联<xref:System.Web.UI.WebControls.WebParts.WebPartManager>的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A>方法已成功完成 (在此期间<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A>调用方法)，然后返回此属性将`true`。  
  
 此属性是受保护的可公开访问别名<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsInitialized%2A>属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="protected bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否启用了个性化设置，以及是否为 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 类的这一实例成功加载了个性化设置数据。</summary>
        <value>
          如果此实例的个性化设置已初始化，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果启用了个性化功能 (如果<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Enabled%2A>属性设置为`true`)，则<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>实例被视为初始化后立即关联<xref:System.Web.UI.WebControls.WebParts.WebPartManager>的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A>方法已成功完成 （在此期间<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A>调用方法)。 之前加载个性化数据，此属性始终返回`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsModifiable">
      <MemberSignature Language="C#" Value="public bool IsModifiable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsModifiable" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsModifiable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsModifiable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsModifiable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前用户是否已授权可以修改状态信息。</summary>
        <value>
          如果用户已授权可以修改状态信息，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 第一次调用此属性时，它将缓存的结果确定用户的权限才能修改个性化设置状态。 如果<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.UserCapabilities%2A>调用此属性在首次后修改字典，更改不会反映在后续调用此属性。  
  
   
  
## Examples  
 下面的代码演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsModifiable%2A>属性。 此代码是在中找到一个更大的代码示例的一部分<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类的说明。  
  
 [!code-csharp[WebParts_WebPartPersonalization#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/persMode.ascx#6)]
 [!code-vb[WebParts_WebPartPersonalization#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/persMode.ascx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.PersonalizationScope Load ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope Load() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Load () As PersonalizationScope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationScope Load();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>初始化个性化设置。</summary>
        <returns>父 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> 的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是初始化代表父级的个性化设置数据的主入口点<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 在父过程中调用此方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A>方法。 通常情况下，如果已对父禁用个性化<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件，将永远不会调用此方法。  
  
 在此方法的过程中，将发生以下初始化：  
  
-   对默认的个性化设置提供程序或自定义提供程序的引用所示<xref:System.Web.UI.WebControls.WebParts.WebPartManager>页面标记或<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ProviderName%2A>获取属性。  
  
-   调用该提供程序来确定用户功能 (<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineUserCapabilities%2A>) 为当前正在执行的用户。  
  
-   当前作用域用户/页/组合的个性化设置状态提供程序，从基础数据存储区加载 (<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState%2A>) 并存储在<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>实例。  
  
-   当前页/用户/范围的个性化设置范围由提供程序 (<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineInitialScope%2A>)。 请注意，此决定的结果可能是不同的值<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A>属性。  
  
 此方法返回的作用域值用作的值<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A>属性。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>由于个性化设置未启用的异常时才将发生<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A>直接调用方法。 在 ASP.NET 实现中，内部帮助程序方法实际上调用来执行负载，和此帮助器方法以无提示方式返回如果没有为页上启用个性化时。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">如果个性化设置未启用（<see cref="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Enabled" /> 等于 <see langword="false" />），则调用此方法。  
  
 \- 或 -  
  
 关联的 <see cref="P:System.Web.UI.Control.Page" /> 的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 属性值为 <see langword="null" />。  
  
 \- 或 -  
  
 <see cref="P:System.Web.UI.Page.Request" /> 控件的关联 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 实例的 <see cref="T:System.Web.UI.Page" /> 属性的值是 <see langword="null" />。</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">页面标记或 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ProviderName" /> 属性中显式设置了一个提供程序，但未能找到该提供程序。  
  
 \- 或 -  
  
 包含个性化设置状态数据的对象为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">加载和反序列化数据时出现问题。  
  
 \- 或 -  
  
 配置文件中的个性化设置提供程序的定义出现错误。</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">基础个性化设置提供程序未能初始化，原因是未能找到默认提供程序或在尝试初始化个性化设置提供程序时出错。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="ModifyStateUserCapability">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartUserCapability ModifyStateUserCapability;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartUserCapability ModifyStateUserCapability" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ModifyStateUserCapability As WebPartUserCapability " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartUserCapability ^ ModifyStateUserCapability;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartUserCapability</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示修改个性化设置状态的用户权限的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已将用户权限由字符串"modifyState"表示在<xref:System.Web.UI.WebControls.WebParts.WebPartUserCapability>实例。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="ProviderName">
      <MemberSignature Language="C#" Value="public virtual string ProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置个性化设置的提供程序的名称。</summary>
        <value>个性化设置提供程序的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回为此属性页声明中设置的值。 如果未设置此属性，它将返回<xref:System.String.Empty>。 在这种情况下，页使用默认个性化设置提供程序配置文件中指定。  
  
 此属性仅在完成之前设置<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A>方法。 这意味着<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ProviderName%2A>属性必须在设置页声明中<xref:System.Web.UI.WebControls.WebParts.WebPartManager>元素。  或者，可以将此属性设置期间`PreInit`阶段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在完成 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" /> 方法之后，进行了将此属性设置为当前值以外的值的尝试。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void ResetPersonalizationState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetPersonalizationState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ResetPersonalizationState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetPersonalizationState ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetPersonalizationState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在基础数据存储区中重置当前的页、范围和用户的个性化设置数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将重置为当前页、 范围和基础数据存储区中的用户的个性化数据。 重置的副作用，当前正在执行的页重新执行通过<xref:System.Web.HttpServerUtility.Transfer%2A>调用。 请注意，此传输重新执行当前页作为`GET`请求，而与该页最初请求的方式无关。  
  
 可以在任何时候调用此方法。 此方法在内部调用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ResetPersonalizationState%2A>上的提供程序的方法。 已成功重置数据后，<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ShouldResetPersonalizationState%2A>属性设置为`true`。 使用此属性是其他地方<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>要跳过从控件属性的解压个性化数据实例并将其保存，如果数据已重置。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 实例无法引用有效的个性化设置提供程序。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="protected virtual void Save ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Save" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Save ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Save();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前的页、范围和用户的个性化设置数据保存到基础数据存储区。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法调用期间<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的<xref:System.Web.UI.Page.SaveStateComplete>事件。 在内部，该方法调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationState%2A>上的提供程序的方法。  
  
 在尝试保存个性化数据，如果当前正在执行的用户不具有调用的功能<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability>(在当前<xref:System.Web.UI.WebControls.WebParts.WebPartUserCapability>实例) 会导致<xref:System.InvalidOperationException>异常。 请注意，这将仅是 true 如果<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件调用受保护<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Save%2A>直接的方法。 在 ASP.NET 实现中，内部帮助程序方法实际上调用来执行保存，和此帮助器方法以无提示方式返回如果当前正在执行的用户没有权限，无法修改数据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前的用户不具有称为 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability" /> 的功能。  
  
 \- 或 -  
  
 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 实例无法引用有效的个性化设置提供程序。  
  
 \- 或 -  
  
 当前没有任何个性化设置提供程序与 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 实例相关联。 如果在调用 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load" /> 之前调用此方法，则可能发生这种情况（个性化设置提供程序引用是在调用 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load" /> 期间获取的。  
  
 \- 或 -  
  
 尚未加载任何个性化设置状态。  
  
 \- 或 -  
  
 关联的 <see cref="T:System.Web.UI.Page" /> 的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 实例为 <see langword="null" />。  
  
 \- 或 -  
  
 <see cref="P:System.Web.UI.Page.Request" /> 控件的关联 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 实例的 <see cref="T:System.Web.UI.Page" /> 属性的值是 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="Scope">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.PersonalizationScope Scope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope Scope" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scope As PersonalizationScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::PersonalizationScope Scope { System::Web::UI::WebControls::WebParts::PersonalizationScope get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取父 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的当前个性化设置范围。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> 实例，指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 的范围。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此值最初设置基于从返回的值上<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A>方法。 可以修改此值，通过调用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>方法。  
  
 请注意，此令牌表示用于应用和提取个性化设置信息的作用域。 此属性的值可能会与不同<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A>属性或<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ChangeScope%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetDirty">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将父 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件标记为具有已更改的个性化数据（即“脏数据”）。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetDirty">
      <MemberSignature Language="C#" Value="protected internal virtual void SetDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SetDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.SetDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub SetDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void SetDirty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将父 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件标记为具有已更改的个性化数据（即“脏数据”）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled%2A>属性设置为`true`，此方法将标记父<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件用作"脏"。 具体取决于的实现详细信息<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的实例<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>，此方法可能调用安全检查和代码访问安全性权限检查。 此方法在内部调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationState.SetWebPartManagerDirty%2A>方法。  
  
 请注意，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件内部跟踪"脏"的状态，并将公开通过管理器的"更新"<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A>属性而不是通过此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未加载任何个性化设置数据。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="SetDirty">
      <MemberSignature Language="C#" Value="protected internal virtual void SetDirty (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SetDirty(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.SetDirty(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void SetDirty(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要标记为“更新”的 Web 部件控件。</param>
        <summary>将指定的 Web 部件控件标记为具有已更改（即“更新”）的个性化设置数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsEnabled%2A>属性设置为`true`，此方法将标记为"脏"指定的 Web 部件控件。 具体取决于的实现详细信息<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的实例<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>，此方法可能调用安全检查和代码访问安全性权限检查。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">进行了将不受父 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 管理的 Web 部件控件标记为“更新”的尝试。</exception>
        <exception cref="T:System.InvalidOperationException">尚未加载任何个性化设置数据。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="ShouldResetPersonalizationState">
      <MemberSignature Language="C#" Value="protected bool ShouldResetPersonalizationState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldResetPersonalizationState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ShouldResetPersonalizationState" />
      <MemberSignature Language="VB.NET" Value="Protected Property ShouldResetPersonalizationState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ShouldResetPersonalizationState { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示当前页的个性化设置数据是否已重置（例如，已请求从基础数据存储区删除个性化设置数据）。</summary>
        <value>
          如果当前页的个性化设置状态已重置，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性设置为`true`，它表示已重置当前页的个性化设置状态，提取的个性化数据从控件和后续保存操作应跳过。 目前，此属性自动设置为`true`个性化基础结构如果<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ResetPersonalizationState%2A>调用方法。  
  
 请注意，虽然有时可以设置此属性没有限制，但该属性必须设置为`true`之前<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的<xref:System.Web.UI.Page.SaveStateComplete>事件以产生任何影响。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleScope">
      <MemberSignature Language="C#" Value="public virtual void ToggleScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ToggleScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ToggleScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ToggleScope();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前页的个性化设置范围从 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 切换到 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />，或从 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 切换到 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法切换当前正在执行页的个性化设置范围。 切换范围导致<xref:System.Web.HttpServerUtility.Transfer%2A>回当前正在执行的页。  
  
 如果发生的 Web 部件控件的导入或导出时调用，此方法会执行任何操作。  
  
 如果切换范围请求则会发生页通过提交`POST`请求，则任何查询字符串值将保留在传输过程; 如果已通过提交页面，不会保留查询字符串参数`GET`请求。  
  
   
  
## Examples  
 下面的代码演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>方法。 此代码是在中找到一个更大的代码示例的一部分<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类的说明。  
  
 [!code-csharp[WebParts_WebPartPersonalization#7](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartPersonalization/CS/persMode.ascx#7)]
 [!code-vb[WebParts_WebPartPersonalization#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartPersonalization/VB/persMode.ascx#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在尝试从 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 范围切换到 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 范围时，当前用户不具有进入 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 范围的用户功能。  
  
 \- 或 -  
  
 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 实例尚未完成初始化。  
  
 \- 或 -  
  
 关联的 <see cref="T:System.Web.UI.Page" /> 的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 实例为 <see langword="null" />。  
  
 \- 或 -  
  
 <see cref="P:System.Web.UI.Page.Request" /> 控件的关联 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 实例的 <see cref="T:System.Web.UI.Page" /> 属性的值是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">进行了切换到未在 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> 枚举中定义的范围的尝试。 从技术角度看，绝不应出现这种情况。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />
      </Docs>
    </Member>
    <Member MemberName="UserCapabilities">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IDictionary UserCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary UserCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.UserCapabilities" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property UserCapabilities As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Collections::IDictionary ^ UserCapabilities { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从授予当前用户的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 获取用户功能集。</summary>
        <value>包含授予当前用户的一组用户功能的 <see cref="T:System.Collections.IDictionary" />，如果用户为匿名用户，则为空的 <see cref="T:System.Collections.Specialized.HybridDictionary" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前<xref:System.Web.UI.WebControls.WebParts.WebPartUserCapability>类包含两个值，该值指示用户的功能：`modifyState`和`enterSharedScope`。 为了便于使用，可以使用帮助器属性检查字典中包含的功能<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.IsModifiable%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CanEnterSharedScope%2A>。 请注意对访问其中任何一个属性; 后更改功能的限制有关详细信息，请参阅每个属性的描述部分。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Docs>
    </Member>
    <Member MemberName="WebPartManager">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManager WebPartManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManager WebPartManager" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartPersonalization.WebPartManager" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WebPartManager As WebPartManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManager ^ WebPartManager { System::Web::UI::WebControls::WebParts::WebPartManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与此 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 实例关联的当前父 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 控件的实例。</summary>
        <value>当前父 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性来确定<xref:System.Web.UI.WebControls.WebParts.WebPartManager>与此实例的关联控件<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Docs>
    </Member>
  </Members>
</Type>