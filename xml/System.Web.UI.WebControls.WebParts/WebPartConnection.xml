<Type Name="WebPartConnection" FullName="System.Web.UI.WebControls.WebParts.WebPartConnection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9876a0ff584b9342112f635529e62289ab52c444" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30591671" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class WebPartConnection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WebPartConnection extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WebPartConnection" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartConnection sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true, "Transformers")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供一个对象，该对象可使两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件形成连接。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Web 部件控件集，连接是链接或两个之间的关联<xref:System.Web.UI.WebControls.WebParts.WebPart>（或其他服务器或用户） 控件，使它们可以共享数据。 共享数据这种能力使得连接超过提供独立的控件的功能的方式使用的控件。 例如，如果一个控件提供了邮政编码数据，而另一个控件可以读取该数据并提供本地天气信息基于邮政编码，然后连接的功能的两个控件提供更大的价值对用户。 若要扩展此示例中，无法创建其他控件还基于邮政编码，如具有链接到本地新闻的控件的显示信息，并可以使用的邮政编码数据的所有这些控件可以与提供的单个控件共享数据邮政编码。 Web 部件应用程序的最终用户可以创建和管理直接从 Web 浏览器，使用标准连接用户界面 (UI) 提供的所有此类兼容的控件之间的连接<xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>控件，或使用提供的自定义用户界面开发人员。  
  
 这<xref:System.Web.UI.WebControls.WebParts.WebPartConnection>类概述是用于创建连接的基本详细信息的常规语句。 有关特定组件和创建连接的涉及到的要求的详细信息，请参阅[Web 部件连接概述](http://msdn.microsoft.com/library/d98cfd0f-ebd6-4871-89d5-abbd2cdef67b)，或请参阅引用类和代码示例下面的讨论中所述。 有几个 Web 部件连接中基本方面：  
  
-   两个<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 每个 Web 部件连接由两个控件组成。 一个控件，用于同时参与多个连接可能但每个单个连接由两个控件组成。 控件可以直接从派生<xref:System.Web.UI.WebControls.WebParts.WebPart>基类，也可以是其他服务器控件，包括 ASP.NET 控件、 自定义服务器控件和用户控件。 不要从派生的控件<xref:System.Web.UI.WebControls.WebParts.WebPart>类，如果置于<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域，使用自动包装<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象在运行时，使其能够从继承<xref:System.Web.UI.WebControls.WebParts.WebPart>类和函数作为运行时<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
-   控件位于<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域。 同时<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和任何其他类型的服务器控件必须驻留在<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域能够参与 Web 部件连接 （和大多数其他 Web 部件功能）。  
  
-   使用者和提供程序。 每个 Web 部件连接中有两个控件： 数据和数据的使用者的提供程序。 提供程序数据提供给使用者通过接口的形式返回数据的指定的回调方法。 （有关如何创建和指定的回调方法的示例，请参阅本主题的示例部分）。此回调方法被称为提供程序连接点。 此连接点 （其"友好的"名称、 ID 和返回的接口的类型） 的详细信息包含在<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>与提供程序控件关联的对象。 使用者通过可以接受接口的实例的指定方法将接收数据。 此方法被称为使用者连接点，以及连接点 （名称、 ID 和的接口类型） 的详细信息包含在<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>与使用者控件关联的对象。  
  
-   兼容的控件或有效的转换器。 若要连接，使用者和提供程序必须是兼容 （即其指定的连接点方法可以使用相同类型的接口） 或必须是<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象支持的转换由提供的类型转换为使用者理解为类型的提供程序。  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> 对象。 可用于存在，连接必须有的实例<xref:System.Web.UI.WebControls.WebParts.WebPartConnection>类，其中包含对提供程序和使用者的控制，以及它们的连接点的详细信息的引用。 如果提供程序和使用者不兼容，并且改用<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象进行连接，则连接引用转换器。  
  
-   建立连接的方法。 兼容的使用者和提供程序控件已正确连接点方法在设计和放置在区域中之后, 和<xref:System.Web.UI.WebControls.WebParts.WebPartConnection>对象都不可用，最后一个必要的基本步骤是发起的连接。 发生这种情况的一种方法是对用户创建的连接通过用户界面。 如果你将放置`<asp:connectionszone>`元素上的网页和其他所需的连接的组件是到位，在运行时用户可以将页切换到连接的显示模式，单击连接上的谓词提供程序或使用者的谓词菜单和一个连接用户界面 (基于<xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>控件) 将出现。 通过此 UI 中，用户可以发起的连接。 启动连接另一种方法是以编程方式执行。 在任一情况下，是否通过 UI 或以编程方式，基础方法，启动的连接是相同的。 应用程序调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法 (或<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法如果使用转换器) 上<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制，并向它传递提供程序、 使用者和及其各自的连接点对象，并且该方法返回<xref:System.Web.UI.WebControls.WebParts.WebPartConnection>对象。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection>类定义一个对象，封装之间两个连接的重要详细信息<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 类包含几乎完全与一个特定连接的详细信息相关的属性。 多个属性涉及连接中的使用者控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer%2A>属性引用自身，使用者控件和<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerID%2A>属性将引用使用者的 id。 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象，包含使用者的连接点的详细信息，该对象引用的使用者的<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPoint%2A>属性。 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID%2A>属性引用的 ID<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象。 所有这些与用户相关的连接属性必须具有值分配给他们创建的连接。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection>类还具有与在连接中，该提供程序控件相关的多个属性，这些属性与对应的使用者。 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider%2A>属性引用的提供者控件本身，而<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID%2A>属性引用其 id。 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPoint%2A>属性引用<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>对象，与<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID%2A>属性引用的提供程序的连接点的 ID。  
  
 多个属性涉及连接的状态。 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsActive%2A>属性指示连接是否处于活动状态 （当前交换数据） 或处于非活动状态 （仍已连接但不是主动共享数据）。 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A>属性指示连接是否共享 （适用于页的所有用户） 或特定于用户的连接，和<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsStatic%2A>属性指示控件是静态的 （声明中的页标记并因此是永久） 或动态 (以编程方式创建，这意味着它可以 deleted)。  
  
   
  
## Examples  
 下面的代码示例演示如何创建两个之间的简单连接<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 该示例演示建立连接的三种方式： 声明方式，通过将连接标记放置在网页; 的标记以编程方式在代码; 中创建连接和 UI，通过将放置<xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>控件在页上，这使得用户能够建立连接。  
  
 下面的代码示例包含四个部分：  
  
-   用户控件，使你能够更改 Web 部件页面上显示模式。  
  
-   源接口和两个代码<xref:System.Web.UI.WebControls.WebParts.WebPart>控制充当提供程序和连接的使用者。  
  
-   网页上承载的控件和运行的代码示例。  
  
-   如何运行该示例页的说明。  
  
 此代码示例的第一部分是使用户能够更改在网页上的显示模式的用户控件。 将以下源代码保存到一个.ascx 文件中，将其分配到的文件名称`Src`属性`Register`指令为此用户控件，即托管的 Web 页面顶部附近。 有关详细信息显示在此控件模式和源代码的说明，请参见[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_Overview#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Overview/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_Overview#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Overview/VB/DisplayModeMenuVB.ascx#6)]  
  
 下面的代码示例的第二部分是接口和控件的源代码。 源文件包含名为一个简单的界面`IZipCode`。 此外，还有<xref:System.Web.UI.WebControls.WebParts.WebPart>类名为`ZipCodeWebPart`，实现接口，并充当提供程序控制。 其`ProvideIZipCode`方法是实现接口的唯一成员的回调方法。 方法只返回接口的实例。 请注意，该方法将标有`ConnectionProvider`其元数据中的属性。 这是用于将方法标识为提供程序的连接点的回调方法的机制。 其他<xref:System.Web.UI.WebControls.WebParts.WebPart>类命名为`WeatherWebPart`，并且它可作为连接的使用者。 此类具有一个名为方法`GetZipCode`获取的实例`IZipCode`从提供者控件的接口。 请注意，此方法作为使用者的连接点方法标记为`ConnectionConsumer`其元数据中的属性。  
  
 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Overview/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Overview/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第三部分是网页。 顶部附近是`Register`用户控制和自定义的指令<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 该示例假定的控件的动态编译，因为控件的源代码应在 App_Code 子文件夹中;`Register`页中的标记引用仅任意标记前缀和控件的命名空间。 自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 （提供程序和使用者） 中声明，网页的`<asp:webpartzone>`元素中，内部`<zonetemplate>`元素。  
  
 页提供了三种方式自定义控件之间的连接。 第一种方法是声明性。 在页中，标记 <`StaticConnections>`元素声明，并且在其中为`<asp:WebPartConnections>`元素，与为属性指定的连接的各种使用者和提供程序详细信息。 这是一种方法创建的连接，具体而言是在直接在 Web 页中，声明`<asp:WebPartManager>`元素。 由于此静态连接，首次加载页面时立即创建两个自定义控件之间的连接。  
  
 构成控件之间的连接的第二种由`<asp:connectionszone>`在页中的元素。 如果用户在运行时，将页切换为连接的显示模式，单击上的一个自定义控件的连接谓词`<asp:connectionszone>`元素自动呈现用于创建连接的用户界面。  
  
 该页还演示创建连接，这是以编程方式执行操作的第三个方法。 在`Button1_Click`方法，该代码创建<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>对象的提供程序控制和检索其连接点的详细信息通过调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>方法。 它执行类似任务的使用者控件中，调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>方法。 最后，它会创建新<xref:System.Web.UI.WebControls.WebParts.WebPartConnection>对象通过调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Overview/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Overview/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 加载网页浏览器中之后，第一个连接已经存在，因为它在内声明`<StaticConnections>`元素。 输入中的某些文本**ZIP 代码提供程序**控制，以及它将显示在使用者控件。 接下来，断开连接两个控件。 使用**显示模式**下拉列表控件中，更改页后，可以连接的显示模式。 单击 （由标题栏中的向下箭头） 的谓词菜单为每个<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并请注意，每个都**连接**选项。 这是显示的谓词菜单中的连接动词仅页位于在连接模式下。 单击其中一个控件，并连接提供的用户界面上的连接谓词<xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>控件的外观。 单击**断开连接**按钮以结束控件之间的静态连接。 使用**显示模式**控件来返回到浏览模式的页。 尝试一些新的文本提供程序中重新输入，并请注意，控件会断开的连接，因为文本无法更新使用者控件中。  
  
 接下来，使用按上面所述的相同方法将页切换到连接的显示模式。 单击上每个控件的连接谓词。 单击**创建连接**链接，并使用提供的用户界面<xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>控件创建控件之间的连接。 这是创建连接的第二个方法。 请注意，一旦建立连接，最后一个的字符串你输入提供程序控件 （即会显示，因为控件已断开连接失败） 中会立即出现在使用者，因为已重新创建连接。 单击**断开连接**按钮以结束当前你刚刚创建的连接。 返回页后，可以浏览模式。 在要演示，将不会更新文本，并且控件再次断开连接的提供程序中输入一些新的文本。  
  
 返回页后，可以连接的显示模式。 而是单击连接谓词，单击**连接 web 部件控件**按钮，说明了建立连接的第三个方法。 此方法而无需使用连接以编程方式在一个简单的步骤中的控件<xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>控件。 请注意，创建连接时，你突然输入提供程序中的最后一个字符串显示在使用者控件中。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />
    <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
    <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
    <altmember cref="T:System.Web.UI.WebControls.WebParts.ConnectionsZone" />
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
    <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartConnection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartConnection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartConnection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.%23ctor%2A>构造函数是公共的以便在网页上的标记中声明连接时，ASP.NET 分析器可以创建实例; 此构造函数不应在开发人员代码中使用。  
  
 如果想要创建<xref:System.Web.UI.WebControls.WebParts.WebPartConnection>对象以编程方式，应使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A?displayProperty=nameWithType>或<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A?displayProperty=nameWithType>中提供的方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 这些方法处理创建连接的许多详细信息，返回<xref:System.Web.UI.WebControls.WebParts.WebPartConnection>对象。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.%23ctor%2A>构造函数<xref:System.Web.UI.WebControls.WebParts.WebPartConnection>类设置的值<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsStatic%2A>属性设置为`true`。 因此新的连接的默认状态将是静态 （这意味着在包含的 Web 页的标记中声明），并共享 （页上的所有用户可见）。 通过声明标记中的页的连接，在典型的方案中，添加连接时，会遇到这种情况`<asp:webpartconnection>`元素。 但是，在其他情况下连接将具有这些属性的不同值。 例如，当你添加连接以编程方式通过在代码中，创建连接对象以及用户在默认用户个性化设置作用域中查看页上，则连接该创建作为动态的每个 user(visible only to the specific user)连接。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsStatic%2A>属性是只读的且这些属性用于确定连接的性质内部设置<xref:System.Web.UI.WebControls.WebParts.WebPartManager>具体取决于如何创建连接的控件 (以声明方式在页标记中，或以编程方式通过你的代码或用户界面）。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      </Docs>
    </Member>
    <Member MemberName="Consumer">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart Consumer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart Consumer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Consumer As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ Consumer { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个作为连接中的使用者控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 对象。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />，表示作为连接中的使用者的 Web 部件控件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个 Web 部件连接中包含的共享数据的两个控件。 一个控件充当数据，提供程序和其他控件充当使用者，接收和处理从提供程序的数据。 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer%2A>属性获取的引用<xref:System.Web.UI.WebControls.WebParts.WebPart>控制作为连接关系中的使用者。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用的<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer%2A>属性。  
  
 下面的代码示例包含四个部分：  
  
-   用户控件，使你能够更改 Web 部件页面上显示模式。  
  
-   源接口和两个代码<xref:System.Web.UI.WebControls.WebParts.WebPart>控制充当提供程序和连接的使用者。  
  
-   网页上承载的控件和运行的代码示例。  
  
-   如何运行该示例页的说明。  
  
 此代码示例的第一部分是使用户能够更改在网页上的显示模式的用户控件。 将以下源代码保存到一个.ascx 文件中，将其分配到的文件名称`Src`属性`Register`指令为此用户控件，即托管的 Web 页面顶部附近。 有关详细信息显示在此控件模式和源代码的说明，请参见[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_Consumer#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Consumer/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_Consumer#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Consumer/VB/DisplayModeMenuVB.ascx#6)]  
  
 下面的代码示例的第二部分是对这两个源代码<xref:System.Web.UI.WebControls.WebParts.WebPart>充当使用者和提供程序连接和用于连接点的接口的控件。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_Consumer#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Consumer/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_Consumer#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Consumer/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第三部分是所承载控件并演示如何使用的 Web 页的代码<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer%2A>属性。 页面顶部附近是`Register`用户控制和自定义控件的指令。 由于本示例使用动态编译`Register`源文件的文件名的指令不需要引用程序集名称; 它包括仅任意标记前缀和控件的命名空间。 在`Button2_Click`方法中，代码访问连接对象，通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制，并获取对使用者控件的引用。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_Consumer#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Consumer/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_Consumer#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Consumer/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 加载浏览器中后，使用**显示模式**下拉列表控件，以将页切换到连接模式。 单击 （由标题栏中的向下箭头） 之一上的谓词菜单<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并单击连接谓词。 使用**连接 web 部件控件**按钮或提供的连接用户界面 (UI) 中，创建两个控件之间的连接。 单击**显示使用者信息**按钮以运行演示代码<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerID" /> 属性的长度为零。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider" />
      </Docs>
    </Member>
    <Member MemberName="ConsumerConnectionPoint">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint ConsumerConnectionPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint ConsumerConnectionPoint" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConsumerConnectionPoint As ConsumerConnectionPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ ConsumerConnectionPoint { System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个对象，该对象作为连接中充当使用者的控件的连接点。</summary>
        <value>与连接中的使用者控件关联的 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用于创建两个连接所需的步骤之一<xref:System.Web.UI.WebControls.WebParts.WebPart>控件是创建每个控件的连接点。 使用者连接点是包含有关如何连接到充当使用者的控件的信息的对象。 在使用者的源代码，一种方法必须标识与`ConnectionConsumer`属性。 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>与使用者控件关联的对象包含有关方法和属性，包括的方法，在用户界面 (UI) 中使用的显示名称的 ID 的详细信息和哪种类型的接口方法可以检索。 此组的使用者有关的信息，其用于形成连接和了解，接口的类型方法共同形成了使用者连接点。  
  
 默认情况下，<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象可连接到仅一个<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>对象一次。 使用者可以有多个方法标识为可能的使用者连接点，但使用者仅可参与一个连接为使用者 （因此，仅其中一个其使用者连接点可以处于活动状态） 一次。 与此相反，<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>可以连接到任意数量的<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象。 可以通过替代来更改此默认行为<xref:System.Web.UI.WebControls.WebParts.ConnectionConsumerAttribute.AllowsMultipleConnections%2A>属性<xref:System.Web.UI.WebControls.WebParts.ConnectionConsumerAttribute>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用的<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPoint%2A>属性。  
  
 该示例包含四个部分：  
  
-   用户控件，使你能够更改 Web 部件页面上显示模式。  
  
-   源接口和两个代码<xref:System.Web.UI.WebControls.WebParts.WebPart>控制充当提供程序和连接的使用者。  
  
-   网页上承载的控件和运行的代码示例。  
  
-   如何运行该示例页的说明。  
  
 此代码示例的第一部分是使用户能够更改在网页上的显示模式的用户控件。 将以下源代码保存到一个.ascx 文件中，将其分配到的文件名称`Src`属性`Register`指令为此用户控件，即托管的 Web 页面顶部附近。 有关详细信息显示在此控件模式和源代码的说明，请参见[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ConsumerConnectionPoint#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPoint/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_ConsumerConnectionPoint#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPoint/VB/DisplayModeMenuVB.ascx#6)]  
  
 下面的代码示例的第二部分是对这两个源代码<xref:System.Web.UI.WebControls.WebParts.WebPart>充当使用者和提供程序连接和用于连接点的接口的控件。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ConsumerConnectionPoint#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPoint/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ConsumerConnectionPoint#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPoint/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第三部分是所承载控件并演示如何使用的 Web 页的代码<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPoint%2A>属性。 在`Button1_Click`方法，以形成连接所需的所有对象都创建，包括<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象。 这些对象传递给<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法才能创建连接。 在`Button2_Click`方法中，代码访问<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPoint%2A>属性并显示点连接的一些详细信息。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ConsumerConnectionPoint#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPoint/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ConsumerConnectionPoint#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPoint/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 加载浏览器中后，使用**显示模式**下拉列表控件，以将页切换到连接模式。 单击 （由标题栏中的向下箭头） 之一上的谓词菜单<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并单击连接谓词。 使用**连接 web 部件控件**按钮或提供的连接 UI 中，创建两个控件之间的连接。 单击**连接点的详细信息**按钮以运行演示代码<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPoint%2A>属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConnectionConsumerAttribute" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Docs>
    </Member>
    <Member MemberName="ConsumerConnectionPointID">
      <MemberSignature Language="C#" Value="public string ConsumerConnectionPointID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConsumerConnectionPointID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID" />
      <MemberSignature Language="VB.NET" Value="Public Property ConsumerConnectionPointID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConsumerConnectionPointID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("default")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置连接上的属性值，该值引用作为该连接的使用者连接点的对象的 ID。</summary>
        <value>包含使用者连接点的 ID 的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于在网页上的标记中声明静态连接，开发人员可以指定的使用者连接点将用于通过分配到的值连接`ConsumerConnectionPointID`属性`<asp:webpartconnection>`元素。 如果值不分配给该属性，<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.DefaultID>使用属性值。  
  
 在创建动态 （编程） 的连接时，通常不应将的值<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID%2A>属性。 你可以轻松调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件中，将传递给它的使用者和使用者连接点对象，（以及其他必需的参数），而该方法将确定正确的 ID，用于使用者的连接点。 同样，如果在断开连接时，你可以调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法而无需指定<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID%2A>属性值。  
  
> [!NOTE]
>  当你指定时，可以确定使用者的连接点的 ID<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他服务器控件充当使用者。 你必须确定检索的提供者控件或转换器提供的接口的实例的使用者中的方法。 若要标识的方法，将其与标记`ConnectionConsumer`code 属性。 当添加此属性时，你可以添加一个可选的字符串值参数，作为使用者的 ID<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象。 如果你提供可选的 ID 参数的值，该值将成为的值<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID%2A>连接的属性。 如果未提供的 ID 值，<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.DefaultID>使用属性值。  
  
   
  
## Examples  
 下面的代码示例演示了声明性和以编程方式利用<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID%2A>属性。  
  
 该示例包含四个部分：  
  
-   用户控件，使你能够更改 Web 部件页面上显示模式。  
  
-   源接口和两个代码<xref:System.Web.UI.WebControls.WebParts.WebPart>控制充当提供程序和连接的使用者。  
  
-   网页上承载的控件和运行的代码示例。  
  
-   如何运行该示例页的说明。  
  
 此代码示例的第一部分是使用户能够更改在网页上的显示模式的用户控件。 将以下源代码保存到一个.ascx 文件中，将其分配到的文件名称`Src`属性`Register`指令为此用户控件，即托管的 Web 页面顶部附近。 有关详细信息显示在此控件模式和源代码的说明，请参见[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ConsumerConnectionPointID#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPointID/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_ConsumerConnectionPointID#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPointID/VB/DisplayModeMenuVB.ascx#6)]  
  
 下面的代码示例的第二部分是为接口和使用者和提供程序的控件的源代码。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ConsumerConnectionPointID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPointID/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ConsumerConnectionPointID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPointID/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第三部分是网页。 请注意，在页标记中，声明连接使用`<StaticConnections>`和`<asp:WebPartsConnection>`元素。 连接声明包含所需`ConsumerConnectionPointID`属性。 用于创建连接的第二个方式出现在`Button1_Click`方法，该代码在其中创建新的连接，使用在使用者控件中定义的连接点。 然后，在`Button2_Click`方法中，代码访问<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID%2A>属性。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ConsumerConnectionPointID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPointID/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ConsumerConnectionPointID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerConnectionPointID/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 加载浏览器中后，已存在的连接由于在页中声明了静态连接。 在提供程序控件中，输入一些文本，并记下它将显示在由于连接的使用者。 接下来，断开的控件。 使用**显示模式**下拉列表控件中，切换页后，可以连接模式。 单击 （由标题栏中的向下箭头） 之一上的谓词菜单<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并单击连接谓词。 单击**断开连接**按钮。 使用**连接 web 部件控件**按钮以重新创建两个控件之间的连接。 单击**连接点的详细信息**按钮以运行访问代码<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerConnectionPointID%2A>属性值。 在控件的下方的标签中情况下，值写出。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.ConnectionPoint.ID" />
      </Docs>
    </Member>
    <Member MemberName="ConsumerID">
      <MemberSignature Language="C#" Value="public string ConsumerID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConsumerID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerID" />
      <MemberSignature Language="VB.NET" Value="Public Property ConsumerID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConsumerID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置连接上的属性值，该值引用作为该连接的使用者的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的 ID。</summary>
        <value>一个字符串，包含作为连接中的使用者的控件的 ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerID%2A>属性值是必需的当你创建之间的连接时<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 如果值未分配给该属性，将引发异常时<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件尝试激活连接。  
  
   
  
## Examples  
 下面的代码示例演示了声明性和以编程方式利用<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerID%2A>属性。  
  
 该示例包含四个部分：  
  
-   用户控件，使你能够更改 Web 部件页面上显示模式。  
  
-   源接口和两个代码<xref:System.Web.UI.WebControls.WebParts.WebPart>控制充当提供程序和连接的使用者。  
  
-   网页上承载的控件和运行的代码示例。  
  
-   如何运行该示例页的说明。  
  
 此代码示例的第一部分是使用户能够更改在网页上的显示模式的用户控件。 将以下源代码保存到一个.ascx 文件中，将其分配到的文件名称`Src`属性`Register`指令为此用户控件，即托管的 Web 页面顶部附近。 有关详细信息显示在此控件模式和源代码的说明，请参见[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ConsumerID#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerID/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_ConsumerID#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerID/VB/DisplayModeMenuVB.ascx#6)]  
  
 下面的代码示例的第二部分是为接口和使用者和提供程序的控件的源代码。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ConsumerID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerID/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ConsumerID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerID/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第三部分是网页。 请注意，在页标记中，声明连接使用`<StaticConnections>`和`<asp:WebPartsConnection>`元素。 连接声明包含所需`ConsumerID`属性。 用于创建连接的第二个方式出现在`Button1_Click`方法，该代码在其中创建新的连接，使用在使用者控件中定义的连接点。 然后，在`Button2_Click`方法中，代码访问的值<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerID%2A>属性并将其显示在标签中。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ConsumerID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerID/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ConsumerID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ConsumerID/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 加载浏览器中后，已存在的连接由于在页中声明了静态连接。 在提供程序控件中，输入一些文本，并记下它将显示在由于连接的使用者。 接下来，断开的控件。 使用**显示模式**下拉列表控件中，切换页后，可以连接模式。 单击 （由标题栏中的向下箭头） 之一上的谓词菜单<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并单击连接谓词。 单击**断开连接**按钮。 使用**连接 web 部件控件**按钮以重新创建两个控件之间的连接。 单击**使用者详细信息**按钮以运行访问代码<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ConsumerID%2A>属性值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer" />
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ID" />
      <MemberSignature Language="VB.NET" Value="Public Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 对象的 ID。</summary>
        <value>包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 的 ID 的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个<xref:System.Web.UI.WebControls.WebParts.WebPartConnection>对象具有唯一值分配给其<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ID%2A>属性。 这是为了确保没有一种方法来区分多个连接。  
  
 如果通过声明创建静态连接`<asp:webpartconnection>`元素在网页上，并且你不将值赋给`ID`时，将引发连接异常属性<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件尝试激活连接。  
  
 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件创建一个新的动态连接时，它调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A>方法来生成连接的唯一 ID。  
  
   
  
## Examples  
 下面的代码示例演示了声明性和以编程方式利用<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ID%2A>属性。  
  
 该示例包含四个部分：  
  
-   用户控件，使你能够更改 Web 部件页面上显示模式。  
  
-   源接口和两个代码<xref:System.Web.UI.WebControls.WebParts.WebPart>控制充当提供程序和连接的使用者。  
  
-   网页上承载的控件和运行的代码示例。  
  
-   如何运行该示例页的说明。  
  
 此代码示例的第一部分是使用户能够更改在网页上的显示模式的用户控件。 将以下源代码保存到一个.ascx 文件中，将其分配到的文件名称`Src`属性`Register`指令为此用户控件，即托管的 Web 页面顶部附近。 有关详细信息显示在此控件模式和源代码的说明，请参见[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ID#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ID/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_ID#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ID/VB/DisplayModeMenuVB.ascx#6)]  
  
 下面的代码示例的第二部分是为接口和使用者和提供程序的控件的源代码。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ID/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ID/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第三部分是网页。 请注意，在页标记中，声明连接使用`<StaticConnections>`和`<asp:WebPartsConnection>`元素。 连接声明包含所需`ID`属性。 用于创建连接的第二个方式出现在`Button1_Click`方法，该代码在其中创建新的连接，使用在使用者控件中定义的连接点。 在这里，ID 属性不是必需的因为连接是动态的与<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件分配一个 ID 为的连接。 在`Button2_Click`方法中，代码访问的值<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ID%2A>属性并将其显示在标签中。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ID/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ID/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 加载浏览器中后，已存在的连接由于在页中声明了静态连接。 在提供程序控件中，输入一些文本，并记下它将显示在由于连接的使用者。 接下来，断开的控件。 使用**显示模式**下拉列表控件中，切换页后，可以连接模式。 单击 （由标题栏中的向下箭头） 之一上的谓词菜单<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并单击连接谓词。 单击**断开连接**按钮。 使用**连接 web 部件控件**按钮以重新创建两个控件之间的连接。 单击**连接详细信息**按钮以运行访问代码<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ID%2A>属性值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 对象当前是否已经建立并且能够在其提供者和使用者控件之间交换数据。</summary>
        <value>
          如果连接处于活动状态，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsActive%2A>属性指示的状态<xref:System.Web.UI.WebControls.WebParts.WebPartConnection>对象。 此状态连接时，连接中的提供程序和使用者的控件进行通信，并且能够交换通过公共接口的数据或<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象。  
  
 当用户查看呈现的页面，其中包含已建立的连接中正常浏览模式时，则将连接通常 active （除非它无法在加载页面时被激活由于某些冲突或其他问题）。 在页和控件的生命周期的早期阶段，该属性值将`false`。 该连接将紧后面激活<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>上的事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>引发控件。 具体而言，该连接将激活后使用者是否已从提供程序检索指定的接口的实例或<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象。  
  
 它是有助于你了解连接是否处于活动状态的情况下可能出现冲突或由于页上的多个连接的同步问题的位置。 例如，如果没有某种类型的两个连接之间的冲突<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件可以选择不激活的多个连接，以避免冲突。  
  
   
  
## Examples  
 下面的代码示例演示使用<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsActive%2A>属性。  
  
 该示例包含三个部分：  
  
-   源接口和两个代码<xref:System.Web.UI.WebControls.WebParts.WebPart>控制充当提供程序和连接的使用者。  
  
-   网页上承载的控件和运行的代码示例。  
  
-   如何运行该示例页的说明。  
  
 下面的代码示例的第一部分是接口，以及使用者和提供程序控件的源代码。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_IsActive#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_IsActive/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_IsActive#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_IsActive/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第二部分是网页。 顶部附近，有`Register`指的是两个动态编译的源代码的指令<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 在中声明静态连接`<StaticConnections>`页面上的元素。 在`<script>`元素是四个事件处理程序。 每个事件处理程序检查的值<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsActive%2A>属性静态连接，并将消息写入<xref:System.Web.UI.WebControls.Label>，该值指示连接在该状态页和控件的生命周期中是否为活动或非活动的控件。 此示例演示在哪一时间点连接将变为活动状态，并且，它将保持活动页后面呈现。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_IsActive#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_IsActive/CS/wpConnectIsActiveCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_IsActive#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_IsActive/VB/wpConnectIsActiveVB.aspx#1)]  
  
 加载浏览器中的页。 已创建静态连接，并且消息已写入显示是否页和控件的生命周期中处于活动状态的不同位置已连接的标签。 单击**连接详细信息**按钮，然后请注意，此连接不是活动在该点，但连接被重新激活后每次<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>事件，并且，它仍处于活动状态 （会保持操作） 后<xref:System.Web.UI.Control.PreRender>页的事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="IsShared">
      <MemberSignature Language="C#" Value="public bool IsShared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsShared" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsShared As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsShared { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 对象是对所有用户可见还是仅对当前用户可见。</summary>
        <value>
          如果连接是共享的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 个人与<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，<xref:System.Web.UI.WebControls.WebParts.WebPartConnection>对象可以是共享或每个用户实例。 共享的实例表示的连接是可见的网页上，所有用户，每个用户实例表示的连接是只对特定用户可见。  
  
 一般情况下，连接将会添加到页的方式确定是否共享的连接。 如果在 Web 网页、 的标记中声明连接，则共享的连接和<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A>属性值是`true`。 此外，如果添加连接时，Web 页被共享个性化设置作用域中，连接也会共享。 通常情况下，当用户使用`<asp:connectionszone>`用户界面 (UI) 来添加连接时，页上已在用户个性化设置作用域，因此不共享的连接和<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A>属性值是`false`。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用的<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A>属性。  
  
 此代码示例包括五个部分：  
  
-   用户控件，使你能够更改 Web 部件页面上显示模式。  
  
-   源接口和两个代码<xref:System.Web.UI.WebControls.WebParts.WebPart>控制充当提供程序和连接的使用者。  
  
-   网页上承载的控件和运行的代码示例。  
  
-   运行示例所需的 Web.config 文件中的条目。  
  
-   如何运行该示例页的说明。  
  
 此代码示例的第一部分是使用户能够更改在网页上的显示模式的用户控件。 将以下源代码保存到一个.ascx 文件中，将其分配到的文件名称`Src`属性`Register`指令为此用户控件，即托管的 Web 页面顶部附近。 有关详细信息显示在此控件模式和源代码的说明，请参见[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_IsShared#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_IsShared/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_IsShared#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_IsShared/VB/DisplayModeMenuVB.ascx#6)]  
  
 下面的代码示例的第二部分是为接口和使用者和提供程序的控件的源代码。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_IsShared#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_IsShared/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_IsShared#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_IsShared/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第三部分是网页。 在`Button2_Click`方法，它会检查<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A>的现有连接的属性，并在页上显示结果。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_IsShared#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_IsShared/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_IsShared#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_IsShared/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 代码示例的第四个部分是将运行示例后，若要能够编辑共享个性化设置范围中的页的用户帐户需要的 Web.config 文件中的条目。 若要启用此功能，必须具有一个条目在 Web.config 文件内`<system.web>`如以下示例所示的部分。  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow users="UserAccount"  
             roles="admin"  
             verbs="enterSharedScope"/>  
    </authorization>            
  </personalization>  
</webParts>  
```  
  
 加载浏览器中后，使用**显示模式**下拉列表控件，以将页切换到连接的显示模式。 单击**连接 web 部件控件**按钮以形成连接。 接下来，单击**连接详细信息**按钮以显示是否共享的连接。 如果你使用默认的用户个性化设置作用域中的页创建连接<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A>属性值应为`false`连接。  
  
 谓词菜单中的其中一个<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 （由标题栏中的向下箭头指示），单击连接谓词。 连接 UI 出现时，单击**断开连接**按钮终止连接。 使用**显示模式**控件来返回到浏览模式的页。  
  
 在**显示模式**控件中，选择**共享**选项以将页切换到共享个性化设置作用域。 请按照与这些上面创建的连接，并再次单击相同的步骤**连接详细信息**按钮以显示是否共享的连接。 在此情况下，值<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsShared%2A>属性应为`true`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 对象是在网页的标记中声明的，还是以编程方式创建的。</summary>
        <value>
          如果连接是静态的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 部件控件之间的连接可以是静态或动态。 在网页中，标记中声明静态连接使用`<asp:WebPartConnection>`元素。 以编程方式创建动态连接或当用户创建一个通过由定义的用户界面 (UI) 的连接<xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>控件。  
  
 静态连接都共享的对象，这意味着它们将可供所有用户的网页。 此外，它们是实质上是永久因为，如静态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，它们不能被永久删除。  
  
> [!NOTE]
>  虽然静态连接对象不能被永久删除，它可以被永久断开。 在这种情况下，断开连接的对象将存在于服务器，但最终用户永远不会注意在页中的对象存在。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用的<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsStatic%2A>属性。  
  
 代码示例包含三个部分：  
  
-   源接口和两个代码<xref:System.Web.UI.WebControls.WebParts.WebPart>控制充当提供程序和连接的使用者。  
  
-   若要承载控件并运行此代码示例网页。  
  
-   如何运行该示例页的说明。  
  
 下面的代码示例的第一部分是接口，以及使用者和提供程序控件的源代码。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_IsStatic#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_IsStatic/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_IsStatic#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_IsStatic/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第二部分是网页。 顶部附近，有`Register`指的是两个动态编译的源代码的指令<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 在中声明静态连接`<StaticConnections>`页面上的元素。 `Button1_Click`方法访问<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsStatic%2A>属性检查连接是否为静态字段。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_IsStatic#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_IsStatic/CS/wpConnectIsStaticCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_IsStatic#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_IsStatic/VB/wpConnectIsStaticVB.aspx#1)]  
  
 加载浏览器中的页。 已创建静态连接。 在提供程序控件中，输入一些文本，并请注意，在使用者控件中显示的文本。 单击**连接详细信息**按钮以显示的值<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.IsStatic%2A>属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      </Docs>
    </Member>
    <Member MemberName="Provider">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart Provider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart Provider" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Provider As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ Provider { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取作为 Web 部件连接中的提供者的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</summary>
        <value>作为数据提供者的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每个 Web 部件连接包含两个<xref:System.Web.UI.WebControls.WebParts.WebPart>控件-使用者和提供程序--和<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider%2A>属性返回中连接到提供程序控件的引用。  
  
 连接 （使用者控件） 中其对应项，如提供程序控件需要建立连接。 是否以编程方式，或通过声明以页持久性格式创建连接，你必须指定一个控件，用于充当用于连接的提供程序。  
  
   
  
## Examples  
 下面的代码示例演示使用<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider%2A>属性。  
  
 代码示例包含三个部分：  
  
-   源接口和两个代码<xref:System.Web.UI.WebControls.WebParts.WebPart>控制充当提供程序和连接的使用者。  
  
-   若要承载控件并运行此代码示例网页。  
  
-   如何运行该示例页的说明。  
  
 下面的代码示例的第一部分是接口，以及使用者和提供程序控件的源代码。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_Provider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Provider/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_Provider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Provider/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第二部分是网页。 顶部附近，有`Register`指的是两个动态编译的源代码的指令<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 在中声明静态连接`<StaticConnections>`页面上的元素。 请注意，在`<asp:webpartconnection>`元素，`ProviderID`属性具有分配给它的提供者控件的 ID。 这是标识提供程序的静态连接所需的。 `Button1_Click`方法访问<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider%2A>属性和一些其详细信息将写入一个标签。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_Provider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_Provider/CS/wpConnectProviderCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_Provider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_Provider/VB/wpConnectProviderVB.aspx#1)]  
  
 加载浏览器中的页。 已创建静态连接。 在提供程序控件中，输入一些文本，并请注意，在使用者控件中显示的文本。 单击**提供程序详细信息**按钮以显示一些通过访问的属性值<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID" /> 属性值的长度为零。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Consumer" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID" />
      </Docs>
    </Member>
    <Member MemberName="ProviderConnectionPoint">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.ProviderConnectionPoint ProviderConnectionPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint ProviderConnectionPoint" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProviderConnectionPoint As ProviderConnectionPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ ProviderConnectionPoint { System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个对象，该对象作为充当连接提供者的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的连接点。</summary>
        <value>与连接中的提供者控件关联的 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用于创建两个连接所需的步骤之一<xref:System.Web.UI.WebControls.WebParts.WebPart>控件是创建每个控件的连接点。 提供程序连接点是包含有关如何连接到控件中充当提供程序的信息的对象。 在提供程序的源代码，一种方法必须标识与`ConnectionProvider`属性。 <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>即关联控件使用提供程序包含有关方法和属性，包括的方法，在用户界面 (UI) 中使用的显示名称的 ID 的详细信息，哪种类型的接口实例方法可以返回到使用者控件。 这套有关提供程序的信息，其用于形成方法连接，以及它提供的接口的类型共同形成了提供程序连接点。  
  
 默认情况下，<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>可连接到仅一个<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>对象一次。 使用者可以有多个方法标识为可能的使用者连接点，但使用者仅可参与一个连接为使用者 （因此，仅其中一个其使用者连接点可以处于活动状态） 一次。 与此相反，<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>可以连接到任意数量的<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>默认情况下的对象。 例如，提供的邮政编码的提供程序控件无法连接到使用邮政代码来创建基于邮政编码，如天气数据、 新闻和等等的数据的各种类型的多个使用者控件。 可以通过替代来更改此默认行为<xref:System.Web.UI.WebControls.WebParts.ConnectionProviderAttribute.AllowsMultipleConnections%2A>属性<xref:System.Web.UI.WebControls.WebParts.ConnectionProviderAttribute>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用的<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPoint%2A>属性。  
  
 该示例包含四个部分：  
  
-   用户控件，使你能够更改 Web 部件页面上显示模式。  
  
-   源接口和两个代码<xref:System.Web.UI.WebControls.WebParts.WebPart>控制充当提供程序和连接的使用者。  
  
-   网页上承载的控件和运行的代码示例。  
  
-   如何运行该示例页的说明。  
  
 此代码示例的第一部分是使用户能够更改在网页上的显示模式的用户控件。 将以下源代码保存到一个.ascx 文件中，将其分配到的文件名称`Src`属性`Register`指令为此用户控件，即托管的 Web 页面顶部附近。 有关详细信息显示在此控件模式和源代码的说明，请参见[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ProviderConnectionPoint#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPoint/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_ProviderConnectionPoint#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPoint/VB/DisplayModeMenuVB.ascx#6)]  
  
 下面的代码示例的第二部分是对这两个源代码<xref:System.Web.UI.WebControls.WebParts.WebPart>充当使用者和提供程序连接和用于连接点的接口的控件。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ProviderConnectionPoint#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPoint/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ProviderConnectionPoint#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPoint/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第三部分是所承载控件并演示如何使用的 Web 页的代码<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPoint%2A>属性。 在`Button1_Click`方法，以形成连接所需的所有对象都创建，包括<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>对象。 请注意调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 各种创建的对象被传递给<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法才能创建连接。 在`Button2_Click`方法中，代码访问<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPoint%2A>属性并显示点连接的一些详细信息。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ProviderConnectionPoint#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPoint/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ProviderConnectionPoint#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPoint/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 加载浏览器中后，使用**显示模式**下拉列表控件，以将页切换到连接模式。 单击 （由标题栏中的向下箭头） 之一上的谓词菜单<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并单击连接谓词。 使用**连接 web 部件控件**按钮或提供的连接 UI 中，创建两个控件之间的连接。 单击**连接点的详细信息**按钮以运行演示代码<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPoint%2A>属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConnectionProviderAttribute" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ProviderConnectionPointID">
      <MemberSignature Language="C#" Value="public string ProviderConnectionPointID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProviderConnectionPointID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID" />
      <MemberSignature Language="VB.NET" Value="Public Property ProviderConnectionPointID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProviderConnectionPointID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("default")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置连接上的属性值，该值引用作为该连接的提供者连接点的对象的 ID。</summary>
        <value>包含提供者连接点对象的 ID 的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于在网页上的标记中声明静态连接，开发人员可以指定的提供程序连接点将用于通过分配到的值连接`ProviderConnectionPointID`属性`<asp:webpartconnection>`元素。 如果值不分配给该属性，<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.DefaultID>使用属性值。  
  
 在创建动态 （编程） 的连接时，通常不应将的值<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID%2A>属性。 你可以轻松调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件中，传给该提供程序和提供程序连接点对象，（以及其他必需的参数），而该方法将确定正确的 ID，用于提供程序的连接点。 同样，如果在断开连接时，你可以调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法而无需指定<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID%2A>属性值。  
  
> [!NOTE]
>  当你指定时，可以确定的提供程序的连接点的 ID<xref:System.Web.UI.WebControls.WebParts.WebPart>或作为提供程序的其他服务器控件。 你必须标识提供程序都包含数据的使用者的接口的实例中的回调方法。 若要标识的方法，将其与标记`ConnectionProvider`code 属性。 当添加此属性时，你可以添加可选的字符串值参数，用作提供程序的 ID<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>对象。 如果你提供可选的 ID 参数的值，该值将成为的值<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID%2A>连接的属性。 如果未提供的 ID 值，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>创建对象时，控件将分配一个默认 ID。  
  
   
  
## Examples  
 下面的代码示例演示了声明性和以编程方式利用<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID%2A>属性。  
  
 该示例包含四个部分：  
  
-   用户控件，使你能够更改 Web 部件页面上显示模式。  
  
-   源接口和两个代码<xref:System.Web.UI.WebControls.WebParts.WebPart>控制充当提供程序和连接的使用者。  
  
-   网页上承载的控件和运行的代码示例。  
  
-   如何运行该示例页的说明。  
  
 此代码示例的第一部分是使用户能够更改在网页上的显示模式的用户控件。 将以下源代码保存到一个.ascx 文件中，将其分配到的文件名称`Src`属性`Register`指令为此用户控件，即托管的 Web 页面顶部附近。 有关详细信息显示在此控件模式和源代码的说明，请参见[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ProviderConnectionPointID#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPointID/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_ProviderConnectionPointID#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPointID/VB/DisplayModeMenuVB.ascx#6)]  
  
 下面的代码示例的第二部分是为接口和使用者和提供程序的控件的源代码。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ProviderConnectionPointID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPointID/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ProviderConnectionPointID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPointID/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第三部分是网页。 请注意，在页标记中，声明连接使用`<StaticConnections>`和`<asp:WebPartsConnection>`元素。 连接声明包含所需`ProviderConnectionPointID`属性。 用于创建连接的第二个方式出现在`Button1_Click`方法，其中该代码创建新的连接，使用的连接点 （和 ID） 提供程序在控件中定义。 然后，在`Button2_Click`方法中，代码访问<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID%2A>属性。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ProviderConnectionPointID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPointID/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ProviderConnectionPointID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderConnectionPointID/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 加载浏览器中后，已存在的连接由于在页中声明了静态连接。 在提供程序控件中，输入一些文本，并记下它将显示在由于连接的使用者。 接下来，断开的控件。 使用**显示模式**下拉列表控件中，切换页后，可以连接模式。 单击 （由标题栏中的向下箭头） 之一上的谓词菜单<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并单击连接谓词。 单击**断开连接**按钮。 使用**连接 web 部件控件**按钮以重新创建两个控件之间的连接。 单击**连接点的详细信息**按钮以运行访问代码<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderConnectionPointID%2A>属性值。 在控件的下方的标签中情况下，值写出。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.ConnectionPoint.ID" />
      </Docs>
    </Member>
    <Member MemberName="ProviderID">
      <MemberSignature Language="C#" Value="public string ProviderID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProviderID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID" />
      <MemberSignature Language="VB.NET" Value="Public Property ProviderID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProviderID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置连接上的属性值，该值引用作为该连接的提供者的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的 ID。</summary>
        <value>包含提供者控件的 ID 的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID%2A>属性值是必需的当您创建两个连接<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 如果值未分配给该属性，将引发异常时<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件尝试激活连接。  
  
   
  
## Examples  
 下面的代码示例演示了声明性和以编程方式利用<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID%2A>属性。  
  
 该示例包含四个部分：  
  
-   用户控件，使你能够更改 Web 部件页面上显示模式。  
  
-   源接口和两个代码<xref:System.Web.UI.WebControls.WebParts.WebPart>控制充当提供程序和连接的使用者。  
  
-   网页上承载的控件和运行的代码示例。  
  
-   如何运行该示例页的说明。  
  
 此代码示例的第一部分是使用户能够更改在网页上的显示模式的用户控件。 将以下源代码保存到一个.ascx 文件中，将其分配到的文件名称`Src`属性`Register`指令为此用户控件，即托管的 Web 页面顶部附近。 有关详细信息显示在此控件模式和源代码的说明，请参见[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ProviderID#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderID/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartConnection_ProviderID#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderID/VB/DisplayModeMenuVB.ascx#6)]  
  
 下面的代码示例的第二部分是为接口和使用者和提供程序的控件的源代码。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ProviderID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderID/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ProviderID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderID/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第三部分是网页。 请注意，在页标记中，声明连接使用`<StaticConnections>`和`<asp:WebPartsConnection>`元素。 连接声明包含所需`ProviderID`属性。 用于创建连接的第二个方式出现在`Button1_Click`方法，该代码在其中创建新的连接，使用在使用者控件中定义的连接点。 然后，在`Button2_Click`方法中，代码访问的值<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID%2A>属性并将其显示在标签中。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ProviderID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderID/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ProviderID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ProviderID/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 加载浏览器中后，已存在的连接由于在页中声明了静态连接。 在提供程序控件中，输入一些文本，并记下它将显示在由于连接的使用者。 接下来，断开的控件。 为此，请使用**显示模式**下拉列表控件，以将页切换到连接模式。 单击 （由标题栏中的向下箭头） 之一上的谓词菜单<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并单击连接谓词。 单击**断开连接**按钮和控件断开连接。 接下来，使用**连接 web 部件控件**按钮以重新创建两个控件之间的连接。 单击**使用者详细信息**按钮以运行访问代码<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ProviderID%2A>属性值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Provider" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartConnection.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重写继承的 <see cref="M:System.Object.ToString" /> 方法，并返回连接对象的类型的简称。</summary>
        <returns>一个字符串，包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 的类型简称（非限定名称）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用主要为方便起见，由控件开发人员。 它可以提高连接对象的显示方式在设计视图中使用较短的类型名，而不是完全限定的类型名称。 但是，该方法可以调用你的代码中的任何点在你想要知道连接对象的类型名称。  
  
   
  
## Examples  
 下面的代码示例演示如何调用<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ToString%2A>方法返回的短类型名称<xref:System.Web.UI.WebControls.WebParts.WebPartConnection>对象。  
  
 代码示例包含三个部分：  
  
-   源接口和两个代码<xref:System.Web.UI.WebControls.WebParts.WebPart>控制充当提供程序和连接的使用者。  
  
-   若要承载控件并运行此代码示例网页。  
  
-   如何运行该示例页的说明。  
  
 下面的代码示例的第一部分是接口，以及使用者和提供程序控件的源代码。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartConnection_ToString#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ToString/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartConnection_ToString#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ToString/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第二部分是网页。 顶部附近，有`Register`指的是两个动态编译的源代码的指令<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 在中声明静态连接`<StaticConnections>`页面上的元素。 `Button1_Click`方法调用<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ToString%2A>方法写入标签的连接类型名称。  
  
 [!code-aspx-csharp[WebParts_WebPartConnection_ToString#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartConnection_ToString/CS/wpConnectToStringCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartConnection_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartConnection_ToString/VB/wpConnectToStringVB.aspx#1)]  
  
 加载浏览器中的页。 已创建静态连接。 在提供程序控件中，输入一些文本，并请注意，在使用者控件中显示的文本。 单击**连接详细信息**按钮以执行<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.ToString%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Transformer">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartTransformer Transformer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartTransformer Transformer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Transformer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transformer As WebPartTransformer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartTransformer ^ Transformer { System::Web::UI::WebControls::WebParts::WebPartTransformer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartTransformer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象，用于在 Web 部件连接中两个不兼容的连接点之间转换数据。</summary>
        <value>
          <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Web 部件连接中，有两种方法可以在其中连接连接中的提供程序和使用者的控件。 它们可以通过其各自直接连接<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint>对象和理解的两个控件的接口类型。 或者，如果它们不兼容，它们可以连接间接使用<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>将从提供程序接口实例转换为理解使用者的类型的对象。  
  
 Transformer 需要作为连接的一部分时<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Transformer%2A>属性提供对的引用<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象。 您可以通过添加自定义转换器 （或 Web 部件控件集提供的转换器之一） 的标记中添加的连接以声明方式在标记中的 Web 网页、 transformer`<asp:WebPartConnection>`元素。 你还可以添加转换器，以编程方式在代码中，创建它的实例，然后调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件创建的连接，并向它传递 transformer 对象以及其他必需的参数。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Docs>
    </Member>
    <Member MemberName="Transformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartTransformerCollection Transformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartTransformerCollection Transformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Transformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transformers As WebPartTransformerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartTransformerCollection ^ Transformers { System::Web::UI::WebControls::WebParts::WebPartTransformerCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerDefaultProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartTransformerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取由 Web 部件控件集内部使用的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象的集合。</summary>
        <value>一个包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformerCollection" /> 对象的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Transformers%2A>属性永远不会适合由开发人员使用。 若要访问与连接关联的转换器，开发人员应始终使用<xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Transformer%2A>属性。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartConnection.Transformers%2A>属性内部由 Web 部件控件集用来启用页开发人员可以声明中的转换器元素`<asp:webpartconnection>`Web 页的标记中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformerCollection" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartConnection.Transformer" />
      </Docs>
    </Member>
  </Members>
</Type>