<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="39878b0a58d88077e3f60f42a8b9f566fd421748" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30601301" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>用作 Web 部件控件集的中心类，管理所有 Web 部件控件、功能和网页上发生的事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件充当 Web 部件应用程序的中心或控制中心。 必须有一个-且只有一个-<xref:System.Web.UI.WebControls.WebParts.WebPartManager>使用 Web 部件控件的每一页上的控件实例。 与 Web 部件应用程序的大多数方面<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件仅适用于经过身份验证的用户。 此外，其功能几乎完全使用驻留在继承自的 Web 部件区域内的服务器控件的工作原理<xref:System.Web.UI.WebControls.WebParts.WebZone>类。 驻留在这些区域之外的页的服务器控件可以具有很少 Web 部件功能或与交互<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 作为在页中，Web 部件功能的中心<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件可执行的下表中所述的任务类型。  
  
|任务类别|控件的作用|  
|-------------------|---------------------------|  
|跟踪 Web 部件控件|将跟踪的许多不同类型的提供 Web 部件功能，包括页面上的控件<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 连接、 区域和其他人。|  
|添加和删除 Web 部件控件|提供用于添加、 删除和关闭方法<xref:System.Web.UI.WebControls.WebParts.WebPart>页面上的控件。|  
|管理连接|创建控件，之间的连接，并监视连接，以及添加和删除它们的进程。|  
|个性化设置的控件和页|使用户能够将控件移至不同的位置，在页中，并将启动用户可以在其中编辑外观、 属性和控件的行为的视图。 维护每一页上的特定于用户的个性化设置。|  
|不同的页视图之间切换|切换不同的页上，专用视图之间的页，以便用户可以执行某些任务，例如更改页面布局或编辑控件。|  
|引发 Web 部件生命周期事件|定义，将引发，并使开发人员能够处理的 Web 部件控件，例如当控件在添加、 移动、 已连接，或删除的生命周期事件。|  
|启用导入和导出的控件|导出包含的属性的状态的 XML 流<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并允许用户方便起见，在对其他页或站点中的复杂控件进行个性化设置的文件中导入。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>类具有大量的属性。 与一致<xref:System.Web.UI.WebControls.WebParts.WebPartManager>跟踪其他控件的角色，它具有多个引用的 Web 部件控件或其他特殊的 Web 部件对象集合的属性。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>属性都是使用的所有集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager>为其跟踪和其他控件管理任务。  
  
 另一组属性包含在 Web 部件应用中发生的某些方案中应用的可自定义警告。 其中包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>属性。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>类重写一些由许多 Web 服务器控件使用其基继承属性。 其中包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>属性。  
  
 最后，没有可用于访问应用程序的当前状态的一组属性。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性指示的页是中的当前显示模式。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>属性指示是否允许控件呈现客户端脚本，这是在其中的用户可能具有不同的功能的浏览器，或者是否关闭了脚本的情况下相关。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>属性都引用包含对许多重要的扩展性情况下使用的 Web 部件方法调用一个实用工具类很有用。 通过隐藏对一个单独的类中的这些方法的调用 (<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>类)，则<xref:System.Web.UI.WebControls.WebParts.WebPartManager>简化类自己的 API。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性提供访问权限的个性化设置对象，用于存储用户的个性化设置和数据保存到永久存储。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>属性指示其<xref:System.Web.UI.WebControls.WebParts.WebPart>用户或应用程序当前选择页上的控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性指示是否在自定义个性化数据<xref:System.Web.UI.WebControls.WebParts.WebPart>控制已更改。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件包含五个内置的显示模式或网页的视图。 开发人员可以扩展此功能，通过扩展类型，如创建自定义显示模式<xref:System.Web.UI.WebControls.WebParts.WebZone>类或<xref:System.Web.UI.WebControls.WebParts.ToolZone>类。 用户可以将页切换到不同的显示模式中，假设的适当类型的对应于给定的显示模式的控件出现在页面上。  
  
> [!NOTE]
>  它是可以扩展此功能，以便用户可以切换到自定义显示模式，而无页上的相应区域。 但是，默认行为是显示模式对应区域。  
  
 标准显示模式中的公共字段由表示<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类。 下表总结了字段和其所指的显示模式。 页的当前显示模式如上所述，始终在中引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性和可以在给定的种类的页，存在的区域的特定页的显示模式集包含在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。  
  
|字段|显示模式的详细信息|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|Web 页; 的普通用户视图默认和最常见的显示模式。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|用户可以重新排列或删除控件，若要更改页面布局视图。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|该视图在其中编辑的用户界面 (UI) 变得可见，则用户可以编辑外观、 属性和控件的正常浏览模式中可见的行为。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|该视图中的目录用户界面变得可见，则用户可以从目录的可用控件，向页面添加控件。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|在其中连接 UI 变得可见，则该视图用户可以连接、 管理或断开控件之间的连接。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件还包含在 Web 部件页面和控件的生命周期中非常重要的事件数。 这些事件提供对 Web 部件控件的行为的精确进行编程控制。 大多数方法适用于<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (或位于其他服务器或用户控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域，以便它们可以充当<xref:System.Web.UI.WebControls.WebParts.WebPart>控件)。 但是，有些事件有关的页面或页上的连接状态。 下表列出了可用的事件，并总结了它们的用途。  
  
> [!NOTE]
>  在下表中的所有情况下，"控件"一词是指<xref:System.Web.UI.WebControls.WebParts.WebPart>控件或任何服务器控件位于某个区域中，使用包装<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>在运行时的对象。  
  
|事件|描述|  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|将控件添加到页上，以确认它授权之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|在页面上的所有连接已都激活后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|激活页上的所有连接的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|页的当前显示模式更改后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|更改页面的显示模式的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|已取消所选内容的控件后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|取消所选控件的内容的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|控件添加到区域后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|将控件添加到区域的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|控件已关闭 （从页中移除） 后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|关闭控件的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|永久删除动态控件 （一种以编程方式创建或添加从目录） 的实例后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|恰好在删除动态控件的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|控件具有在其区域内移动或移动到另一个区域后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|恰好在移动控件的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|两个控件选择来参与连接建立连接后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|连接两个控件的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|已断开连接的两个控件后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|恰好在断开连接两个控件的过程之前发生。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件具有很多用于管理 Web 部件页的方法。 此处未列出的方法一大组是其名称采用的形式在方法*EventName*。 这些方法通常引发其关联的事件，并且使用类型的处理程序提供事件<xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>。 开发人员继承自可重写这些方法中的大多数<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类。 此外，页开发人员可以使用这些方法关联的事件提供自定义处理程序。 例如中的情况下<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件，无法添加页开发人员`OnWebPartAdded`属性设为`<asp:webpartmanager>`以及 Web 页上，然后分配自定义的方法名称添加到该属性提供的事件自定义处理标记中的元素。 属性对应于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>方法和事件处理大多数 Web 部件事件和其关联的方法的工作方式此基本模式。  
  
 此外，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件具有方法特定于的管理任务<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (和服务器或用户控件用作<xref:System.Web.UI.WebControls.WebParts.WebPart>控件)。 这些方法包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>。  
  
 另一组方法专用于连接。 这包括方法如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>。  
  
 最后，一些<xref:System.Web.UI.WebControls.WebParts.WebPartManager>方法专注于个性化功能。 其中包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>。  
  
 有关其他详细信息<xref:System.Web.UI.WebControls.WebParts.WebPartManager>方法可通过访问<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>属性，请参阅的文档<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>类。  
  
   
  
## Examples  
 下面的代码示例演示如何声明和以编程方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 下面的代码示例包含四个部分：  
  
-   一个用户控件，使你能够更改 Web 部件页面上的显示模式。  
  
-   包含两个自定义网页<xref:System.Web.UI.WebControls.WebParts.WebPart>可连接控件和`<asp:webpartmanager>`元素。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口。  
  
-   该示例在浏览器中的工作原理说明。  
  
 用户控件具有显示可能的显示模式在页上，提供在页上存在的 Web 部件控件的下拉列表框控件。 在此代码示例的 Web 页中，此用户控件声明的正下方<xref:System.Web.UI.WebControls.WebParts.WebPartManager>页面的标记中的元素，并且没有`Register`指令要注册此控件的 Web 页的顶部附近。 有关详细信息显示在此控件模式和源代码的说明，请参见[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 网页的声明性标记包含`Register`为用户控制和自定义控件的指令。 没有`<asp:webpartmanager>`元素，`<asp:webpartzone>`元素以包含自定义控件和`<asp:connectionszone>`元素。 此页还包含一些处理连接相关的事件的内联代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制; 连接和断开连接控件时，你可以看到此代码的作用。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 请注意，没有名为接口`IZipCode`，而在中实现此接口`ZipCodeWebPart`类。 此类具有一个名为的特殊的回调方法`ProvideIZipCode`充当提供程序。 其他类型，名为`WeatherWebPart`，还具有一个名为的特殊方法实现`GetIZipCode`，以便在要充当其他控件的使用者的控件。  
  
 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例假定你具有源代码编译到程序集和`Register`网页中的指令引用的程序集名称。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 你已加载浏览器中的 Web 页后，单击**显示模式**下拉列表控件，然后选择**连接**切换页后，可以连接模式。 连接模式使用`<asp:connectionszone>`元素以启用你创建控件之间的连接。 在连接模式中，单击标题栏中的向下箭头**邮政编码**控件来激活其谓词菜单中，，然后单击**连接**。 连接用户界面显示后，请单击**创建使用者连接**链接。 单元格将显示包含一个下拉列表框控件。 选择**天气控件**在下拉列表中，然后单击**连接**来完成这两个控件的连接。 单击**关闭**，然后使用**显示模式**下拉列表来返回到正常浏览模式的页。 你可以输入邮政编码，然后使用者控件将使用你输入的值更新。 因为`ZipCode`属性已标记有`Personalizable`在源代码中，此属性的值的属性将保留在浏览器会话，从而节省了由用户输入的值。 更复杂的使用者控件无法执行邮政编码信息、 查找天气信息根据的代码，并向用户显示。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件专为进行扩展。 因为它是，因此必须还扩展到 Web 部件应用程序，当你想要扩展某些特定类型或在 Web 部件控件集，在许多情况下控制中部<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类，因为它是可能会有一些属性或使所需的方法 自定义类型的 Web 部件应用程序上下文中的工作。 Web 部件参考文档 (请参阅<see cref="N:System.Web.UI.WebControls.WebParts" />)，讨论如何扩展 Web 部件在键入时，经常需要进行扩展的提及<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类，或演示如何扩展中的代码示例。</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A>构造函数初始化所使用的几个重要变量<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 直接影响所有 Web 部件页的一个分配是默认页面显示模式设置为浏览模式的事实 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>激活网页上当前所有非活动连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>到页上的每个请求以激活之间的现有连接上调用方法<xref:System.Web.UI.WebControls.WebParts.WebPart>和驻留在其他服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域。 在某些情况下，例如，如果存在冲突的连接被激活，则此方法中反过来调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法来结束有问题的连接。 断开连接的过程<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>引发事件。 通常，开发人员可以取消此事件，但在这种情况，这是不能取消的连接中冲突，因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件需要为了完成激活连接的过程中解决该冲突。 有关详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">要添加至网页或在页上打开的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />（或服务器或用户控件）。</param>
        <param name="zone">向其添加 <c>webPart</c> 的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex">一个整数，表示 <c>webPart</c> 在 <c>zone</c> 中占用的序号位置（相对于 <c>zone</c> 中的其他控件）。</param>
        <summary>提供向网页添加 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的标准编程方法。</summary>
        <returns>添加到页的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法使用这两个添加新的动态<xref:System.Web.UI.WebControls.WebParts.WebPart>控制到页中，并重新打开以前已关闭在页面上的静态或动态控件。 当调用该方法时若要添加新控件时，它实际创建一份所引用的控件`webPart`参数。 一个新的 ID 生成的控件，复制，因此，开发人员应引用<xref:System.Web.UI.WebControls.WebParts.WebPart>从要获取新的 ID 值的方法返回的控件。 当调用方法以重新打开以前关闭的控件时，它将返回对所引用的控件的直接引用`webPart`参数。  
  
> [!IMPORTANT]
>  应始终使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法，而不是<xref:System.Web.UI.ControlCollection.Add%2A>方法的引用的控件的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType>属性，以将添加<xref:System.Web.UI.WebControls.WebParts.WebPart>以编程方式控制到页中，因为使用<xref:System.Web.UI.ControlCollection.Add%2A>方法将引发异常。 若要添加不是控件<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (换而言之，一个将使用自动换行的服务器控件<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件在运行时)，首先应调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法以创建该控件，然后调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法将添加该控件。 此方法的演示，请参阅示例部分。  
  
   
  
## Examples  
 下面的代码示例演示使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法以编程方式将服务器控件添加到页。 页面标记包含一个空`<asp:webpartzone>`元素，和`<asp:webpartmanager>`元素。 第一次**添加日历**单击按钮时，代码在事件处理程序创建<xref:System.Web.UI.WebControls.Calendar>控制，并将其添加到作为区域<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象，调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 为 <see langword="null" />。  
  
 \- 或 -  
  
 <paramref name="zone" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="zone" /> 没有在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的区域集合中注册。  
  
 \- 或 -  
  
 <paramref name="webPart" /> 已存在于 <paramref name="zone" /> 中。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="zoneIndex" /> 的值小于零。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当调用 <see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> 方法以确定 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件是否能够添加到页中时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件会发生<xref:System.Web.UI.WebControls.WebParts.WebPart>控件添加到页。 有大量的常见方案，可以在其中将控件添加到页。 有关这些的完整说明，请参阅备注部分<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法。 时添加一个控件，它必须检查以查看是否其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性已设置并且，如果是这样，是否控件有权添加到页面。  
  
 开发人员可以创建事件处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，以提供筛选为控件。 如果控件的<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性值不符合事件处理程序代码中的条件，控件不会添加到页。  
  
   
  
## Examples  
 下面的代码示例演示如何设置的自定义事件处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，会自动重写默认值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法。  
  
 中的代码`mgr1_AuthorizeWebPart`方法检查页上的控件是否具有其各自<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性值设置为`user`，并且如果是这样，则返回`true`，这意味着它们将被授权并添加到页面。 这假定的默认方法是允许用户查看用户个性化设置作用域中的页的控件。 但请注意，在示例 1 中的控件都有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性值设置为`admin`。 开发人员可能会将此筛选器放置在旨在用于只管理用户才能看到专用控件。 此控件将会失败期间的授权检查<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，并将不会显示。 请注意，未将属性设置的控件的显示也;它们都被认为不是筛选方案的一部分，因为其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>未设置属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象的集合，这些对象可用于在服务器控件之间创建 Web 部件连接。</summary>
        <value>包含一组 <see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" /> 对象的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>方法创建集合。 默认情况下，将从应用程序配置文件读取可用的转换器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正为其建立连接的控件。</param>
        <summary>开始连接两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>方法存在，以便可以在不同的阶段，为开发人员提供更好地控制连接过程完成构成控件之间的连接的过程。 该方法执行初始检查以确保组`webPart`处于可以合法方式连接的状态。 如果`webPart`通过所有检查，然后将设置为当前所选控件 (请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>属性)，并可以继续连接过程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">页上的当前显示模式不是 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 已关闭。  
  
 \- 或 -  
  
 <paramref name="webPart" /> 不是 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合的组成部分。  
  
 - 或 -  
  
 <paramref name="webPart" /> 等于 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 控件。</exception>
        <block subset="none" type="overrides">
          <para>开发人员需要扩展<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件可能希望重写此方法在派生类。 一种方法是将调用基方法，然后添加一些附加的自定义处理;或者，你可能想要完全自定义启动控件之间的连接的过程。 例如，你可能想要验证在创建连接之前，某些数据也可用。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要编辑的控件。</param>
        <summary>开始 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的编辑过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法存在，以便可以在不同的阶段，为开发人员提供更好地控制该过程完成编辑控件的过程。 该方法执行初始检查以确保组`webPart`处于可以编辑的状态。 如果`webPart`通过所有检查，然后将设置为当前所选控件 (请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>属性)，并编辑过程可继续进行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">页上的当前显示模式不是 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 已关闭。  
  
 \- 或 -  
  
 <paramref name="webPart" /> 不是 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合的组成部分。  
  
 - 或 -  
  
 <paramref name="webPart" /> 等于 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 控件。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示包含 Web 部件控件的页的默认显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>字段引用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>对象，创建并包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 由于这是一个静态对象，你可以引用直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>而无需控件的实例的类。  
  
 包含 Web 部件页在首次加载时，在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>（浏览模式） 默认情况下。 当用户只需浏览与它们在正常的网页上时，在浏览模式中会保留页。 如果用户想要对进行个性化设置的页面布局、 控件、 外观或行为，它们必须将页切换到一个专用的显示模式可通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>字段以编程方式。 此代码填充下拉列表的受支持的显示模式，在这种情况下是浏览和设计。 请注意，，在`Page_PreRender`方法时，代码将检查是否当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性设置为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>。 如果是这样，`Label1`将是可见的如果不是，`Label1`将隐藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 加载浏览器中后，您拥有默认情况下浏览模式。 请注意，该值指示在浏览模式中的页上的标签。 使用下拉列表框控件将页切换到设计模式。 请注意，由于中的代码`Page_PreRender`方法，标签现在处于隐藏状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检查将参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，以确定它们是否能够被连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法用于确定是否两个<xref:System.Web.UI.WebControls.WebParts.WebPart>控件可以连接。 方法通常用作条件的检查，再调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法检查的两个控件能够形成连接之前，必须满足的条件数。 以下列表总结了进行连接的主条件。 如果满足这些条件 （加上一些附加内部条件），该方法返回`true`，这意味着这些控件可以连接：  
  
-   提供程序和使用者控件不能为`null`，它们必须包含在所引用的控件的集合和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性。  
  
-   提供程序和使用者不能为同一个控件。 换而言之<xref:System.Web.UI.WebControls.WebParts.WebPart>控件无法连接到其自身。  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint>对象 （连接点） 提供程序和使用者不能为`null`。  
  
-   无法关闭的提供程序和使用者 (两个控件的<xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A>属性可以是`true`)。  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A>的连接点控件的属性必须与匹配的控件类型的使用者和提供程序。  
  
-   连接点必须同时启用 (其<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A>方法必须返回`true`)。  
  
-   每个连接点没有必须尝试窗体中所指定在自己的更多连接<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A>属性。  
  
-   如果<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象 (transformer) 是需要连接不兼容的控件，它不能是`null`。 但是，如果控件已经兼容，则转换器必须为`null`。  
  
-   转换器 （如果使用） 必须引用在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>集合。  
  
-   转换器 （如果使用） 必须具有接口，以便它可以转换两个控件之间的数据提供程序和使用者与兼容。 使用者和提供程序的辅助接口还必须是兼容的。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">在控件连接时为 <c>consumer</c> 提供数据的控件。</param>
        <param name="providerConnectionPoint">使 <c>provider</c> 能够参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />。</param>
        <param name="consumer">控件连接时从 <c>provider</c> 接收数据的控件。</param>
        <param name="consumerConnectionPoint">一个 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，它作为回调方法，以便 <c>consumer</c> 可以参与连接。</param>
        <summary>当使用者和提供者控件有兼容接口且不需要 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 对象时，请检查将参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 控件，以确定它们是否能够被连接。</summary>
        <returns>一个布尔值，指示是否能连接 <paramref name="provider" /> 和 <paramref name="consumer" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于连接`provider`和`consumer`如果这两个控件具有兼容的连接点类型，以便<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象，则不需要。 你可能想要使用此方法验证两个控件，可以连接，然后再调<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>若要创建的编程连接。  
  
 此重载使用相同的实现<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>方法重载中，使用唯一的例外是，此重载不需要转换器。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此方法。  
  
 下面的代码示例包含四个部分：  
  
-   一个用户控件，使你能够更改 Web 部件页面上的显示模式。  
  
-   包含两个自定义网页<xref:System.Web.UI.WebControls.WebParts.WebPart>可连接控件`<asp:webpartmanager>`元素，并创建连接使用某些事件处理代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口。  
  
-   该示例在浏览器中的工作原理说明。  
  
 下面的代码示例的第一部分是用于更改显示模式的用户控件。 你可以从示例部分中获取该用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式和用户控件的工作原理的详细信息，请参阅[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 网页的声明性标记包含`Register`为用户控制和自定义控件的指令。 没有`<asp:webpartmanager>`元素，`<asp:webpartzone>`元素以包含自定义控件和`<asp:connectionszone>`元素。 请注意，在`Page_Load`方法，代码将检查是否连接可并且，如果是这样，定义一个提供程序、 一个使用者和它们各自的连接点，然后将新的连接添加到的一组静态连接引用的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 它包含一个接口和两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，其中一个充当一个提供程序，并将对方列为使用者。 因为它们具有兼容的连接点 (这两个识别`IZipCode`接口)，不需要转换器来建立连接。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 你已加载浏览器中的 Web 页后，单击**显示模式**下拉列表控件，然后选择**连接**切换页后，可以连接模式。 连接模式使用`<asp:connectionszone>`元素以启用你创建控件之间的连接。 在连接模式中，单击标题栏中的向下箭头**邮政编码**控件来激活其谓词菜单中，，然后单击**连接**。 显示连接用户界面 (UI) 后，请注意，已由中包含的代码创建连接时`Page_Load`方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">在控件连接时为 <c>consumer</c> 提供数据的控件。</param>
        <param name="providerConnectionPoint">一个 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，它作为回调方法，以便 <c>provider</c> 可以参与连接。</param>
        <param name="consumer">控件连接时从 <c>provider</c> 接收数据的控件。</param>
        <param name="consumerConnectionPoint">一个 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，它作为回调方法，以便 <c>consumer</c> 可以参与连接。</param>
        <param name="transformer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />，它使不兼容的 <c>provider</c> 和 <c>consumer</c> 得以连接。</param>
        <summary>检查将参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，以确定这些控件是否能够连接，并使用 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象在不兼容的使用者和提供者之间创建连接。</summary>
        <returns>一个布尔值，它指示 <paramref name="provider" /> 和 <paramref name="consumer" /> 是否可以形成连接。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于连接`provider`和`consumer`如果这两个控件具有不兼容的连接点类型，以便<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象是必需的。 你可能想要使用此方法验证两个控件，可以连接，然后再调<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>若要创建的编程连接。  
  
 此重载使用相同的实现<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>方法重载中，使用唯一的例外是，此重载所需的转换器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于从控件目录向网页添加服务器控件的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>字段引用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>对象，创建并包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 由于这是一个静态对象，你可以引用直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>而无需控件的实例的类。  
  
 如果用户想要将控件添加到页中，如果可用的服务器控件目录，则可以切换到页<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>（目录模式），并显示目录用户界面 (UI)。 用于 Web 部件目录的用户界面提供的<xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase>区域控件。 开发人员在设计时，将该区域添加到页，然后将服务器控件添加到该区域，以便用户将能够在运行时将这些控件添加到相应的页面。 开发人员已添加这些控件后，目录模式变得页上受支持的显示模式，因为所需的控件有若要启用目录的模式。  
  
 当用户将某页目录模式、 区域和已添加到变得可见，它的所有服务器控件切换和用户可以从要添加到页中，或从页中删除控件的目录中选择控件。 控件已添加到页后，会显示在普通浏览模式中，更新页。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>字段以编程方式。 此代码填充页上，在这种情况下是浏览、 设计和目录的受支持的显示模式的下拉列表。 由于可以目录模式了`<asp:CatalogZone>`元素及其子元素在 Web 页。 请注意，，在`Page_PreRender`方法时，代码将检查是否当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性设置为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>。 如果是这样，`Label1`将是可见的如果不是，`Label1`将隐藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 加载浏览器中后，您拥有默认情况下浏览模式。 请注意，隐藏页上的标签。 使用下拉列表框控件将页切换到目录模式。 请注意，由于中的代码`Page_PreRender`方法，标签才现在可见。 可以在目录中选择的控件，并将其添加到以下任一页上的两个区域。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检查发出请求的浏览器的功能，并检查 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" /> 属性的值，以确定是否呈现客户端脚本。</summary>
        <returns>一个布尔值，指示是否呈现客户端脚本。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个警告，用户关闭在连接中充当其他控件的提供者的控件时，会显示该警告。</summary>
        <value>一个包含警告消息的字符串。 默认值是一条由 .NET Framework 提供的、特定于区域性的消息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，通常会显示任何消息。 这意味着若要关闭控件有关的详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法。  
  
 但是，当控件连接到另一个控件，并充当提供程序的数据的另一个控件，当用户尝试关闭该控件时，将显示默认警告消息。 消息会通知用户，提供程序控制即将关闭，这意味着控制连接到此提供程序，如使用者不会使用任何数据。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>属性使开发人员能够自定义向用户显示警告消息。  
  
 当用户关闭，如果页开发人员将为空或 null 字符串值分配给此属性，将显示任何警告消息框<xref:System.Web.UI.WebControls.WebParts.WebPart>是一个提供程序的控制。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>属性向用户显示的自定义的警告。  
  
 下面的代码示例包含四个部分：  
  
-   一个用户控件，使你能够更改 Web 部件页面上的显示模式。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口。  
  
-   包含两个自定义网页<xref:System.Web.UI.WebControls.WebParts.WebPart>可连接控件和`<asp:webpartmanager>`元素。  
  
-   该示例在浏览器中的工作原理说明。  
  
 下面的代码包含示例的网页部分。 你还需要自定义用户控件和上面提到的自定义控件的源代码。 从示例部分获取这两项<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。  
  
 以下 Web 页的代码演示如何将分配到自定义警告消息<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>属性中的声明性标记中`<asp:webpartmanager>`元素。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 你已加载浏览器中的 Web 页后，单击**显示模式**下拉列表控件，然后选择**连接**切换页后，可以连接模式。 连接模式使用`<asp:connectionszone>`元素以启用你创建控件之间的连接。 在连接模式中，单击标题栏中的向下箭头**邮政编码**控件来激活其谓词菜单中，，然后单击**连接**。 显示连接用户界面 (UI) 后，单击**创建使用者连接**链接。 单元格将显示包含一个下拉列表框控件。 选择**天气控件**下拉列表中，然后单击**连接**来完成这两个控件的连接。 单击**关闭**，然后使用**显示模式**下拉列表来返回到正常浏览模式的页。 最后，单击的谓词菜单**邮政编码**控件 （这是提供程序控制在此情况下），然后选择**关闭**。 自定义消息分配给<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>属性显示。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 中关闭的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或服务器控件。</param>
        <summary>以不在网页上呈现，但可以重新打开的方式关闭 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法移除<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他服务器控件，以使其不呈现最初包含它的 Web 页面上。 已关闭的控件添加到<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>对象，这将保持对已关闭的控件的引用，并使得要还原到页的控件。 关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件仍显示在所引用的集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性。  
  
 关闭控件是不同的删除它。 已关闭的控件仍可用于还原到页中，但已删除的控件实例永久删除，而且将永远无法还原。 而不管是否<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件是 （在页面的标记中声明） 的静态或动态 （添加到页面以编程方式或通过用户从 Web 部件目录），它可以关闭并重新打开页面上。  
  
 通常情况下，用户可以关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>通过单击其谓词菜单并选择关闭谓词的控件。 也可以通过直接调用关闭控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法并将其传递到的引用`webPart`。  
  
 在页面上其中<xref:System.Web.UI.WebControls.WebParts.WebPart>控件已关闭，如果开发人员声明`<asp:catalogzone>`元素，并在其中添加`<asp:pagecatalogpart>`元素，它提供了简单的用户界面 (UI) 的用户还原到页在运行时的已关闭的控件。 用户可以将页切换到目录的显示模式，并且已关闭的控件将出现在该页目录。 用户可以选择已关闭的控件并将其添加回第一页的任何位置，它们需要，以及然后将所选的控件的还原到页和按正常方式呈现。  
  
 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法被调用时，它会发出多个事件： <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> （如果有多个控件），和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>（如果有连接的控件）。 通常，开发人员可以取消这些事件，但在某些情况下它不能取消服务。 有关详细信息，请参阅的文档<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>， <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 方法。  
  
 下面的代码示例包含四个部分：  
  
-   一个用户控件，使你能够更改页面显示模式。  
  
-   自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
-   网页。  
  
-   该示例在浏览器中的工作原理说明。  
  
 下面的代码示例的第一部分是用于更改显示模式的用户控件。 你可以从示例部分中获取该用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式和用户控件的工作原理的详细信息，请参阅[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 下面的代码示例的第二部分是自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此示例使用的动态编译方法;因此没有任何`Assembly`属性中`Register`指令对于此控件在 Web 页的顶部。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 下面的代码示例的第三部分是网页。 页包含<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域，使用 <`asp:pagecatalogpart>`中声明的元素。 这是将包含哪些内容的已关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控制并使用户能够将其添加回页面。 `Button1_Click`方法直接调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法来关闭自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，但用户还可关闭通过谓词菜单控件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 加载浏览器中后，关闭自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>通过单击该控件的标头中的谓词菜单 （的箭头符号），然后单击控件**关闭**。 现在将页面更改为目录模式下通过选择**目录**中**显示模式**下拉列表控件。 页目录将显示已关闭的控件。 选择已关闭的控件旁边的复选框，单击**添加**以将其添加到页上，然后单击**关闭**来返回到浏览模式的页。 控件还原到页。 现在关闭它同样，这次通过单击**关闭 web 部件**按钮。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 不在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合中。  
  
 \- 或 -  
  
 <paramref name="webPart" /> 是共享控件，并已被另一个用户关闭。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于显示特殊用户界面 (UI) 以便用户管理 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之间的连接的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>字段引用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>对象，创建并包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 由于这是一个静态对象，你可以引用直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>而无需控件的实例的类。  
  
 当用户想管理之间的连接<xref:System.Web.UI.WebControls.WebParts.WebPart>控件在网页上，如果<xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>区域已声明的页上，则可以切换到页<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式。 连接的显示模式显示特殊 UI 管理连接，包括连接或断开连接控件，以及如何编辑现有连接的详细信息的功能。  
  
 如果你想要为用户提供的功能使用由 Web 部件控件集提供的用户界面管理连接，您必须声明`<asp:connectionszone>`页面的标记中的元素。 与其他类型的元素不同<xref:System.Web.UI.WebControls.WebParts.WebZone>区域，不需要将此元素中的任何其他标记添加; 你只需声明元素本身。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式。  
  
 代码示例包含三个部分：  
  
-   包含接口和自定义的源文件<xref:System.Web.UI.WebControls.WebParts.WebPart>能够形成连接的控件。  
  
-   提供一个连接用户界面并演示如何使用的 Web 页<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式。  
  
-   如何运行该示例的说明。  
  
 下面的代码示例的第一部分是包含一个接口和两个自定义的源文件<xref:System.Web.UI.WebControls.WebParts.WebPart>的设计使它们可以连接的控件。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用的动态编译方法。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 该示例的第二部分是承载的自定义控件的网页。 在服务器中`<script>`页上的标记是填充下拉列表可在页面的显示模式的几种方法。 用户可选择这些从下拉列表中，若要更改页面的显示模式。 可用的显示模式之一是连接的显示模式，因为`<asp:connectionszone>`元素在页面的标记中声明。 请注意，此元素不包含任何其他子元素;它存在只是为了支持用户的连接管理 UI。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式将显示在此示例在两个位置。 首先，在`Page_Init`方法中，连接的显示模式作为添加到下拉列表中的显示模式，该代码循环访问集合中引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。 第二个，`Page_PreRender`方法检查当前的显示模式，在页上，如果当前的模式和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>，在显示一条消息<xref:System.Web.UI.WebControls.Label>控件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 加载浏览器中后，单击下拉列表并选择**连接**页切换到连接的显示模式。 请注意，将显示一条消息，告诉你该页面的是连接的显示模式。 现在，单击谓词菜单 （箭头符号） 之一的标题栏中<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，，然后单击**连接**谓词菜单中。 连接后显示用户界面，单击链接以创建连接。 使用连接用户界面中显示的下拉列表，请选择另一个控件，将参与该连接，并单击**连接**按钮。 建立的连接。 单击**关闭**按钮，，然后使用在页面顶部的下拉列表来返回页后，可以浏览的显示模式。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上所有当前连接的集合的引用。</summary>
        <value>包含一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> 对象的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>属性提供一种方法，若要访问的当前页上的连接。 集合本身是只读的且希望操作集合中的特定连接开发人员应使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>等方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何声明和以编程方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 下面的代码示例包含四个部分：  
  
-   一个用户控件，使你能够更改 Web 部件页面上的显示模式。  
  
-   包含两个自定义网页<xref:System.Web.UI.WebControls.WebParts.WebPart>可连接控件和`<asp:webpartmanager>`元素。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口。  
  
-   该示例在浏览器中的工作原理说明。  
  
 下面的代码包含示例的网页部分。 你还需要自定义用户控件和上面提到的自定义控件的源代码。 从示例部分获取这两项<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。  
  
 以下 Web 页的代码演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>属性以编程方式获取页上的当前连接的计数。 请注意，在`<script>`标记部分中，代码以处理两个事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制访问<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>属性以获取该计数。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 你已加载浏览器中的 Web 页后，单击**显示模式**下拉列表控件，然后选择**连接**切换页后，可以连接模式。 连接模式使用`<asp:connectionszone>`元素以启用你创建控件之间的连接。 在连接模式中，单击标题栏中的向下箭头**邮政编码**控件来激活其谓词菜单中，，然后单击**连接**。 连接用户界面 (UI) 显示后，单击**创建使用者连接**链接。 单元格将显示包含一个下拉列表框控件。 选择**天气控件**下拉列表中，然后单击**连接**来完成这两个控件的连接。 单击**关闭**，然后使用**显示模式**下拉列表来返回到正常浏览模式的页。 请注意，一个标签现在显示的连接数和数<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 如果您现在返回到连接模式并断开连接两个控件，则在返回到浏览模式下，应更新标签的内容，并且应该有任何连接。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在页上的所有当前 Web 部件连接不仅已经连接，而且已经开始在每个连接所涉及的使用者控件和提供者控件之间共享数据之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 生命周期的连接，此事件发生后页面完成其加载过程。 它还后发生<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件，只是指示<xref:System.Web.UI.WebControls.WebParts.WebPart>或已成功连接所涉及的特定连接的服务器控件。 在情况下在有多个连接在页中，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>方法指示在页面上的所有有效 Web 部件连接现活动和能够共享数据。 了解所有连接都处于活动状态后，开发人员可以执行任意数量的任务，包括将通知用户的所有连接的状态通知使用者控件处理和显示来自其提供程序，数据等等。  
  
 此事件与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A>方法，它引发事件并允许开发人员创建自定义事件处理程序。  
  
 页开发人员可以创建自定义事件处理程序，通过添加`OnConnectionsActivated`属性设为`<asp:webpartmanager>`页上，，然后将自定义的方法名称分配到的属性中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在激活网页上所有已建立的 Web 部件连接的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 生命周期的连接，会发生此事件页之前完成其加载进程，如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>调用方法。 不同于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>事件，这就需要之间的特定连接<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他服务器控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>事件发生时在页面上的所有可能的连接已连接，并且要激活。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>与关联事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>方法，将引发事件。 控件开发人员想要扩展的可以添加到页面的连接类型可以重写受保护<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>方法并激活其他类型的连接。  
  
 页开发人员可以创建自定义事件处理程序，通过添加`OnConnectionsActivating`属性设为`<asp:webpartmanager>`页上，，然后将自定义的方法名称分配到的属性中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中的两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控件（或其他能建立连接的服务器控件）之间创建一个连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法窗体的任何这两者之间的连接<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的控件。 在之前调用此方法来创建的连接，你可能还需要调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>条件检查，以确保控件符合要求的形成连接中的方法。  
  
> [!NOTE]
>  还有可能不是两个服务器控件之间创建连接<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 一般情况下，必须在两个控件是自定义服务器控件 (例如，从继承的控件<xref:System.Web.UI.WebControls.WebControl>或现有的 ASP.NET 服务器控件)，以便你可以添加所需的成员。 控件还必须满足下方指定要求。  
  
 任何类型的两个控件之间的连接方案必须满足以下要求，以进行连接：  
  
-   每个控件位于<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>（它不必是同一区域） 的区域。  
  
-   在 Web 部件控件集中实现时，连接中的提供者控件实现一个接口作为用作回调到提供程序，并具有一个公共方法`ConnectionProvider`的方法，以标识为提供程序连接上的元数据属性点。 因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>方法检索提供程序连接点是虚方法，派生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件不一定具有要使用相同的元数据属性。  
  
-   在 Web 部件控件集中实现时，在连接中，使用者控件还具有一种特殊的方法，使它能够获取对在提供程序的回调方法中，公开的接口的引用和使用者具有`ConnectionConsumer`上的元数据属性该方法以标识为使用者连接点。 因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>方法检索使用者连接点是虚方法，派生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件不一定具有要使用相同的元数据属性。  
  
-   回调方法必须是兼容的中 （这意味着使用者和提供程序可以共享数据直接） 提供程序的回调方法或开发人员, 提供的接口，使用者可以将它们的类型必须使用<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象传递给将从提供程序的数据转换为使用者可以使用的窗体。  
  
    > [!IMPORTANT]
    >  当你不需要转换器时，则使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>方法重载。 当需要转换器时，使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>方法重载。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，负责向另一个连接控件提供数据。</param>
        <param name="providerConnectionPoint">用作连接回调方法的方法。 正如在 Web 部件控件集中实现的一样，这是 <c>provider</c> 中以 <see langword="ConnectionProvider" /> 元数据属性标记的一个公共方法。</param>
        <param name="consumer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，负责接收来自 <c>provider</c> 的数据，然后处理或显示接收到的数据。</param>
        <param name="consumerConnectionPoint">与 <c>providerConnectionPoint</c> 连接的方法，它接收连接的数据。 正如在 Web 部件控件集中实现的一样，这是 <c>consumer</c> 中以 <see langword="ConnectionConsumer" /> 元数据属性标记的一个公共方法。</param>
        <summary>只使用对控件的引用和控件所指定的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 对象在两个 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 或 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> 控件之间创建连接。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />，包含连接所需的提供者和使用者的各种信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载用于在其连接点充分兼容确保它们而无需使用连接时连接控件<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象。 当调用该方法的此重载时，它只需将传递到另一重载版本的方法的调用并将传递`null`需要的参数<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象。  
  
 当你尝试以编程方式连接两个控件时，你可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>条件检查，以确定是否可以直接连接控件中的方法。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此方法以编程方式创建的连接。 有关所需要运行该示例的完整代码，请参阅示例部分<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 从该示例中，你需要允许您更改在页上，显示模式的用户控件的源代码和源代码的两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
 承载这两个 Web 页的代码控制如下所示。 页使用`Register`顶部的指令以声明的用户控件和自定义控件。 然后以声明方式在引用的自定义控件`<asp:webpartzone>`元素。 处理的代码`Button1_Click`方法创建使用控件之间的连接<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 加载浏览器中后，单击**连接 web 部件控件**按钮以形成连接。 然后可以在文本框中，输入一些数据，并单击**输入 5 位邮政编码**按钮演示控件已连接，以及在第二个更新的第一个控件中输入该数据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态集合的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件集合是只读的。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />，它的角色是为另一个连接的控件提供数据。</param>
        <param name="providerConnectionPoint">
          <c>provider</c> 中以 <see langword="ConnectionProvider" /> 元数据属性标记的公共方法，可用作连接的回调方法。</param>
        <param name="consumer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />，负责从 <c>provider</c> 或 <c>transformer</c> 中接收数据，然后处理或显示接收到的数据。</param>
        <param name="consumerConnectionPoint">
          <c>consumer</c> 中以 <see langword="ConnectionConsumer" /> 元数据属性标记的公共方法，可与 <c>providerConnectionPoint</c> 连接以接收连接的数据。</param>
        <param name="transformer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />，它通过将数据从 <c>provider</c> 转换为 <c>consumer</c> 可以处理的格式来实现两个控件之间的连接。</param>
        <summary>使用对两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控件的引用、它们的指定 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> 对象和一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象在这两个控件之间创建连接。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />，它包含有关提供者、使用者以及连接所需的转换器的信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载用于在其连接点不兼容时连接控件。 发生不兼容时`consumer`实现其他接口比`provider`作为连接点。 Transformer 将数据转换可以理解的一种`consumer`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">连接已在 <see cref="E:System.Web.UI.Control.PreRender" /> 中激活。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含在网页的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中并由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控件管理的所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />、服务器或用户控件的集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.ControlCollection" />，包含由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件管理的所有控件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>属性不引用所引用的其他控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制，如各种区域控件，<xref:System.Web.UI.WebControls.WebParts.EditorPart>或<xref:System.Web.UI.WebControls.WebParts.CatalogPart>控件和其他人。  
  
 Web 部件控件集，以及在不应在代码中调用的大多数开发情况下使用此属性。 出于此原因，虽然属性是公共的但会将其隐藏的 IntelliSense。 开发人员想要访问的集合<xref:System.Web.UI.WebControls.WebParts.WebPart>或由其他服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件应使用其<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要复制的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</param>
        <summary>由 Web 部件控件集用来创建 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件的副本，以向网页中添加该控件。</summary>
        <returns>要添加到页中的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>在代码中直接的方法。 内部调用此方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件添加新的动态的过程的一部分<xref:System.Web.UI.WebControls.WebParts.WebPart>或到页上的服务器控件。 动态控件添加到页面以编程方式或通过 Web 部件用户界面 (UI)，例如用户从控件，而不是直接在页面的标记中声明一个静态控件的目录中添加控件。  
  
> [!NOTE]
>  如果开发人员想要使该方法以处理复制方案的更多控制，则可以在派生类中重写方法。 有关详细信息，请参阅对继承者部分的说明。  
  
 添加一个新的动态控件时，如果它是<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法返回的控件的新实例。 如果正在添加的控件 （如用户控件、 一个自定义控件或 ASP.NET 控件） 的服务器控件的某些其他类型，已将具有与包装控件<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>由 Web 部件控件集的对象。 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法遇到<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件，它将返回的新实例<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件中它包装的子控件的新实例。  
  
 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法创建要返回的控件的新副本，它还将重置所有属性的值为其默认值。 请注意，是否你想要保留可个性化属性的值，并将它们复制到新的控件实例，应调用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A>以及方法。 由执行的最后一步<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法是调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A>方法来获取控件的新 ID。  
  
> [!NOTE]
>  此方法获取复制的控件的新 ID，因为你不应依赖于引用原始 id 添加到页面的动态控件 相反，应引用该方法返回的控件的新实例。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>该方法声明为<see langword="virtual" />，以便开发人员无法从此继承<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类，请重写方法，并提供有关其他方案，它可以在其中创建控件的副本。 例如，该方法无法 （可选） 作为输入接收已序列化到 XML 文件的控件。 该方法无法反序列化 XML （如果存在），然后调用基方法来处理现有用例，并返回的新实例<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />控件。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建一组在网站配置文件中指定的转换器，并将它们添加到 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" /> 属性所引用的转换器的集合。</summary>
        <returns>网站的配置文件中指定的转换器的集合。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>可以重写此方法以添加其他应用程序可以使用的转换器。 例如，可以编写该方法从 Web 服务中检索可用转换器的列表。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回网页上的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件所管理的所有控件的集合。 此类不能被继承。</summary>
        <returns>一个 <see cref="T:System.Web.UI.ControlCollection" />，由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件所管理的所有 Web 部件控件组成。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>此方法是受保护的密封，因为它是继承的类可见<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类，但它不能重写。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为 Web 部件应用程序创建由所有可能的显示模式组成的显示模式集。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含所有受支持的显示模式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法创建的所有可能的显示模式，而不仅仅是支持特定页面上的显示模式的列表。 有关受支持的显示模式的详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。  
  
 默认情况下，Web 部件控件集创建下列一组用于在 Web 部件页上的显示模式：  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 开发人员可以创建自定义显示模式，可以使用或不相关的自定义派生自的区域<xref:System.Web.UI.WebControls.WebParts.WebZone>或<xref:System.Web.UI.WebControls.WebParts.ToolZone>类。 若要创建的自定义显示模式，你必须从<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>类，也要添加为支持的模式，在页面上的显示模式，你必须从继承<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类并重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>方法。  
  
 当使用添加显示模式<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A>方法，你应将其添加你希望它们出现在任何用户界面 (UI) 控件中的顺序 (如<xref:System.Web.UI.WebControls.ListBox>控件)，向用户提供可能的显示模式在页面上。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> 方法。  
  
 此代码示例包括五个部分：  
  
-   一个用户控件，使你能够更改 Web 部件页面上的显示模式。  
  
-   承载其他控件的网页。  
  
-   用户控件，驻留在<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域在网页上，并使您能够输入和显示在标签中的文本。  
  
-   包含两个控件的源代码文件。 一个是一个自定义<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件，以及其他是一个自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>要添加到页面的默认显示模式对象。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口。  
  
-   该示例在浏览器中的工作原理说明。  
  
 下面的代码示例的第一部分是用于更改显示模式的用户控件。 你可以从示例部分中获取该用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式和用户控件的工作原理的详细信息，请参阅[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 该示例的第二部分是网页。 它包含两个<xref:System.Web.UI.WebControls.WebParts.WebPartZone>控制，用户控件和自定义<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 请注意`Register`页顶部的指令以引用的用户控件和已编译的控件的命名空间。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 该示例的第三个部分是用于输入和显示文本的用户控件。 它使用<xref:System.Web.UI.WebControls.MultiView>控件创建的用户界面的多个视图。 一个视图显示与`Button1`按钮，另一个没有。 请注意，在重写`OnPreRender`方法，代码检查以查看是否页目前处于的自定义显示模式，因此，如果是这样，显示用户控件，其中包括按钮的第一个视图。 如果该页是中的自定义显示模式，例如，如果页是在浏览或设计模式下，不会隐藏按钮。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 该示例的第四个部分是两个自定义类的源文件。 请注意，自定义<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>方法，并且它首先调用基方法，以添加所有默认显示模式，然后添加自定义显示模式。 自定义显示模式类， `InLineEditDisplayMode`，只需继承自<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>、 构造函数中，在设置的显示模式的名称和重写基属性以建立自定义显示的特征数。  
  
 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 若要运行的代码示例，加载浏览器中的页。 请注意，该页是当前处于浏览模式，并且没有按钮是可见的。 使用**显示模式**下拉列表控件中，更改到页**内联编辑显示**模式，并请注意现在`Button1`按钮是在较低的用户控件中可见。 添加一些文本，然后单击按钮来更新控件。 请注意，页面显示返回到浏览模式，并现在显示您输入的文本，而按钮再次处于隐藏状态，因为页不再的自定义显示模式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取一个唯一值，用于充当动态连接的 ID。</summary>
        <returns>一个包含连接的唯一 ID 的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A>方法生成的 GUID 值，并将其转换为字符串，以便作为连接的唯一 ID。 此方法叫做每次创建动态连接。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>开发人员可以重写此方法在派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类更改的实现以生成唯一 id。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">为其生成 ID 的控件的 <see cref="T:System.Type" />。</param>
        <summary>为动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件生成唯一 ID。</summary>
        <returns>一个字符串，包含控件的唯一 ID。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Web.UI.WebControls.WebParts.WebPart>控件添加到网页，则它们可以是静态 （这意味着页标记中声明的控件） 或动态 （这意味着它们将以编程方式添加）。 在任何方案中其中<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件创建新的动态控件将添加到页上，它会调用此方法以生成唯一 id。  
  
 方法是虚方法，使开发人员可以重写它如果他们想要提供自定义实现来生成 id。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartType" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">作为失败控件 ID 的字符串。 如果失败涉及 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，则该 ID 为其子服务器控件的 ID。</param>
        <param name="originalTypeName">字符串，失败控件的 <see cref="T:System.Type" /> 名称。 如果失败涉及 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，则该类型名称是其子服务器控件的类型。</param>
        <param name="originalPath">包含用户控件路径的字符串（如果失败涉及包含子用户控件的 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />）。</param>
        <param name="genericWebPartID">返回 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> ID 的字符串（如果加载或创建控件的失败涉及该类型的控件）。</param>
        <param name="errorMessage">包含要在页中显示的错误消息的字符串。</param>
        <summary>当加载或创建动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的尝试因某种原因失败时，创建插入页中并向最终用户显示的特殊控件。</summary>
        <returns>插入页中以替代未能加载或创建的控件的 <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A>时 Web 部件控件集尝试加载或创建的动态实例调用方法<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件和它出于某些原因而失败。 该方法将创建<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>对象，将一条错误消息分配给它，并将其返回。 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>控件插入失败，在控件的位置，并且其错误消息显示在页上。  
  
 不能调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A>在代码中直接的方法。 但是，你可以从继承<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类和扩展方法。 有关详细信息，请参阅继承者部分的说明。  
  
 最终用户可以使用<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>控制在页中很多像常规<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 若要删除错误消息，用户可以控制通过单击关闭关闭谓词，此时该控件将添加到<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>对象，像任何其他已关闭的控件一样。 如果最终用户删除<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>控件时，无法加载服务器控件也将删除从页中。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果你想要自定义中返回的信息<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />控件，可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />方法，调用基方法，将不同的值分配给传递给该基方法的参数，然后返回生成<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />控件。 例如，如果你不希望最终用户查看<paramref name="originalPath" />值 （该值将显示用户控件的虚拟目录路径），在调用基方法时无法传递一个空字符串 ("") 为该参数。  
  
 此外可以自定义的行为<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />控件本身，通过它继承。 例如，你可能希望重写其<see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" />或<see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" />属性。</para>
        </block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个个性化设置对象，该对象包含当前网页的用户个性化设置数据。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />，包含用户的个性化设置数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>方法返回的对象来包含和管理针对当前页的用户的个性化设置。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件管理此对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">一个不是 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的服务器控件。</param>
        <summary>用 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 对象包装一个不是 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控件的服务器控件，以使该控件能具有 Web 部件的功能。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，包装 <paramref name="control" /> 并使其功能与真正的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件一样。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法是用于启用不的服务器控件的主要机制<xref:System.Web.UI.WebControls.WebParts.WebPart>控件以与相同的功能对其执行<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，因此完全参与 Web 部件应用程序。 大大地使用此方法，开发人员展开他们可以使用 Web 部件应用程序中的服务器控件的数，因为几乎任何类型的服务器控件-可以使用标准 ASP.NET 控件、 用户控件和自定义控件。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件还使用此方法在两种情况下包装服务器控件与<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象。 当用户将服务器控件添加到页上通过使用<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>控制，如果导入的控件不是<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>调用方法。 此外，当服务器控件中声明中的持久性格式<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>在网页上，区域<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法调用的任何控件不<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
 当以编程方式向区域添加服务器控件时，典型的方法是使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法包装控件<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象，，然后调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法将控件添加到所有的集合<xref:System.Web.UI.WebControls.WebParts.WebPart>控件在页上，通过引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法。 在`Button2_Click method`、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>调用方法来包装<xref:System.Web.UI.WebControls.Calendar>控件替换为<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>之前将其添加到该区域的对象。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>可以重写此方法，以便使用派生<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />类相反的基类提供的 Web 部件控件集。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个自定义警告消息，当最终用户删除一个控件时，将显示该消息。</summary>
        <value>包含警告消息文本的字符串。 默认值是经本地化的警告消息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户删除<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，通常显示默认警告消息。 它会警告用户控件的此实例中删除时，删除是永久性。 页开发人员可以向用户提供了如何向页面添加控件的新实例 (如通过的目录<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，或通过某些编程的方式)，但永久移除已删除的控件的当前实例。 如果需要，将显示警告对话框中包含一个按钮，用户取消删除操作。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>属性使开发人员能够设置向用户显示该警告消息。  
  
 如果页开发人员分配一个空字符串 ("") 将显示此属性，没有警告消息对话框中的值，当用户中删除<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>属性未显示在静态的情况下<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和服务器控件。 静态控件是在内声明的服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域中的网页上的标记。 此类控件是静态的因为它们不能删除，因此将永远不会在这种情况下显示删除警告消息。 静态控件可以关闭的用户，但已关闭的控件添加到页目录中，从中它可以重新添加到页面的用户，而永远无法恢复删除的控件。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>属性以声明方式和以编程方式。  
  
 有四个部分的代码示例：  
  
-   一个用户控件，使你能够更改页面显示模式。  
  
-   自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
-   网页。  
  
-   该示例在浏览器中的工作原理说明。  
  
 下面的代码示例的第一部分是用于更改显示模式的用户控件。 你可以从示例部分中获取该用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式和用户控件的工作原理的详细信息，请参阅[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 下面的代码示例的第二部分是自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此示例使用的动态编译方法;因此没有任何`Assembly`属性中`Register`指令对于此控件在 Web 页的顶部。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 下面的代码示例的第三部分是网页。 页包含<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域，使用的自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>在区域中，声明的控件，以便用户可以将其添加到页在运行时。 请注意，可以从页中删除仅动态控件 （以编程方式或从类似于此目录添加到页面的控件）。 静态控件 (在内声明的控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域中的页面的标记) 被关闭，但是永远不会删除。 `<asp:webpartmanager>`元素声明的自定义值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>属性使用`DeleteWarning`属性。 `Button1_Click`方法将分配到另一个自定义值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 加载浏览器中后，你需要添加<xref:System.Web.UI.WebControls.WebParts.WebPart>到页面的控件。 使用**显示模式**下拉列表控件，选择目录模式。 出现目录时，选择自定义控件旁边的复选框，单击**添加**以将其添加到页上，然后单击**关闭**来返回到浏览模式的页。 现在，控件可见，则可以将其删除。 使用**显示模式**再次控件中，将页切换到设计模式 （页在浏览模式中时不能删除控件）。 单击的标头中的谓词菜单 （的箭头符号）<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并选择**删除**。 在设置的警告`DeleteWarning`特性随即显示。 单击**取消**。 现在，单击标记按钮**更改删除警告**，其中以编程方式更改的属性值。 从在控件上的谓词菜单中，选择**删除**试，请注意，此时会出现其他警告消息。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要删除的服务器控件。</param>
        <summary>永久地从网页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的动态实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>方法永久移除所表示的控件`webPart`从页中的参数。 与关闭的控件，它将添加到<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控制，可以在已删除的控件实例可以永远不会添加回页回页上，添加。  
  
> [!NOTE]
>  Web 部件控件的实施方式的设置，用户若要删除动态的能力<xref:System.Web.UI.WebControls.WebParts.WebPart>控件取决于用户和控件添加到页面中的个性化设置范围。 如果控件添加页面时共享作用域中 （由具有权限的用户），然后控件无法删除由各个用户页面时用户作用域中。  
  
 可以删除仅动态控件。 以编程方式或通过用户从目录中添加控件动态控件添加到页。 静态控件添加到以声明方式中标记或持久性格式的页。 声明性的标记是永久地存在于标记，因为静态控件永远不会被删除，但它们可以关闭并重新打开。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 方法。 第一次**添加日历**单击按钮时，代码在事件处理程序创建<xref:System.Web.UI.WebControls.Calendar>控制，并将其添加到作为区域<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象。 因为会以编程方式添加控件，它是动态控件，并因此可以删除。 当用户单击**删除日历**按钮，该代码可确保控件存在，，且然后将其删除通过调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>方法。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于更改包含 Web 部件控件的网页布局的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>字段引用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>对象，创建并包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 由于这是一个静态对象，你可以引用直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>而无需控件的实例的类。  
  
 包含 Web 部件页在首次加载时，在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>（浏览模式） 默认情况下。 如果用户想要通过将控件移到不同的区域或在当前区域内更改页的布局，它们必须先切换到页<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>（设计模式下）。 在设计模式下，将显示各种区域的用户界面 (UI)，而且用户可以拖动控件来更改布局。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>字段以编程方式。 此代码填充页上，在这种情况下是浏览和设计的受支持的显示模式的下拉列表。 请注意，，在`Page_PreRender`方法时，代码将检查是否当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性设置为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>。 如果是这样，`Label1`将是可见的如果不是，`Label1`将隐藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 加载浏览器中后，您拥有默认情况下浏览模式。 请注意，隐藏页上的标签。 使用下拉列表框控件将页切换到设计模式。 请注意，由于中的代码`Page_PreRender`方法，标签才现在可见。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要断开连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</param>
        <summary>移除要关闭或要从其所参与的连接中删除的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法的 Web 部件控件集在页或从页中删除控件时由内部调用。 在此类方案中，方法被调用来删除该控件从任何连接其中包含作为使用者或提供程序。 如果从任何连接删除控件，则此方法也会调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法来结束的任何连接`webPart`涉及。  
  
 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法调用，因此，它会发出<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件。 通常，此事件可以被取消，但不是能取消两种情况下。 页上，在请求期间发生的一种情况时<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>调用方法。 如果在现有的连接之间冲突<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法将调用以关闭之一相互冲突的连接，并在这种情况<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件不能被取消，因为必须解决冲突。  
  
 另一种情况时<xref:System.Web.UI.WebControls.WebParts.WebPart>或关闭或删除当前连接的服务器控件。 在这种情况下，因的控件而正在从删除页上，其连接需要被终止，因此不能取消设计使然<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件中断的结束连接过程。 有关详细信息，请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 方法。 使用两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，Web 页使你可以通过单击按钮，另一个按钮使你能够断开的控件时控件之间创建连接。 如果该页是在浏览模式中，并且控件已连接时，会关闭每个控件的重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法断开连接已关闭的控件，结束该连接，并显示一条消息。  
  
 下面的代码示例包含四个部分：  
  
-   用于更改显示模式用户控件。  
  
-   包含自定义的源文件<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
-   承载控件网页。  
  
-   该示例在浏览器中的工作原理说明。  
  
 下面的代码示例的第一部分是用于更改显示模式的用户控件。 你可以从示例部分中获取该用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式和用户控件的工作原理的详细信息，请参阅[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 第二部分是包含两个自定义的源代码的文件<xref:System.Web.UI.WebControls.WebParts.WebPart>将连接的控件和自定义<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此示例使用动态编译，因此`Register`相应地声明引用这些组件在网页中的指令在 Web 页的顶部。 有关演示编译选项的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 在源代码，请注意继承的控件`MyWebPartManager`可重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法。 此方法检查页来查看是否被关闭的控件参与连接并且，如果是这样，调用中的每个连接<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法来结束该连接。 这等同于中的方法的基实现<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 重写的方法然后自定义的基实现，通过一条消息写入页。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第三部分是网页。 请注意，在靠近顶部，它包含`Register`指令用于注册用户控件，并具有动态编译的程序集<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 页都有两种主要方法。 `Button1_Click`方法创建控件之间的连接时`Button2_Click`方法则断开控件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 加载页面后，单击**连接**按钮以将控件连接。 然后单击其中一个控件 （控件的标头中的向下箭头），谓词菜单并选择**关闭**从谓词菜单。 当你尝试关闭该控件时，重写的方法调用、 连接结束，和将消息写入到页。 如果你想要重置页后，可以还原已关闭的控件并尝试其他选项，请单击**重置用户状态**链接以移除个性化设置数据和还原页面的原始状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">表示服务器控件之间的连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</param>
        <summary>执行断开网页中连接的服务器控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法执行的结束之间的连接的整个过程<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件，当你将其传递`connection`参数。  
  
 此方法用于断开控件，当你将放`<asp:connectionszone>`在网页上，用于提供用户界面 (UI) 管理连接的元素。 在一个页面时连接的显示模式 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>)，和当前的连接存在时，用户可以单击调用一个按钮<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法来结束该连接。  
  
 你还可以调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法直接从代码中，如果你想要以编程方式，而不必添加断开控件`<asp:connectionszone>`到页元素。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 方法。 使用两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，Web 页使你可以通过单击按钮，另一个按钮使你能够断开的控件时控件之间创建连接。  
  
 下面的代码示例包含四个部分：  
  
-   用于更改显示模式用户控件。  
  
-   包含自定义的源文件<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
-   承载控件网页。  
  
-   该示例在浏览器中的工作原理说明。  
  
 下面的代码示例的第一部分是用于更改显示模式的用户控件。 你可以从示例部分中获取该用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式和用户控件的工作原理的详细信息，请参阅[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 第二部分是包含两个自定义的源代码的文件<xref:System.Web.UI.WebControls.WebParts.WebPart>将连接的控件。 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此示例使用动态编译，因此`Register`相应地声明引用这些组件在网页中的指令在 Web 页的顶部。 有关演示编译选项的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第三部分是网页。 请注意，在靠近顶部，它包含`Register`指令用于注册用户控件并具有动态编译的程序集<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 页都有两种主要方法。 `Button1_Click`方法创建控件之间的连接和`Button2_Click`方法则断开控件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 加载页面后，你可以单击**连接**按钮以将控件连接。 如果在文本框控件中，输入一些文本，然后单击**Enter**按钮，将连接 （它不会显示如果控件已断开连接） 的控件中显示的文本。 如果你单击**断开连接**按钮，控件将断开连接。 你可以通过使用验证控件的连接状态**显示模式**下拉列表控件，以将页切换到**连接**模式。 之后，这样，在每个控件的标题栏中单击 （由箭头表示） 的谓词菜单，然后选择**连接**项。 连接用户界面会显示出来;它是可用的因为没有`<asp:connectionszone>`页面中声明的元素。 你可以连接和断开此 UI 控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connection" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 或 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 中。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 为只读。  
  
 \- 或 -  
  
 <paramref name="connection" /> 已从 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 断开。  
  
 \- 或 -  
  
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 为只读。  
  
 \- 或 -  
  
 <paramref name="connection" /> 已从 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 断开。</exception>
        <block subset="none" type="overrides">
          <para>您可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />方法如果你想要更改断开连接的默认实现<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />控件。 如果你重写方法，并且你只想要将某些实现添加到现有的方法，你可以调用基方法，然后执行你自己的代码。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置包含 Web 部件控件的网页的活动显示模式。</summary>
        <value>确定页显示模式的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 页面，其中包含 Web 部件控件始终是几个可能的显示模式之一中。 有关显示模式的详细信息，请参阅[Web 部件页显示模式](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>类创建网页上的显示模式。 使用的基本<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>类，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件创建可以用在包含 Web 部件控件的页的多个标准显示模式对象。 这些标准的显示模式进行了介绍<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>类概述。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件还管理使用 Web 部件控件的页面的显示模式。 使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件在页上保留对当前显示模式的引用。 你还可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性以将页切换到不同的显示模式。 更改使用 Web 部件控件的页面上的显示模式的示例，请参阅[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 作为管理显示模式中，一部分<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件还提供事件和事件处理程序与相关显示模式，如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A>方法和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>方法。 这些方法提供了一种机制自定义页面的行为，以及甚至对于添加的自定义显示模式。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性。 在加载浏览器中之后, 可以使用页面底部附近的按钮切换显示模式。 加载时，该页已于默认情况下浏览模式。 如果你切换到设计模式，可以将服务器控件从一个区域中拖动到另一个字符串，或排列在一个区域中的两个控件。 如果你切换到编辑模式，你可以单击任何一个服务器控件，选择的标头中的谓词菜单**编辑**，和编辑使用提供的编辑用户界面 (UI) 的控件。  
  
> [!NOTE]
>  在 Web 部件应用程序中的显示模式之间切换是很常见，并且你可能想要提供一致的可重用方式来执行此操作在所有页，其中包含 Web 部件控件上。 有关在很多页上，可以重用更改显示模式和用户控件的示例，请参阅[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">赋给该属性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">赋给该属性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象不是受支持的显示模式。  
  
 \- 或 -  
  
 赋给该属性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象已禁用。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 Web 部件页上的当前显示模式更改之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 显示模式是 Web 部件应用程序不可或缺的组成部分。 当用户切换到不同的显示模式在网页上时，页通常会采用非常不同的外观，具体取决于新的显示模式的目的。 显示模式已更改后，你可能想要进行某些更改在用户界面 (UI)，如隐藏或显示某些控件中，更改所选的 UI 元素的外观，依此类推。  
  
> [!NOTE]
>  显示模式的详细信息，请参阅[Web 部件页显示模式](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。 有关使用事件的详细信息，请参阅[如何： 在 Web 窗体应用程序中使用事件](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户单击网页上的谓词以启动不同显示模式之间的更改过程之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 显示模式是 Web 部件应用程序不可或缺的组成部分。 当用户切换到不同的显示模式在网页上时，页通常会采用非常不同的外观，具体取决于新的显示模式的目的。 用户启动的过程将更改为新的显示模式，通过单击谓词后，你可能想要通过使用用户界面 (UI) 中进行某些更改<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A>属性来确定新的显示模式将是什么，，然后将更改各种 UI元素相应地。 有用的方式来执行此操作是重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>方法以自定义 UI。  
  
> [!NOTE]
>  显示模式的详细信息，请参阅[Web 部件页显示模式](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。 有关使用事件的详细信息，请参阅[如何： 在 Web 窗体应用程序中使用事件](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件关联的所有显示模式的只读集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 控件关联的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>属性引用所有关联显示模式，这与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性，即在引用有 （上受支持） 的当前页的显示模式。  
  
 两个提供的显示模式、 浏览和设计，始终支持在页面上。 其他三个显示模式、 编辑、 目录和连接，支持仅当页具有相应的特定显示模式工作所需的区域类型时。 例如，如果你的页面不包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>区域，编辑显示模式将显示在所引用的集合中<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>属性，但不是会显示所引用的集合中<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示了以编程方式利用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>属性。 代码使用此属性来填充该列表与所有 Web 部件控件集内可用的显示模式，甚至是那些不支持在当前页。 在这种情况下，该目录并连接的显示模式不受支持，因为所需的相应区域不在页面上。  
  
 其他三个显示模式--浏览、 设计和编辑--支持的页上。 编辑支持模式，因为页包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>区域，而浏览和设计模式始终受支持。  
  
 加载浏览器中后，你可以使用下拉列表控件切换到设计模式，来自浏览模式的页，然后编辑模式。 在编辑模式下，你可以单击每个服务器控件的标头中的下拉列表谓词菜单并选择**编辑**编辑该控件。 请注意，如果你选择**目录**或**连接**在下拉列表中，生成一个错误页。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取网页上当前存在的所有动态连接的集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />，其中包含对页上所有动态连接的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 动态连接都是以编程方式，而不是静态创建的连接。 静态连接创建的 Web 窗体页的标记中声明它们。 通过编程方式，或一个用户创建了使用连接用户界面 (UI) 的连接形成动态连接。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>集合，但它是只读的无法更改其内容，提供以编程方式访问每个动态连接对象。  
  
> [!NOTE]
>  执行常见的操作，如连接或断开<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，开发人员应使用的公共方法上,<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类，如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>，而不是尝试直接修改连接中的对象<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>集合。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示最终用户可在其中编辑和修改服务器控件的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>字段引用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>对象，创建并包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 由于这是一个静态对象，你可以引用直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>而无需控件的实例的类。  
  
 包含 Web 部件页在首次加载时，在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>（浏览模式） 默认情况下。 如果用户想要编辑或修改服务器控件，则首先必须切换到页<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>（编辑模式）。 其次，它们必须选择要编辑，请通过单击该控件的标头中的谓词菜单上的编辑谓词的特定服务器控件。 控件处于编辑模式后，编辑的用户界面 (UI) 将显示用于编辑所选的控件。  
  
 若要启用页面上的编辑模式，该页必须包含至少一个<xref:System.Web.UI.WebControls.WebParts.EditorZone>区域包含一个或多个所提供的编辑控件，如<xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart>控件或自定义编辑控件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>字段以编程方式。 此代码填充页上，在这种情况下是浏览、 设计和编辑的受支持的显示模式的下拉列表。 若要支持编辑，`<asp:EditorZone>`元素是在页中。 请注意，，在`Page_PreRender`方法时，代码将检查是否当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性设置为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>。 如果是这样，`Label1`将是可见的如果不是，`Label1`将隐藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 加载浏览器中后，您拥有默认情况下浏览模式。 请注意页面上的标签将被隐藏。 使用下拉列表框控件将页切换到编辑模式。 请注意，由于中的代码`Page_PreRender`方法，标签才现在可见。 单击**编辑**在每个控件，若要启用特定控件的编辑谓词菜单中的谓词。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值确定在包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的网页上是否启用了客户端脚本。</summary>
        <value>一个布尔值，指示页上是否可以运行客户端脚本。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>属性提供一种方法供开发人员用于禁用客户端脚本。 你可能需要禁用客户端脚本出于安全目的，或者以确保页面的所有用户将都具有类似的用户体验，即使它们使用不同的浏览器。  
  
 你可以禁用客户端脚本通过添加`EnableClientScript`属性设为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>元素在网页上，如下所示的声明性代码的以下行：  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 此外，开发人员可以消除此属性，通过继承<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类和设置默认值为`false`。  
  
 Web 部件控件集使用客户端脚本以提供一些客户端用户界面 (UI) 和个性化功能。 如果禁用客户端脚本，Web 部件控件仍起作用，但某些功能将被禁用。 禁用了将控件拖动到不同区域的功能，以及能够呈现 （谓词改为显示为控件的标题栏中的链接） 的控件的标题栏中的下拉列表谓词菜单中的谓词。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示网页启用了主题。</summary>
        <value>一个布尔值，指示是否启用了主题。 在所有情况下均为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件重写基<xref:System.Web.UI.Control.EnableTheming%2A>属性以确保它始终返回值为`true`。 这是因为 Web 部件控件集要求使用主题来进行呈现 Web 部件控件的子控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制的和窗体中的网页上的用户界面 (UI)。 例如，主题用于呈现各种区域，并驻留在区域，其中包括各种类型的控件部件控件 (继承的控件<xref:System.Web.UI.WebControls.WebParts.Part>类)，用户控件、 ASP.NET 服务器控件和自定义服务器控件。  
  
 尽管重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>属性实现为读/写属性，根据其基属性，因为设计使然，它始终必须返回的值，你不能设置此属性， `true`。 如果你尝试设置属性，<xref:System.NotSupportedException>引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">尝试设置该属性值。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>完成将 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件连接到另一个控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>方法完成连接的过程<xref:System.Web.UI.WebControls.WebParts.WebPart>到另一个控件的控件。 它是对应于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>方法。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>方法可以确保个性化设置对象引用的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性是可修改，这是必要的因为建立连接本身是一种类型的个性化设置。 然后，该方法确保，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>对象不是`null`，最后调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 属性所引用的控件为 <see langword="null" />。</exception>
        <block subset="none" type="overrides">
          <para>开发人员需要扩展<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件可能希望重写此方法在派生类。 一种方法是调用基方法，然后添加一些附加的自定义处理，或者你可能想要完全自定义完成控件之间的连接的整个过程。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>完成编辑 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>方法完成编辑过程<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 它是对应于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>方法可以确保个性化设置对象引用的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性是可修改，这是必要的因为编辑控件是一个过程，需要更改个性化设置。 然后，该方法确保，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>对象不是`null`，以便当前所选<xref:System.Web.UI.WebControls.WebParts.WebPart>控件可以更改，并最后调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 属性所引用的控件为 <see langword="null" />。</exception>
        <block subset="none" type="overrides">
          <para>开发人员需要扩展<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件可能希望重写此方法在派生类。 一种方法是调用基方法，然后添加一些附加的自定义处理，或者你可能想要完全自定义完成编辑控件的整个过程。 例如，在重写方法中，您可以首先调用基方法，然后添加某些代码来确定所做的编辑更改，并显示的更改的列表返回到最终用户确认。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在用户尝试从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件导出敏感状态数据时显示的警告消息的文本。</summary>
        <value>一个包含警告消息的字符串。 默认消息是由 .NET Framework 提供的、特定于区域性的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户尝试导出敏感状态数据从<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，如果任何正在导出的数据来自已标记为敏感的源代码中的成员时，向在消息框中，告知他们的用户显示一条警告消息正在导出敏感数据并提供取消导出的机会。 开发人员可以通过设置标记为敏感的特定成员的数据`isSensitive`参数`[Personalizable]`属性设为`true`成员上。 有关此属性和参数的详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute>类。  
  
> [!IMPORTANT]
>  当你使用 Web 部件的导出功能时，敏感无法可能将数据导出到未经授权的用户。 有关如何防范此威胁的详细信息，请参阅[保护 Web 部件页](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 每当用户尝试导出，将显示默认消息。 但是，通过将值分配给<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>属性，你可以提供自定义的警告消息。  
  
   
  
## Examples  
 下面的代码示例演示如何以声明方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>属性。  
  
 以下 Web 页的代码使用标准<xref:System.Web.UI.WebControls.BulletedList>控制并将其放在区域中。 将与包装控件<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件在运行时，使它能够充当真正<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 若要使控件可导出，`ExportMode`属性添加到`<asp:bulletedlist>`元素和属性值设置为<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>，这意味着该敏感和非敏感数据可以导出。 另请注意，在`<asp:webpartmanager>`元素，`ExportSensitiveDataWarning`属性分配自定义值。  
  
 请注意，对于该代码示例能工作，则必须在 Web.config 文件，以使导出 Web 部件描述文件中添加的设置。 确保你有此代码示例为 Web 页相同的目录中的 Web.config 文件。 在`<system.web>`部分中，请确保有`<webParts>`具有元素`enableExport`属性设置为`true`，如下所示的以下标记。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 加载浏览器中后，请在包含链接的控件的标题栏中单击 （向下箭头表示） 的谓词菜单。 在谓词菜单中，选择**导出**，请注意，与该自定义警告出现一个消息框。 如果你想要继续导出，请单击**确定**，从而允许您使用该控件相关的所有数据保存的 XML 说明文件的本地副本。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">将从中导出数据的控件。</param>
        <param name="writer">一个 <see cref="T:System.Xml.XmlWriter" />，它将导出的数据从 <c>webPart</c> 写入 XML 说明文件。</param>
        <summary>创建包含服务器控件的状态和属性数据的 XML 说明文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>方法将从各种状态和属性的数据组合`webPart`到 XML 文件。 数据包括有关控件本身，包括程序集、 状态数据和属性数据的信息。 启动导出的用户可以将 XML 文件保存到磁盘中，本地计算机或网络上。 然后，其他用户可以说明文件导入到另一个页面或网站，并将状态和属性数据应用到的其他实例`webPart`。 这样，用户可以共享并重复使用其服务器控件上的设置快速而方便的机制和它还为开发人员提供一种控制的外观和行为的导出和导入控件的方法。  
  
 上的属性`webPart`不导出的默认值。 若要启用导出的属性，必须将其与标记`[Personalizable]`的源代码中的属性。 也可以将标记为包含敏感数据，通过设置可导出属性`isSensitive`参数`[Personalizable]`属性设为`true`。 默认情况下，`isSensitive`是`false`。 开发人员可以将参数设置为`true`以指示数据是敏感。  
  
 若要启用`webPart`要导出，开发人员设置其<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>属性值为<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>（包括所有可个性化和敏感属性） 或<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>，导出除敏感属性.  
  
> [!IMPORTANT]
>  允许用户将数据导出从控件，并将数据导入其他控件，需要某些安全风险。 开发人员应使用前面讨论方法来保护敏感数据，并且如果他们想要避免完全公开数据的风险，它们不使导出上`webPart`根本。 有关 Web 部件安全问题的详细信息，请参阅[保护 Web 部件页](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 为 <see langword="null" />。  
  
 \- 或 -  
  
 <paramref name="writer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 中所引用的控件集合中。  
  
 \- 或 -  
  
 <paramref name="webPart" /> 的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" /> 属性设置为值 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" />，该值表明对 <paramref name="webPart" /> 禁用导出。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>被重写以防止将焦点设置在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件上，因为该控件没有用户界面 (UI)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A>方法重写基<xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType>方法，并在调用方调用的方法时引发异常。 因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件没有用户界面，并且是永远不会对用户可见，则它从不允许将焦点设置在本身上。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">调用方尝试调用 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" /> 方法，该方法在没有用户界面的控件中不受支持。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">作为连接中的使用者的服务器控件。</param>
        <summary>检索 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> 对象的集合，这些对象可以作为来自如下服务器控件的连接点：该服务器控件正在作为 Web 部件连接中的使用者。</summary>
        <returns>包含使用者中的所有连接点的 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 部件连接中始终涉及两个控件，一个充当数据，另一个充当数据的使用者的提供程序。 每个控件必须具有一个或多个定义为连接点的方法。 对于使用者控件，其连接点为<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象。 检索使用者连接点是构成 Web 部件连接中的必需步骤。  
  
 使用者必须始终具有至少一个连接点，若要能够建立连接。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>方法检查使用者控件，并检索其所有连接点的集合。 如果<xref:System.Web.UI.WebControls.WebParts.WebPart>控件具有没有连接点，该方法返回一个空集合。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 方法。  
  
 下面的代码示例包含四个部分：  
  
-   一个用户控件，使你能够更改 Web 部件页面上的显示模式。  
  
-   包含两个自定义网页<xref:System.Web.UI.WebControls.WebParts.WebPart>可连接控件和`<asp:webpartmanager>`元素。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口。  
  
-   该示例在浏览器中的工作原理说明。  
  
 下面的代码示例的第一部分是用于更改显示模式的用户控件。 你可以从示例部分中获取该用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式和用户控件的工作原理的详细信息，请参阅主题[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 网页的声明性标记包含`Register`为用户控制和自定义控件的指令。 没有`<asp:webpartmanager>`元素，`<asp:webpartzone>`元素以包含自定义控件和`<asp:connectionszone>`元素。 请注意，在`Page_Load`方法，代码将检查来查看是否连接已存在并且，如果不是，定义提供程序、 一个使用者和它们各自的连接点，并且然后将新的连接添加到的一套所引用的静态连接<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>属性。 请注意，<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection>使用检索的对象<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>方法然后传递给<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法来确定是否可以创建两个控件之间的连接。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 你可以获取此代码，以及用于编译它，从示例部分的说明<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。  
  
 你已加载浏览器中的 Web 页后，单击**显示模式**下拉列表控件，然后选择**连接**切换页后，可以连接模式。 连接模式使用`<asp:connectionszone>`元素以启用你创建控件之间的连接。 在连接模式中，单击标题栏中的向下箭头**邮政编码**控件来激活其谓词菜单中，，然后单击**连接**。 显示连接用户界面 (UI) 后，请注意，已由中包含的代码创建连接时`Page_Load`方法。 如果在更高版本的浏览器会话中返回此页，此静态连接将已建立，并且将不需要重新创建每次加载页面。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 的实例的网页。</param>
        <summary>检索对页上的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的当前实例的引用。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />，引用该控件在页上的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>方法很有用的上下文中你想要检索对当前的引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 出现这种常用情况是如果你正在编写的自定义控件在开发过程的 ID 不能知道<xref:System.Web.UI.WebControls.WebParts.WebPartManager>将控件置于其。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>方法是静态的因此您可以直接无的实例调用它<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 Web 部件中的某些控件控件集，如<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，具有<xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A>可以检索对当前的引用的属性<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 因此，在使用此类控件，你应使用此属性来检索的引用。  
  
 如果你在编码在其中你知道的 ID 的上下文中<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制，例如编写内联代码在 Web 页中，它是最简单和直接引用方式效率最高<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件使用其 id。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 方法。 该示例由两部分组成： 一个自定义服务器控件和承载控件的网页。  
  
 自定义<xref:System.Web.UI.WebControls.Label>控件使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>方法来检索其中的 ID<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件在当前页，然后显示该 id。  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 下面的代码示例提供承载中的控件的网页<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 加载浏览器中后，请注意，当前的 ID<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件显示在自定义<xref:System.Web.UI.WebControls.Label>控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="page" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">此方法返回其 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 值的控件。</param>
        <summary>获取一个字符串，其中包含 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 属性的值。</summary>
        <returns>一个字符串，包含 <paramref name="webPart" /> 的计算得出的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 获取的计算所得的值<xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A>属性`webPart`。 当开发人员不将值赋给<xref:System.Web.UI.WebControls.WebParts.Part.Title%2A>属性<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，此方法产生的值显示为标题。 无标题控件的计算的值包含，该值指示在当前区域内的控件的序列号为一个字符串，后面追加一个数字。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 不在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合中。</exception>
        <block subset="none" type="overrides">
          <para>可以重写此方法，以更改如何计算默认显示标题。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在导出的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</param>
        <summary>获取当用户尝试导出 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件时包含在请求中的相对虚拟路径和查询字符串。</summary>
        <returns>一个字符串，其中包含共同形成导出控件请求的相对虚拟路径和查询字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A>方法是包含该控件的页的服务器位置的相对虚拟路径加上追加的查询字符串值，窗体导出请求提交到服务器。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A>方法允许将请求提交，以防止恶意脚本攻击之前编码字符串。  
  
> [!NOTE]
>  有关保护 Web 部件应用程序的详细信息，请参阅[保护 Web 部件页](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">一个服务器控件，它存在于 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 中，并在运行时被包装为 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 的子控件。</param>
        <summary>获取对 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控件的实例的引用，该实例包含一个服务器控件。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，将 <paramref name="control" /> 包装为子控件。 如果 <paramref name="control" /> 未包含在 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 中，则此方法返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般情况下，有两种类别的控件的开发人员放在<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域，以参与 Web 部件应用程序：<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，继承自<xref:System.Web.UI.WebControls.WebParts.WebPart>基类和其他服务器控件，它可以是标准ASP.NET 控件、 自定义控件或用户控件。 当任何这些控件将置于<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域，它将的功能<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 A<xref:System.Web.UI.WebControls.WebParts.WebPart>控件具有此功能本质上就是，但其他类型的服务器控件不这样做。 若要启用其他服务器控件，使其作为<xref:System.Web.UI.WebControls.WebParts.WebPart>控制当它们都将置于<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域，ASP.NET 包装它们与<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件。 因为<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件继承直接从<xref:System.Web.UI.WebControls.WebParts.WebPart>类，它为其子控件提供 true Web 部件功能。  
  
 通常在运行时，页开发人员可能想要获取对引用<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包含一个区域中的服务器控件的控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法使它们能够检索到的引用<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法。 此代码示例包含<xref:System.Web.UI.WebControls.Calendar>控件中声明<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域。 `Button1_Click`方法首先将该 ID 的输出<xref:System.Web.UI.WebControls.Calendar>到标签，然后使用控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法来检索到的引用<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包装日历的控件。 ID<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制和其子控件的 ID (即<xref:System.Web.UI.WebControls.Calendar>控件)，将打印到第二个标签。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">作为连接中的提供者的服务器控件。</param>
        <summary>检索 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" /> 对象的集合，这些对象可作为来自如下服务器控件的连接点：该服务器控件正在作为 Web 部件连接中的提供者。</summary>
        <returns>包含提供者中的所有连接点的 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 部件连接中始终涉及两个控件，一个充当数据，另一个充当数据的使用者的提供程序。 每个控件必须具有一个或多个定义为连接点的方法。 对于提供程序控件，其连接点为<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>对象。  
  
 一个提供程序必须始终具有至少一个连接点，若要能够建立连接。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>方法检查提供程序控制，并检索其所有连接点的集合。 检索提供程序连接点是构成 Web 部件连接中的必需步骤。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 方法。  
  
 该示例包含四个部分：  
  
-   一个用户控件，使你能够更改 Web 部件页面上的显示模式。  
  
-   包含两个自定义网页<xref:System.Web.UI.WebControls.WebParts.WebPart>可连接控件和`<asp:webpartmanager>`元素。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口。  
  
-   该示例在浏览器中的工作原理说明。  
  
 下面的代码示例的第一部分是用于更改显示模式的用户控件。 你可以从示例部分中获取该用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式和用户控件的工作原理的详细信息，请参阅[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 网页的声明性标记包含`Register`为用户控制和自定义控件的指令。 没有`<asp:webpartmanager>`元素，`<asp:webpartzone>`元素以包含自定义控件和`<asp:connectionszone>`元素。 请注意，在`Page_Load`方法，代码将检查来查看是否连接已存在并且，如果不是，定义提供程序、 一个使用者和它们各自的连接点，并且然后将新的连接添加到的一套所引用的静态连接<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>属性。 请注意，<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection>使用检索的对象<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>方法然后传递给<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法来确定是否可以创建两个控件之间的连接。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 你可以获取此代码，以及用于编译它，从示例部分的说明<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。  
  
 你已加载浏览器中的 Web 页后，单击**显示模式**下拉列表控件，然后选择**连接**切换页后，可以连接模式。 连接模式使用`<asp:connectionszone>`元素以启用你创建控件之间的连接。 在连接模式中，单击标题栏中的向下箭头**邮政编码**控件来激活其谓词菜单中，，然后单击**连接**。 显示连接用户界面 (UI) 后，请注意，已由中包含的代码创建连接时`Page_Load`方法。 如果在更高版本的浏览器会话中返回此页，此静态连接将已建立，并且将不需要重新创建每次加载页面。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">一个 <see cref="T:System.Xml.XmlReader" />，它从导入的 XML 说明文件中读取状态和属性数据。</param>
        <param name="errorMessage">在导入过程中遇到错误时将向用户显示的 <see cref="T:System.String" />。</param>
        <summary>导入包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的状态和属性数据的 XML 说明文件，并将这些数据应用于控件。</summary>
        <returns>在导入的 XML 说明文件中引用的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />（或由 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 包装并因此被视为 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 的服务器控件）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>方法导入由 XML 说明文件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>的服务器控件的方法。 它不是导入，则实际的服务器控件，但仅包含有关控件的状态和属性数据的说明文件。 控件和说明文件中引用的程序集必须已经是用户尝试导入说明文件服务器上可用。  
  
 若要启用导入一个控件，开发人员需要添加<xref:System.Web.UI.WebControls.WebParts.CatalogZone>将在何处启用导入的页上的控件。 在该区域，<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>必须添加控件。 此控件提供一个文件对话框，允许用户浏览并找到要导入的说明文件。  
  
 用户查找的描述文件，并开始导入后，通过阅读说明文件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>方法。 如果没有错误，并且如果找到的程序集和控件，将服务器控件添加到目录中<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>控制和说明文件中指定的各种属性和状态数据应用于控件。 然后，用户可以选择的控件，并将其添加到页面。  
  
> [!IMPORTANT]
>  如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>方法，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>方法有一些潜在的安全风险。 因为它涉及到将数据导入网站，恶意用户可能尝试插入到说明文件导入的错误数据或甚至脚本代码。 然后将错误数据无法显示页面，或在数据库中，或插入的脚本无法运行。 与导入描述文件，以及避免这些风险的方法关联的潜在风险的概述，请参阅[保护 Web 部件页](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.EndOfStreamException">
          <paramref name="reader" /> 未能读取文件。  
  
 \- 或 -  
  
 需要 <paramref name="reader" /> 来显示导入错误消息，但在文件中未找到。  
  
 \- 或 -  
  
 <paramref name="reader" /> 已到达文件末尾，但未找到包含导出数据的 XML 元素。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> 类的引用，该类用于合并和拆分实际在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类中实现的，但通常对控件开发人员很有用的一组方法。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />，<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 通过它可引用已拆分为 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> 的各种方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>属性公开的 Api 来调入一组<xref:System.Web.UI.WebControls.WebParts.WebPartManager>主要用于扩展性用例的方法。  
  
 使用这些内部的方法的设计的方法是通过其进行访问<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>属性。 由于受保护属性，你仅可以访问它并调用的方法的实例内<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>通过继承的类<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类。  
  
> [!NOTE]
>  此属性隐藏的中的 IntelliSense [!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]。 但是，在派生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类，则仍可以访问的属性，其不同的成员。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定能否将 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件添加到页中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 部件功能的灵活性的一部分是能够在运行时将服务器控件添加到网页。 有大量的服务器控件中的常见方案 (可以是自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 一个自定义服务器控件、 一个用户控件或 ASP.NET 控件) 可以添加。  
  
 在以下常见方案中，Web 部件控件集尝试将服务器控件添加到页中，与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>调用方法对它们进行授权：  
  
-   通过声明一个网页中的标记中添加服务器控件时<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域。  
  
-   当服务器控件是以编程方式添加到区域。  
  
-   当用户将导入控件的 Web 部件目录的服务器控件。  
  
-   如果现有从个性化设置数据存储区加载服务器控件。  
  
-   当服务器控件添加到<xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart>以使其可在目录中的服务器控件的控件。  
  
 在其中添加控件，每个方案<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>调用方法来确保已满足，所有的授权条件以允许要添加的控件。 当控件已经过授权时，将被添加通常因为它处于如果没有任何筛选方案。 当未授权控件时，Web 部件控件集可以响应中有多种，具体取决于上下文。 可以以无提示方式失败控件集 （如果不需要通知用户） 添加未经授权的一部分，它可以显示错误消息，或者它可以将添加的实例<xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart>作为占位符的类。 此占位符对象不是在页上可见，但会显示在页的源代码以指示未经授权的控件已被排除。  
  
 是否获得授权控件的行列式是授权筛选器。 授权筛选器是在 Web 部件控件集，使开发人员从页中排除不满足指定的条件的任何控件的功能。  
  
 若要创建筛选的方案，开发人员必须执行两项操作。 首先，他们必须分配到一个字符串值 （该值可以为任意）<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>每个属性<xref:System.Web.UI.WebControls.WebParts.WebPart>他们计划在方案中使用的控件。 它们还可以为其他类型的服务器控件的不是此属性分配一个值<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，因为如果它们都将置于<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域，此类控件使用包装<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件在运行时，而此控件继承<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性。  
  
 用于创建筛选方案的第二个必要步骤是为覆盖<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>方法，或创建的事件处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件。 在这些方法中，开发人员可以检查<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性，如果值指示不应授权控件，开发人员可确保和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法返回的值`false`。  
  
> [!NOTE]
>  有关代码示例和如何设置自定义的筛选方案使用的说明<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，请参阅该方法的重载的主题。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在接受授权检查的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件。</param>
        <summary>执行确定控件是否被授权添加到页中的初始步骤。</summary>
        <returns>一个布尔值，指示能否将 <paramref name="webPart" /> 添加到页中。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法是调用 Web 部件控件集用来检查授权的初始方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 它接受`webPart`作为参数，并开始最终确定是否将控件添加到页的过程。 此方法在代码中直接调用需要以确定是否授权给定的控件时。  
  
 此方法执行初始任务确定控件是否继承自<xref:System.Web.UI.WebControls.WebParts.WebPart>类或者是否<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控制，并且，如果是这样，哪种类型的子控制它包含。 若要完成的任务的授权，它调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>重载方法。  
  
   
  
## Examples  
 下面的代码示例演示如何调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29>从你的代码以确定控件是否有权添加到页面的方法。  
  
 代码示例包含三个部分：  
  
-   自定义<xref:System.Web.UI.WebControls.WebParts.WebPartManager>重写的控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法。  
  
-   创建的筛选器的网页<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
-   如何运行的代码示例说明。  
  
 此代码示例使用自定义<xref:System.Web.UI.WebControls.WebParts.WebPartManager>重写的控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>重载方法以提供自定义的处理操作的<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性。 此控件的属性值为检查`admin`并且，如果值存在，对该控件的授权。 如果控件具有不同的值，未授权;因为它们可能不为筛选方案的一部分，以及，授权控件而不通过属性值。  
  
 若要运行此代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用的动态编译方法。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 下面的代码示例的第二部分创建筛选器可能排除控件。 以下 Web 页包含三个 ASP.NET 服务器控件中的`<asp:webpartzone>`元素。 请注意，第一个和第二个控件具有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性设置为不同的值，并且第三个不会分配属性。 可以在运行时，检查此授权值和控件可以添加到页面，如果在筛选器匹配由开发人员设置的条件。 另请注意，在`Page_Load`方法，该代码调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29>方法来确定是否每个控件是否经过授权，以及如果是，则设置每个控件<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 请注意，为代码的示例正常工作，必须添加的设置在 Web.config 文件，以使导出 Web 部件描述文件中。 确保你有此代码示例为 Web 页相同的目录中的 Web.config 文件。 在`<system.web>`部分中，请确保有`<webParts>`具有元素`enableExport`属性设置为`true`，如下所示的以下标记。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 加载浏览器中后，请注意，将显示第一个控件，这是由于它匹配重写方法中的条件。 第二个控件未添加到页上，因为筛选器排除。 此外添加了第三个控件，因为它不具有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性集。 请注意，如果单击任一控件的标题栏中的谓词菜单图标时，他们可以同时导出，因为其各自<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>都分配了属性值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage">
          <para>在代码中直接调用此方法。 如果你想要授权过程的更好地进行编程控制，则可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />重载方法。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">被检查授权情况的控件的 <see cref="T:System.Type" />。</param>
        <param name="path">被授权的控件的源文件的相对应用程序路径（如果该控件为用户控件）。</param>
        <param name="authorizationFilter">赋予 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 属性的任意字符串值，用于授权是否可将控件添加至页中。</param>
        <param name="isShared">指示被检查授权情况的控件是否为共享控件，共享意味着它对应用程序的许多用户或所有用户可见，并且其 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> 属性值设为 <see langword="true" />。</param>
        <summary>执行确定控件是否已经过授权可添加至页的最后步骤。</summary>
        <returns>一个布尔值，指示控件是否已经过授权可添加至页中。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>重载方法确定控件是否有权添加到页面中的最后步骤执行。 该方法确保`type`是有效的类型，而`path`被检查的控件是一个用户控件的情况下，才会包含一个值。 然后，它调用的重要<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法，将引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件。  
  
   
  
## Examples  
 下面的代码示例演示如何重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法来确定控件是否有权添加到页。  
  
 第一步是创建的筛选器可能排除控件。 以下 Web 页包含三个 ASP.NET 服务器控件中的`<asp:webpartzone>`元素。 请注意，第一个和第二个控件具有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性设置为不同的值，并且第三个不会分配属性。 可以在运行时，检查此授权值和控件可以添加到页面，如果在筛选器匹配由开发人员设置的条件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 第二步是重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>方法，并创建自定义授权筛选器处理。 请注意，代码首先检查属性是否具有一个值，以便任何控件，不会分配<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性将自动添加。 如果控件具有筛选器，代码会返回该`true`仅当筛选器值等于`admin`。 此示例演示一个简单的机制，可用于向特定用户，具体取决于其角色显示某些控件。 尽管超出本主题的范围了使用角色的完整示例，您可以使用相同的逻辑作为在此代码示例中，重写的方法，只不过无法检查当前用户是否属于与授权筛选器值匹配的角色然后将仅针对该用户控件添加。 这将使您创建其中某些用户将看到所有控件和其他用户将只能都看到所选的控件的页面。 这是如果你使用角色的可能外观检查筛选器的逻辑：  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用的动态编译方法。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 加载浏览器中后，请注意，将显示第一个控件，这是由于它匹配重写方法中的条件。 第二个控件未添加到页上，因为其筛选器值被排除。 添加了第三个控件，因为它不具有其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性集。 如果你更改在第二个控件，并将检索与匹配的第一个控件，然后再次运行此页上的属性值，以及添加第二个控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> 为用户控件，且 <paramref name="path" /> 为 <see langword="null" /> 或空字符串 ("")。  
  
 \- 或 -  
  
 <paramref name="type" /> 不是用户控件，且 <paramref name="path" /> 已赋值。</exception>
        <block subset="none" type="overrides">
          <para>可以重写此方法通过继承<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类，如果你想要检查授权时提供附加的处理。 你可能想要重写方法以检查某些值<paramref name="authorizationFilter" />参数，并基于值，返回一个布尔值，确定是否将控件添加到页。  
  
 对于页开发人员还想要检查授权筛选器，并提供自定义处理，没有用于执行在.aspx 页中，或在代码隐藏文件中，此内联操作而无需从任何类继承的选项。 你可以声明备用事件处理程序中的页<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />方法<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件。 有关更多详细信息及示例，请参阅<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />方法。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否已进行了个性化设置更改，这些更改影响 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件所控制的页级别个性化设置详细信息。</summary>
        <value>一个布尔值，指示是否已进行了个性化设置更改。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>属性内部来跟踪是否有任何它所管理的页面级别个性化数据已更改。 当用户执行各种级别的页，如添加或删除的个性化设置操作时，将更改个性化数据<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，连接或断开控件，通过移动控件和其他操作更改页面的布局。  
  
> [!NOTE]
>  用户还可以执行级别的控制，这意味着它们对特定的控件进行个性化修改，个性化和所做的更改仅影响该控件。 示例将编辑控件，并可以更改其标题文本或它的背景色。 控件级别个性化设置不会影响所跟踪的页面级别个性化数据<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件，因此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>属性值不会更改为`true`控件级别个性化发生时。  
  
 尽管该方法受保护并不直接由调用方，访问<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>直接由调用方，然后才能访问属性，并返回此属性的值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">包含要加载的保留的状态数据。</param>
        <summary>加载从前一个页请求保存并需要在后续请求上还原的控件状态数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>方法可用于还原应在回发期间的页上，保留的属性数据，即使<xref:System.Web.UI.Control.EnableViewState%2A>属性设置为`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="savedState" /> 不是有效的 <see cref="P:System.Web.UI.PageStatePersister.ControlState" />。</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，它包含要加载的状态数据。</param>
        <summary>存储由个性化对象传递给 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的自定义个性化数据，稍后会将其用于初始化过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A>方法提供的窗体中的已保存的状态数据<xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary>对象。 此数据最终使用加载到 Web 部件控件的个性化数据以及执行其他初始化任务。  
  
> [!NOTE]
>  开始时的一系列方法调用此方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A>方法最初请求关联<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>对象提供个性化数据到<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 不能在代码中直接调用此方法。 但是，，可以直接调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>方法，后者自身调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A>方法并返回个性化数据。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>开发人员可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />方法在派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 对象。</summary>
        <value>仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet>类型反序列化导入过程中使用此属性返回的对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 对象。</summary>
        <value>获取仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet>导入所有操作都只键入反序列化过程中使用此属性返回的对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">要移动的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件。</param>
        <param name="zone">
          <c>webPart</c> 要移动到的目标 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex">一个整数，指示 <c>webPart</c> 在 <c>zone</c> 中相对于其他控件的索引。</param>
        <summary>将 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件从一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域移动到另一个区域，或移动到相同区域中的新位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法来移动`webPart`到在同一区域中，或不同区域中的新位置。 你可以直接从代码中，调用此方法，也会调用时用户将控件移到新位置在 Web 部件用户界面 (UI) 中使用各种选项。  
  
 之前，必须满足的条件数`webPart`可以移动，和其中的大部分由本主题的异常部分中列出的项。 如果`webPart`中未包含<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域开始时，不能移入某个区域。  
  
 在满足的条件后，操作按以下顺序发生移动`webPart`:  
  
1.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 事件。  
  
2.  `webPart` 从其当前区域 （如有必要），删除和添加到其新的区域或在其当前的区域内的新位置。  
  
3.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 事件。  
  
4.  `zoneIndex`的每个<xref:System.Web.UI.WebControls.WebParts.WebPart>起点和目标区域中的控件重置，以反映移动的控件。  
  
   
  
## Examples  
 下面的代码示例演示如何调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法直接从代码以移动<xref:System.Web.UI.WebControls.WebParts.WebPart>到另一个控件从一个区域。  
  
 代码示例包含三个部分：  
  
-   用于更改显示模式用户控件。  
  
-   承载控件网页。  
  
-   如何运行的代码示例说明。  
  
 下面的代码示例的第一部分是用于更改显示模式的用户控件。 你可以从示例部分中获取该用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式和用户控件的工作原理的详细信息，请参阅[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 该示例的第二部分是一个网页，其中包含两个区域，其中每个包含两个服务器控件。 当用户单击**移动 web 部件**在页上中的代码的按钮`Button1_Click`方法将第一个区域中控件移动到第二个区域中的新位置。 请注意，代码必须先调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法来检索<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包装对象`list1`控件。 这是必需的因为的第一个参数<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法需要<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，而`list1`是 ASP.NET 服务器控件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 在页面加载后，单击**移动 web 部件**按钮，并请注意，包含链接的控件将移到第二个区域中的中间位置。 通过调用以编程方式完成这种控件移动<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法。 你还可以使用**显示模式**下拉列表控件，以将页切换到设计模式，并在设计模式下，你可以将控件拖到不同区域或它们各自区域中的不同位置。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法也由调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件以处理此类用户启动移动。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 集合中。  
  
 \- 或 -  
  
 <paramref name="zone" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 集合中。  
  
 \- 或 -  
  
 <paramref name="webPart" /> 控件的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> 属性所引用的区域为 <see langword="null" />，意味着 <paramref name="webPart" /> 当前未包含在任何区域中。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> 或 <paramref name="zone" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="zoneIndex" /> 小于零。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> 事件并调用该事件的处理程序（如果存在）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法由调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，当<xref:System.Web.UI.WebControls.WebParts.WebPart>控件要添加到页面的授权检查。 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法调用，因此，它会发出<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，并且如果没有为事件处理程序方法，它调用处理程序。  
  
 授权的过程<xref:System.Web.UI.WebControls.WebParts.WebPart>控件是一个重要的 Web 部件功能。 每个<xref:System.Web.UI.WebControls.WebParts.WebPart>或添加到的区域的服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件将经历授权过程以确定是否可以添加控件。 默认情况下，Web 部件控件集不提供任何筛选条件，以防止控件添加到区域。 但控件集提供了开发人员创建其自己的筛选条件所需的机制。 通过使用这些机制，可以创建自定义筛选方案。 例如，你可以创建筛选器，以便如果用户是管理员角色中，某些控件将添加到区域中，当呈现页面，并且如果用户是用户角色中，将不会添加这些控件。  
  
 在授权过程中筛选控件使用机制<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法，与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>上的事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。  
  
 若要创建筛选的方案，没有实质上是两个任务。 首先，你还将字符串转换为分配<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>每个属性<xref:System.Web.UI.WebControls.WebParts.WebPart>你想要筛选的控件。 这些字符串值可以是任意的但它们应包含你想要作为筛选依据的条件。 例如，如果你想给定的控件要添加到区域才管理员用户正在查看页上，则可以分配的字符串值`admin`的属性。 然后可以使用 ASP.NET 角色功能，并将你的站点的所有用户都添加到各种角色，例如管理员、 经理和用户。 当正在加载页面时，筛选代码将检查用户的哪些角色中，将其与要检查的控件上的授权筛选器值比较，如果该用户的管理员角色的是 （例如），并且你已设置的控件<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>的值`admin`，无法添加控件。  
  
 创建筛选方案的第二步是编写代码以检查<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性值在<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，并确定每个控件是否已被添加到其区域之前的授权。 有两个用于此筛选代码的放置位置选项。 第一个选项是页开发人员的首选的选项。 你可以创建一个方法来处理<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>直接在 Web 页的服务器脚本代码，或单独的代码文件中的事件。 将你的方法与事件相关联通过添加`OnAuthorizeWebPart`属性设为的标记<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制在页中，如下面的示例标记代码中所示。  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 所有自定义方法都只需是检查每个<xref:System.Web.UI.WebControls.WebParts.WebPart>控制是否满足筛选条件，然后，根据结果，将分配到一个布尔值<xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A>属性<xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs>对象，以指示是否<xref:System.Web.UI.WebControls.WebParts.WebPart>控件均可以是添加。 示例部分中的代码演示如何执行此操作。  
  
 有关在何处放置筛选代码的第二个选项是继承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类，并重写一个方法以检查筛选器条件。 可以重写以执行此操作的两个方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType>方法或<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法。 尽管任何一种方法将起作用，但在大多数情况下它是更可取的方法重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，因为它提供了更多的编程控制对整个授权过程中，而<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法执行只有一项特定任务这是引发的事件和处理程序提出的检查。 有关自定义的代码示例<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类，并重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType>的方法重载。  
  
   
  
## Examples  
 下面的代码示例演示如何设置的自定义事件处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件，从而使处理程序可以提供自定义筛选代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法。 此示例将页开发人员提供筛选的方案和授权的典型方式<xref:System.Web.UI.WebControls.WebParts.WebPart>控件添加到页。  
  
 在 Web 页中，请注意，`<asp:webpartmanager>`元素具有`OnAuthorizeWebPart`具有分配给它的事件处理程序名称属性。 该方法检查页上的控件是否具有其各自<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性值设置为`admin`，并且如果是这样，则返回`true`，这意味着它们将被授权并添加到页面。  
  
> [!NOTE]
>  请注意，控件不具有任何值分配给<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性还将添加，因为它们都被认为不是筛选方案的一部分。 此操作可能是筛选方案中常用的方法： 将筛选某些控件，并且其他人不会因为其假定为可供所有用户。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 设置角色中的用户不在本主题的范围，因为此代码示例将不会检查中筛选的用户角色。 但是，筛选控件根据用户角色的方案是，可能需要此筛选功能的最常见用途之一。 如果角色对你的站点，并且你想要检查此方法以筛选控件中的用户角色，该方法类似于下面的代码块 （而不是在前面的代码示例不使用角色更简单的方法）。  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> 事件以指示已加载页及其控件，并且已激活页上的连接，可以开始共享数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A>方法引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>页面完成加载过程后的事件。 该方法提供了一种添加事件的处理程序方法。  
  
 页开发人员可以通过添加添加自定义事件处理程序`OnConnectionsActivated`属性设为`<asp:webpartmanager>`页，然后将自定义的方法名称分配到的属性中的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>开发人员可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />方法在派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> 事件以指示已加载页及其控件，可以开始激活连接的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>方法引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>事件，开发人员提供一种机制，用于以编程方式自定义激活连接的过程。  
  
 页开发人员可以通过添加添加自定义事件处理程序`OnConnectionsActivating`属性设为`<asp:webpartmanager>`页，然后将自定义的方法名称分配到的属性中的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>开发人员可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />方法在派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />，包含与更改后的显示模式相关联的事件数据。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> 事件，以指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件在网页上已完成从一种显示模式切换到另一种显示模式的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A>其基类中的方法形成只引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>您可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />方法。 例如，在更改之后的显示模式，你可能想要更改中的用户界面 (UI)，具体取决于哪些显示模式中包含的外观的某些内容<see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" />属性。 或者，你可能想要隐藏某些内容，或显示某个控件。  
  
 当你重写方法时，你应通常调用基方法重写的方法的最后一步骤，以便自定义代码先运行，并且上一次，引发该事件，该值指示模式更改为完整。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">一个 <see cref="T:System.EventArgs" />，包含与正在更改的显示模式相关联的事件数据。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> 事件，以指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件在网页上正处于从一种显示模式切换到另一种显示模式的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>其基类中的方法形成只引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>您可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />方法。 例如，当正在更改时的显示模式，你可能想要检查将哪些的新显示模式 (通过使用<see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" />属性) 和更改新的显示模式将基于的用户界面 (UI) 中的某些内容。 如果你的自定义显示模式，你可能想要使某些控件在自定义模式即将成为新的显示模式的情况下可见。  
  
 当你重写此方法时，你应通常调用基方法重写的方法的第一步以便引发事件以指示正在启动的显示模式更改。 然后，自定义代码可以更改在用户界面 (UI) 之前实际显示新的显示模式。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.Init" /> 事件，该事件是 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件生命周期中的第一个事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A>方法调用基方法，将引发<xref:System.Web.UI.Control.Init>控件，然后执行几个预备步骤，如确保只有一个实例的事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件在页中，并加载个性化数据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">页上还有另一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.PreRender" /> 事件，该事件恰好在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件被呈现在网页上之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A>方法调用基方法，将引发<xref:System.Web.UI.Control.PreRender>事件控件，然后注册了多个包含 Web 部件的页所需的客户端脚本控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> 事件，该事件在新选择了某个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件或清除对它的选择之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>事件，这通常是在开发人员可能希望更改用户界面 (UI) 的外观的时间点。 例如，当新<xref:System.Web.UI.WebControls.WebParts.WebPart>控件被选定，Web 部件控件集更改新选择的控件的呈现。 清除控件的选择之后，呈现返回到正常。  
  
 在用户选择特定<xref:System.Web.UI.WebControls.WebParts.WebPart>控件以供编辑，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>调用方法。 当用户完成编辑控件，并将其关闭，清除了控件的选择，结果<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>再次调用方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>有几个选项与相关<see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />事件，可以使开发人员自定义更改所选的控件后发生的呈现。 在声明性代码中，在<see langword="&lt;asp:webpartmanager&gt;" />元素无法设置<see langword="OnSelectedWebPartChanged" />属性，并为其分配自定义方法的名称。 在事件发生时，在自定义的方法中，你可以修改所选控件的呈现。 另一个选项是继承自<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类并重写此方法。 第三个选项是自定义在区域级别; 呈现例如，你可以从继承<see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" />类，并重写其<see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />方法，以自定义控件选中和清除编辑过程的呈现。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" /> 事件，该事件在更改当前选择的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>事件，更改其中的过程中发生<xref:System.Web.UI.WebControls.WebParts.WebPart>当前选中控件。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件使用此方法，而且关联的事件，以提供取消进程在其中更改所选的控件的机会。 例如，在调用该方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法，并还在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>方法，以提供一种方法来取消该过程。 如果用户单击正在编辑的控件上的取消谓词，该控件不再处于选中状态和未保存编辑的任何更改，因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法使它能够取消编辑的更改。  
  
> [!NOTE]
>  期间的开始和结束连接的过程的方法同样调用方法<xref:System.Web.UI.WebControls.WebParts.WebPart>到另一个控件，以便取消该进程的控件。  
  
 页开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>通过添加事件`OnSelectedWebPartChanging`属性设为`<asp:webpartmanager>`中声明性页面标记，并将自定义方法的名称分配给该属性的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">与控件的移除相关联的事件数据。</param>
        <summary>引发基 <see cref="E:System.Web.UI.Control.Unload" /> 事件，并从网页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件已被添加到某个页之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>期间添加的过程中调用方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (或添加到其他服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域) 到页。  
  
 页开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>通过添加事件`OnWebPartAdded`属性设为 <`asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" /> 事件，该事件将在向 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域添加 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控件（或服务器控件，或用户控件）的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A>方法引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>事件，它指示控件正在添加。 该方法还提供了选项来取消添加过程。 如果成功添加控件，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件遵循。  
  
 页开发人员可以通过添加为关联的事件提供自定义的处理程序`OnWebPartAdding`属性设为`<asp:webpartmanager>`上 Web 页面中，，然后将自定义的方法名称分配给该属性的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>创建派生的开发人员<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />方法以自定义事件处理。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> 事件以表明控件已从页中移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>方法引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件，则指示<xref:System.Web.UI.WebControls.WebParts.WebPart>已在页面上已成功关闭控件 （或其他服务器或用户控件）。  
  
 若要关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件意味着若要删除从页以便不呈现，并且还将其放在一个特殊持有对象调用页目录。 对应于一个页目录<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控制，维护对已关闭的引用<xref:System.Web.UI.WebControls.WebParts.WebPart>为每个页的控件。 如果<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控件声明内的网页<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域，用户可以将页切换到目录的显示模式，并将以前关闭任何控件添加回页面。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>方法使开发人员创建的自定义处理程序有机会<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件。 页开发人员可以通过添加添加自定义事件处理程序`OnWebPartClosed`属性设为`<asp:webpartmanager>`页，然后将自定义的方法名称分配到的属性中的元素。 开发人员可能在此方法中执行的一个有用的任务是显示在已关闭的控件的位置的占位符，完成与工具提示将告知用户如何将控件添加回页面。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" /> 事件，该事件将在从页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A>方法引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件来指示控制正在被关闭或从页中移除。 该方法还提供了选项来取消关闭进程。 如果控件已成功移除从页中，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件遵循。  
  
 页开发人员可以通过添加为关联的事件提供自定义的处理程序`OnWebPartClosinging`属性设为`<asp:webpartmanager>`上 Web 页面中，，然后将自定义的方法名称分配给该属性的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>创建派生的开发人员<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />方法以自定义事件处理。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" /> 事件，该事件在从页中永久删除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>在删除过程中调用方法<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (或添加到其他服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域) 从一个页面。  
  
 页开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>通过添加事件`OnWebPartDeleted`属性设为 <`asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" /> 事件，该事件指示动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域中包含的服务器控件或用户控件）正处于被删除的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅动态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件可以被删除，并且当删除控件时，控件实例从页面中永久删除，无法还原。 动态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件是指那些以编程方式，添加或从 Web 部件目录，而不是静态控件中声明的网页上的标记。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A>方法引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>事件来指示，从其区域永久删除控件。 该方法还提供了机会取消删除过程。 如果控件已成功删除从页中，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件遵循。  
  
 页开发人员可以通过添加为关联的事件提供自定义的处理程序`OnWebPartDeleting`属性设为`<asp:webpartmanager>`上 Web 页面中，，然后将自定义的方法名称分配给该属性的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>创建派生的开发人员<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />方法以自定义事件处理。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件已被移动到页上的不同位置之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>方法引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件在最后的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法，可确保移动控件的过程完成之前的任何代码在事件处理程序将运行。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>在其当前的区域内或另一个区域，在移动控件和是否移动是以编程方式或通过用户拖动控件并不重要时引发事件。  
  
 页开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>通过添加事件`OnWebPartMoved`属性设为 <`asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" /> 事件，该事件指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />、服务器控件或用户控件正处于移动过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>方法引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>事件发生时<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他服务器控件将被移到另一个区域或其区域。 该方法还提供了取消移动过程的机会。 如果移动已成功完成，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件遵循。  
  
 页开发人员可以通过添加为关联的事件提供自定义的处理程序`OnWebPartMoving`属性设为`<asp:webpartmanager>`上 Web 页面中，，然后将自定义的方法名称分配给该属性的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>创建派生的开发人员<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />方法以自定义事件处理。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之间建立了连接之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A>方法将引发其对应的事件在最后的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法，这样可以确保事件处理程序中的任何代码运行之前完成连接两个控件所必需的步骤。  
  
 该方法提供了对创建连接的过程进行编程控制和关联的事件是在该处若要更新的用户界面 (UI) 或通知用户已建立的连接的方便的点。  
  
 页开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>通过添加事件`OnWebPartsConnected`属性设为 <`asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" /> 事件，该事件发生于在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域内包含的两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或服务器控件或用户控件之间建立连接的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A>方法引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>事件，发生在两个控件尝试建立连接。 该方法提供了机会取消连接尝试。 如果连接成功，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件遵循。  
  
 页开发人员可以通过添加为关联的事件提供自定义的处理程序`OnWebPartsConnecting`属性设为`<asp:webpartmanager>`上 Web 页面中，，然后将自定义的方法名称分配给该属性的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>创建派生的开发人员<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />方法以自定义事件处理。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之间的连接已终止之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A>方法将引发其对应的事件在最后的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法，该终止两个控件之间的连接的过程所执行方法。  
  
 该方法提供了对结束连接的过程进行编程控制，以便开发人员可以通知用户，对用户界面 (UI)，进行更改或对应用程序进行其他更改。  
  
 页开发人员可以创建自定义处理程序<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>通过添加事件`OnWebPartsDisconnected`属性设为 <`asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" /> 事件，该事件指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中的两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或服务器控件或用户控件正处于结束连接的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A>方法引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件，发生在两个控件正在结束连接。 该方法提供了机会取消断开连接过程。 如果连接成功移除，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>事件遵循。  
  
 页开发人员可以通过添加为关联的事件提供自定义的处理程序`OnWebPartsDisconnecting`属性设为`<asp:webpartmanager>`上 Web 页面中，，然后将自定义的方法名称分配给该属性的元素。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>创建派生的开发人员<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />方法以自定义事件处理。</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对包含网页个性化设置数据的对象的引用。</summary>
        <value>包含个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性使您能够访问<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>与通过页关联的对象<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 使用此属性，可访问的个性化设置对象的各种成员。 例如，你可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>方法切换页面的个性化设置范围从共享到用户作用域，反之亦然。 你还可找到出当前的个性化设置范围的页上，是否启用了个性化设置甚至在页上的提供程序用于个性化数据时，和的详细信息。  
  
 请注意，数据引用的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性是仅将跟踪的页面级别个性化数据<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 特定于控件的个性化数据，如可个性化设置的属性的值<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，不是属于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性。  
  
> [!NOTE]
>  Web 部件个性化设置的详细信息，请参阅[Web 部件个性化概述](http://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性以编程方式。  
  
 以下网页上，用户可以进入编辑模式，若要编辑的某些方面<xref:System.Web.UI.WebControls.Calendar>控件。 **切换范围**按钮页切换到用户或共享个性化设置作用域。 **编辑模式**和**浏览模式**按钮每个页切换到适当的显示模式。 请注意，在`<script>`标记文件中，两个方法，用于处理事件的使用部分<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性来访问基础对象的有用成员。 具体而言，这些方法使用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>方法和<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A>通过访问的对象属性<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 若要运行的代码示例，你还必须允许用户共享的作用域中的页进行个性化设置。 将条目添加到 Web.config 文件中，可在`<system.web>`部分，如下所示的以下标记。  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 加载浏览器中后，单击**切换范围**按钮，然后请注意，页现在显示在共享范围。 单击**编辑模式**要更改的显示模式，请单击上可见的控件的谓词菜单并选择**编辑**从菜单。 请注意，这两个编辑控件的用户界面 (UI) 显示。 现在，请单击**浏览模式**以返回到正常浏览。 如果页面显示在共享的范围内，单击**切换范围**再次以确保该页是用户作用域中。 接下来，请按照相同的步骤来再次编辑控件，但请注意，现在在编辑 UI，<xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart>控件未出现。 这是因为当页位于共享个性化设置范围中时，此控件才有效。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件能够发出用于各种个性化设置功能（例如，在网页中拖动 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件）的客户端脚本。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">一个 <see cref="T:System.Web.UI.HtmlTextWriter" />，它接收控件的内容以写入页。</param>
        <summary>重写以防止 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件呈现任何内容。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的状态数据，以便在将来请求包含该控件的网页时可以还原这些数据。</summary>
        <returns>一个 <see cref="T:System.Object" />，它包含控件的已保存的状态数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>方法保存应保持在页回发期间的属性的状态数据，即使<xref:System.Web.UI.Control.EnableViewState%2A>属性设置为`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，它包含要加载的状态数据。</param>
        <summary>保存由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件维护的自定义个性化设置状态数据，以便重新加载该页时可以重新加载此数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>方法过程至关重要个性化设置，因为它允许个性化的用户设置，以供将来的浏览器会话存储并访问到页。 该方法保存自定义个性化设置状态数据，其中包括以下各项： 动态<xref:System.Web.UI.WebControls.WebParts.WebPart>或已添加到页或从一个页; 已移页; 的控件，并且具有的动态连接中删除的服务器控件已创建或删除。  
  
 不能在代码中直接调用此方法。 但是，可以调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>方法，其自身调用此方法以保存个性化数据。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>开发人员可以重写此方法在派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类自定义保存个性化数据的过程。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对当前选择的用于编辑或用于创建与另一个控件的连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件的引用。</summary>
        <value>当前选择的用于编辑或建立连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>属性返回的引用<xref:System.Web.UI.WebControls.WebParts.WebPart>或进行编辑或创建与另一个控件的连接当前所选其他服务器控件。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件提供了几个有用的方法和事件处理过程中选择一个控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>刚才所选控件后，但在进行任何更改之前发生的事件。 若要发动控件上的某些操作，它在选定后，重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。 例如，你可能想要更改的控件选择但尚未，未更改以直观地强调所选控件的外观。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>事件发生后已更改所选的控件。 若要更改后对其执行在控件上的某些操作，请重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在对一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的选择已经发生更改并被移动到网页上的另一个控件之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以结合使用此事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法可以更改选定控件的用户界面 (UI)。 例如，如果用户将页切换到设计模式下 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>)，然后选择<xref:System.Web.UI.WebControls.WebParts.WebPart>控件拖到新位置的意图，与很常见的呈现所选的控件，例如通过更改来更改的颜色其边框或背景处于选定状态时。  
  
> [!NOTE]
>  有关使用事件的详细信息，请参阅[如何： 在 Web 窗体应用程序中使用事件](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在更改网页上 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件当前的选定状态的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以结合使用此事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。 页开发人员可以通过添加在代码中创建事件处理程序`OnSelectedWebPartChanging`属性设为`<asp:webpartmanager>`页上，并将该属性的值设置为自定义方法的名称中的元素将处理该事件。  
  
 在开始或结束之间控件，并开始和结束时间的编辑控件的连接的过程中，将引发此事件。 有关详细信息，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。  
  
 通常，当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>作为更改所选的控件的用户的操作的直接结果引发事件，可以取消该事件。 但是，没有事件不能在其中被取消的方案。 如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>中删除控件，<xref:System.Web.UI.WebControls.WebParts.WebPart>它包含的控件必须先结束所有，否则它们将被孤立。 在这种情况下<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 不用户，它必须确定当前选定哪个控件，以及何时更改而无需中断，不可能选择，以便它可以完成清除过程所有控件。 因此，根据设计<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>方法不能在此情况下取消。 可以取消的相关事件，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>设置一个标志，该标志指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的自定义个性化设置数据已更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>方法设置的个性化组件最终导致的 Web 部件控件集，以保存更新的个性化设置数据的标志。 有关详细信息可能会导致更改跟踪的个性化设置数据的方案<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>方法不能在代码中直接调用并不能重写，因为它在内部使用由 Web 部件控件集作为 Web 部件个性化功能的一部分。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>可以调用该方法由派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类。 这会很有用，如果你想要自定义组件的 Web 部件控件集并因此需要控制设置标志个性化数据的过程个性化设置。</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">已被选择的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</param>
        <summary>将 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 属性值设置为等于当前选定的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A>期间的开始或结束编辑指定的控件的进程调用方法`webPart`参数，并且那些开头或结尾包括连接`webPart`。  
  
 在编辑和连接过程中，开头`webPart`是以进行编辑，或输入连接已选择的控件。  
  
 在编辑和连接过程中，末尾`null`传递给<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A>方法，这会导致当前所选控件不再被选定。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个空字符串 ("")，使 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件不能应用任何外观。</summary>
        <value>一个空字符串，该字符串防止 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件使用指定给它的外观。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>属性重写继承<xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType>属性可避免<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件，这是不可见的控件中，从使用外观。 属性的实现可以防止外观通过始终返回空字符串从指定`get`访问器，并始终引发异常，尝试在中设置一个值是否`set`访问器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">尝试设置该属性值。</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上所有定义为静态连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 对象的集合的引用。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />，包含页上的所有静态连接。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>属性由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件来跟踪和管理页上的所有静态连接。 静态连接，与动态连接，相比不必添加到页面中，每次呈现页面。  
  
 此属性所引用的集合包含是否以编程方式创建或使用指定的页，存在的所有静态连接`<asp:webpartconnection>`页面的标记中的元素。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>属性。  
  
 下面的代码示例包含四个部分：  
  
-   一个用户控件，使你能够更改 Web 部件页面上的显示模式。  
  
-   源代码文件包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口。  
  
-   包含两个自定义网页<xref:System.Web.UI.WebControls.WebParts.WebPart>可连接控件和`<asp:webpartmanager>`元素。  
  
-   该示例在浏览器中的工作原理说明。  
  
 下面的代码包含示例的网页部分。 你还需要从示例部分获取例子-自定义用户控件和自定义控件和接口的源代码的前两个部分<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 该主题还介绍了用于编译选项<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
 下面的代码示例的第三部分是网页。 页的声明性标记包含`Register`为用户控制和自定义控件的指令。 没有`<asp:webpartmanager>`元素，`<asp:webpartzone>`元素以包含自定义控件和`<asp:connectionszone>`元素。 请注意，在`Page_Load`方法，代码将检查来查看是否连接已存在并且，如果不是，定义提供程序、 一个使用者和它们各自的连接点，并且然后将新的连接添加到的一套所引用的静态连接<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 你已加载浏览器中的 Web 页后，单击**显示模式**下拉列表控件，然后选择**连接**切换页后，可以连接模式。 连接模式使用`<asp:connectionszone>`元素以启用你创建控件之间的连接。 在连接模式中，单击标题栏中的向下箭头**邮政编码**控件来激活其谓词菜单中，，然后单击**连接**。 显示连接用户界面 (UI) 后，请注意，已由中包含的代码创建连接时`Page_Load`方法。 如果在更高版本的浏览器会话中返回此页，此静态连接将已建立，并且将不需要重新创建每次加载页面。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取特定网页上所有可用显示模式的只读集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含特定网页上的可用 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性包含实际可用在页中，给定的类型的页上存在的区域控件的显示模式。  
  
> [!NOTE]
>  可以禁用显示模式，并且当禁用的显示模式时，未添加到<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>集合，即使该显示模式支持的区域的对应类型是在页上存在。  
  
 始终支持浏览模式和设计模式。 而异的显示模式是编辑、 目录和连接模式。 其中每个显示模式是与特定类型的关联<xref:System.Web.UI.WebControls.WebParts.ToolZone>控件。 它是该特定类型的区域，在网页上导致一个要添加到所引用的集合的特定显示模式存在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。 例如，如果 Web 页包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>但不是区域<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域，然后编辑显示模式是一个受支持的模式，在该页上，但不是支持的目录的显示模式。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性不同于<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>属性，引用的集合包含与当前可用的所有显示模式<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制，甚至那些不支持的特定页。  
  
   
  
## Examples  
 下面的代码示例演示了以编程方式利用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。 代码使用此属性来填充仅显示可用的模式在当前网页的列表。  
  
 有三种受支持此页上的显示模式： 浏览、 设计和编辑。 前两个始终可用，并且编辑模式是在此代码示例中可用，因为该页包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>控件。 目录和连接模式不在显示时，显示，因为它们的相应区域不在此页上。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 加载浏览器中后，你可以使用下拉列表控件切换到设计模式，来自浏览模式的页，然后编辑模式。 在编辑模式下，你可以单击每个服务器控件的标头中的下拉列表谓词菜单并选择**编辑**编辑该控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件管理的自定义个性化设置状态数据是否已在网页上更改。</summary>
        <value>一个布尔值，指示个性化设置状态数据是否已更改。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性提供一种方法，以便调用方确定个性化状态由管理的数据是否<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制已更改。 当用户个性化页级别的详细信息，例如通过更改页面布局、 创建或删除连接，并添加或删除控件，个性化数据由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制更改。 这是受保护的值返回到调用方传递方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>属性，无法由调用方直接访问该属性。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性不指示是否可个性化属性值或影响外观的个人的单独属性<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，已更改。 控制级别个性化会单独跟踪的每个控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性指示仅个性化数据，在页级别上是由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制已更改。  
  
 以下列表描述了个性化的会导致某些常见实例<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性返回的值`true`，以指示，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件具有某些更改的个性化数据：  
  
-   关闭一个静态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 （或服务器或用户控件） 在页面上。  
  
-   还原已关闭的静态<xref:System.Web.UI.WebControls.WebParts.WebPart>从页目录回页的控件。  
  
-   将在其区域内或向另一个区域移动任何控件。  
  
-   将控件添加的目录从<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件，或以编程方式添加控件。  
  
-   创建两个连接<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，以编程方式或通过使用连接用户界面 (UI)。  
  
-   删除两个连接<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，以编程方式或通过使用连接用户界面。  
  
 若要访问此属性的值，必须强制转换<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件实例与<xref:System.Web.UI.WebControls.WebParts.IPersonalizable>接口; 你可以然后读取<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A>属性值。  
  
   
  
## Examples  
 下面的代码示例演示的简单用法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性，以指示某些常见的页个性化实例导致<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的个性化设置数据更改。  
  
 下面的代码示例包含四个部分：  
  
-   一个用户控件，可以更改包含 Web 部件控件的页面上的显示模式。  
  
-   包含两个自定义代码的源文件<xref:System.Web.UI.WebControls.WebParts.WebPart>可连接控件和接口。  
  
-   承载所有控件的网页。  
  
-   下面的代码示例的工作原理的说明。  
  
 下面的代码示例的第一部分是用于更改显示模式的用户控件。 你可以从示例部分中获取该用户控件的源代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述。 有关显示模式和用户控件的工作原理的信息，请参阅[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 该示例的第二部分是使用自定义控件和接口的源文件。 请注意，`IZipCode`接口公开一个方法，并且作为此方法实现在自定义的`ZipCodeWebPart`控件用作回调方法以启用`ZipCodeWebPart`充当连接方案中的提供程序。 另一个控件， `WeatherWebPart`，连接中充当使用者控制; 它可以使用提供的特定界面`ZipCodeWebPart`。 在实际应用中，`WeatherWebPart`无法使用提供程序，从一个个性化的邮政编码值，然后向用户提供图形天气信息。  
  
 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译;因此，请注意，`Register`指令以在 Web 页的顶部此组件只包含`TagPrefix`和`Namespace`属性，而不`Assembly`属性。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第三部分是网页。 请注意，它包含两个<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域，其中包含两个自定义第一个<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 此外，还有<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域，其中包含一种标准<xref:System.Web.UI.WebControls.Calendar>用户可添加到页面的控件。 `<asp:connectionszone>`元素提供一个连接的用户控件之间创建连接的用户界面。 在`Page_PreRender`方法，请注意，它会检查以查看是否个性化数据已更改，如果出现这种情况，将更新的文本`Label1`。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 加载浏览器中后，尝试创建的某些方案将更改个性化数据本主题的备注部分中列出。 当更改涉及跟踪的个性化设置方案之一时进行各种更改时<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制的文本`Label1`显示控件以指示已更改个性化数据。 例如，你可以：  
  
-   通过单击控件之间创建连接**连接 web 部件控件**按钮。  
  
-   使用**显示模式**下拉列表控件，以将页切换到目录模式，并添加**我的日历**控件添加到第二个<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域。  
  
-   更改页更改要浏览模式，请单击 （显示具有标题栏中的箭头符号） 的谓词菜单的**我的日历**控件，并选择**关闭**关闭它并将其添加到页目录。  
  
-   使页返回到目录模式，并添加**我的日历**回页的控件。  
  
-   使用**显示模式**控件将页切换到设计模式，并通过将一个或多个拖到另一个区域，或在同一区域中的不同位置重新排列控件的布局。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，它包含要加载的状态数据。</param>
        <summary>返回先前保存的需要加载到 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的自定义个性化状态数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是实现的<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType>方法，为 Web 部件控件集直接访问受保护提供了一种方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType>方法。 当调用此方法时，它将存储由自定义个性化的数据<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件，并且以前保存更高版本在初始化过程中使用的永久性的数据存储中。  
  
> [!NOTE]
>  在大多数情况下，页和控件开发人员代码不必调用此方法，因为主要由 Web 部件控件集用作检索个性化设置数据的机制。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>开发人员将在其中使用此方法的一种情况是如果他们正在开发一个自定义个性化框架，以代替其中一个提供由 Web 部件控件集。 在这种情况下，开发人员无法从此继承<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类并重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />方法返回的自定义实现<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />对象。 自定义<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />对象将调用的实现<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />方法在适当的时间来加载自定义个性化数据。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，包含待保存的状态数据。</param>
        <summary>保存由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件管理的自定义个性化设置状态数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>方法是实现的<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType>方法，为 Web 部件控件集直接访问受保护提供了一种方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType>方法。 当调用此方法时，它将保存由管理的所有个人的数据<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件添加到为 Web 部件应用程序配置的永久性的数据存储。  
  
> [!NOTE]
>  在大多数情况下，页和控件开发人员代码不必调用此方法，因为主要由 Web 部件控件集用作保存个性化设置数据的机制。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>开发人员将在其中使用此方法的一种情况是如果他们正在开发一个自定义个性化框架，以代替其中一个提供由 Web 部件控件集。 在这种情况下，开发人员无法从此继承<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类并重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />方法返回的自定义实现<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />对象。 自定义<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />对象将调用的实现<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />方法在适当的时间来保存自定义个性化数据。</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将个性化设置状态数据应用到 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件，调用基方法以便能够跟踪对控件视图状态数据的更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对视图状态数据的更改存储在<xref:System.Web.UI.StateBag>对象，并可通过该控件的访问<xref:System.Web.UI.Control.ViewState%2A>属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值可使子控件可见。</summary>
        <value>一个布尔值，指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件及其子控件是否可见。 在所有情况下均为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件重写基<xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType>属性始终返回的值`true`为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>属性。 即使<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件本身不可见，请<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>属性应设置为`true`，以便其所有子控件都都默认情况下可见。  
  
 如果你尝试设置的值<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>属性，它始终生成错误，因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件已重写基属性行为，并防止将任何值分配给属性。  
  
 此属性在可视化设计器，可绑定并非是可在运行时绑定。 有关详情，请参阅<xref:System.ComponentModel.BindableAttribute>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">尝试向该属性指定一个值。</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件已被添加到 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域之后发生，以指示已成功添加了控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件非常有用，该值指示动态控件 （而不是正在中的页标记声明，以编程方式添加控件） 已成功添加到区域。 结合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>方法，该事件提供了开发人员提供一种方法来更新用户界面 (UI) 或通知用户已成功添加控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在向 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域添加动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他服务器控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>事件由引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A>方法后将控件添加到区域的过程已开始。 此事件提供了机会在完成之前取消过程。 如果添加过程成功，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件。  
  
 页开发人员可以通过添加为事件提供自定义处理程序`OnWebPartAdding`属性设为`<asp:webpartmanager>`页上，并将自定义的方法名称分配给该属性中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当从页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或服务器控件，或用户控件）时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件指示，控件已成功关闭，由用户或以编程方式。 若要关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件意味着若要删除从页以便不呈现，并且还将其放在一个特殊持有对象调用页目录。 对应于一个页目录<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控制，维护对已关闭的引用<xref:System.Web.UI.WebControls.WebParts.WebPart>为每个页的控件。 如果<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控件声明内的网页<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域，用户可以将页切换到目录的显示模式，并将以前关闭任何控件添加回页面。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>与关联事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>方法，它同时引发事件，并为其提供一个处理程序。  
  
 页开发人员可以通过添加添加自定义事件处理程序`OnWebPartClosed`属性设为`<asp:webpartmanager>`页，然后将自定义的方法名称分配到的属性中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在从页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或服务器控件，或用户控件）的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件由引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A>方法时<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件正在关闭一个控件。 如果该控件的删除操作成功，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件。  
  
 页开发人员可以通过添加为事件提供自定义处理程序`OnWebPartClosed`属性设为 <`asp:webpartmanager>`页上，并将自定义的方法名称分配给该属性中的元素。  
  
 通常，当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>作为用户结束的直接结果引发事件<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，可以取消该事件。 但是，没有事件不能在其中被取消的方案。 如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>中删除控件，<xref:System.Web.UI.WebControls.WebParts.WebPart>它包含的控件必须先结束所有，否则它们将被孤立。 在这种情况下<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，不是用户。 以及何时<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件正在调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法来关闭每个控件，与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>引发事件，事件不能被取消 （按照设计），因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>需要完成的清理任务所有区域的控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件已从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域删除之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件非常有用，该值指示动态控件 （而不是正在中的页标记声明，以编程方式添加控件） 已成功删除从区域。 结合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>方法，该事件提供了开发人员提供一种方法来更新用户界面 (UI) 或通知用户已成功删除控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中永久删除动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他服务器控件的实例的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>事件由引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A>方法，在删除动态控件 （通过编程方式或通过 Web 部件用户界面的用户已添加的控件） 的过程。 事件提供了机会在它完成之前取消过程。 如果成功完成删除过程，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件。  
  
 页开发人员可以通过添加为事件提供自定义处理程序`OnWebPartDeleting`属性设为`<asp:webpartmanager>`页上，并将自定义的方法名称分配给该属性中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件已被移动到网页上的不同位置之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件同时适用于静态 （在网页上的标记中声明） 和动态控件。 与之关联<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>方法。 因为引发事件时完成移动后，开发人员可以包含事件处理程序来提供某些通知提供给用户、 一些验证或某些其他操作。 若要添加事件处理程序，你可以添加`OnWebPartMoved`属性设为`<asp:webpartmanager>`页上，并将赋给特性的自定义方法的名称中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在移动 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中包含的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他服务器控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>引发事件时<xref:System.Web.UI.WebControls.WebParts.WebPart>或在其自己的区域内或另一个区域，将被移其他服务器控件。 当用户拖动控件，或以编程方式移动时，则可以发生此情况。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>事件由引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>方法，并提供机会在完成之前取消移动的过程。 如果移动已完成，控件已放置在新位置，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件。  
  
 页开发人员可以创建自定义事件处理程序，通过添加`OnWebPartMoving`属性设为`<asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件所跟踪的所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的引用。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" />，包含对一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件跟踪所有<xref:System.Web.UI.WebControls.WebParts.WebPart>中包含的控件<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>页上的区域。 尽管该集合是只读的你可以访问单个<xref:System.Web.UI.WebControls.WebParts.WebPart>以编程方式控制通过对它们的集合并进行更改。  
  
> [!NOTE]
>  可以具有<xref:System.Web.UI.WebControls.WebParts.WebPart>控件将外部的页面上放置<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域，这会导致控件未跟踪<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制或中引用其<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>集合。 但是，很少使用<xref:System.Web.UI.WebControls.WebParts.WebPart>管理区域，之外，因为它然后丢失其 Web 部件功能并作为正常的服务器控件。  
  
 任何类型的控件，无论是自定义可以放置在区域中，<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 标准 ASP.NET 控件、 一个用户控件或自定义服务器控件，可以被视为<xref:System.Web.UI.WebControls.WebParts.WebPart>控件在运行时。 不是控件时<xref:System.Web.UI.WebControls.WebParts.WebPart>控件放入<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域，在 ASP.NET 包装控件的运行时<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象，以便控件可以具有的行为与真正<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 因此，通过使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性，<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件可以跟踪任何类型的服务器控件，无论它派生自<xref:System.Web.UI.WebControls.WebParts.WebPart>类。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性以编程方式来访问各<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 请注意，在 Web 页中，声明性标记内`<asp:webpartzone>`元素中，有是两个标准的 ASP.NET 服务器控件。 虽然这些不是继承自<xref:System.Web.UI.WebControls.WebParts.WebPart>类，因为它们处于它们将自动换行与区域<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象在运行时，并因此将包含所引用的集合在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性。 您也可以添加自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、 用户控件或自定义服务器控制在此区域中，并且它们将进行处理相同的方式。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 请注意，为代码的示例正常工作，必须添加的设置在 Web.config 文件，以使导出 Web 部件描述文件中。 确保你有此代码示例为 Web 页相同的目录中的 Web.config 文件。 在`<system.web>`部分中，请确保有`<webParts>`具有元素`enableExport`属性设置为`true`，如下所示的以下标记。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 如果您单击将页加载到浏览器中之后, **web 部件计数**按钮，该代码使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性以返回集合中的控件的计数。 如果你单击**隐藏日历标题**按钮，代码将日历更改，以便带仅边框和标题不呈现。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或者服务器或用户控件）之间已建立特定连接之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>与关联事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A>方法。 此事件非常有用，因为你知道连接已完成后，你可能想要通知的事实，用户或甚至更改页面的用户界面 (UI)。 例如，你可能想要显示某个提供两个控件之间的成功连接的建议的图形图像或显示简要的消息，，然后在各个页面显示模式回浏览模式。  
  
 页开发人员可以通过添加与此事件关联的自定义事件处理程序`OnWebPartsConnected`属性设为`<asp:webpartmanager>`页上，并将自定义的方法名称分配给该属性中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在创建 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或放置在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域中的服务器控件或用户控件）之间的连接的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>事件由引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A>方法，并且它表明连接过程已开始 （例如，用户已选择了某个控件并单击连接谓词），但尚未完成。 事件提供了机会在完成之前取消连接。 如果连接成功完成，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件。  
  
 页开发人员可以通过添加添加自定义事件处理程序`OnWebPartsConnecting`属性设为`<asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件之间的连接已终止之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>与关联事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A>方法。 此事件非常有用，因为你知道连接终止后，你可能想要通知用户，在代码中，执行某些清除操作或在用户界面 (UI) 中进行其他更改。  
  
 页开发人员可以通过添加与此事件关联的自定义事件处理程序`OnWebPartsDisConnected`属性设为`<asp:webpartmanager>`页上，并将自定义的方法名称分配给该属性中的元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在结束以前连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件之间的连接的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件由引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A>方法，并表明这样的事实用户已单击断开连接的谓词，或<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>否则调用方法。 事件提供了机会取消完成之前结束连接的过程。 如果连接由于成功结束，此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>事件。  
  
 页开发人员可以通过添加添加自定义事件处理程序`OnWebPartsDisconnecting`属性设为`<asp:webpartmanager>`元素，并将自定义的方法名称分配给该属性。  
  
 通常，当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>作为结束连接的用户的操作的直接结果引发事件，可以取消该事件。 但是，有几种应用场景中的事件不能被取消。 第一个方案是，如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>中删除控件，<xref:System.Web.UI.WebControls.WebParts.WebPart>它包含的控件必须先结束所有，否则它们将被孤立。 在这种情况下<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控制关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件，不用户，和它必须还能够以终止绝不会遭受的中断，任何连接的控件的连接，以便它可以完成清理和关闭的过程所有控件。 因此，根据设计<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>方法不能在此情况下取消。 可以取消的相关事件，请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件。  
  
 在其中第二个方案<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件不能被取消时<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>调用方法时 （这在到页中，每个请求过程中例如调用），并且没有某种类型的页上的现有连接中的冲突。 例如，用户可能是连接到控件 y 的控件 x 但控件 x 来控制 z，共享的用户连接和尚未控件 x 不允许进行多个连接。 在这种情况下，连接的每个用户的设置优先，和<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件将解决冲突，通过调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法和结束之间的连接 x 和 z 适用于特定用户。 因为此断开连接是至关重要的设计来解决冲突时，<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件不能在此方案中被取消。  
  
 在其中的第三个方案<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>方法不能取消时<xref:System.Web.UI.WebControls.WebParts.WebPart>或删除或关闭当前连接的服务器控件。 由于控件肯定会从此页中删除，它是逻辑必不可少若要删除其连接的。 因此，当<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件时，将调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法，该方法引发<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件，根据设计是不可能不存在，可取消事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域的集合的引用。</summary>
        <value>引用一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" /> 区域的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>属性由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件跟踪<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>在网页上的区域。 请注意属性不引用所有类型的区域;它引用派生自的区域<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>类，其中包括<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域。  
  
 尽管该属性引用的集合是只读的但可以使用它可以访问集合中的单个对象，并以编程方式使用它们。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>属性以编程方式来访问各<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域控件。 请注意，在声明性 Web 页标记中，有两个`<asp:webpartzone>`每个包含服务器控件的元素。 在`<script>`部分中的页上，代码使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>属性来访问各个区域，列出所有区域的 Id，然后将更改在第二个区域的背景色。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 请注意，为代码的示例正常工作，必须添加的设置在 Web.config 文件，以使导出 Web 部件描述文件中。 确保你有此代码示例为 Web 页相同的目录中的 Web.config 文件。 在`<system.web>`部分中，请确保有`<webParts>`具有元素`enableExport`属性设置为`true`，如下所示的以下标记。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 如果您单击将页加载到浏览器中之后,**列表区域 Id**按钮，该代码使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>属性可以列出集合中的所有区域的 Id。 如果你单击**更改区域 BackColor**按钮，代码将更改第二个区域的背景色。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>