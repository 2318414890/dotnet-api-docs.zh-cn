<Type Name="ConsumerConnectionPoint" FullName="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cb9fefe53ca0dc6efecfbfa06ad64f25a529c339" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30590781" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ConsumerConnectionPoint : System.Web.UI.WebControls.WebParts.ConnectionPoint" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ConsumerConnectionPoint extends System.Web.UI.WebControls.WebParts.ConnectionPoint" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
  <TypeSignature Language="VB.NET" Value="Public Class ConsumerConnectionPoint&#xA;Inherits ConnectionPoint" />
  <TypeSignature Language="C++ CLI" Value="public ref class ConsumerConnectionPoint : System::Web::UI::WebControls::WebParts::ConnectionPoint" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.WebControls.WebParts.ConnectionPoint</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>定义连接点对象，该对象允许服务器控件作为使用者，以建立与提供者的连接。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在两个服务器控件之间的每个 Web 部件连接，每个控件必须具有 （以及其他要求） 关联的连接点对象，使它可连接到另一个控件并可提供或使用数据，具体取决于是否控件指定为提供程序或连接的使用者。 A<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint>对象通常包含控件可以如何连接到另一个控件，它可以共享的数据的类型的详细信息。 对于作为连接中的使用者的控件，其连接点必须是<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象。 Web 部件连接和连接点上的信息，请参阅下面的另请参阅部分中列出的主题。  
  
 若要创建<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象，将需要执行几个步骤：  
  
1.  允许使用者控件引用接口实例。 A<xref:System.Web.UI.WebControls.WebParts.WebPart>或其他服务器控件 (将添加到的服务器任何的控件类型<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域可用) 必须能够使用的特定接口实例的数据。 控件不需要实现接口，;仅提供程序必须实现它。 使用者也可以使用确切的接口类型提供程序提供服务; 如果不是，请<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象可以用于将数据从提供程序的接口类型的使用者理解的类型转换。 启用使用者的典型方法是声明一个私有字段以包含所需的接口类型的引用。  
  
2.  标识一个回调方法。 使用者中的方法必须标识为要与该提供程序建立连接的回调方法。 此方法检索提供程序实现，并将分配它给 （例如） 该私有字段创建第一步中接口的实例。 标识使用者中的回调方法的 Web 部件方法是将添加`ConnectionConsumer`元数据属性 (由定义<xref:System.Web.UI.WebControls.WebParts.ConnectionConsumerAttribute>类) 到接收接口实例的方法。 添加属性后，所需的唯一参数是要使用的使用者连接点的显示名称。 此外可添加可选参数，例如 id。  
  
3.  进程和输出接口实例中的数据。 根据需要对数据执行任何内部处理，然后通常使用者控件将呈现到页的数据。 执行此操作的常用方法是重写控件的<xref:System.Web.UI.Control.OnPreRender%2A>方法。  
  
    > [!NOTE]
    >  在过程中发出同步请求，使用者应请求数据直接从提供程序期间或之后<xref:System.Web.UI.Control.PreRender>事件。 过程的异步请求，如果在呈现过程中，将提供程序的回调方法未调用的任意位置开发人员可以假定已向使用者发送任何数据。  
  
 控件具有已配置为使用者后，该控件可以参与 （假设，提供者控件也配置并且可用） 的连接。 若要创建的网页上的标记的静态声明性的连接，开发人员可以使用`<asp:webpartconnection>`元素。 如果`ConnectionConsumer`标识回叫方法的使用者源代码中的属性指定的 ID 的连接点，则该值必须分配给`ConsumerConnectionPointID`属性中`<asp:webpartconnection>`页面上的元素。 开发人员可能会指定一个使用者连接点的 ID 的原因是在使用者控件中定义的多个连接点。 如果为使用者控件中的使用者连接点不指定 ID，值没有要分配给`ConsumerConnectionPointID`属性页中，因为将使用从获取的默认值创建连接<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.DefaultID>字段。  
  
 若要在代码中创建的连接，开发人员必须创建一个新<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象通过调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>方法并传递到该使用者控件，以及的 ID 或索引定义的 ID<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>使用者控件中的对象。 返回<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象，对使用者控件的引用以及对提供程序控件和相应的引用<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>对象，都传递给<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法来创建一个新<xref:System.Web.UI.WebControls.WebParts.WebPartConnection>对象。  
  
 开发人员可以使用使用者连接点，以声明方式或以编程方式建立连接的一部分，但用户可以与使用者连接点建立连接通过用户界面 (UI) 还进行交互。 如果开发人员声明<xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>控件在网页上，它提供对用户创建连接的运行时用户界面。 如果用户选择提供程序控制通过单击建立连接的起始点作为其连接谓词 （它们还可以选择使用者; 没有任何区别中生成连接），在 UI 中，他们将看到具有的下拉列表控件显示可用使用者连接点 （或如果有多个快照的点） 的名称提供程序可以发送到的数据。 用户必须选择要建立连接的使用者连接点。  
  
 A<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象将直接与一个特定的使用者控件相关联，并将连接的详细信息存储在继承自基类的属性<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint>类。 例如，在继承<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.InterfaceType%2A>属性，使用者连接点保存的界面，它使用的类型。 如果提供程序和连接中的使用者同时了解接口类型，这些控件是兼容并能够建立直接连接。 如果提供程序和使用者不能具有相同的接口类型，它们是不兼容，并且必须使用<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>要转换的提供程序连接点对象<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.InterfaceType%2A>到使用者可以使用的类型的属性。 另一个重要的继承的属性是<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.DisplayName%2A>属性，它提供一个友好名称以显示在 UI 中供用户从中选择的使用者连接点时创建连接。 显示名称是必需的参数，开发人员添加时`ConnectionConsumer`属性设为使用者控件中的回调方法。 继承<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ID%2A>属性也十分有用，因为上述，由于其提供的唯一标识符的使用者连接点的事件中使用者具有多个连接点。 使用者可以有多个<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象定义中，然后在此情况下，当开发人员将添加`ConnectionConsumer`属性到方法时，它们应指定一个要区分每个连接点的 ID 值。 另一个值得注意的继承的属性是<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A>属性，它指示使用者连接点是否可以同时连接到多个提供程序。 此属性值是`false`默认情况下，使用者连接点 (而它默认为`true`提供程序连接点)。  
  
 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>类会将多个唯一的方法添加到成员它继承自<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint>类。 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint.SetObject%2A>方法将调用者自身定义回调方法，以从提供程序检索接口实例。 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint.SupportsConnection%2A>方法返回一个布尔值，该值指示连接点是否能够建立连接，基于关联的使用者控件的当前状态。  
  
   
  
## Examples  
 下面的代码示例演示如何以声明方式创建连接，以编程方式，或通过用户界面，每种情况中都使用使用者连接点的简单。  
  
 该示例包含四个部分：  
  
-   用户控件，使你能够更改 Web 部件页面上显示模式。  
  
-   源接口和两个代码<xref:System.Web.UI.WebControls.WebParts.WebPart>控制充当提供程序和连接的使用者。  
  
-   网页上承载的控件和运行的代码示例。  
  
-   如何运行该示例页的说明。  
  
 此代码示例的第一部分是使用户能够更改在网页上的显示模式的用户控件。 将以下源代码保存到一个.ascx 文件中，将其分配到的文件名称`Src`属性`Register`指令为此用户控件，即托管的 Web 页面顶部附近。 有关详细信息显示在此控件模式和源代码的说明，请参见[演练： 在 Web 部件页面上更改显示模式](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)。  
  
 [!code-aspx-csharp[WebParts_ConnectionPoint_Overview#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_ConnectionPoint_Overview/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_ConnectionPoint_Overview#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_ConnectionPoint_Overview/VB/DisplayModeMenuVB.ascx#6)]  
  
 下面的代码示例的第二部分是接口和控件的源代码。 源文件包含名为一个简单的界面`IZipCode`。 此外，还有<xref:System.Web.UI.WebControls.WebParts.WebPart>类名为`ZipCodeWebPart`，实现接口，并充当提供程序控制。 其他<xref:System.Web.UI.WebControls.WebParts.WebPart>类命名为`WeatherWebPart`，并且它可作为连接的使用者。 此类具有一个名为方法`GetZipCode`获取的实例`IZipCode`从提供者控件的接口。 请注意，此方法作为使用者的连接点方法标记为`ConnectionConsumer`其元数据中的属性。 这是用于标识使用者控件中的连接点方法的机制。  
  
 若要运行的代码示例，必须编译此源代码。 你可以显式编译，并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者，您可以在站点的 App_Code 文件夹中，其中它将动态编译运行时将源代码。 此代码示例使用动态编译。 有关演示如何编译的演练，请参阅[演练： 开发和使用自定义 Web 服务器控件](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_ConnectionPoint_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_ConnectionPoint_Overview/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_ConnectionPoint_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_ConnectionPoint_Overview/VB/ZipCodeComponent.vb#2)]  
  
 下面的代码示例的第三部分是网页。 顶部附近是`Register`指令用于注册构成该连接，自定义控件和用户控件，使用户能够更改显示在页面上的模式。 以声明方式内创建连接本身`<staticconnections>`页面上的元素。 此示例演示创建连接的一种方式-注意`ConsumerConnectionPointID`属性中`<asp:webpartconnection>`元素。 你还可以以编程方式; 创建连接有关执行此操作的代码位于`Button1_Click`方法。 在这种情况下，<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>创建对象，然后传递到创建实际的连接的方法。 是否以声明方式或以编程方式创建连接，连接点必须始终指定与提供程序和使用者。 `Button2_Click`方法访问<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint>对象提供程序和使用者，并将其属性值的一些写入到页中的标签。  
  
 [!code-aspx-csharp[WebParts_ConnectionPoint_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_ConnectionPoint_Overview/CS/connectionPointCS.aspx#1)]
 [!code-aspx-vb[WebParts_ConnectionPoint_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_ConnectionPoint_Overview/VB/connectionPointVB.aspx#1)]  
  
 加载浏览器中后，单击**连接点详细信息**按钮。 显示有关在声明性的连接中建立的提供程序和使用者连接点的信息。 接下来，使用**显示模式**下拉列表控件切换到页连接模式。 上的谓词菜单**ZIP 代码提供程序**<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 （由标题栏中的向下箭头），单击连接谓词。 自动创建用户界面出现，连接`<asp:connectionszone>`页面中声明的控件。 这是另一种创建连接 （通过用户界面），以及前面所述的声明性和编程方法。 单击**断开连接**按钮以终止现有的静态连接。 单击**创建使用者连接**链接。 UI 现在显示一个下拉列表控件，其中列出了使用者连接点的显示名称。 在下拉列表中，选择连接点，然后单击**连接**以完成连接。 接下来，单击**断开连接**试。 单击**动态连接**按钮以编程方式创建连接。 使用**显示模式**控件来返回到浏览模式的页。 单击**连接点详细信息**按钮再次，指示有关的详细信息的使用者连接点对象一次的详细信息。  
  
 此示例已经演示了建立的连接和以下三种方式使用使用者连接点： 网页标记; 中声明静态连接在使用的代码中创建的连接<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象和通过连接 UI 用户创建的连接。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
    <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConsumerConnectionPoint (System.Reflection.MethodInfo callbackMethod, Type interfaceType, Type controlType, string displayName, string id, bool allowsMultipleConnections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.MethodInfo callbackMethod, class System.Type interfaceType, class System.Type controlType, string displayName, string id, bool allowsMultipleConnections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint.#ctor(System.Reflection.MethodInfo,System.Type,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callbackMethod As MethodInfo, interfaceType As Type, controlType As Type, displayName As String, id As String, allowsMultipleConnections As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConsumerConnectionPoint(System::Reflection::MethodInfo ^ callbackMethod, Type ^ interfaceType, Type ^ controlType, System::String ^ displayName, System::String ^ id, bool allowsMultipleConnections);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callbackMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="interfaceType" Type="System.Type" />
        <Parameter Name="controlType" Type="System.Type" />
        <Parameter Name="displayName" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="allowsMultipleConnections" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="callbackMethod">使用者控件中的方法，该方法将接口实例返回给使用者以建立连接。</param>
        <param name="interfaceType">使用者从提供者接收的接口的 <see cref="T:System.Type" />。</param>
        <param name="controlType">使用者连接点所关联的使用者控件的 <see cref="T:System.Type" />。</param>
        <param name="displayName">在连接用户界面 (UI) 中向用户显示的使用者连接点的友好显示名称。</param>
        <param name="id">使用者连接点的唯一标识符。</param>
        <param name="allowsMultipleConnections">一个布尔值，指示使用者连接点是否可同时拥有与提供者的多个连接。</param>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint.%23ctor%2A>构造函数<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>类只需调用基构造函数，传递到它的各种参数，并初始化的基类。  
  
 基类构造函数检查大量的连接点的参数，并可能会引发几个例外。 有关可能的异常的列表，请参阅异常部分。  
  
 你可以调用<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint.%23ctor%2A>构造函数来创建你自己的实例<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>类。 但是，在你所在只需建立的连接并不扩展类的情况下，应调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>方法从提供程序返回连接点对象。  
  
   
  
## Examples  
 下面的代码示例演示如何从派生<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>类来创建自定义提供程序连接点。  
  
 代码示例包含三个部分：  
  
-   包含提供程序的源文件<xref:System.Web.UI.WebControls.WebParts.WebPart>控制，请使用者<xref:System.Web.UI.WebControls.WebParts.WebPart>控制和自定义<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象。  
  
-   承载静态连接中的控件的网页。  
  
-   如何运行此代码示例的说明。  
  
 下面的代码示例的第一部分是提供程序和使用者的源<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>名为的类`TableConsumerConnectionPoint`。 请注意，构造函数的`TableConsumerConnectionPoint`类调用基构造函数，将其传递所需的参数，如参数部分中所示。 此外请注意，在`TableConsumer`类，`SetConnectionInterface`方法指定为连接的回调方法和`ConnectionConsumer`属性声明自定义`TableConsumerConnectionPoint`作为参数。 此示例演示如何创建自定义使用者连接点，然后将其与使用者控件相关联。 此示例假定，时动态编译的源代码，因此应将源代码文件放在 Web 应用程序的 App_Code 子文件夹。  
  
 [!code-csharp[UI.WebControls.WebParts.ProviderConnectionPoint#1](~/samples/snippets/csharp/VS_Snippets_WebNet/UI.WebControls.WebParts.ProviderConnectionPoint/CS/connectionControls.cs#1)]  
  
 下面的代码示例的第二部分是承载在静态 Web 部件连接中的自定义控件的网页。 页的顶部是`Register`指令，用于声明一个前缀和自定义控件的命名空间。 使用声明连接`<asp:webpartconnection>`元素，提供程序和使用者的控件中声明`<asp:webpartzone>`元素。  
  
 [!code-aspx-csharp[UI.WebControls.WebParts.ProviderConnectionPoint#3](~/samples/snippets/csharp/VS_Snippets_WebNet/UI.WebControls.WebParts.ProviderConnectionPoint/CS/defaultcs.aspx#3)]  
  
 加载浏览器中的页。 已在控件之间的连接存在，并且使用者显示的数据从提供程序，因为连接被声明为页中的静态连接。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callbackMethod" /> 为 <see langword="null" />。  
  
 \- 或 -  
  
 <paramref name="interfaceType" /> 为 <see langword="null" />。  
  
 \- 或 -  
  
 <paramref name="controlType" /> 为 <see langword="null" />。  
  
 \- 或 -  
  
 <paramref name="displayName" /> 为 <see langword="null" /> 或空字符串 ("")。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="controlType" /> 与使用者控件（或从使用者控件派生的有效类）的类型不同。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="SetObject">
      <MemberSignature Language="C#" Value="public virtual void SetObject (System.Web.UI.Control control, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetObject(class System.Web.UI.Control control, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint.SetObject(System.Web.UI.Control,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetObject(System::Web::UI::Control ^ control, System::Object ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="control">与使用者连接点相关联的使用者控件。</param>
        <param name="data">从提供者控件返回的接口实例。</param>
        <summary>调用使用者控件中的回调方法，并从提供者控件检索接口实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法从提供程序包含数据的使用者控件接收接口实例。  
  
 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint.SetObject%2A>方法由调用<xref:System.Web.UI.WebControls.WebParts.WebPartConnection>对象时连接正在激活。 这是一个是初始化的连接和启用共享数据的两个控件的一部分的关键步骤。  
  
 连接中的使用者控件必须能够使用相同类型的接口作为提供程序。 如果不存在，会不兼容的控件和<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象必须用于建立连接。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="SupportsConnection">
      <MemberSignature Language="C#" Value="public virtual bool SupportsConnection (System.Web.UI.Control control, System.Web.UI.WebControls.WebParts.ConnectionInterfaceCollection secondaryInterfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SupportsConnection(class System.Web.UI.Control control, class System.Web.UI.WebControls.WebParts.ConnectionInterfaceCollection secondaryInterfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint.SupportsConnection(System.Web.UI.Control,System.Web.UI.WebControls.WebParts.ConnectionInterfaceCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool SupportsConnection(System::Web::UI::Control ^ control, System::Web::UI::WebControls::WebParts::ConnectionInterfaceCollection ^ secondaryInterfaces);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="secondaryInterfaces" Type="System.Web.UI.WebControls.WebParts.ConnectionInterfaceCollection" />
      </Parameters>
      <Docs>
        <param name="control">与 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> 相关联的使用者控件。</param>
        <param name="secondaryInterfaces">参与连接的任何辅助接口的 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionInterfaceCollection" />。</param>
        <summary>确定使用者连接点当前能否建立连接。</summary>
        <returns>
          如果连接点当前可建立连接，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint.SupportsConnection%2A>方法的实现始终返回`true`在所有情况下，对于<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>类。 此方法的目的是让该状态检查`control`和`secondaryInterfaces`的某些关键点，以确定是否<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象是目前能够创建的连接。  
  
 可以有方案其中`control`处于状态可能会使其无法建立连接，或在何处`secondaryInterfaces`可以建立连接之前，必须存在。 在这种情况下，开发人员可以继承<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>类，并重写<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint.SupportsConnection%2A>方法，提供用于确定何时准备好支持连接的连接点的自定义实现。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>