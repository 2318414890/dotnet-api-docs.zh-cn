<Type Name="CodeDomProvider" FullName="System.CodeDom.Compiler.CodeDomProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="76e1c10af9bc52b1c139e5e4706c9601f70ed474" />
    <Meta Name="ms.sourcegitcommit" Value="3507e865a3613c00760f25ad1045aaa11bae4dd8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/23/2018" />
    <Meta Name="ms.locfileid" Value="31781347" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CodeDomProvider : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeDomProvider extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.Compiler.CodeDomProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeDomProvider&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeDomProvider abstract : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>为 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现提供基类。 此类为抽象类。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.CodeDom.Compiler.CodeDomProvider>可以用于创建和检索代码生成器和代码编译器的实例。 代码生成器可用于以特定的语言生成代码，而代码编译器可用于将代码编译为程序集。  
  
> [!NOTE]
>  在[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]、 方法可在代码生成器和代码编译器都可直接从代码提供程序。 不需要调用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>或<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>访问，以及这些方法标记为过时。 这适用于预先存在的以及新的代码提供程序实现。  
  
 A<xref:System.CodeDom.Compiler.CodeDomProvider>实现通常提供的代码生成和/或代码编译接口，用于生成代码和管理一种编程语言的编译。 支持多种语言<xref:System.CodeDom.Compiler.CodeDomProvider>附带的实现[!INCLUDE[winsdklong](~/includes/winsdklong-md.md)]。 这些语言包括 C#、Visual Basic、C++ 和 JScript。 开发人员或编译器供应商可以实现<xref:System.CodeDom.Compiler.ICodeGenerator>和<xref:System.CodeDom.Compiler.ICodeCompiler>接口，并提供<xref:System.CodeDom.Compiler.CodeDomProvider>的 CodeDOM 将支持扩展到其他编程语言。  
  
 [ &lt;System.codedom&gt;元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)计算机配置文件 (Machine.config) 提供了面向开发人员和编译器供应商可以添加其他的配置设置的机制<xref:System.CodeDom.Compiler.CodeDomProvider>实现。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider>类提供静态方法，以发现和枚举<xref:System.CodeDom.Compiler.CodeDomProvider>的计算机上的实现。 <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A>方法返回的所有设置<xref:System.CodeDom.Compiler.CodeDomProvider>的计算机上的实现。 <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>方法返回特定的设置<xref:System.CodeDom.Compiler.CodeDomProvider>实现中，根据编程语言名称。 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法返回的实例<xref:System.CodeDom.Compiler.CodeDomProvider>特定语言的实现。  
  
 有关配置文件中的语言提供程序设置的更多详细信息，请参阅[编译器和语言提供程序设置架构](http://msdn.microsoft.com/library/c020b139-8699-4f0d-9ac9-70d0c5b2a8c8)。  
  
> [!NOTE]
>  此类，使链接要求，并且在类级别继承要求。 A<xref:System.Security.SecurityException>如果直接调用方或派生的类没有完全信任权限，则引发。 有关安全要求的详细信息，请参阅[链接需求](~/docs/framework/misc/link-demands.md)和[的继承需求](http://msdn.microsoft.com/library/28b9adbb-8f08-4f10-b856-dbf59eb932d9)。  
  
   
  
## Examples  
 下面的示例程序可以生成和编译的程序，将打印"Hello World"使用的 CodeDOM 模型所基于的源代码<xref:System.Console>类。 提供 Windows 窗体用户界面。 用户可以选择目标编程语言从几个选项： C#、 Visual Basic 和 JScript。  
  
 [!code-cpp[CodeDomExample#1](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#1)]
 [!code-csharp[CodeDomExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#1)]
 [!code-vb[CodeDomExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此类不能由部分受信任的代码使用。</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">对继承者的完全信任。 此类不能由部分受信任的代码继承。</permission>
    <block subset="none" type="overrides">
      <para>在.NET framework 1.0 和 1.1 版中中的代码提供程序包含的实现<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />， <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />， <see cref="T:System.CodeDom.Compiler.ICodeParser" />，和<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />。 在[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]、 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />， <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />，和<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />方法已过时，和的方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />和<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />中直接提供<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />类。 你应在你的代码提供程序实现中重写这些方法，并不调用基方法。</para>
    </block>
    <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
    <altmember cref="T:Microsoft.CSharp.CSharpCodeProvider" />
    <altmember cref="T:Microsoft.VisualBasic.VBCodeProvider" />
    <altmember cref="T:Microsoft.JScript.JScriptCodeProvider" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeDomProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeDomProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此类不能由部分受信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromDom">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom (System.CodeDom.Compiler.CompilerParameters options, params System.CodeDom.CodeCompileUnit[] compilationUnits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom(class System.CodeDom.Compiler.CompilerParameters options, class System.CodeDom.CodeCompileUnit[] compilationUnits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromDom(System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromDom (options As CompilerParameters, ParamArray compilationUnits As CodeCompileUnit()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromDom(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::CodeDom::CodeCompileUnit ^&gt; ^ compilationUnits);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="compilationUnits" Type="System.CodeDom.CodeCompileUnit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">一个 <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 对象，它指示编译的设置。</param>
        <param name="compilationUnits">
          <see cref="T:System.CodeDom.CodeCompileUnit" /> 类型数组，指示要编译的代码。</param>
        <summary>基于包含在 <see cref="N:System.CodeDom" /> 对象的指定数组中的 <see cref="T:System.CodeDom.CodeCompileUnit" /> 树，使用指定的编译器设置编译程序集。</summary>
        <returns>一个 <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 对象，它指示编译的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeCompiler>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>的提供程序的方法。 在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。 如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeCompiler>供基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides">
          <para>如果你重写此方法，你必须调用基类的对应方法。 基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />与预先存在的提供程序使用代码编译器的兼容性的方法。 基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />实现来执行此功能。 你将获得<see cref="T:System.NotImplementedException" />如果不使用代码编译器的代码提供调用基类方法。</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromFile">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile (System.CodeDom.Compiler.CompilerParameters options, params string[] fileNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile(class System.CodeDom.Compiler.CompilerParameters options, string[] fileNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromFile(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromFile (options As CompilerParameters, ParamArray fileNames As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromFile(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ fileNames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="fileNames" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">一个 <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 对象，它指示编译的设置。</param>
        <param name="fileNames">要编译的文件名称的数组。</param>
        <summary>从包含在指定文件中的源代码，使用指定的编译器设置编译程序集。</summary>
        <returns>指示编译结果的 <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeCompiler>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>的提供程序的方法。 在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。 如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeCompiler>供基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides">
          <para>如果你重写此方法，你必须调用基类的对应方法。 基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />与预先存在的提供程序使用代码编译器的兼容性的方法。 基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />实现来执行此功能。 你将获得<see cref="T:System.NotImplementedException" />如果不使用代码编译器的代码提供调用基类方法。</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromSource">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource (System.CodeDom.Compiler.CompilerParameters options, params string[] sources);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource(class System.CodeDom.Compiler.CompilerParameters options, string[] sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromSource(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromSource (options As CompilerParameters, ParamArray sources As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromSource(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ sources);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="sources" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">一个 <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 对象，它指示此编译的编译器设置。</param>
        <param name="sources">要编译的源代码字符串的数组。</param>
        <summary>从包含源代码的字符串的指定数组，使用指定的编译器设置编译程序集。</summary>
        <returns>指示编译结果的 <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeCompiler>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>的提供程序的方法。 在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。 如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeCompiler>供基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides">
          <para>如果你重写此方法，你必须调用基类的对应方法。 基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />与预先存在的提供程序使用代码编译器的兼容性的方法。 基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />实现来执行此功能。 你将获得<see cref="T:System.NotImplementedException" />如果不使用代码编译器的代码提供调用基类方法。</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CreateCompiler">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeCompiler CreateCompiler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeCompiler CreateCompiler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCompiler () As ICodeCompiler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeCompiler ^ CreateCompiler();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ICodeCompiler is obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeCompiler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，创建一个新的代码编译器。</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />，可用于编译基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法已过时中[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]。 建议的替代项是调用<xref:System.CodeDom.Compiler.ICodeCompiler>代码提供程序中直接提供的方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，应实现<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />中的成员<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />类，并引发<see cref="T:System.NotSupportedException" />当调用此方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateEscapedIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateEscapedIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateEscapedIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEscapedIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateEscapedIdentifier(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要为其创建转义标识符的字符串。</param>
        <summary>创建指定值的转义标识符。</summary>
        <returns>值的转义标识符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A> 测试标识符是否与任何保留相冲突或语言关键字和如果是这样，返回一个等效的带有特定于语言的转义码格式设置的名称。 这称为转义标识符。 转义的标识符包含相同`value`但添加了转义代码格式设置，以使标识符与关键字区分开来。 两个实现示例是前面`value`使用"@"或包括`value`与"["和"]"。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。 在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。 如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides">
          <para>如果你重写此方法，你必须调用基类的对应方法。 基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。 基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。 你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateGenerator">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，创建一个新的代码生成器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeGenerator CreateGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateGenerator () As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ICodeGenerator is obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，创建一个新的代码生成器。</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可用于生成基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法已过时中[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]。 建议的替代项是调用<xref:System.CodeDom.Compiler.ICodeGenerator>方法中直接提供<xref:System.CodeDom.Compiler.CodeDomProvider>类。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，应实现<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />中的成员<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />类，并引发<see cref="T:System.NotSupportedException" />当调用此方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (output As TextWriter) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="output">用于输出的 <see cref="T:System.IO.TextWriter" />。</param>
        <summary>在派生类中重写时，使用指定的 <see cref="T:System.IO.TextWriter" /> 创建新的代码生成器以用于输出。</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可用于生成基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用指定<xref:System.IO.TextWriter>输出。 此方法支持增量更新的源代码的更多优化的代码生成。  
  
> [!NOTE]
>  基类实现调用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法，在中已过时[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]，并导致<xref:System.NotSupportedException>如果<xref:System.CodeDom.Compiler.ICodeGenerator>不返回对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.TextWriter" />
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (fileName As String) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要输出到的文件名。</param>
        <summary>在派生类中重写时，使用指定文件名创建新的代码生成器以用于输出。</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可用于生成基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用输出指定的文件名称。  
  
> [!NOTE]
>  基类实现调用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法，在中已过时[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]，并导致<xref:System.NotSupportedException>如果<xref:System.CodeDom.Compiler.ICodeGenerator>不返回对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParser">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeParser CreateParser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeParser CreateParser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateParser () As ICodeParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeParser ^ CreateParser();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ICodeParser is obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeParser</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，创建一个新的代码分析器。</summary>
        <returns>
          <see cref="T:System.CodeDom.Compiler.ICodeParser" />，可用于分析源代码。 此基实现总是返回 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProvider">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取指定语言的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">语言名称。</param>
        <summary>获取指定语言的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实例。</summary>
        <returns>为指定语言名称实现的 CodeDOM 提供程序。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  此方法通常用于应用程序可选择性地使用多个提供商之一中创建的代码提供程序实例。 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> 可以在运行时指定你想要实例化的代码提供程序。 如果你知道在哪个代码提供程序是要使用的设计时，你应创建的该代码提供程序实例而不使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法返回<xref:System.CodeDom.Compiler.CodeDomProvider>实例特定的语言名称; 它是类似于调用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>与语言提供程序类型的方法。 使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>如果想要动态找到的语言名称的配置的提供程序实现。  
  
 如果语言名称，为配置了多个提供程序实现<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>返回最后一个匹配的配置元素的提供程序实例。  
  
 使用<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType>方法重载时您希望特定语言提供程序实现。 例如，使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法以获取支持的语言名称的提供程序实例`"CSharp"`; 使用<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType>方法重载来获取专为提供程序实例<xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType>实现。 应使用 [\]，CultureInfo、 对象\<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%2CSystem.Object%5B%5D%29?displayProperty=nameWithType > 如果你有多个为一种语言的代码提供程序并且您希望其实例化特定代码提供程序的方法。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>方法检查是否至少一个提供程序实现支持特定语言。 你可以验证语言名称使用<xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>之前将其传递给<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>。 如果你不受支持的语言将名称传递给<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A><xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>引发。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A>方法可以用于确定所有<xref:System.CodeDom.Compiler.CodeDomProvider>的计算机，包括开发人员和中标识的编译器供应商提供的其他实现上实现[ &lt;system.codedom&gt;元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)计算机配置文件 (Machine.config) 中。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法返回的实例<xref:System.CodeDom.Compiler.CodeDomProvider>特定语言的实现。  
  
 语言名称不区分大小写。  
  
   
  
## Examples  
 下面的代码示例确定<xref:System.CodeDom.Compiler.CodeDomProvider>输入的语言和显示语言提供程序的配置设置的实现。 此代码示例摘自更大的示例为提供<xref:System.CodeDom.Compiler.CompilerInfo>类。  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <paramref name="language" /> 在此计算机上没有已配置的提供程序。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="language" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language, System.Collections.Generic.IDictionary&lt;string,string&gt; providerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; providerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String, providerOptions As IDictionary(Of String, String)) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ providerOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
        <Parameter Name="providerOptions" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="language">语言名称。</param>
        <param name="providerOptions">来自配置文件的提供程序选项的集合。</param>
        <summary>获取指定的语言和提供程序选项的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实例。</summary>
        <returns>为指定语言名称和选项实现的 CodeDOM 提供程序。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  此方法通常用于应用程序可选择性地使用多个提供商之一中创建的代码提供程序实例。 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> 使用此选项可指定在运行时你想要实例化的代码提供程序的版本。 如果你知道在哪个代码提供程序是要使用的设计时，应创建而不是使用该代码提供程序实例的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29>方法。  
  
 使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29>如果想要动态查找特定的语言和选项的配置的提供程序实现。 语言名称不区分大小写。 有关受支持的提供程序选项的信息，请参阅特定 CodeDOM 提供程序文档。  
  
 有关验证提供程序和调用提供程序，如果语言名称为配置了多个提供程序实现的信息，请参阅备注部分的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29>方法。  
  
   
  
## Examples  
 下面的示例演示如何通过使用创建的提供程序实例`providerOptions`参数。  
  
 [!code-csharp[CodeDomProvider.ProviderOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/codedomprovider.provideroptions/cs/program.cs#1)]
 [!code-vb[CodeDomProvider.ProviderOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/codedomprovider.provideroptions/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateValidIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateValidIdentifier(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要为其生成有效标识符的字符串。</param>
        <summary>为指定的值创建有效标识符。</summary>
        <returns>指定值的有效标识符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A> 测试是否与保留的标识符冲突或语言关键字和如果因此，尝试返回有效的标识符名称不冲突。 通常返回的标识符仅略有修改以使标识符与关键字; 区分开来例如，名称可能前面使用下划线 (_) 字符。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。 在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。 如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides">
          <para>如果你重写此方法，你必须调用基类的对应方法。 基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。 基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。 你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FileExtension">
      <MemberSignature Language="C#" Value="public virtual string FileExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileExtension" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FileExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FileExtension { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于当前语言的源代码文件的默认文件扩展名。</summary>
        <value>与当前语言的源文件扩展名相对应的文件扩展名。 此基实现总是返回 <see cref="F:System.String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 代码生成器和代码编译器通过使用此属性以指示应生成还是使用哪些文件扩展名。  
  
   
  
## Examples  
 下面的代码示例创建的实例<xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>。 此示例显示提供程序名称、 哈希代码和默认文件扩展名为新的提供程序实例。  
  
 [!code-cpp[CodeDom_CompilerInfo#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#3)]
 [!code-csharp[CodeDom_CompilerInfo#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#3)]
 [!code-vb[CodeDom_CompilerInfo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromCompileUnit">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromCompileUnit (System.CodeDom.CodeCompileUnit compileUnit, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromCompileUnit(class System.CodeDom.CodeCompileUnit compileUnit, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit(System.CodeDom.CodeCompileUnit,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromCompileUnit (compileUnit As CodeCompileUnit, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromCompileUnit(System::CodeDom::CodeCompileUnit ^ compileUnit, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compileUnit" Type="System.CodeDom.CodeCompileUnit" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="compileUnit">要为其生成代码的 <see cref="T:System.CodeDom.CodeCompileUnit" />。</param>
        <param name="writer">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</param>
        <summary>为指定的代码文档对象模型 (CodeDOM) 编译单元生成代码，并使用指定的选项将代码发送到指定的文本编写器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。 在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。 如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。  
  
   
  
## Examples  
 下面的代码示例演示了利用<xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A>方法来生成中的"Hello World"应用程序的代码<xref:System.CodeDom.CodeCompileUnit>。 此示例摘自更大的示例为提供<xref:System.CodeDom.Compiler.CodeDomProvider>类。  
  
 [!code-cpp[CodeDomExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#3)]
 [!code-vb[CodeDomExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides">
          <para>如果你重写此方法，你必须调用基类的对应方法。 基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。 基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。 你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromExpression">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromExpression (System.CodeDom.CodeExpression expression, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromExpression(class System.CodeDom.CodeExpression expression, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromExpression(System.CodeDom.CodeExpression,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromExpression (expression As CodeExpression, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromExpression(System::CodeDom::CodeExpression ^ expression, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.CodeDom.CodeExpression" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="expression">一个 <see cref="T:System.CodeDom.CodeExpression" /> 对象，指示要为其生成代码的表达式。</param>
        <param name="writer">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</param>
        <summary>为指定的代码文档对象模型 (CodeDOM) 表达式生成代码，并使用指定的选项将代码发送到指定的文本编写器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。 在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。 如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides">
          <para>如果你重写此方法，你必须调用基类的对应方法。 基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。 基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。 你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromMember">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromMember (System.CodeDom.CodeTypeMember member, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromMember(class System.CodeDom.CodeTypeMember member, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember(System.CodeDom.CodeTypeMember,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromMember (member As CodeTypeMember, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromMember(System::CodeDom::CodeTypeMember ^ member, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.CodeDom.CodeTypeMember" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="member">一个 <see cref="T:System.CodeDom.CodeTypeMember" /> 对象，指示要为其生成代码的成员。</param>
        <param name="writer">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</param>
        <summary>为指定的代码文档对象模型 (CodeDOM) 成员声明生成代码，并使用指定的选项将代码发送到指定的文本编写器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基类实现引发<xref:System.NotImplementedException>。 请参阅<xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType>文档描述此方法的实现。  
  
   
  
## Examples  
 下面的代码示例演示了利用<xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A>方法的实施方式<xref:Microsoft.CSharp.CSharpCodeProvider>和<xref:Microsoft.VisualBasic.VBCodeProvider>类。  
  
 [!code-csharp[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/cs/program.cs#1)]
 [!code-vb[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法不会在派生类中被重写。</exception>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeMember" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromNamespace">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromNamespace (System.CodeDom.CodeNamespace codeNamespace, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromNamespace(class System.CodeDom.CodeNamespace codeNamespace, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromNamespace(System.CodeDom.CodeNamespace,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromNamespace(System::CodeDom::CodeNamespace ^ codeNamespace, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeNamespace" Type="System.CodeDom.CodeNamespace" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="codeNamespace">一个 <see cref="T:System.CodeDom.CodeNamespace" /> 对象，指示要为其生成代码的命名空间。</param>
        <param name="writer">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</param>
        <summary>为指定的代码文档对象模型 (CodeDOM) 命名空间生成代码，并使用指定的选项将代码发送到指定的文本编写器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。 在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。 如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides">
          <para>如果你重写此方法，你必须调用基类的对应方法。 基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。 基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。 你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeNamespace" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromStatement">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromStatement (System.CodeDom.CodeStatement statement, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromStatement(class System.CodeDom.CodeStatement statement, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromStatement(System.CodeDom.CodeStatement,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromStatement (statement As CodeStatement, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromStatement(System::CodeDom::CodeStatement ^ statement, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statement" Type="System.CodeDom.CodeStatement" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="statement">
          <see cref="T:System.CodeDom.CodeStatement" />，包含要为其生成代码的 CodeDOM 元素。</param>
        <param name="writer">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</param>
        <summary>为指定的代码文档对象模型 (CodeDOM) 语句生成代码，并使用指定的选项将代码发送到指定的文本编写器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。 在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。 如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides">
          <para>如果你重写此方法，你必须调用基类的对应方法。 基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。 基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。 你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeStatement" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromType">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromType (System.CodeDom.CodeTypeDeclaration codeType, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromType(class System.CodeDom.CodeTypeDeclaration codeType, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromType(System.CodeDom.CodeTypeDeclaration,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromType (codeType As CodeTypeDeclaration, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromType(System::CodeDom::CodeTypeDeclaration ^ codeType, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeType" Type="System.CodeDom.CodeTypeDeclaration" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="codeType">一个 <see cref="T:System.CodeDom.CodeTypeDeclaration" /> 对象，指示要为其生成代码的类型。</param>
        <param name="writer">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options">
          <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</param>
        <summary>为指定的代码文档对象模型 (CodeDOM) 类型声明生成代码，并使用指定的选项将代码发送到指定的文本编写器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。 在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。 如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides">
          <para>如果你重写此方法，你必须调用基类的对应方法。 基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。 基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。 你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GetAllCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllCompilerInfo () As CompilerInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::CodeDom::Compiler::CompilerInfo ^&gt; ^ GetAllCompilerInfo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此计算机的语言提供程序和编译器配置设置。</summary>
        <returns>一个 <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> 类型的数组，表示所有配置的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现的设置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A>进行枚举在计算机上的语言提供程序设置方法。  
  
> [!NOTE]
>  在[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]，由.NET Framework 提供的默认语言提供程序中未指定[ &lt;system.codedom&gt;元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)编译器配置部分，不能删除，因此该方法返回有关默认的提供程序和任何配置文件中指定的信息。  
  
   
  
## Examples  
 下面的代码示例枚举计算机上的语言提供程序，并显示每个语言提供程序的配置和编译器设置。 此代码示例摘自更大的示例为提供<xref:System.CodeDom.Compiler.CompilerInfo>类。  
  
 [!code-cpp[CodeDom_CompilerInfo#8](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#8)]
 [!code-csharp[CodeDom_CompilerInfo#8](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#8)]
 [!code-vb[CodeDom_CompilerInfo#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo GetCompilerInfo (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo GetCompilerInfo(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompilerInfo (language As String) As CompilerInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CompilerInfo ^ GetCompilerInfo(System::String ^ language);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">语言名称。</param>
        <summary>返回指定语言的语言提供程序和编译器配置设置。</summary>
        <returns>一个 <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> 对象，由已配置的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现的设置填充。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt;元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)计算机配置文件包含每个语言提供程序和编译器配置设置<xref:System.CodeDom.Compiler.CodeDomProvider>计算机上的实现。 有关计算机配置文件的信息，请参阅中的计算机配置文件部分[配置应用](http://msdn.microsoft.com/library/86bd26d3-737e-4484-9782-19b17f34cd1f)。 <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>方法搜索指定的语言名称每个提供程序配置元素。 返回<xref:System.CodeDom.Compiler.CompilerInfo>实例包含配置的语言提供程序和编译器设置。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>方法检查是否至少一个提供程序实现支持特定语言。 你可以验证语言名称使用<xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>之前将其传递给<xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>。 这可防止引发<xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>访问时<xref:System.CodeDom.Compiler.CompilerInfo>不受支持的语言名称的实例。  
  
 如果为输入的语言名称配置了多个提供程序实现<xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>返回从最后一个匹配提供的设置配置元素。  
  
 语言名称不区分大小写。  
  
   
  
## Examples  
 下面的代码示例确定<xref:System.CodeDom.Compiler.CodeDomProvider>输入的语言和显示语言提供程序的配置设置的实现。 此代码示例摘自更大的示例为提供<xref:System.CodeDom.Compiler.CompilerInfo>类。  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">
          <paramref name="language" /> 在此计算机上没有已配置的提供程序。</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <paramref name="language" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">要为其检索类型转换器的对象类型。</param>
        <summary>获取指定数据类型的 <see cref="T:System.ComponentModel.TypeConverter" />。</summary>
        <returns>指定类型的 <see cref="T:System.ComponentModel.TypeConverter" />；如果无法找到指定类型的 <see cref="T:System.ComponentModel.TypeConverter" />，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生的类可以重写此方法以针对特定数据类型提供特定类型的类型转换器。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetLanguageFromExtension">
      <MemberSignature Language="C#" Value="public static string GetLanguageFromExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetLanguageFromExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLanguageFromExtension (extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetLanguageFromExtension(System::String ^ extension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="extension">文件扩展名。</param>
        <summary>返回与指定文件扩展名关联的语言名称，如 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 编译器配置节中所配置的那样。</summary>
        <returns>与文件扩展名关联的语言名称，如 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 编译器配置设置中所配置的那样。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt;元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)计算机配置文件 (Machine.config) 包含每个语言提供程序和编译器配置设置<xref:System.CodeDom.Compiler.CodeDomProvider>上的实现计算机。 <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>方法搜索指定的文件名称扩展每个提供程序配置元素。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A>方法检查是否至少一个提供程序实现支持特定的文件扩展名。 你可以验证文件名称扩展 using<xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A>之前将其传递给<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>。 这可以防止<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>从引发<xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>不支持的文件名称扩展。  
  
 如果提供程序实现支持的输入的文件扩展名，并且有多个受支持的语言为该提供程序，然后配置<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>返回该提供程序的第一个语言名称。 如果输入的文件扩展名，配置了多个提供程序实现<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>返回语言名称的最后一个匹配提供配置元素中。  
  
 语言名称和文件扩展名不区分大小写。  
  
   
  
## Examples  
 下面的代码示例确定<xref:System.CodeDom.Compiler.CodeDomProvider>输入的文件扩展名为显示语言提供程序的配置设置的实现。 此代码示例摘自更大的示例为提供<xref:System.CodeDom.Compiler.CompilerInfo>类。  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">
          <paramref name="extension" /> 在此计算机上没有已配置的语言提供程序。</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <paramref name="extension" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeOutput">
      <MemberSignature Language="C#" Value="public virtual string GetTypeOutput (System.CodeDom.CodeTypeReference type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeOutput(class System.CodeDom.CodeTypeReference type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetTypeOutput(System.CodeDom.CodeTypeReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeOutput (type As CodeTypeReference) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeOutput(System::CodeDom::CodeTypeReference ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.CodeDom.CodeTypeReference" />
      </Parameters>
      <Docs>
        <param name="type">指示返回类型的 <see cref="T:System.CodeDom.CodeTypeReference" />。</param>
        <summary>获取由指定的 <see cref="T:System.CodeDom.CodeTypeReference" /> 指示的类型。</summary>
        <returns>指定类型的文本表示形式，针对此代码生成器生成代码时所用的语言进行了格式设置。 例如，在 Visual Basic 中，为 <see cref="T:System.CodeDom.CodeTypeReference" /> 类型传入 <see cref="T:System.Int32" /> 将返回“Integer”。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。 在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。 如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides">
          <para>如果你重写此方法，你必须调用基类的对应方法。 基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。 基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。 你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedExtension">
      <MemberSignature Language="C#" Value="public static bool IsDefinedExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedExtension (extension As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedExtension(System::String ^ extension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="extension">文件扩展名。</param>
        <summary>测试文件扩展名是否在计算机上配置了关联的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现。</summary>
        <returns>
          如果为指定的文件扩展名配置了 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt;元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)计算机配置文件 (Machine.config) 包含每个语言提供程序和编译器配置设置<xref:System.CodeDom.Compiler.CodeDomProvider>上的实现计算机。 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A>方法搜索指定的文件扩展名的提供程序配置元素。  
  
 文件扩展名不区分大小写。  
  
   
  
## Examples  
 下面的代码示例确定<xref:System.CodeDom.Compiler.CodeDomProvider>输入的文件扩展名为显示语言提供程序的配置设置的实现。 此代码示例摘自更大的示例为提供<xref:System.CodeDom.Compiler.CompilerInfo>类。  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="extension" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefinedLanguage">
      <MemberSignature Language="C#" Value="public static bool IsDefinedLanguage (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedLanguage(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedLanguage (language As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedLanguage(System::String ^ language);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">语言名称。</param>
        <summary>测试某语言是否已在计算机上配置了 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现。</summary>
        <returns>
          如果为指定语言配置了 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt;元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)计算机配置文件 (Machine.config) 包含每个语言提供程序和编译器配置设置<xref:System.CodeDom.Compiler.CodeDomProvider>上的实现计算机。 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>方法搜索指定的语言名称的提供程序配置元素。  
  
 语言名称不区分大小写。  
  
   
  
## Examples  
 下面的代码示例确定<xref:System.CodeDom.Compiler.CodeDomProvider>输入的语言和显示语言提供程序的配置设置的实现。 此代码示例摘自更大的示例为提供<xref:System.CodeDom.Compiler.CompilerInfo>类。  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="language" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual bool IsValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsValidIdentifier (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsValidIdentifier(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要验证为一个有效标识符的值。</param>
        <summary>返回一个值，该值指示指定的值是否是当前语言的有效标识符。</summary>
        <returns>
          如果 <paramref name="value" /> 参数是有效标识符，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法测试标识符是否有效。 <xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A>方法是特定于提供程序。 一个提供程序对有效的标识符可能不是有效的其他提供程序。 如果`value`包含字符的 ASCII 字符范围，之外检查可能用于编译代码的所有语言的标识符。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。 在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。 如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />在派生类中，设计该方法以返回<see langword="true" />只有值符合语言的规则，并且不与关键字冲突。  
  
 如果你重写此方法，你必须调用基类的对应方法。 基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。 基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。 你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LanguageOptions">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.LanguageOptions LanguageOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.CodeDom.Compiler.LanguageOptions LanguageOptions" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LanguageOptions As LanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::CodeDom::Compiler::LanguageOptions LanguageOptions { System::CodeDom::Compiler::LanguageOptions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.LanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取语言功能标识符。</summary>
        <value>指示语言的特殊功能的 <see cref="T:System.CodeDom.Compiler.LanguageOptions" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.CodeCompileUnit Parse (System.IO.TextReader codeStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.CodeCompileUnit Parse(class System.IO.TextReader codeStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Parse(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Parse (codeStream As TextReader) As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::CodeCompileUnit ^ Parse(System::IO::TextReader ^ codeStream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeStream" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="codeStream">用于读取待分析代码的 <see cref="T:System.IO.TextReader" /> 对象。</param>
        <summary>将从指定文本流读取的代码编译进 <see cref="T:System.CodeDom.CodeCompileUnit" />。</summary>
        <returns>
          <see cref="T:System.CodeDom.CodeCompileUnit" />，包含已分析代码的表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeParser>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A>的提供程序的方法。 在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。 如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeParser>供基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides">
          <para>如果你重写此方法，你必须调用基类的对应方法。 基类方法使用过时的派生类中创建一个分析器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />与预先存在的提供程序使用代码分析程序的兼容性的方法。 基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeParser" />实现来执行此功能。 你将获得<see cref="T:System.NotImplementedException" />如果从代码提供程序不使用代码分析器调用基类方法。</para>
        </block>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.IO.TextReader" />
      </Docs>
    </Member>
    <Member MemberName="Supports">
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport generatorSupport) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport supports) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" FrameworkAlternate="xamarinmac-3.0;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generatorSupport" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="supports" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generatorSupport">To be added.</param>
        <param name="supports">To be added.</param>
        <summary>返回一个值，该值指示是否提供了指定的代码生成支持。</summary>
        <returns>
          如果提供了指定的代码生成支持，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可以调用的数量<xref:System.CodeDom.Compiler.GeneratorSupport>标志一次以一组的功能测试方法加入一组以及二进制文件的相应功能标志`OR`运算符 (&#124;)。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。 在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。 如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides">
          <para>如果你重写此方法，你必须调用基类的对应方法。 基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。 基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。 你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
      </Docs>
    </Member>
  </Members>
</Type>