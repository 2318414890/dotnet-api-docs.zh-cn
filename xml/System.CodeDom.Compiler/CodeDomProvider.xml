<Type Name="CodeDomProvider" FullName="System.CodeDom.Compiler.CodeDomProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="76e1c10af9bc52b1c139e5e4706c9601f70ed474" />
    <Meta Name="ms.sourcegitcommit" Value="3507e865a3613c00760f25ad1045aaa11bae4dd8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/23/2018" />
    <Meta Name="ms.locfileid" Value="31781347" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CodeDomProvider : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeDomProvider extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.Compiler.CodeDomProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeDomProvider&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeDomProvider abstract : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="e2fe2-101">为 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现提供基类。</span>
      <span class="sxs-lookup">
        <span data-stu-id="e2fe2-101">Provides a base class for <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementations.</span>
      </span>
      <span data-ttu-id="e2fe2-102">此类为抽象类。</span>
      <span class="sxs-lookup">
        <span data-stu-id="e2fe2-102">This class is abstract.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-103">A<xref:System.CodeDom.Compiler.CodeDomProvider>可以用于创建和检索代码生成器和代码编译器的实例。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-103">A <xref:System.CodeDom.Compiler.CodeDomProvider> can be used to create and retrieve instances of code generators and code compilers.</span></span> <span data-ttu-id="e2fe2-104">代码生成器可用于以特定的语言生成代码，而代码编译器可用于将代码编译为程序集。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-104">Code generators can be used to generate code in a particular language, and code compilers can be used to compile code into assemblies.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-105">在[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]、 方法可在代码生成器和代码编译器都可直接从代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-105">In the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], the methods made available in the code generator and code compiler are available directly from the code provider.</span></span> <span data-ttu-id="e2fe2-106">不需要调用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>或<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>访问，以及这些方法标记为过时。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-106">You do not need to call <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> or <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> to access the methods, and those methods are marked as obsolete.</span></span> <span data-ttu-id="e2fe2-107">这适用于预先存在的以及新的代码提供程序实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-107">This applies to preexisting as well as new code provider implementations.</span></span>  
  
 <span data-ttu-id="e2fe2-108">A<xref:System.CodeDom.Compiler.CodeDomProvider>实现通常提供的代码生成和/或代码编译接口，用于生成代码和管理一种编程语言的编译。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-108">A <xref:System.CodeDom.Compiler.CodeDomProvider> implementation typically provides code generation and/or code compilation interfaces for generating code and managing compilation for a single programming language.</span></span> <span data-ttu-id="e2fe2-109">支持多种语言<xref:System.CodeDom.Compiler.CodeDomProvider>附带的实现[!INCLUDE[winsdklong](~/includes/winsdklong-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-109">Several languages are supported by <xref:System.CodeDom.Compiler.CodeDomProvider> implementations that ship with the [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)].</span></span> <span data-ttu-id="e2fe2-110">这些语言包括 C#、Visual Basic、C++ 和 JScript。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-110">These languages include C#, Visual Basic, C++, and JScript.</span></span> <span data-ttu-id="e2fe2-111">开发人员或编译器供应商可以实现<xref:System.CodeDom.Compiler.ICodeGenerator>和<xref:System.CodeDom.Compiler.ICodeCompiler>接口，并提供<xref:System.CodeDom.Compiler.CodeDomProvider>的 CodeDOM 将支持扩展到其他编程语言。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-111">Developers or compiler vendors can implement the <xref:System.CodeDom.Compiler.ICodeGenerator> and <xref:System.CodeDom.Compiler.ICodeCompiler> interfaces and provide a <xref:System.CodeDom.Compiler.CodeDomProvider> that extends CodeDOM support to other programming languages.</span></span>  
  
 <span data-ttu-id="e2fe2-112">[ &lt;System.codedom&gt;元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)计算机配置文件 (Machine.config) 提供了面向开发人员和编译器供应商可以添加其他的配置设置的机制<xref:System.CodeDom.Compiler.CodeDomProvider>实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-112">The [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file (Machine.config) provides a mechanism for developers and compiler vendors to add configuration settings for additional <xref:System.CodeDom.Compiler.CodeDomProvider> implementations.</span></span>  
  
 <span data-ttu-id="e2fe2-113"><xref:System.CodeDom.Compiler.CodeDomProvider>类提供静态方法，以发现和枚举<xref:System.CodeDom.Compiler.CodeDomProvider>的计算机上的实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-113">The <xref:System.CodeDom.Compiler.CodeDomProvider> class provides static methods to discover and enumerate the <xref:System.CodeDom.Compiler.CodeDomProvider> implementations on a computer.</span></span> <span data-ttu-id="e2fe2-114"><xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A>方法返回的所有设置<xref:System.CodeDom.Compiler.CodeDomProvider>的计算机上的实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-114">The <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> method returns the settings for all <xref:System.CodeDom.Compiler.CodeDomProvider> implementations on a computer.</span></span> <span data-ttu-id="e2fe2-115"><xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>方法返回特定的设置<xref:System.CodeDom.Compiler.CodeDomProvider>实现中，根据编程语言名称。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-115">The <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> method returns the settings for a specific <xref:System.CodeDom.Compiler.CodeDomProvider> implementation, based on the programming language name.</span></span> <span data-ttu-id="e2fe2-116"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法返回的实例<xref:System.CodeDom.Compiler.CodeDomProvider>特定语言的实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-116">The <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> method returns an instance of a <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for a specific language.</span></span>  
  
 <span data-ttu-id="e2fe2-117">有关配置文件中的语言提供程序设置的更多详细信息，请参阅[编译器和语言提供程序设置架构](http://msdn.microsoft.com/library/c020b139-8699-4f0d-9ac9-70d0c5b2a8c8)。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-117">For more details on language provider settings in the configuration file, see [Compiler and Language Provider Settings Schema](http://msdn.microsoft.com/library/c020b139-8699-4f0d-9ac9-70d0c5b2a8c8).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-118">此类，使链接要求，并且在类级别继承要求。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-118">This class makes a link demand and an inheritance demand at the class level.</span></span> <span data-ttu-id="e2fe2-119">A<xref:System.Security.SecurityException>如果直接调用方或派生的类没有完全信任权限，则引发。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-119">A <xref:System.Security.SecurityException> is thrown if either the immediate caller or the derived class does not have full trust permission.</span></span> <span data-ttu-id="e2fe2-120">有关安全要求的详细信息，请参阅[链接需求](~/docs/framework/misc/link-demands.md)和[的继承需求](http://msdn.microsoft.com/library/28b9adbb-8f08-4f10-b856-dbf59eb932d9)。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-120">For details about security demands, see [Link Demands](~/docs/framework/misc/link-demands.md) and [Inheritance Demands](http://msdn.microsoft.com/library/28b9adbb-8f08-4f10-b856-dbf59eb932d9).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2fe2-121">下面的示例程序可以生成和编译的程序，将打印"Hello World"使用的 CodeDOM 模型所基于的源代码<xref:System.Console>类。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-121">The following example program can generate and compile source code based on a CodeDOM model of a program that prints "Hello World" using the <xref:System.Console> class.</span></span> <span data-ttu-id="e2fe2-122">提供 Windows 窗体用户界面。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-122">A Windows Forms user interface is provided.</span></span> <span data-ttu-id="e2fe2-123">用户可以选择目标编程语言从几个选项： C#、 Visual Basic 和 JScript。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-123">The user can select the target programming language from several selections: C#, Visual Basic, and JScript.</span></span>  
  
 [!code-cpp[CodeDomExample#1](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#1)]
 [!code-csharp[CodeDomExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#1)]
 [!code-vb[CodeDomExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
      <span data-ttu-id="e2fe2-124">直接调用方的完全信任。</span>
      <span class="sxs-lookup">
        <span data-stu-id="e2fe2-124">for full trust for the immediate caller.</span>
      </span>
      <span data-ttu-id="e2fe2-125">此类不能由部分受信任的代码使用。</span>
      <span class="sxs-lookup">
        <span data-stu-id="e2fe2-125">This class cannot be used by partially trusted code.</span>
      </span>
    </permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="e2fe2-126">对继承者的完全信任。</span>
      <span class="sxs-lookup">
        <span data-stu-id="e2fe2-126">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="e2fe2-127">此类不能由部分受信任的代码继承。</span>
      <span class="sxs-lookup">
        <span data-stu-id="e2fe2-127">This class cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="e2fe2-128">在.NET framework 1.0 和 1.1 版中中的代码提供程序包含的实现<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />， <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />， <see cref="T:System.CodeDom.Compiler.ICodeParser" />，和<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />。</span>
        <span class="sxs-lookup">
          <span data-stu-id="e2fe2-128">In the .NET Framework versions 1.0 and 1.1, code providers consist of implementations of <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />, <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, <see cref="T:System.CodeDom.Compiler.ICodeParser" />, and <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />.</span>
        </span>
        <span data-ttu-id="e2fe2-129">在[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]、 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />， <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />，和<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />方法已过时，和的方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />和<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />中直接提供<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />类。</span>
        <span class="sxs-lookup">
          <span data-stu-id="e2fe2-129">In the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />, <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />, and <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> methods are obsolete, and the methods of <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> and <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> are directly available in the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> class.</span>
        </span>
        <span data-ttu-id="e2fe2-130">你应在你的代码提供程序实现中重写这些方法，并不调用基方法。</span>
        <span class="sxs-lookup">
          <span data-stu-id="e2fe2-130">You should override those methods in your code provider implementation and not call the base methods.</span>
        </span>
      </para>
    </block>
    <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
    <altmember cref="T:Microsoft.CSharp.CSharpCodeProvider" />
    <altmember cref="T:Microsoft.VisualBasic.VBCodeProvider" />
    <altmember cref="T:Microsoft.JScript.JScriptCodeProvider" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeDomProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeDomProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e2fe2-131">初始化 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-131">Initializes a new instance of the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="e2fe2-132">直接调用方的完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-132">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e2fe2-133">此类不能由部分受信任的代码使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-133">This class cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromDom">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom (System.CodeDom.Compiler.CompilerParameters options, params System.CodeDom.CodeCompileUnit[] compilationUnits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom(class System.CodeDom.Compiler.CompilerParameters options, class System.CodeDom.CodeCompileUnit[] compilationUnits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromDom(System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromDom (options As CompilerParameters, ParamArray compilationUnits As CodeCompileUnit()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromDom(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::CodeDom::CodeCompileUnit ^&gt; ^ compilationUnits);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="compilationUnits" Type="System.CodeDom.CodeCompileUnit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">
          <span data-ttu-id="e2fe2-134">一个 <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 对象，它指示编译的设置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-134">A <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> object that indicates the settings for the compilation.</span>
          </span>
        </param>
        <param name="compilationUnits">
          <span data-ttu-id="e2fe2-135">
            <see cref="T:System.CodeDom.CodeCompileUnit" /> 类型数组，指示要编译的代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-135">An array of type <see cref="T:System.CodeDom.CodeCompileUnit" /> that indicates the code to compile.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-136">基于包含在 <see cref="N:System.CodeDom" /> 对象的指定数组中的 <see cref="T:System.CodeDom.CodeCompileUnit" /> 树，使用指定的编译器设置编译程序集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-136">Compiles an assembly based on the <see cref="N:System.CodeDom" /> trees contained in the specified array of <see cref="T:System.CodeDom.CodeCompileUnit" /> objects, using the specified compiler settings.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-137">一个 <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 对象，它指示编译的结果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-137">A <see cref="T:System.CodeDom.Compiler.CompilerResults" /> object that indicates the results of the compilation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-138">在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeCompiler>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>的提供程序的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-138">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> method of the provider.</span></span> <span data-ttu-id="e2fe2-139">在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-139">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="e2fe2-140">如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeCompiler>供基类调用实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-140">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="e2fe2-141">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法均不在派生类中重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-141">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-142">如果你重写此方法，你必须调用基类的对应方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-142">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="e2fe2-143">基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />与预先存在的提供程序使用代码编译器的兼容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-143">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method for compatibility with preexisting providers that use code compilers.</span>
            </span>
            <span data-ttu-id="e2fe2-144">基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />实现来执行此功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-144">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="e2fe2-145">你将获得<see cref="T:System.NotImplementedException" />如果不使用代码编译器的代码提供调用基类方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-145">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code compiler.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromFile">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile (System.CodeDom.Compiler.CompilerParameters options, params string[] fileNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile(class System.CodeDom.Compiler.CompilerParameters options, string[] fileNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromFile(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromFile (options As CompilerParameters, ParamArray fileNames As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromFile(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ fileNames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="fileNames" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">
          <span data-ttu-id="e2fe2-146">一个 <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 对象，它指示编译的设置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-146">A <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> object that indicates the settings for the compilation.</span>
          </span>
        </param>
        <param name="fileNames">
          <span data-ttu-id="e2fe2-147">要编译的文件名称的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-147">An array of the names of the files to compile.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-148">从包含在指定文件中的源代码，使用指定的编译器设置编译程序集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-148">Compiles an assembly from the source code contained in the specified files, using the specified compiler settings.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-149">指示编译结果的 <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-149">A <see cref="T:System.CodeDom.Compiler.CompilerResults" /> object that indicates the results of compilation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-150">在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeCompiler>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>的提供程序的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-150">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> method of the provider.</span></span> <span data-ttu-id="e2fe2-151">在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-151">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="e2fe2-152">如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeCompiler>供基类调用实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-152">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="e2fe2-153">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法均不在派生类中重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-153">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-154">如果你重写此方法，你必须调用基类的对应方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-154">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="e2fe2-155">基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />与预先存在的提供程序使用代码编译器的兼容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-155">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method for compatibility with preexisting providers that use code compilers.</span>
            </span>
            <span data-ttu-id="e2fe2-156">基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />实现来执行此功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-156">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="e2fe2-157">你将获得<see cref="T:System.NotImplementedException" />如果不使用代码编译器的代码提供调用基类方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-157">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code compiler.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromSource">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource (System.CodeDom.Compiler.CompilerParameters options, params string[] sources);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource(class System.CodeDom.Compiler.CompilerParameters options, string[] sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromSource(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromSource (options As CompilerParameters, ParamArray sources As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromSource(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ sources);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" />
        <Parameter Name="sources" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">
          <span data-ttu-id="e2fe2-158">一个 <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 对象，它指示此编译的编译器设置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-158">A <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> object that indicates the compiler settings for this compilation.</span>
          </span>
        </param>
        <param name="sources">
          <span data-ttu-id="e2fe2-159">要编译的源代码字符串的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-159">An array of source code strings to compile.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-160">从包含源代码的字符串的指定数组，使用指定的编译器设置编译程序集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-160">Compiles an assembly from the specified array of strings containing source code, using the specified compiler settings.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-161">指示编译结果的 <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-161">A <see cref="T:System.CodeDom.Compiler.CompilerResults" /> object that indicates the results of compilation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-162">在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeCompiler>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>的提供程序的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-162">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> method of the provider.</span></span> <span data-ttu-id="e2fe2-163">在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-163">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="e2fe2-164">如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeCompiler>供基类调用实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-164">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="e2fe2-165">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法均不在派生类中重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-165">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-166">如果你重写此方法，你必须调用基类的对应方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-166">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="e2fe2-167">基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />与预先存在的提供程序使用代码编译器的兼容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-167">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method for compatibility with preexisting providers that use code compilers.</span>
            </span>
            <span data-ttu-id="e2fe2-168">基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />实现来执行此功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-168">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="e2fe2-169">你将获得<see cref="T:System.NotImplementedException" />如果不使用代码编译器的代码提供调用基类方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-169">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code compiler.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CreateCompiler">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeCompiler CreateCompiler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeCompiler CreateCompiler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCompiler () As ICodeCompiler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeCompiler ^ CreateCompiler();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ICodeCompiler is obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeCompiler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e2fe2-170">在派生类中重写时，创建一个新的代码编译器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-170">When overridden in a derived class, creates a new code compiler.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-171">
            <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />，可用于编译基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-171">An <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> that can be used for compilation of <see cref="N:System.CodeDom" /> based source code representations.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-172">此方法已过时中[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-172">This method is obsolete in the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)].</span></span> <span data-ttu-id="e2fe2-173">建议的替代项是调用<xref:System.CodeDom.Compiler.ICodeCompiler>代码提供程序中直接提供的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-173">The recommended alternative is to call the <xref:System.CodeDom.Compiler.ICodeCompiler> methods that are directly available in the code provider.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-174">在[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，应实现<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />中的成员<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />类，并引发<see cref="T:System.NotSupportedException" />当调用此方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-174">In the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], you should implement the <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> members in the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> class and throw a <see cref="T:System.NotSupportedException" /> when this method is called.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateEscapedIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateEscapedIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateEscapedIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEscapedIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateEscapedIdentifier(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="e2fe2-175">要为其创建转义标识符的字符串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-175">The string for which to create an escaped identifier.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-176">创建指定值的转义标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-176">Creates an escaped identifier for the specified value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-177">值的转义标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-177">The escaped identifier for the value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-178"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A> 测试标识符是否与任何保留相冲突或语言关键字和如果是这样，返回一个等效的带有特定于语言的转义码格式设置的名称。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-178"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A> tests whether the identifier conflicts with any reserved or language keywords, and if so, returns an equivalent name with language-specific escape code formatting.</span></span> <span data-ttu-id="e2fe2-179">这称为转义标识符。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-179">This is referred to an escaped identifier.</span></span> <span data-ttu-id="e2fe2-180">转义的标识符包含相同`value`但添加了转义代码格式设置，以使标识符与关键字区分开来。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-180">The escaped identifier contains the same `value` but has escape-code formatting added to differentiate the identifier from the keyword.</span></span> <span data-ttu-id="e2fe2-181">两个实现示例是前面`value`使用"@"或包括`value`与"["和"]"。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-181">Two implementation examples are preceding the `value` with "@" or bracketing the `value` with "[" and "]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-182">在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-182">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="e2fe2-183">在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-183">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="e2fe2-184">如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-184">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="e2fe2-185">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-185">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-186">如果你重写此方法，你必须调用基类的对应方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-186">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="e2fe2-187">基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-187">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="e2fe2-188">基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-188">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="e2fe2-189">你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-189">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateGenerator">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e2fe2-190">在派生类中重写时，创建一个新的代码生成器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-190">When overridden in a derived class, creates a new code generator.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeGenerator CreateGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateGenerator () As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ICodeGenerator is obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e2fe2-191">在派生类中重写时，创建一个新的代码生成器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-191">When overridden in a derived class, creates a new code generator.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-192">
            <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可用于生成基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-192">An <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> that can be used to generate <see cref="N:System.CodeDom" /> based source code representations.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-193">此方法已过时中[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-193">This method is obsolete in the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)].</span></span> <span data-ttu-id="e2fe2-194">建议的替代项是调用<xref:System.CodeDom.Compiler.ICodeGenerator>方法中直接提供<xref:System.CodeDom.Compiler.CodeDomProvider>类。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-194">The recommended alternative is to call the <xref:System.CodeDom.Compiler.ICodeGenerator> methods that are directly available in the <xref:System.CodeDom.Compiler.CodeDomProvider> class.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-195">在[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，应实现<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />中的成员<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />类，并引发<see cref="T:System.NotSupportedException" />当调用此方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-195">In the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], you should implement the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> members in the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> class and throw a <see cref="T:System.NotSupportedException" /> when this method is called.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (output As TextWriter) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="output">
          <span data-ttu-id="e2fe2-196">用于输出的 <see cref="T:System.IO.TextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-196">A <see cref="T:System.IO.TextWriter" /> to use to output.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-197">在派生类中重写时，使用指定的 <see cref="T:System.IO.TextWriter" /> 创建新的代码生成器以用于输出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-197">When overridden in a derived class, creates a new code generator using the specified <see cref="T:System.IO.TextWriter" /> for output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-198">
            <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可用于生成基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-198">An <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> that can be used to generate <see cref="N:System.CodeDom" /> based source code representations.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-199">此方法使用指定<xref:System.IO.TextWriter>输出。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-199">This method uses the specified <xref:System.IO.TextWriter> for output.</span></span> <span data-ttu-id="e2fe2-200">此方法支持增量更新的源代码的更多优化的代码生成。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-200">This method supports more optimized code generation that incrementally updates the source code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-201">基类实现调用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法，在中已过时[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]，并导致<xref:System.NotSupportedException>如果<xref:System.CodeDom.Compiler.ICodeGenerator>不返回对象。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-201">The base class implementation calls the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method, which is obsolete in the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] and results in a <xref:System.NotSupportedException> if an <xref:System.CodeDom.Compiler.ICodeGenerator> object is not returned.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.TextWriter" />
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (fileName As String) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="e2fe2-202">要输出到的文件名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-202">The file name to output to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-203">在派生类中重写时，使用指定文件名创建新的代码生成器以用于输出。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-203">When overridden in a derived class, creates a new code generator using the specified file name for output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-204">
            <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可用于生成基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-204">An <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> that can be used to generate <see cref="N:System.CodeDom" /> based source code representations.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-205">此方法使用输出指定的文件名称。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-205">This method uses the specified file name for output.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-206">基类实现调用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法，在中已过时[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]，并导致<xref:System.NotSupportedException>如果<xref:System.CodeDom.Compiler.ICodeGenerator>不返回对象。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-206">The base class implementation calls the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method, which is obsolete in the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] and results in a <xref:System.NotSupportedException> if an <xref:System.CodeDom.Compiler.ICodeGenerator> object is not returned.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParser">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeParser CreateParser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeParser CreateParser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateParser () As ICodeParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeParser ^ CreateParser();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ICodeParser is obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeParser</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e2fe2-207">在派生类中重写时，创建一个新的代码分析器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-207">When overridden in a derived class, creates a new code parser.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-208">
            <see cref="T:System.CodeDom.Compiler.ICodeParser" />，可用于分析源代码。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-208">An <see cref="T:System.CodeDom.Compiler.ICodeParser" /> that can be used to parse source code.</span>
          </span>
          <span data-ttu-id="e2fe2-209">此基实现总是返回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-209">The base implementation always returns <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProvider">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e2fe2-210">获取指定语言的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-210">Gets a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> instance for the specified language.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">
          <span data-ttu-id="e2fe2-211">语言名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-211">The language name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-212">获取指定语言的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-212">Gets a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> instance for the specified language.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-213">为指定语言名称实现的 CodeDOM 提供程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-213">A CodeDOM provider that is implemented for the specified language name.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-214">此方法通常用于应用程序可选择性地使用多个提供商之一中创建的代码提供程序实例。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-214">This method is most commonly used to create an instance of a code provider in an application that may optionally use one of several providers.</span></span> <span data-ttu-id="e2fe2-215"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> 可以在运行时指定你想要实例化的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-215"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> allows you to specify at run time the code provider you wish to instantiate.</span></span> <span data-ttu-id="e2fe2-216">如果你知道在哪个代码提供程序是要使用的设计时，你应创建的该代码提供程序实例而不使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-216">If you know at design time which code provider is to be used, you should create an instance of that code provider rather than use the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> method.</span></span>  
  
 <span data-ttu-id="e2fe2-217"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法返回<xref:System.CodeDom.Compiler.CodeDomProvider>实例特定的语言名称; 它是类似于调用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>与语言提供程序类型的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-217">The <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> method returns a <xref:System.CodeDom.Compiler.CodeDomProvider> instance for a specific language name; it is similar to calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method with the language provider type.</span></span> <span data-ttu-id="e2fe2-218">使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>如果想要动态找到的语言名称的配置的提供程序实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-218">Use <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> when you want to dynamically find a configured provider implementation for a language name.</span></span>  
  
 <span data-ttu-id="e2fe2-219">如果语言名称，为配置了多个提供程序实现<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>返回最后一个匹配的配置元素的提供程序实例。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-219">If more than one provider implementation is configured for the language name, <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> returns a provider instance for the last matching configuration element.</span></span>  
  
 <span data-ttu-id="e2fe2-220">使用<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType>方法重载时您希望特定语言提供程序实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-220">Use the <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> method overload when you want a specific language provider implementation.</span></span> <span data-ttu-id="e2fe2-221">例如，使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法以获取支持的语言名称的提供程序实例`"CSharp"`; 使用<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType>方法重载来获取专为提供程序实例<xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType>实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-221">For example, use the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> method to get a provider instance that supports the language name `"CSharp"`; use the <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> method overload to get a provider instance specifically for the <xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType> implementation.</span></span> <span data-ttu-id="e2fe2-222">应使用 [\]，CultureInfo、 对象\<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%2CSystem.Object%5B%5D%29?displayProperty=nameWithType > 如果你有多个为一种语言的代码提供程序并且您希望其实例化特定代码提供程序的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-222">You should use the [\], CultureInfo, Object\<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method if you have multiple code providers for a language and you desire to instantiate a specific code provider.</span></span>  
  
 <span data-ttu-id="e2fe2-223"><xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>方法检查是否至少一个提供程序实现支持特定语言。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-223">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> method checks whether at least one provider implementation supports a specific language.</span></span> <span data-ttu-id="e2fe2-224">你可以验证语言名称使用<xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>之前将其传递给<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-224">You can validate a language name using <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> before passing it to <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>.</span></span> <span data-ttu-id="e2fe2-225">如果你不受支持的语言将名称传递给<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A><xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>引发。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-225">If you pass an unsupported language name to <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> a <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> is thrown.</span></span>  
  
 <span data-ttu-id="e2fe2-226"><xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A>方法可以用于确定所有<xref:System.CodeDom.Compiler.CodeDomProvider>的计算机，包括开发人员和中标识的编译器供应商提供的其他实现上实现[ &lt;system.codedom&gt;元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)计算机配置文件 (Machine.config) 中。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-226">The <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> method can be used to determine all <xref:System.CodeDom.Compiler.CodeDomProvider> implementations on a computer, including additional implementations provided by developers and compiler vendors that are identified in the [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file (Machine.config).</span></span>  
  
 <span data-ttu-id="e2fe2-227"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法返回的实例<xref:System.CodeDom.Compiler.CodeDomProvider>特定语言的实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-227">The <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> method returns an instance of a <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for a specific language.</span></span>  
  
 <span data-ttu-id="e2fe2-228">语言名称不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-228">Language names are case-insensitive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2fe2-229">下面的代码示例确定<xref:System.CodeDom.Compiler.CodeDomProvider>输入的语言和显示语言提供程序的配置设置的实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-229">The following code example determines the <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for an input language and displays the configured settings for the language provider.</span></span> <span data-ttu-id="e2fe2-230">此代码示例摘自更大的示例为提供<xref:System.CodeDom.Compiler.CompilerInfo>类。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-230">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <span data-ttu-id="e2fe2-231">
            <paramref name="language" /> 在此计算机上没有已配置的提供程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-231">The <paramref name="language" /> does not have a configured provider on this computer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e2fe2-232">
            <paramref name="language" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-232">The <paramref name="language" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e2fe2-233">调用方没有所要求的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-233">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="e2fe2-234">直接调用方的完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-234">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e2fe2-235">此成员不能由部分信任的代码使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-235">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language, System.Collections.Generic.IDictionary&lt;string,string&gt; providerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; providerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String, providerOptions As IDictionary(Of String, String)) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ providerOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
        <Parameter Name="providerOptions" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="language">
          <span data-ttu-id="e2fe2-236">语言名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-236">The language name.</span>
          </span>
        </param>
        <param name="providerOptions">
          <span data-ttu-id="e2fe2-237">来自配置文件的提供程序选项的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-237">A collection of provider options from the configuration file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-238">获取指定的语言和提供程序选项的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-238">Gets a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> instance for the specified language and provider options.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-239">为指定语言名称和选项实现的 CodeDOM 提供程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-239">A CodeDOM provider that is implemented for the specified language name and options.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-240">此方法通常用于应用程序可选择性地使用多个提供商之一中创建的代码提供程序实例。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-240">This method is most commonly used to create an instance of a code provider in an application that may optionally use one of several providers.</span></span> <span data-ttu-id="e2fe2-241"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> 使用此选项可指定在运行时你想要实例化的代码提供程序的版本。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-241"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> enables you to specify at run time the version of the code provider you want to instantiate.</span></span> <span data-ttu-id="e2fe2-242">如果你知道在哪个代码提供程序是要使用的设计时，应创建而不是使用该代码提供程序实例的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-242">If you know at design time which code provider is to be used, you should create an instance of that code provider instead of using the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> method.</span></span>  
  
 <span data-ttu-id="e2fe2-243">使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29>如果想要动态查找特定的语言和选项的配置的提供程序实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-243">Use <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> when you want to dynamically find a configured provider implementation for a specific language and options.</span></span> <span data-ttu-id="e2fe2-244">语言名称不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-244">Language names are case-insensitive.</span></span> <span data-ttu-id="e2fe2-245">有关受支持的提供程序选项的信息，请参阅特定 CodeDOM 提供程序文档。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-245">For information about supported provider options, see the specific CodeDOM provider documentation.</span></span>  
  
 <span data-ttu-id="e2fe2-246">有关验证提供程序和调用提供程序，如果语言名称为配置了多个提供程序实现的信息，请参阅备注部分的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29>方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-246">For information about validating a provider and calling a provider if more than one provider implementation is configured for the language name, see the Remarks section of the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2fe2-247">下面的示例演示如何通过使用创建的提供程序实例`providerOptions`参数。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-247">The following example shows how to create an instance of a provider by using the `providerOptions` parameter.</span></span>  
  
 [!code-csharp[CodeDomProvider.ProviderOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/codedomprovider.provideroptions/cs/program.cs#1)]
 [!code-vb[CodeDomProvider.ProviderOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/codedomprovider.provideroptions/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateValidIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateValidIdentifier(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="e2fe2-248">要为其生成有效标识符的字符串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-248">The string for which to generate a valid identifier.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-249">为指定的值创建有效标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-249">Creates a valid identifier for the specified value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-250">指定值的有效标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-250">A valid identifier for the specified value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-251"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A> 测试是否与保留的标识符冲突或语言关键字和如果因此，尝试返回有效的标识符名称不冲突。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-251"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A> tests whether the identifier conflicts with reserved or language keywords, and if so, attempts to return a valid identifier name that does not conflict.</span></span> <span data-ttu-id="e2fe2-252">通常返回的标识符仅略有修改以使标识符与关键字; 区分开来例如，名称可能前面使用下划线 (_) 字符。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-252">Usually the returned identifier is only slightly modified to differentiate the identifier from the keyword; for example, the name might be preceded by the underscore ("_") character.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-253">在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-253">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="e2fe2-254">在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-254">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="e2fe2-255">如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-255">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="e2fe2-256">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-256">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-257">如果你重写此方法，你必须调用基类的对应方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-257">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="e2fe2-258">基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-258">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="e2fe2-259">基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-259">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="e2fe2-260">你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-260">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FileExtension">
      <MemberSignature Language="C#" Value="public virtual string FileExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileExtension" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FileExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FileExtension { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e2fe2-261">获取用于当前语言的源代码文件的默认文件扩展名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-261">Gets the default file name extension to use for source code files in the current language.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e2fe2-262">与当前语言的源文件扩展名相对应的文件扩展名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-262">A file name extension corresponding to the extension of the source files of the current language.</span>
          </span>
          <span data-ttu-id="e2fe2-263">此基实现总是返回 <see cref="F:System.String.Empty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-263">The base implementation always returns <see cref="F:System.String.Empty" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-264">代码生成器和代码编译器通过使用此属性以指示应生成还是使用哪些文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-264">This property is used by code generators and code compilers to indicate what file extensions should be generated or used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2fe2-265">下面的代码示例创建的实例<xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-265">The following code example creates an instance of <xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e2fe2-266">此示例显示提供程序名称、 哈希代码和默认文件扩展名为新的提供程序实例。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-266">The example displays the provider name, hash code and default file name extension for the new provider instance.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#3)]
 [!code-csharp[CodeDom_CompilerInfo#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#3)]
 [!code-vb[CodeDom_CompilerInfo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromCompileUnit">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromCompileUnit (System.CodeDom.CodeCompileUnit compileUnit, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromCompileUnit(class System.CodeDom.CodeCompileUnit compileUnit, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit(System.CodeDom.CodeCompileUnit,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromCompileUnit (compileUnit As CodeCompileUnit, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromCompileUnit(System::CodeDom::CodeCompileUnit ^ compileUnit, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compileUnit" Type="System.CodeDom.CodeCompileUnit" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="compileUnit">
          <span data-ttu-id="e2fe2-267">要为其生成代码的 <see cref="T:System.CodeDom.CodeCompileUnit" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-267">A <see cref="T:System.CodeDom.CodeCompileUnit" /> for which to generate code.</span>
          </span>
        </param>
        <param name="writer">
          <span data-ttu-id="e2fe2-268">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-268">The <see cref="T:System.IO.TextWriter" /> to which the output code is sent.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="e2fe2-269">
            <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-269">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-270">为指定的代码文档对象模型 (CodeDOM) 编译单元生成代码，并使用指定的选项将代码发送到指定的文本编写器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-270">Generates code for the specified Code Document Object Model (CodeDOM) compilation unit and sends it to the specified text writer, using the specified options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-271">在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-271">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="e2fe2-272">在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-272">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="e2fe2-273">如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-273">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2fe2-274">下面的代码示例演示了利用<xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A>方法来生成中的"Hello World"应用程序的代码<xref:System.CodeDom.CodeCompileUnit>。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-274">The following code example shows the use of the <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A> method to generate code for a "Hello World" application from a <xref:System.CodeDom.CodeCompileUnit>.</span></span> <span data-ttu-id="e2fe2-275">此示例摘自更大的示例为提供<xref:System.CodeDom.Compiler.CodeDomProvider>类。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-275">This example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CodeDomProvider> class.</span></span>  
  
 [!code-cpp[CodeDomExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#3)]
 [!code-vb[CodeDomExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="e2fe2-276">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-276">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-277">如果你重写此方法，你必须调用基类的对应方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-277">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="e2fe2-278">基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-278">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="e2fe2-279">基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-279">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="e2fe2-280">你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-280">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromExpression">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromExpression (System.CodeDom.CodeExpression expression, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromExpression(class System.CodeDom.CodeExpression expression, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromExpression(System.CodeDom.CodeExpression,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromExpression (expression As CodeExpression, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromExpression(System::CodeDom::CodeExpression ^ expression, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.CodeDom.CodeExpression" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="expression">
          <span data-ttu-id="e2fe2-281">一个 <see cref="T:System.CodeDom.CodeExpression" /> 对象，指示要为其生成代码的表达式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-281">A <see cref="T:System.CodeDom.CodeExpression" /> object that indicates the expression for which to generate code.</span>
          </span>
        </param>
        <param name="writer">
          <span data-ttu-id="e2fe2-282">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-282">The <see cref="T:System.IO.TextWriter" /> to which output code is sent.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="e2fe2-283">
            <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-283">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-284">为指定的代码文档对象模型 (CodeDOM) 表达式生成代码，并使用指定的选项将代码发送到指定的文本编写器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-284">Generates code for the specified Code Document Object Model (CodeDOM) expression and sends it to the specified text writer, using the specified options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-285">在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-285">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="e2fe2-286">在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-286">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="e2fe2-287">如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-287">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="e2fe2-288">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-288">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-289">如果你重写此方法，你必须调用基类的对应方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-289">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="e2fe2-290">基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-290">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="e2fe2-291">基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-291">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="e2fe2-292">你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-292">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromMember">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromMember (System.CodeDom.CodeTypeMember member, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromMember(class System.CodeDom.CodeTypeMember member, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember(System.CodeDom.CodeTypeMember,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromMember (member As CodeTypeMember, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromMember(System::CodeDom::CodeTypeMember ^ member, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.CodeDom.CodeTypeMember" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="member">
          <span data-ttu-id="e2fe2-293">一个 <see cref="T:System.CodeDom.CodeTypeMember" /> 对象，指示要为其生成代码的成员。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-293">A <see cref="T:System.CodeDom.CodeTypeMember" /> object that indicates the member for which to generate code.</span>
          </span>
        </param>
        <param name="writer">
          <span data-ttu-id="e2fe2-294">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-294">The <see cref="T:System.IO.TextWriter" /> to which output code is sent.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="e2fe2-295">
            <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-295">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-296">为指定的代码文档对象模型 (CodeDOM) 成员声明生成代码，并使用指定的选项将代码发送到指定的文本编写器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-296">Generates code for the specified Code Document Object Model (CodeDOM) member declaration and sends it to the specified text writer, using the specified options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-297">基类实现引发<xref:System.NotImplementedException>。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-297">The base class implementation throws a <xref:System.NotImplementedException>.</span></span> <span data-ttu-id="e2fe2-298">请参阅<xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType>文档描述此方法的实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-298">See <xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType> for documentation describing an implementation of this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2fe2-299">下面的代码示例演示了利用<xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A>方法的实施方式<xref:Microsoft.CSharp.CSharpCodeProvider>和<xref:Microsoft.VisualBasic.VBCodeProvider>类。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-299">The following code example shows the use of the <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A> method as implemented by the <xref:Microsoft.CSharp.CSharpCodeProvider> and <xref:Microsoft.VisualBasic.VBCodeProvider> classes.</span></span>  
  
 [!code-csharp[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/cs/program.cs#1)]
 [!code-vb[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="e2fe2-300">此方法不会在派生类中被重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-300">This method is not overridden in a derived class.</span>
          </span>
        </exception>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeMember" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromNamespace">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromNamespace (System.CodeDom.CodeNamespace codeNamespace, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromNamespace(class System.CodeDom.CodeNamespace codeNamespace, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromNamespace(System.CodeDom.CodeNamespace,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromNamespace(System::CodeDom::CodeNamespace ^ codeNamespace, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeNamespace" Type="System.CodeDom.CodeNamespace" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="codeNamespace">
          <span data-ttu-id="e2fe2-301">一个 <see cref="T:System.CodeDom.CodeNamespace" /> 对象，指示要为其生成代码的命名空间。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-301">A <see cref="T:System.CodeDom.CodeNamespace" /> object that indicates the namespace for which to generate code.</span>
          </span>
        </param>
        <param name="writer">
          <span data-ttu-id="e2fe2-302">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-302">The <see cref="T:System.IO.TextWriter" /> to which output code is sent.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="e2fe2-303">
            <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-303">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-304">为指定的代码文档对象模型 (CodeDOM) 命名空间生成代码，并使用指定的选项将代码发送到指定的文本编写器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-304">Generates code for the specified Code Document Object Model (CodeDOM) namespace and sends it to the specified text writer, using the specified options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-305">在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-305">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="e2fe2-306">在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-306">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="e2fe2-307">如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-307">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="e2fe2-308">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-308">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-309">如果你重写此方法，你必须调用基类的对应方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-309">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="e2fe2-310">基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-310">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="e2fe2-311">基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-311">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="e2fe2-312">你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-312">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeNamespace" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromStatement">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromStatement (System.CodeDom.CodeStatement statement, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromStatement(class System.CodeDom.CodeStatement statement, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromStatement(System.CodeDom.CodeStatement,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromStatement (statement As CodeStatement, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromStatement(System::CodeDom::CodeStatement ^ statement, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statement" Type="System.CodeDom.CodeStatement" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="statement">
          <span data-ttu-id="e2fe2-313">
            <see cref="T:System.CodeDom.CodeStatement" />，包含要为其生成代码的 CodeDOM 元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-313">A <see cref="T:System.CodeDom.CodeStatement" /> containing the CodeDOM elements for which to generate code.</span>
          </span>
        </param>
        <param name="writer">
          <span data-ttu-id="e2fe2-314">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-314">The <see cref="T:System.IO.TextWriter" /> to which output code is sent.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="e2fe2-315">
            <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-315">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-316">为指定的代码文档对象模型 (CodeDOM) 语句生成代码，并使用指定的选项将代码发送到指定的文本编写器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-316">Generates code for the specified Code Document Object Model (CodeDOM) statement and sends it to the specified text writer, using the specified options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-317">在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-317">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="e2fe2-318">在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-318">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="e2fe2-319">如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-319">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="e2fe2-320">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-320">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-321">如果你重写此方法，你必须调用基类的对应方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-321">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="e2fe2-322">基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-322">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="e2fe2-323">基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-323">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="e2fe2-324">你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-324">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeStatement" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromType">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromType (System.CodeDom.CodeTypeDeclaration codeType, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromType(class System.CodeDom.CodeTypeDeclaration codeType, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromType(System.CodeDom.CodeTypeDeclaration,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromType (codeType As CodeTypeDeclaration, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromType(System::CodeDom::CodeTypeDeclaration ^ codeType, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeType" Type="System.CodeDom.CodeTypeDeclaration" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Parameters>
      <Docs>
        <param name="codeType">
          <span data-ttu-id="e2fe2-325">一个 <see cref="T:System.CodeDom.CodeTypeDeclaration" /> 对象，指示要为其生成代码的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-325">A <see cref="T:System.CodeDom.CodeTypeDeclaration" /> object that indicates the type for which to generate code.</span>
          </span>
        </param>
        <param name="writer">
          <span data-ttu-id="e2fe2-326">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-326">The <see cref="T:System.IO.TextWriter" /> to which output code is sent.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="e2fe2-327">
            <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-327">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-328">为指定的代码文档对象模型 (CodeDOM) 类型声明生成代码，并使用指定的选项将代码发送到指定的文本编写器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-328">Generates code for the specified Code Document Object Model (CodeDOM) type declaration and sends it to the specified text writer, using the specified options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-329">在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-329">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="e2fe2-330">在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-330">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="e2fe2-331">如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-331">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="e2fe2-332">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-332">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-333">如果你重写此方法，你必须调用基类的对应方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-333">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="e2fe2-334">基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-334">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="e2fe2-335">基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-335">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="e2fe2-336">你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-336">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GetAllCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllCompilerInfo () As CompilerInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::CodeDom::Compiler::CompilerInfo ^&gt; ^ GetAllCompilerInfo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e2fe2-337">返回此计算机的语言提供程序和编译器配置设置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-337">Returns the language provider and compiler configuration settings for this computer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-338">一个 <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> 类型的数组，表示所有配置的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现的设置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-338">An array of type <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> representing the settings of all configured <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementations.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-339">使用<xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A>进行枚举在计算机上的语言提供程序设置方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-339">Use the <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> method to enumerate the language provider settings on a computer.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-340">在[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]，由.NET Framework 提供的默认语言提供程序中未指定[ &lt;system.codedom&gt;元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)编译器配置部分，不能删除，因此该方法返回有关默认的提供程序和任何配置文件中指定的信息。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-340">In the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], the default language providers supplied by the .NET Framework are not specified in the [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) compiler configuration section and cannot be removed, so this method returns information about the default providers and any specified in the configuration file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2fe2-341">下面的代码示例枚举计算机上的语言提供程序，并显示每个语言提供程序的配置和编译器设置。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-341">The following code example enumerates the language providers on the computer and displays the configuration and compiler settings for each language provider.</span></span> <span data-ttu-id="e2fe2-342">此代码示例摘自更大的示例为提供<xref:System.CodeDom.Compiler.CompilerInfo>类。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-342">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#8](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#8)]
 [!code-csharp[CodeDom_CompilerInfo#8](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#8)]
 [!code-vb[CodeDom_CompilerInfo#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e2fe2-343">调用方没有所要求的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-343">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="e2fe2-344">直接调用方的完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-344">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e2fe2-345">此成员不能由部分信任的代码使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-345">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo GetCompilerInfo (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo GetCompilerInfo(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompilerInfo (language As String) As CompilerInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CompilerInfo ^ GetCompilerInfo(System::String ^ language);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">
          <span data-ttu-id="e2fe2-346">语言名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-346">A language name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-347">返回指定语言的语言提供程序和编译器配置设置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-347">Returns the language provider and compiler configuration settings for the specified language.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-348">一个 <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> 对象，由已配置的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现的设置填充。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-348">A <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> object populated with settings of the configured <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-349">[ &lt;System.codedom&gt;元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)计算机配置文件包含每个语言提供程序和编译器配置设置<xref:System.CodeDom.Compiler.CodeDomProvider>计算机上的实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-349">The [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file contains the language provider and compiler configuration settings for each <xref:System.CodeDom.Compiler.CodeDomProvider> implementation on the computer.</span></span> <span data-ttu-id="e2fe2-350">有关计算机配置文件的信息，请参阅中的计算机配置文件部分[配置应用](http://msdn.microsoft.com/library/86bd26d3-737e-4484-9782-19b17f34cd1f)。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-350">For information about machine configuration files, see the Machine Configuration Files section in [Configuring Apps](http://msdn.microsoft.com/library/86bd26d3-737e-4484-9782-19b17f34cd1f).</span></span> <span data-ttu-id="e2fe2-351"><xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>方法搜索指定的语言名称每个提供程序配置元素。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-351">The <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> method searches each provider configuration element for the specified language name.</span></span> <span data-ttu-id="e2fe2-352">返回<xref:System.CodeDom.Compiler.CompilerInfo>实例包含配置的语言提供程序和编译器设置。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-352">The returned <xref:System.CodeDom.Compiler.CompilerInfo> instance contains the configured language provider and compiler settings.</span></span>  
  
 <span data-ttu-id="e2fe2-353"><xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>方法检查是否至少一个提供程序实现支持特定语言。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-353">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> method checks whether at least one provider implementation supports a specific language.</span></span> <span data-ttu-id="e2fe2-354">你可以验证语言名称使用<xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>之前将其传递给<xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-354">You can validate a language name using <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> before passing it to <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>.</span></span> <span data-ttu-id="e2fe2-355">这可防止引发<xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>访问时<xref:System.CodeDom.Compiler.CompilerInfo>不受支持的语言名称的实例。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-355">This prevents throwing a <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> when you access the <xref:System.CodeDom.Compiler.CompilerInfo> instance for an unsupported language name.</span></span>  
  
 <span data-ttu-id="e2fe2-356">如果为输入的语言名称配置了多个提供程序实现<xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>返回从最后一个匹配提供的设置配置元素。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-356">If more than one provider implementation is configured for the input language name, <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> returns the settings from the last matching provider configuration element.</span></span>  
  
 <span data-ttu-id="e2fe2-357">语言名称不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-357">Language names are case-insensitive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2fe2-358">下面的代码示例确定<xref:System.CodeDom.Compiler.CodeDomProvider>输入的语言和显示语言提供程序的配置设置的实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-358">The following code example determines the <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for an input language and displays the configured settings for the language provider.</span></span> <span data-ttu-id="e2fe2-359">此代码示例摘自更大的示例为提供<xref:System.CodeDom.Compiler.CompilerInfo>类。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-359">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">
          <span data-ttu-id="e2fe2-360">
            <paramref name="language" /> 在此计算机上没有已配置的提供程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-360">The <paramref name="language" /> does not have a configured provider on this computer.</span>
          </span>
        </exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <span data-ttu-id="e2fe2-361">
            <paramref name="language" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-361">The <paramref name="language" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e2fe2-362">调用方没有所要求的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-362">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="e2fe2-363">直接调用方的完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-363">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e2fe2-364">此成员不能由部分信任的代码使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-364">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="e2fe2-365">要为其检索类型转换器的对象类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-365">The type of object to retrieve a type converter for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-366">获取指定数据类型的 <see cref="T:System.ComponentModel.TypeConverter" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-366">Gets a <see cref="T:System.ComponentModel.TypeConverter" /> for the specified data type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-367">指定类型的 <see cref="T:System.ComponentModel.TypeConverter" />；如果无法找到指定类型的 <see cref="T:System.ComponentModel.TypeConverter" />，则为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-367">A <see cref="T:System.ComponentModel.TypeConverter" /> for the specified type, or <see langword="null" /> if a <see cref="T:System.ComponentModel.TypeConverter" /> for the specified type cannot be found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-368">派生的类可以重写此方法以针对特定数据类型提供特定类型的类型转换器。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-368">A derived class can override this method to provide specific types of type converters for specific data types.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetLanguageFromExtension">
      <MemberSignature Language="C#" Value="public static string GetLanguageFromExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetLanguageFromExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLanguageFromExtension (extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetLanguageFromExtension(System::String ^ extension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="extension">
          <span data-ttu-id="e2fe2-369">文件扩展名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-369">A file name extension.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-370">返回与指定文件扩展名关联的语言名称，如 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 编译器配置节中所配置的那样。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-370">Returns a language name associated with the specified file name extension, as configured in the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> compiler configuration section.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-371">与文件扩展名关联的语言名称，如 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 编译器配置设置中所配置的那样。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-371">A language name associated with the file name extension, as configured in the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> compiler configuration settings.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-372">[ &lt;System.codedom&gt;元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)计算机配置文件 (Machine.config) 包含每个语言提供程序和编译器配置设置<xref:System.CodeDom.Compiler.CodeDomProvider>上的实现计算机。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-372">The [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file (Machine.config) contains the language provider and compiler configuration settings for each <xref:System.CodeDom.Compiler.CodeDomProvider> implementation on the computer.</span></span> <span data-ttu-id="e2fe2-373"><xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>方法搜索指定的文件名称扩展每个提供程序配置元素。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-373">The <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> method searches each provider configuration element for the specified file name extension.</span></span>  
  
 <span data-ttu-id="e2fe2-374"><xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A>方法检查是否至少一个提供程序实现支持特定的文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-374">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> method checks whether at least one provider implementation supports a specific file name extension.</span></span> <span data-ttu-id="e2fe2-375">你可以验证文件名称扩展 using<xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A>之前将其传递给<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-375">You can validate a file name extension using <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> before passing it to <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>.</span></span> <span data-ttu-id="e2fe2-376">这可以防止<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>从引发<xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>不支持的文件名称扩展。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-376">This prevents <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> from throwing a <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> for an unsupported file name extension.</span></span>  
  
 <span data-ttu-id="e2fe2-377">如果提供程序实现支持的输入的文件扩展名，并且有多个受支持的语言为该提供程序，然后配置<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>返回该提供程序的第一个语言名称。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-377">If a provider implementation supports the input file name extension, and there are multiple supported languages configured for that provider, then <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> returns the first language name for that provider.</span></span> <span data-ttu-id="e2fe2-378">如果输入的文件扩展名，配置了多个提供程序实现<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>返回语言名称的最后一个匹配提供配置元素中。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-378">If more than one provider implementation is configured for the input file name extension, <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> returns the language name from the last matching provider configuration element.</span></span>  
  
 <span data-ttu-id="e2fe2-379">语言名称和文件扩展名不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-379">Language names and file name extensions are case-insensitive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2fe2-380">下面的代码示例确定<xref:System.CodeDom.Compiler.CodeDomProvider>输入的文件扩展名为显示语言提供程序的配置设置的实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-380">The following code example determines the <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for an input file name extension and displays the configured settings for the language provider.</span></span> <span data-ttu-id="e2fe2-381">此代码示例摘自更大的示例为提供<xref:System.CodeDom.Compiler.CompilerInfo>类。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-381">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">
          <span data-ttu-id="e2fe2-382">
            <paramref name="extension" /> 在此计算机上没有已配置的语言提供程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-382">The <paramref name="extension" /> does not have a configured language provider on this computer.</span>
          </span>
        </exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <span data-ttu-id="e2fe2-383">
            <paramref name="extension" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-383">The <paramref name="extension" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e2fe2-384">调用方没有所要求的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-384">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="e2fe2-385">直接调用方的完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-385">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e2fe2-386">此成员不能由部分信任的代码使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-386">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeOutput">
      <MemberSignature Language="C#" Value="public virtual string GetTypeOutput (System.CodeDom.CodeTypeReference type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeOutput(class System.CodeDom.CodeTypeReference type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetTypeOutput(System.CodeDom.CodeTypeReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeOutput (type As CodeTypeReference) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeOutput(System::CodeDom::CodeTypeReference ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.CodeDom.CodeTypeReference" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="e2fe2-387">指示返回类型的 <see cref="T:System.CodeDom.CodeTypeReference" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-387">A <see cref="T:System.CodeDom.CodeTypeReference" /> that indicates the type to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-388">获取由指定的 <see cref="T:System.CodeDom.CodeTypeReference" /> 指示的类型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-388">Gets the type indicated by the specified <see cref="T:System.CodeDom.CodeTypeReference" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-389">指定类型的文本表示形式，针对此代码生成器生成代码时所用的语言进行了格式设置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-389">A text representation of the specified type, formatted for the language in which code is generated by this code generator.</span>
          </span>
          <span data-ttu-id="e2fe2-390">例如，在 Visual Basic 中，为 <see cref="T:System.CodeDom.CodeTypeReference" /> 类型传入 <see cref="T:System.Int32" /> 将返回“Integer”。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-390">In Visual Basic, for example, passing in a <see cref="T:System.CodeDom.CodeTypeReference" /> for the <see cref="T:System.Int32" /> type will return "Integer".</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-391">在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-391">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="e2fe2-392">在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-392">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="e2fe2-393">如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-393">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="e2fe2-394">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-394">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-395">如果你重写此方法，你必须调用基类的对应方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-395">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="e2fe2-396">基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-396">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="e2fe2-397">基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-397">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="e2fe2-398">你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-398">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedExtension">
      <MemberSignature Language="C#" Value="public static bool IsDefinedExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedExtension (extension As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedExtension(System::String ^ extension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="extension">
          <span data-ttu-id="e2fe2-399">文件扩展名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-399">A file name extension.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-400">测试文件扩展名是否在计算机上配置了关联的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-400">Tests whether a file name extension has an associated <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementation configured on the computer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-401">如果为指定的文件扩展名配置了 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现，则为 <see langword="true" />；否则，为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-401">
              <see langword="true" /> if a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementation is configured for the specified file name extension; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-402">[ &lt;System.codedom&gt;元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)计算机配置文件 (Machine.config) 包含每个语言提供程序和编译器配置设置<xref:System.CodeDom.Compiler.CodeDomProvider>上的实现计算机。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-402">The [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file (Machine.config) contains the language provider and compiler configuration settings for each <xref:System.CodeDom.Compiler.CodeDomProvider> implementation on the computer.</span></span> <span data-ttu-id="e2fe2-403"><xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A>方法搜索指定的文件扩展名的提供程序配置元素。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-403">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> method searches the provider configuration elements for the specified file name extension.</span></span>  
  
 <span data-ttu-id="e2fe2-404">文件扩展名不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-404">File name extensions are case-insensitive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2fe2-405">下面的代码示例确定<xref:System.CodeDom.Compiler.CodeDomProvider>输入的文件扩展名为显示语言提供程序的配置设置的实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-405">The following code example determines the <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for an input file name extension and displays the configured settings for the language provider.</span></span> <span data-ttu-id="e2fe2-406">此代码示例摘自更大的示例为提供<xref:System.CodeDom.Compiler.CompilerInfo>类。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-406">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e2fe2-407">
            <paramref name="extension" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-407">The <paramref name="extension" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e2fe2-408">调用方没有所要求的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-408">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="e2fe2-409">直接调用方的完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-409">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e2fe2-410">此成员不能由部分信任的代码使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-410">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefinedLanguage">
      <MemberSignature Language="C#" Value="public static bool IsDefinedLanguage (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedLanguage(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedLanguage (language As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedLanguage(System::String ^ language);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="language">
          <span data-ttu-id="e2fe2-411">语言名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-411">The language name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-412">测试某语言是否已在计算机上配置了 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-412">Tests whether a language has a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementation configured on the computer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-413">如果为指定语言配置了 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现，则为 <see langword="true" />；否则，为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-413">
              <see langword="true" /> if a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementation is configured for the specified language; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-414">[ &lt;System.codedom&gt;元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)计算机配置文件 (Machine.config) 包含每个语言提供程序和编译器配置设置<xref:System.CodeDom.Compiler.CodeDomProvider>上的实现计算机。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-414">The [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file (Machine.config) contains the language provider and compiler configuration settings for each <xref:System.CodeDom.Compiler.CodeDomProvider> implementation on the computer.</span></span> <span data-ttu-id="e2fe2-415"><xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>方法搜索指定的语言名称的提供程序配置元素。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-415">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> method searches the provider configuration elements for the specified language name.</span></span>  
  
 <span data-ttu-id="e2fe2-416">语言名称不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-416">Language names are case-insensitive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2fe2-417">下面的代码示例确定<xref:System.CodeDom.Compiler.CodeDomProvider>输入的语言和显示语言提供程序的配置设置的实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-417">The following code example determines the <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for an input language and displays the configured settings for the language provider.</span></span> <span data-ttu-id="e2fe2-418">此代码示例摘自更大的示例为提供<xref:System.CodeDom.Compiler.CompilerInfo>类。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-418">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e2fe2-419">
            <paramref name="language" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-419">The <paramref name="language" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e2fe2-420">调用方没有所要求的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-420">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="e2fe2-421">直接调用方的完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-421">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e2fe2-422">此成员不能由部分信任的代码使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-422">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual bool IsValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsValidIdentifier (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsValidIdentifier(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="e2fe2-423">要验证为一个有效标识符的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-423">The value to verify as a valid identifier.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-424">返回一个值，该值指示指定的值是否是当前语言的有效标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-424">Returns a value that indicates whether the specified value is a valid identifier for the current language.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-425">如果 <paramref name="value" /> 参数是有效标识符，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-425">
              <see langword="true" /> if the <paramref name="value" /> parameter is a valid identifier; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-426">此方法测试标识符是否有效。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-426">This method tests whether an identifier is valid.</span></span> <span data-ttu-id="e2fe2-427"><xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A>方法是特定于提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-427">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A> method is provider specific.</span></span> <span data-ttu-id="e2fe2-428">一个提供程序对有效的标识符可能不是有效的其他提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-428">Identifiers that are valid for one provider might not be valid for other providers.</span></span> <span data-ttu-id="e2fe2-429">如果`value`包含字符的 ASCII 字符范围，之外检查可能用于编译代码的所有语言的标识符。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-429">If `value` contains characters outside of the ASCII character range, check the identifier for all the languages that might be used to compile the code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-430">在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-430">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="e2fe2-431">在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-431">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="e2fe2-432">如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-432">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="e2fe2-433">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-433">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-434">在重写<see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />在派生类中，设计该方法以返回<see langword="true" />只有值符合语言的规则，并且不与关键字冲突。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-434">When overriding <see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" /> in a derived class, design the method to return <see langword="true" /> only if the value fits the rules of the language and does not conflict with a keyword.</span>
            </span>
            <span data-ttu-id="e2fe2-435">如果你重写此方法，你必须调用基类的对应方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-435">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="e2fe2-436">基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-436">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="e2fe2-437">基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-437">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="e2fe2-438">你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-438">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LanguageOptions">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.LanguageOptions LanguageOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.CodeDom.Compiler.LanguageOptions LanguageOptions" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LanguageOptions As LanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::CodeDom::Compiler::LanguageOptions LanguageOptions { System::CodeDom::Compiler::LanguageOptions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.LanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e2fe2-439">获取语言功能标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-439">Gets a language features identifier.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e2fe2-440">指示语言的特殊功能的 <see cref="T:System.CodeDom.Compiler.LanguageOptions" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-440">A <see cref="T:System.CodeDom.Compiler.LanguageOptions" /> that indicates special features of the language.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.CodeCompileUnit Parse (System.IO.TextReader codeStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.CodeCompileUnit Parse(class System.IO.TextReader codeStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Parse(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Parse (codeStream As TextReader) As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::CodeCompileUnit ^ Parse(System::IO::TextReader ^ codeStream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeStream" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="codeStream">
          <span data-ttu-id="e2fe2-441">用于读取待分析代码的 <see cref="T:System.IO.TextReader" /> 对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-441">A <see cref="T:System.IO.TextReader" /> object that is used to read the code to be parsed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e2fe2-442">将从指定文本流读取的代码编译进 <see cref="T:System.CodeDom.CodeCompileUnit" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-442">Compiles the code read from the specified text stream into a <see cref="T:System.CodeDom.CodeCompileUnit" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-443">
            <see cref="T:System.CodeDom.CodeCompileUnit" />，包含已分析代码的表示形式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-443">A <see cref="T:System.CodeDom.CodeCompileUnit" /> that contains a representation of the parsed code.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-444">在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeParser>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A>的提供程序的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-444">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeParser> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A> method of the provider.</span></span> <span data-ttu-id="e2fe2-445">在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-445">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="e2fe2-446">如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeParser>供基类调用实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-446">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeParser> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="e2fe2-447">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-447">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-448">如果你重写此方法，你必须调用基类的对应方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-448">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="e2fe2-449">基类方法使用过时的派生类中创建一个分析器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />与预先存在的提供程序使用代码分析程序的兼容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-449">The base-class method creates a parser in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" /> method for compatibility with preexisting providers that use code parsers.</span>
            </span>
            <span data-ttu-id="e2fe2-450">基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeParser" />实现来执行此功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-450">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeParser" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="e2fe2-451">你将获得<see cref="T:System.NotImplementedException" />如果从代码提供程序不使用代码分析器调用基类方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-451">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code parser.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.IO.TextReader" />
      </Docs>
    </Member>
    <Member MemberName="Supports">
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport generatorSupport) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport supports) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" FrameworkAlternate="xamarinmac-3.0;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generatorSupport" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="supports" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generatorSupport">To be added.</param>
        <param name="supports">To be added.</param>
        <summary>
          <span data-ttu-id="e2fe2-452">返回一个值，该值指示是否提供了指定的代码生成支持。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-452">Returns a value indicating whether the specified code generation support is provided.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e2fe2-453">如果提供了指定的代码生成支持，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-453">
              <see langword="true" /> if the specified code generation support is provided; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2fe2-454">此方法可以调用的数量<xref:System.CodeDom.Compiler.GeneratorSupport>标志一次以一组的功能测试方法加入一组以及二进制文件的相应功能标志`OR`运算符 (&#124;)。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-454">This method can be called with a number of <xref:System.CodeDom.Compiler.GeneratorSupport> flags at once to test for a set of capabilities by joining a set of appropriate capability flags together with a binary `OR` operator (&#124;).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e2fe2-455">在.NET framework 1.0 和 1.1 版中，此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>实现返回<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>的提供程序的方法。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-455">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="e2fe2-456">在 2.0 版中，此方法可以调用的代码提供程序上直接即使它不被覆盖的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-456">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="e2fe2-457">如果代码提供程序不重写此方法，<xref:System.CodeDom.Compiler.ICodeGenerator>供基类调用实现。</span><span class="sxs-lookup"><span data-stu-id="e2fe2-457">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="e2fe2-458">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e2fe2-458">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e2fe2-459">如果你重写此方法，你必须调用基类的对应方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-459">If you override this method, you must not call the corresponding method of the base class.</span>
            </span>
            <span data-ttu-id="e2fe2-460">基类方法使用过时的派生类中创建的生成器<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />与预先存在的提供程序使用代码生成器的兼容性的方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-460">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span>
            </span>
            <span data-ttu-id="e2fe2-461">基类方法然后调用中的等效方法<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现来执行此功能。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-461">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span>
            </span>
            <span data-ttu-id="e2fe2-462">你将获得<see cref="T:System.NotImplementedException" />如果不使用代码生成器的代码提供调用基类方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e2fe2-462">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
      </Docs>
    </Member>
  </Members>
</Type>