<Type Name="MemoryStream" FullName="System.IO.MemoryStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="02ca3cbe99f600c2f813c7c537dac714efc08b5b" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31910955" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MemoryStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit MemoryStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.MemoryStream" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryStream : System::IO::Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>创建一个流，其后备存储为内存。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 流的当前位置是在其下一步读取或写入操作的位置可能发生的位置。 可以检索当前的位置，或将其设置通过<xref:System.IO.MemoryStream.Seek%2A>方法。 新实例时<xref:System.IO.MemoryStream>创建的当前位置设置为零。  
  
[!INCLUDE[note_unnecessary_dispose](~/includes/note-unnecessary-dispose.md)]
  
 创建与非无符号的字节数组的内存流提供非可调整大小的数据的流。 在使用字节数组时，你不能将追加到或收缩流，尽管你可能能够修改的现有内容，具体取决于传递到构造函数的参数。 空内存流进行大小调整，和可以写入和读取。  
  
 如果<xref:System.IO.MemoryStream>对象添加到 ResX 文件或.resources 文件，请调用<xref:System.Resources.ResourceManager.GetStream%2A>方法在运行时来检索该值。  
  
 如果<xref:System.IO.MemoryStream>对象进行序列化到的资源文件，它实际上将序列化为<xref:System.IO.UnmanagedMemoryStream>。 此行为提供更好的性能，以及能够直接，而无需经历获取指向数据的指针<xref:System.IO.Stream>方法。  
  
   
  
## Examples  
 下面的代码示例演示如何读取和写入内存使用作为后备存储的数据。  
  
 [!code-cpp[System.IO.MemoryStream#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#1)]
 [!code-csharp[System.IO.MemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#1)]
 [!code-vb[System.IO.MemoryStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.IO.MemoryStream" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>使用初始化为零的可扩展容量初始化 <see cref="T:System.IO.MemoryStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.MemoryStream.CanRead%2A>， <xref:System.IO.MemoryStream.CanSeek%2A>，和<xref:System.IO.MemoryStream.CanWrite%2A>属性都设置为`true`。  
  
 当前流的容量会自动增加了当你使用<xref:System.IO.MemoryStream.SetLength%2A>方法以将长度设置为值大于当前流的容量。  
  
 此构造函数将公开基础流处理时，其<xref:System.IO.MemoryStream.GetBuffer%2A>返回。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">从中创建当前流的无符号字节数组。</param>
        <summary>基于指定的字节数组初始化 <see cref="T:System.IO.MemoryStream" /> 类的无法调整大小的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.MemoryStream.CanRead%2A>， <xref:System.IO.MemoryStream.CanSeek%2A>，和<xref:System.IO.MemoryStream.CanWrite%2A>属性都设置为`true`。 <xref:System.IO.MemoryStream.Capacity%2A> 设置为指定的字节数组的长度。 新的流可以写入，但不可调整大小。  
  
 流的长度不能设置为一个值大于指定的字节数组中; 的初始长度但是，可以截断流 (请参阅<xref:System.IO.MemoryStream.SetLength%2A>)。  
  
 此构造函数不公开基础流。 <xref:System.IO.MemoryStream.GetBuffer%2A> 引发<xref:System.UnauthorizedAccessException>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">内部数组的初始大小（以字节为单位）。</param>
        <summary>使用按指定要求初始化的可扩展容量初始化 <see cref="T:System.IO.MemoryStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.MemoryStream.CanRead%2A>， <xref:System.IO.MemoryStream.CanSeek%2A>，和<xref:System.IO.MemoryStream.CanWrite%2A>属性都设置为`true`。  
  
 使用时将自动增加容量<xref:System.IO.MemoryStream.SetLength%2A>方法以将长度设置为值大于当前流的容量。 除`MemoryStream`使用 byte [] 参数构造的写入操作的末尾`MemoryStream`展开`MemoryStream`。  
  
 此构造函数将公开基础流<xref:System.IO.MemoryStream.GetBuffer%2A>返回。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.MemoryStream>类。  
  
 [!code-cpp[System.IO.MemoryStream#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#2)]
 [!code-csharp[System.IO.MemoryStream#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#2)]
 [!code-vb[System.IO.MemoryStream#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> 为负数。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), writable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, bool writable);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer">从中创建此流的无符号字节的数组。</param>
        <param name="writable">
          <see cref="P:System.IO.MemoryStream.CanWrite" /> 属性的设置，确定该流是否支持写入。</param>
        <summary>在 <see cref="P:System.IO.MemoryStream.CanWrite" /> 属性按指定设置的状态下，基于指定的字节数组初始化 <see cref="T:System.IO.MemoryStream" /> 类的无法调整大小的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.MemoryStream.CanRead%2A>和<xref:System.IO.MemoryStream.CanSeek%2A>属性都设置为`true`。 <xref:System.IO.MemoryStream.Capacity%2A> 设置为指定的字节数组的长度。  
  
 流的长度不能设置为一个值大于指定的字节数组中; 的初始长度但是，可以截断流 (请参阅<xref:System.IO.MemoryStream.SetLength%2A>)。  
  
 此构造函数不公开基础流。 <xref:System.IO.MemoryStream.GetBuffer%2A> 引发<xref:System.UnauthorizedAccessException>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">从中创建此流的无符号字节的数组。</param>
        <param name="index">
          <c>buffer</c> 内的索引，流从此处开始。</param>
        <param name="count">流的长度（以字节为单位）。</param>
        <summary>基于字节数组的指定区域（索引）初始化 <see cref="T:System.IO.MemoryStream" /> 类的无法调整大小的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.MemoryStream.CanRead%2A>， <xref:System.IO.MemoryStream.CanSeek%2A>，和<xref:System.IO.MemoryStream.CanWrite%2A>属性都设置为`true`，但不能更改容量。 将 <xref:System.IO.MemoryStream.Capacity%2A> 设置为 `count`。  
  
 流的长度不能设置为一个值大于指定的字节数组中; 的初始长度但是，可以截断流 (请参阅<xref:System.IO.MemoryStream.SetLength%2A>)。  
  
 此构造函数不公开基础流。 <xref:System.IO.MemoryStream.GetBuffer%2A> 引发<xref:System.UnauthorizedAccessException>。 但是，你可以写入到流。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer, writable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count, bool writable);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer">从中创建此流的无符号字节的数组。</param>
        <param name="index">
          <c>buffer</c> 内的索引，流从此处开始。</param>
        <param name="count">流的长度（以字节为单位）。</param>
        <param name="writable">
          <see cref="P:System.IO.MemoryStream.CanWrite" /> 属性的设置，确定该流是否支持写入。</param>
        <summary>在 <see cref="P:System.IO.MemoryStream.CanWrite" /> 属性按指定设置的状态下，基于字节数组的指定区域，初始化 <see cref="T:System.IO.MemoryStream" /> 类的无法调整大小的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.MemoryStream.CanRead%2A>和<xref:System.IO.MemoryStream.CanSeek%2A>属性都设置为`true`。 将 <xref:System.IO.MemoryStream.Capacity%2A> 设置为 `count`。  
  
 流的长度不能设置为一个值大于指定的字节数组中; 的初始长度但是，可以截断流 (请参阅<xref:System.IO.MemoryStream.SetLength%2A>)。  
  
 此构造函数不公开基础流。 <xref:System.IO.MemoryStream.GetBuffer%2A> 引发<xref:System.UnauthorizedAccessException>。 但是，你可以写入到流如果`writable`是`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 为负。</exception>
        <exception cref="T:System.ArgumentException">缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable, bool publiclyVisible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer, writable As Boolean, publiclyVisible As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
        <Parameter Name="publiclyVisible" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer">从中创建此流的无符号字节的数组。</param>
        <param name="index">
          <c>buffer</c> 内的索引，流从此处开始。</param>
        <param name="count">流的长度（以字节为单位）。</param>
        <param name="writable">
          <see cref="P:System.IO.MemoryStream.CanWrite" /> 属性的设置，确定该流是否支持写入。</param>
        <param name="publiclyVisible">
          设置为 <see langword="true" /> 可以启用 <see cref="M:System.IO.MemoryStream.GetBuffer" />，它返回无符号字节数组，流从该数组创建；否则为 <see langword="false" />。</param>
        <summary>在 <see cref="P:System.IO.MemoryStream.CanWrite" /> 属性和调用 <see cref="M:System.IO.MemoryStream.GetBuffer" /> 的能力按指定设置的状态下，基于字节数组的指定区域初始化 <see cref="T:System.IO.MemoryStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.MemoryStream.CanRead%2A>和<xref:System.IO.MemoryStream.CanSeek%2A>属性都设置为`true`。 将 <xref:System.IO.MemoryStream.Capacity%2A> 设置为 `count`。  
  
 新的流实例都可以写入，但<xref:System.IO.MemoryStream.Capacity%2A>不能更改基础字节数组。 流的长度不能设置为一个值大于指定的字节数组中; 的初始长度但是，可以截断流 (请参阅<xref:System.IO.MemoryStream.SetLength%2A>)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 为负数。</exception>
        <exception cref="T:System.ArgumentException">缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前流是否支持读取。</summary>
        <value>
          如果流是打开的，则为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果从派生的类<xref:System.IO.Stream>不支持读取，则调用<xref:System.IO.MemoryStream.Read%2A>和<xref:System.IO.MemoryStream.ReadByte%2A>方法将引发<xref:System.NotSupportedException>。  
  
 如果流已关闭，则此属性返回`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前流是否支持查找。</summary>
        <value>
          如果流是打开的，则为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果从派生的类<xref:System.IO.Stream>不支持查找，则调用<xref:System.IO.MemoryStream.Length%2A>， <xref:System.IO.MemoryStream.SetLength%2A>， <xref:System.IO.MemoryStream.Position%2A>，和<xref:System.IO.MemoryStream.Seek%2A>引发<xref:System.NotSupportedException>。  
  
 如果流已关闭，则此属性返回`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前流是否支持写入。</summary>
        <value>
          如果流支持写入，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果从派生的类<xref:System.IO.Stream>不支持写入，调用<xref:System.IO.Stream.SetLength%2A>， <xref:System.IO.Stream.Write%2A>，或<xref:System.IO.Stream.WriteByte%2A>引发<xref:System.NotSupportedException>。  
  
 如果流已关闭，则此属性返回`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置分配给该流的字节数。</summary>
        <value>流的缓冲区的可使用部分的长度。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Capacity` 是系统提供的字节数组的缓冲区长度。 `Capacity` 不能设置为小于当前流的长度的值。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.MemoryStream>类。  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">容量设置为负或小于流的当前长度。</exception>
        <exception cref="T:System.ObjectDisposedException">当前流已关闭。</exception>
        <exception cref="T:System.NotSupportedException">
          对不能修改其容量的流调用 <see langword="set" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public override void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bufferSize">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">当前流的内容将复制到的流。</param>
        <param name="bufferSize">缓冲区的大小（以字节为单位）。 此值必须大于零。</param>
        <param name="cancellationToken">要监视取消请求的标记。</param>
        <summary>使用指定的缓冲区大小和取消令牌，从当前流中异步读取所有字节并将其写入到另一个流中。</summary>
        <returns>表示异步复制操作的任务。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="buffersize" /> 为负数或零。</exception>
        <exception cref="T:System.ObjectDisposedException">当前流或目标流已释放。</exception>
        <exception cref="T:System.NotSupportedException">当前流不支持阅读，或目标流不支持写入。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放 <see cref="T:System.IO.MemoryStream" /> 类使用的非托管资源，并可以选择释放托管资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法称为由公共<xref:System.ComponentModel.Component.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。 <xref:System.ComponentModel.Component.Dispose%2A> 调用受保护<xref:System.IO.MemoryStream.Dispose%2A>方法替换`disposing`参数设置为`true`。 <xref:System.Object.Finalize%2A> 调用<xref:System.IO.MemoryStream.Dispose%2A>与`disposing`设置为`false`。  
  
 当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.IO.MemoryStream> 引用的、由任何托管对象持有的全部资源。 此方法调用每个引用对象的 <xref:System.ComponentModel.Component.Dispose%2A> 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> 可以由其他对象多次调用。 在重写<see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />请注意不要引用已释放的以前调用中的对象<see cref="M:System.ComponentModel.Component.Dispose" />。 有关如何实现详细信息<see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />，请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
 有关详细信息<see cref="M:System.ComponentModel.Component.Dispose" />和<see cref="M:System.Object.Finalize" />，请参阅[清洗向上非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重写 <see cref="M:System.IO.Stream.Flush" /> 方法以便不执行任何操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将替代<xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>方法。  
  
 因为写入到的任何数据<xref:System.IO.MemoryStream>对象写入到 RAM，此方法是冗余。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">要监视取消请求的标记。</param>
        <summary>异步清除此流的所有缓冲区，并监视取消请求。</summary>
        <returns>表示异步刷新操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因为写入到的任何数据<xref:System.IO.MemoryStream>对象写入到 RAM，此方法是冗余。  
  
 如果在完成之前，将取消该操作，返回的任务包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>属性。  
  
 你可以通过创建的实例创建一个取消标记<xref:System.Threading.CancellationTokenSource>类并传入<xref:System.Threading.CancellationTokenSource.Token%2A>属性作为`cancellationToken`参数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">已释放流。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBuffer">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.GetBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBuffer () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBuffer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回从中创建此流的无符号字节的数组。</summary>
        <returns>创建此流所用的字节数组；或者如果在当前实例的构造期间没有向 <see cref="T:System.IO.MemoryStream" /> 构造函数提供字节数组，则为基础数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，该缓冲区包含分配的字节数，这可能是未使用。 例如，如果"test"的字符串写入到<xref:System.IO.MemoryStream>对象、 从返回的缓冲区的长度<xref:System.IO.MemoryStream.GetBuffer%2A>为 256，而不 4，其中有 252 个字节未使用。 若要获取仅缓冲区中的数据，请使用<xref:System.IO.MemoryStream.ToArray%2A>方法; 但是，<xref:System.IO.MemoryStream.ToArray%2A>在内存中创建的数据副本。  
  
 也可以是缓冲区`null`。  
  
 若要创建`MemoryStream`使用公开可见的缓冲区，使用的实例<xref:System.IO.MemoryStream.%23ctor%2A>， <xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29>，或<xref:System.IO.MemoryStream.%23ctor%28System.Int32%29>。 如果当前流已调整大小，两次调用此方法如果基础字节数组的大小调整调用之间不会返回相同的阵列。 有关附加信息，请参见 <xref:System.IO.MemoryStream.Capacity%2A>。  
  
> [!NOTE]
>  当内存流已关闭时，此方法有效。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">未使用公共可见缓冲区创建 <see langword="MemoryStream" /> 的实例。</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取流的长度（以字节为单位）。</summary>
        <value>流的长度（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.MemoryStream>类。  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置流中的当前位置。</summary>
        <value>流中的当前位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.MemoryStream>类。  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">此位置设置为负值或大于 <see cref="F:System.Int32.MaxValue" /> 的值。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">此方法返回时，该缓冲区包含指定的字节数组，该数组的 <c>offset</c> 和 (<c>offset</c> + <c>count</c> - 1) 之间的值替换为从当前源中读取的字节。</param>
        <param name="offset">
          <c>buffer</c> 中的从零开始的字节偏移量，从此处开始存储当前流中的数据。</param>
        <param name="count">最多读取的字节数。</param>
        <summary>从当前流中读取字节块并将数据写入缓冲区。</summary>
        <returns>写入缓冲区中的总字节数。 如果字节数当前不可用，则总字节数可能小于所请求的字节数；如果在读取到任何字节前已到达流结尾，则为零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.IO.Stream.Read%2A>。  
  
 `offset`参数指定了中的第一个字节的偏移量`buffer`写入当前流中的数据到。 `count`参数提供的最大若要从当前流中读取的字节数。 如果已到达流结尾，则返回的值是实际数字节，则为零。  
  
 如果读取的操作成功，流中的当前位置向前移动读取的字节数。 如果发生异常，将流中的当前位置保持不变。  
  
 `Read`方法将返回零，仅当已到达流结尾。 在所有其他情况下，`Read`始终至少 1 个字节从流中读取在返回之前。 根据定义，如果不会提供数据时调用流中`Read`、`Read`方法返回的零 （自动到达流结尾）。 实现可以自由地返回少于所请求的字节，即使尚未达到流结尾。  
  
 使用<xref:System.IO.BinaryReader>读取基元数据类型。  
  
> [!CAUTION]
>  如果在中指定的字节数组`buffer`参数是由基础缓冲区<xref:System.IO.MemoryStream.GetBuffer%2A>方法，将覆盖的数组内容，并不会引发异常。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.MemoryStream>类。  
  
 [!code-cpp[System.IO.MemoryStream#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#7)]
 [!code-csharp[System.IO.MemoryStream#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#7)]
 [!code-vb[System.IO.MemoryStream#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="count" /> 为负数。</exception>
        <exception cref="T:System.ArgumentException">
          缓冲区长度减去 <paramref name="offset" /> 的结果小于 <paramref name="count" />。</exception>
        <exception cref="T:System.ObjectDisposedException">当前流实例已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; destination, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; destination, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Memory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">数据写入的缓冲区。</param>
        <param name="offset">
          <c>buffer</c> 中的字节偏移量，从该偏移量开始写入流中的数据。</param>
        <param name="count">最多读取的字节数。</param>
        <param name="cancellationToken">要监视取消请求的标记。 默认值为 <see cref="P:System.Threading.CancellationToken.None" />。</param>
        <summary>从当前流异步读取字节的序列，将流中的位置提升读取的字节数，并监视取消请求。</summary>
        <returns>表示异步读取操作的任务。 <paramref name="TResult" /> 参数的值包含读入缓冲区的总字节数。 如果当前可用字节数少于所请求的字节数，则该结果值可小于所请求的字节数；如果已到达流结尾时，则为 0（零）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在完成之前，将取消该操作，返回的任务包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>属性。  
  
 你可以通过创建的实例创建一个取消标记<xref:System.Threading.CancellationTokenSource>类并传入<xref:System.Threading.CancellationTokenSource.Token%2A>属性作为`cancellationToken`参数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="count" /> 为负数。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</exception>
        <exception cref="T:System.NotSupportedException">流不支持读取。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放流。</exception>
        <exception cref="T:System.InvalidOperationException">之前的读取操作当前正在使用流。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前流中读取一个字节。</summary>
        <returns>强制转换为 <see cref="T:System.Int32" /> 的字节；或者如果已到达流的末尾，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.IO.Stream.ReadByte%2A>。  
  
 如果读取的操作成功，将流中的当前位置被高级 1 个字节。 如果发生异常，将流中当前的位置不变。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.MemoryStream>类。  
  
 [!code-cpp[System.IO.MemoryStream#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#8)]
 [!code-csharp[System.IO.MemoryStream#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#8)]
 [!code-vb[System.IO.MemoryStream#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">当前流实例已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, loc As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin loc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="loc" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">流内的新位置。 它是相对于 <c>loc</c> 参数的位置，而且可正可负。</param>
        <param name="loc">类型 <see cref="T:System.IO.SeekOrigin" /> 的值，它用作查找引用点。</param>
        <summary>将当前流中的位置设置为指定值。</summary>
        <returns>流内的新位置，通过将初始引用点和偏移量合并计算而得。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>。  
  
 支持查找到流的长度超出任何位置。  
  
 不要使用<xref:System.IO.MemoryStream.Seek%2A>方法，以确定流中的新位置，如果<xref:System.IO.MemoryStream>使用非零偏移量初始化的。 如果这样做，<xref:System.IO.MemoryStream.Seek%2A>将返回了不准确值。 请改用<xref:System.IO.MemoryStream.Position%2A>属性以获取流的新位置。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.MemoryStream>类。  
  
 [!code-cpp[System.IO.MemoryStream#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#6)]
 [!code-csharp[System.IO.MemoryStream#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#6)]
 [!code-vb[System.IO.MemoryStream#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">试图在流的开始位置之前进行查找。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.IO.SeekOrigin" /> 无效。  
  
 或  
  
 <paramref name="offset" /> 导致算法溢出。</exception>
        <exception cref="T:System.ObjectDisposedException">当前流实例已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">用于设置长度的值。</param>
        <summary>将当前流的长度设为指定值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.IO.Stream.SetLength%2A>。  
  
 如果指定的值小于当前流的长度，则流将被截断。 如果截断后流中的当前位置是末尾的流，<xref:System.IO.MemoryStream.ReadByte%2A>方法返回-1，<xref:System.IO.MemoryStream.Read%2A>方法读取到提供的字节数组中，零字节和<xref:System.IO.MemoryStream.Write%2A>和<xref:System.IO.MemoryStream.WriteByte%2A>方法追加在流结尾，增加其长度的指定字节数。 如果指定的值大于当前容量并且流可进行调整，增加容量，并将流中的当前位置保持不变。 如果长度增加，旧和新的长度之间流的内容将初始化为零。  
  
> [!NOTE]
>  A<xref:System.IO.MemoryStream>实例必须支持此方法可工作的写入。 使用<xref:System.IO.MemoryStream.CanWrite%2A>属性来确定当前实例是否支持写入。 有关附加信息，请参见 <xref:System.IO.Stream.CanWrite%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">当前流无法调整大小，而且 <paramref name="value" /> 大于当前容量。  
  
 或  
  
 当前流不支持写入。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> 为负或者大于 <see cref="T:System.IO.MemoryStream" /> 的最大长度，其中最大长度为 (<see cref="F:System.Int32.MaxValue" />- origin)，origin 为基础缓冲区中作为流的起点的索引。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual byte[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ToArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将流内容写入字节数组，而与 <see cref="P:System.IO.MemoryStream.Position" /> 属性无关。</summary>
        <returns>新的字节数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法中省略<xref:System.IO.MemoryStream>从数组。 若要获取整个缓冲区，使用<xref:System.IO.MemoryStream.GetBuffer%2A>方法。  
  
 此方法返回的内容的副本<xref:System.IO.MemoryStream>作为字节数组。 如果当前实例在提供的字节数组构造的则返回此实例有权访问数组的一部分的副本。 请参阅<xref:System.IO.MemoryStream.%23ctor%2A>有关详细信息的构造函数。  
  
> [!NOTE]
>  此方法适用时<xref:System.IO.MemoryStream>已关闭。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetBuffer">
      <MemberSignature Language="C#" Value="public virtual bool TryGetBuffer (out ArraySegment&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetBuffer([out] valuetype System.ArraySegment`1&lt;unsigned int8&gt;&amp; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetBuffer (ByRef buffer As ArraySegment(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetBuffer([Runtime::InteropServices::Out] ArraySegment&lt;System::Byte&gt; % buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ArraySegment&lt;System.Byte&gt;&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">用于创建此流的字节数组段。</param>
        <summary>返回从中创建此流的无符号字节的数组。 用于指示转换是否成功的返回值。</summary>
        <returns>
          如果转换成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (source As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">从中写入数据的缓冲区。</param>
        <param name="offset">
          <c>buffer</c> 中的从零开始的字节偏移量，从此处开始将字节复制到当前流。</param>
        <param name="count">最多写入的字节数。</param>
        <summary>使用从缓冲区读取的数据将字节块写入当前流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.IO.Stream.Write%2A>。  
  
 `offset`参数指定了中的第一个字节的偏移量`buffer`从，编写与`count`参数指定了要写入的字节数。 如果写入操作成功，将流中的当前位置被前进写入的字节数。 如果发生异常，将流中当前的位置不变。  
  
 除`MemoryStream`使用 byte [] 参数构造的写入操作的末尾`MemoryStream`展开`MemoryStream`。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.MemoryStream>类。  
  
 [!code-cpp[System.IO.MemoryStream#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#3)]
 [!code-csharp[System.IO.MemoryStream#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#3)]
 [!code-vb[System.IO.MemoryStream#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">流不支持写入。 有关其他信息，请参见 <see cref="P:System.IO.Stream.CanWrite" />。  
  
 或  
  
 当前位置到流结尾的距离小于 <paramref name="count" /> 字节，并且无法修改容量。</exception>
        <exception cref="T:System.ArgumentException">
          缓冲区长度减去 <paramref name="offset" /> 的结果小于 <paramref name="count" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="count" /> 为负。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">当前流实例已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; source, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">从中写入数据的缓冲区。</param>
        <param name="offset">
          <c>buffer</c> 中的从零开始的字节偏移量，从此处开始将字节复制到该流。</param>
        <param name="count">最多写入的字节数。</param>
        <param name="cancellationToken">要监视取消请求的标记。 默认值为 <see cref="P:System.Threading.CancellationToken.None" />。</param>
        <summary>将字节的序列异步写入当前流，将该流中的当前位置提升写入的字节数，并监视取消请求。</summary>
        <returns>表示异步写入操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在完成之前，将取消该操作，返回的任务包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>属性。  
  
 你可以通过创建的实例创建一个取消标记<xref:System.Threading.CancellationTokenSource>类并传入<xref:System.Threading.CancellationTokenSource.Token%2A>属性作为`cancellationToken`参数。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="count" /> 为负数。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</exception>
        <exception cref="T:System.NotSupportedException">流不支持写入。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放流。</exception>
        <exception cref="T:System.InvalidOperationException">流正在由前一次写操作使用。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">要写入的字节。</param>
        <summary>将一个字节写入当前位置上的当前流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.IO.Stream.WriteByte%2A>。  
  
 除`MemoryStream`使用 byte [] 参数构造的写入操作的末尾`MemoryStream`展开`MemoryStream`。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.MemoryStream>类。  
  
 [!code-cpp[System.IO.MemoryStream#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#4)]
 [!code-csharp[System.IO.MemoryStream#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#4)]
 [!code-vb[System.IO.MemoryStream#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">流不支持写入。 有关其他信息，请参见 <see cref="P:System.IO.Stream.CanWrite" />。  
  
 或  
  
 当前位置位于流的末尾，而且容量不能被修改。</exception>
        <exception cref="T:System.ObjectDisposedException">当前流已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public virtual void WriteTo (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteTo(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">要写入此内存流的流。</param>
        <summary>将此内存流的整个内容写入到另一个流中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 打开当前的流时，此方法等效于调用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>上的此流的基础缓冲区。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">当前流或目标流已关闭。</exception>
      </Docs>
    </Member>
  </Members>
</Type>