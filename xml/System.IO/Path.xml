<Type Name="Path" FullName="System.IO.Path">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a11f5ee9fd09a64d31ea598cecdfb26efc81f310" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37651702" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="75438-101">对包含文件或目录路径信息的 <see cref="T:System.String" /> 实例执行操作。</span>
      <span class="sxs-lookup">
        <span data-stu-id="75438-101">Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information.</span>
      </span>
      <span data-ttu-id="75438-102">这些操作是以跨平台的方式执行的。</span>
      <span class="sxs-lookup">
        <span data-stu-id="75438-102">These operations are performed in a cross-platform manner.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-103">.NET Framework 不支持直接访问通过路径是设备名称，如物理磁盘"\\\\。 \PHYSICALDRIVE0"。</span><span class="sxs-lookup"><span data-stu-id="75438-103">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="75438-104">路径是提供的文件或目录的位置的字符串。</span><span class="sxs-lookup"><span data-stu-id="75438-104">A path is a string that provides the location of a file or directory.</span></span> <span data-ttu-id="75438-105">路径不一定指向磁盘; 上的位置例如，路径可能会映射到在内存中或在设备上的位置。</span><span class="sxs-lookup"><span data-stu-id="75438-105">A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</span></span> <span data-ttu-id="75438-106">由当前平台确定路径的确切格式。</span><span class="sxs-lookup"><span data-stu-id="75438-106">The exact format of a path is determined by the current platform.</span></span> <span data-ttu-id="75438-107">例如，在某些系统中，路径可以开始驱动器或卷字母开头，而此元素中不存在其他系统。</span><span class="sxs-lookup"><span data-stu-id="75438-107">For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</span></span> <span data-ttu-id="75438-108">在某些系统中，文件路径可以包含扩展插件，指示存储在文件中的信息类型。</span><span class="sxs-lookup"><span data-stu-id="75438-108">On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</span></span> <span data-ttu-id="75438-109">文件扩展名的格式与平台相关;例如，某些系统限制为三个字符，扩展和其他人不这样做。</span><span class="sxs-lookup"><span data-stu-id="75438-109">The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</span></span> <span data-ttu-id="75438-110">当前平台还确定的字符用于分隔路径的元素集和指定路径时，不能使用的字符集。</span><span class="sxs-lookup"><span data-stu-id="75438-110">The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</span></span> <span data-ttu-id="75438-111">由于这些差异的字段`Path`类的某些成员的具体行为以及`Path`类是依赖于平台的。</span><span class="sxs-lookup"><span data-stu-id="75438-111">Because of these differences, the fields of the `Path` class as well as the exact behavior of some members of the `Path` class are platform-dependent.</span></span>  
  
 <span data-ttu-id="75438-112">路径可以包含绝对或相对的位置信息。</span><span class="sxs-lookup"><span data-stu-id="75438-112">A path can contain absolute or relative location information.</span></span> <span data-ttu-id="75438-113">绝对路径完全指定的位置： 文件或目录可以唯一地标识而不考虑当前的位置。</span><span class="sxs-lookup"><span data-stu-id="75438-113">Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</span></span> <span data-ttu-id="75438-114">相对路径指定部分的位置： 定位使用相对路径指定的文件时，当前的位置使用作为起始点。</span><span class="sxs-lookup"><span data-stu-id="75438-114">Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</span></span> <span data-ttu-id="75438-115">若要确定当前目录，请调用<xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="75438-115">To determine the current directory, call <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="75438-116">大多数成员`Path`类不使用文件系统进行交互，且不验证是否存在指定的路径字符串的文件。</span><span class="sxs-lookup"><span data-stu-id="75438-116">Most members of the `Path` class do not interact with the file system and do not verify the existence of the file specified by a path string.</span></span> <span data-ttu-id="75438-117">`Path` 类成员的修改的路径字符串，如<xref:System.IO.Path.ChangeExtension%2A>，文件系统中对文件的名称无效。</span><span class="sxs-lookup"><span data-stu-id="75438-117">`Path` class members that modify a path string, such as <xref:System.IO.Path.ChangeExtension%2A>, have no effect on names of files in the file system.</span></span> <span data-ttu-id="75438-118">`Path` 成员将执行操作，但是，验证指定的路径字符串的内容并引发<xref:System.ArgumentException>异常，如果该字符串包含无效的路径字符串中从返回的字符中定义的字符<xref:System.IO.Path.GetInvalidPathChars%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="75438-118">`Path` members do, however, validate the contents of a specified path string, and throw an <xref:System.ArgumentException> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <xref:System.IO.Path.GetInvalidPathChars%2A> method.</span></span> <span data-ttu-id="75438-119">例如，在基于 Windows 的桌面平台上无效路径字符可能包括引号 （"）、 小于 (\<)、 大于号 (>)、 竖线 (&#124;)，退格符 (\b)、 null (\0) 和 Unicode 字符 16 到 18 和 20 到 25。</span><span class="sxs-lookup"><span data-stu-id="75438-119">For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</span></span>  
  
 <span data-ttu-id="75438-120">成员`Path`类使您能够快速轻松地执行常见操作，例如确定文件扩展名是否属于某个路径，并将两个字符串组合成一个路径名称。</span><span class="sxs-lookup"><span data-stu-id="75438-120">The members of the `Path` class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</span></span>  
  
 <span data-ttu-id="75438-121">所有成员`Path`类是静态的因此可以无需具有路径的实例调用。</span><span class="sxs-lookup"><span data-stu-id="75438-121">All members of the `Path` class are static and can therefore be called without having an instance of a path.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75438-122">在接受路径作为输入字符串的成员，该路径必须是格式正确，或引发的异常。</span><span class="sxs-lookup"><span data-stu-id="75438-122">In members that accept a path as an input string, that path must be well-formed or an exception is raised.</span></span> <span data-ttu-id="75438-123">例如，如果路径是完全限定名称，但以空格开头，在类的方法不修整路径。</span><span class="sxs-lookup"><span data-stu-id="75438-123">For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</span></span> <span data-ttu-id="75438-124">因此，该路径的格式不正确，并且会引发的异常。</span><span class="sxs-lookup"><span data-stu-id="75438-124">Therefore, the path is malformed and an exception is raised.</span></span> <span data-ttu-id="75438-125">同样的路径的组合不能完全限定两次。</span><span class="sxs-lookup"><span data-stu-id="75438-125">Similarly, a path or a combination of paths cannot be fully qualified twice.</span></span> <span data-ttu-id="75438-126">例如，"c:\temp c:\windows"还会引发异常在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="75438-126">For example, "c:\temp c:\windows" also raises an exception in most cases.</span></span> <span data-ttu-id="75438-127">请确保使用接受一个路径字符串的方法时您的路径的格式是否正确。</span><span class="sxs-lookup"><span data-stu-id="75438-127">Ensure that your paths are well-formed when using methods that accept a path string.</span></span>  
  
 <span data-ttu-id="75438-128">在接受一个路径的成员，路径可以引用的文件或只是一个目录。</span><span class="sxs-lookup"><span data-stu-id="75438-128">In members that accept a path, the path can refer to a file or just a directory.</span></span> <span data-ttu-id="75438-129">指定的路径也可以指相对路径或服务器和共享名称的通用命名约定 (UNC) 路径。</span><span class="sxs-lookup"><span data-stu-id="75438-129">The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</span></span> <span data-ttu-id="75438-130">例如，以下所有条件都可接受的路径：</span><span class="sxs-lookup"><span data-stu-id="75438-130">For example, all the following are acceptable paths:</span></span>  
  
-   <span data-ttu-id="75438-131">"c:\\\MyDir\\\MyFile.txt"在 C# 或 Visual Basic 中的"c:\MyDir\MyFile.txt"。</span><span class="sxs-lookup"><span data-stu-id="75438-131">"c:\\\MyDir\\\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="75438-132">"c:\\\MyDir"在 C# 或 Visual Basic 中的"c:\MyDir"。</span><span class="sxs-lookup"><span data-stu-id="75438-132">"c:\\\MyDir" in C#, or "c:\MyDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="75438-133">"MyDir\\\MySubdir"在 C# 或 Visual Basic 中的"MyDir\MySubDir"。</span><span class="sxs-lookup"><span data-stu-id="75438-133">"MyDir\\\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="75438-134">"\\\\\\\MyServer\\\MyShare"在 C# 中，或"\\\MyServer\MyShare"在 Visual Basic 中。</span><span class="sxs-lookup"><span data-stu-id="75438-134">"\\\\\\\MyServer\\\MyShare" in C#, or "\\\MyServer\MyShare" in Visual Basic.</span></span>  
  
 <span data-ttu-id="75438-135">因为对字符串执行所有这些操作时，就无法验证结果在所有方案中有效。</span><span class="sxs-lookup"><span data-stu-id="75438-135">Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</span></span> <span data-ttu-id="75438-136">例如，<xref:System.IO.Path.GetExtension%2A>方法分析将传递给它一个字符串，并从该字符串返回的扩展名。</span><span class="sxs-lookup"><span data-stu-id="75438-136">For example, the <xref:System.IO.Path.GetExtension%2A> method parses a string that you pass to it and returns the extension from that string.</span></span> <span data-ttu-id="75438-137">但是，这并不意味着在磁盘上存在具有该扩展名的文件。</span><span class="sxs-lookup"><span data-stu-id="75438-137">However, this does not mean that a file with that extension exists on the disk.</span></span>  
  
 <span data-ttu-id="75438-138">通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="75438-138">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-139">下面的代码示例演示了一些主要成员`Path`类。</span><span class="sxs-lookup"><span data-stu-id="75438-139">The following code example demonstrates some of the main members of the `Path` class.</span></span>  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="75438-140">提供平台特定的替换字符，该替换字符用于在反映分层文件系统组织的路径字符串中分隔目录级别。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-140">Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-141">在此字段中存储的字符不能在<xref:System.IO.Path.InvalidPathChars>。</span><span class="sxs-lookup"><span data-stu-id="75438-141">The character stored in this field cannot be in <xref:System.IO.Path.InvalidPathChars>.</span></span> <span data-ttu-id="75438-142">此字段可以设置为相同的值<xref:System.IO.Path.DirectorySeparatorChar>。</span><span class="sxs-lookup"><span data-stu-id="75438-142">This field can be set to the same value as <xref:System.IO.Path.DirectorySeparatorChar>.</span></span> <span data-ttu-id="75438-143">`AltDirectorySeparatorChar` 和<xref:System.IO.Path.DirectorySeparatorChar>都是可用于分隔的路径字符串中的目录级别。</span><span class="sxs-lookup"><span data-stu-id="75438-143">`AltDirectorySeparatorChar` and <xref:System.IO.Path.DirectorySeparatorChar> are both valid for separating directory levels in a path string.</span></span>  
  
 <span data-ttu-id="75438-144">此字段的值为斜杠 （'/') 在 Windows、 UNIX 和 Macintosh 操作系统上。</span><span class="sxs-lookup"><span data-stu-id="75438-144">The value of this field is a slash ('/') on Windows, UNIX and Macintosh operating systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-145">下面的代码示例演示如何使用`AltDirectorySeparatorChar`字段。</span><span class="sxs-lookup"><span data-stu-id="75438-145">The following code example demonstrates a use of the `AltDirectorySeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="75438-146">要修改的路径信息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-146">The path information to modify.</span>
          </span>
          <span data-ttu-id="75438-147">该路径不能包含在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定义的任何字符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-147">The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span>
          </span>
        </param>
        <param name="extension">
          <span data-ttu-id="75438-148">新的扩展名（有或没有前导句点）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-148">The new extension (with or without a leading period).</span>
          </span>
          <span data-ttu-id="75438-149">指定 <see langword="null" /> 以从 <c>path</c> 移除现有扩展名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-149">Specify <see langword="null" /> to remove an existing extension from <c>path</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="75438-150">更改路径字符串的扩展名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-150">Changes the extension of a path string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-151">已修改的路径信息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-151">The modified path information.</span>
          </span>
          <span data-ttu-id="75438-152">在基于 Windows 的桌面平台上，如果 <paramref name="path" /> 是 <see langword="null" /> 或空字符串 (“”)，则返回的路径信息是未修改的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-152">On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified.</span>
          </span>
          <span data-ttu-id="75438-153">如果 <paramref name="extension" /> 为 <see langword="null" />，则返回的字符串包含指定的路径（其扩展名已移除）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-153">If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed.</span>
          </span>
          <span data-ttu-id="75438-154">如果 <paramref name="path" /> 不具有扩展名且 <paramref name="extension" /> 不为 <see langword="null" />，则返回的路径字符串包含追加到 <paramref name="path" /> 结尾的 <paramref name="extension" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-154">If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-155">如果既没有`path`也不`extension`包含句点 （.）、`ChangeExtension`添加句点。</span><span class="sxs-lookup"><span data-stu-id="75438-155">If neither `path` nor `extension` contains a period (.), `ChangeExtension` adds the period.</span></span>  
  
 <span data-ttu-id="75438-156">`extension`参数可以包含多个句点和任何有效的路径字符，并且可以是任意长度。</span><span class="sxs-lookup"><span data-stu-id="75438-156">The `extension` parameter can contain multiple periods and any valid path characters, and can be any length.</span></span> <span data-ttu-id="75438-157">如果`extension`是`null`，则返回的字符串包含的内容`path`与最后一个删除期间和之后的所有字符。</span><span class="sxs-lookup"><span data-stu-id="75438-157">If `extension` is `null`, the returned string contains the contents of `path` with the last period and all characters following it removed.</span></span>  
  
 <span data-ttu-id="75438-158">如果`extension`为空字符串，返回的路径字符串包含的内容`path`后到最后一个周期的所有字符中删除。</span><span class="sxs-lookup"><span data-stu-id="75438-158">If `extension` is an empty string, the returned path string contains the contents of `path` with any characters following the last period removed.</span></span>  
  
 <span data-ttu-id="75438-159">如果`path`不具有扩展名和`extension`不是`null`，则返回的字符串包含`path`跟`extension`。</span><span class="sxs-lookup"><span data-stu-id="75438-159">If `path` does not have an extension and `extension` is not `null`, the returned string contains `path` followed by `extension`.</span></span>  
  
 <span data-ttu-id="75438-160">如果`extension`不是`null`，并且不包含前导句点，则添加句点。</span><span class="sxs-lookup"><span data-stu-id="75438-160">If `extension` is not `null` and does not contain a leading period, the period is added.</span></span>  
  
 <span data-ttu-id="75438-161">如果`path`包含多个句点分隔的多个扩展插件返回的字符串包含的内容`path`与最后一个句点以及其后的所有字符替换为`extension`。</span><span class="sxs-lookup"><span data-stu-id="75438-161">If `path` contains a multiple extension separated by multiple periods, the returned string contains the contents of `path` with the last period and all characters following it replaced by `extension`.</span></span> <span data-ttu-id="75438-162">例如，如果`path`是"\Dir1\examples\pathtests.csx.txt"和`extension`为"cs"，修改后的路径为"\Dir1\examples\pathtests.csx.cs"。</span><span class="sxs-lookup"><span data-stu-id="75438-162">For example, if `path` is "\Dir1\examples\pathtests.csx.txt" and `extension` is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</span></span>  
  
 <span data-ttu-id="75438-163">不能验证返回的结果在所有方案中有效。</span><span class="sxs-lookup"><span data-stu-id="75438-163">It is not possible to verify that the returned results are valid in all scenarios.</span></span> <span data-ttu-id="75438-164">例如，如果`path`为空，`extension`追加。</span><span class="sxs-lookup"><span data-stu-id="75438-164">For example, if `path` is empty, `extension` is appended.</span></span>  
  
 <span data-ttu-id="75438-165">通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="75438-165">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-166">下面的代码示例演示如何使用`ChangeExtension`方法。</span><span class="sxs-lookup"><span data-stu-id="75438-166">The following code example demonstrates a use of the `ChangeExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="75438-167">
            <paramref name="path" /> 包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中已定义的一个或多个无效字符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-167">
              <paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="75438-168">将多个字符串组合成一个路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-168">Combines strings into a path.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">
          <span data-ttu-id="75438-169">由路径的各部分构成的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-169">An array of parts of the path.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="75438-170">将字符串数组组合成一个路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-170">Combines an array of strings into a path.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-171">已组合的路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-171">The combined paths.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-172">`paths` 应为要组合的路径部分的一组。</span><span class="sxs-lookup"><span data-stu-id="75438-172">`paths` should be an array of the parts of the path to combine.</span></span> <span data-ttu-id="75438-173">如果其中一个后续路径的绝对路径，然后合并操作重置开头放弃所有以前的组合的路径的绝对路径。</span><span class="sxs-lookup"><span data-stu-id="75438-173">If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</span></span>  
  
 <span data-ttu-id="75438-174">组合路径中省略了长度为零的字符串。</span><span class="sxs-lookup"><span data-stu-id="75438-174">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="75438-175">参数不进行分析，如果它们具有空白区域。</span><span class="sxs-lookup"><span data-stu-id="75438-175">The parameters are not parsed if they have white space.</span></span>  
  
 <span data-ttu-id="75438-176">对于目录和文件名称不是所有无效的字符被解释为不可接受的`Combine`方法，因为您可以将这些字符用于搜索通配符字符。</span><span class="sxs-lookup"><span data-stu-id="75438-176">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="75438-177">例如，虽然`Path.Combine("c:\\", "*.txt")`也可能是无效如果您打算从它创建一个文件，它是作为搜索字符串有效。</span><span class="sxs-lookup"><span data-stu-id="75438-177">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="75438-178">因此成功解释通过`Combine`方法。</span><span class="sxs-lookup"><span data-stu-id="75438-178">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-179">下面的示例将一个字符串数组合并成一个路径。</span><span class="sxs-lookup"><span data-stu-id="75438-179">The following example combines an array of strings into a path.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="75438-180">数组中的一个字符串包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定义的一个或多个无效字符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-180">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="75438-181">数组中的一个字符串为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-181">One of the strings in the array is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" />
        <Parameter Name="path2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path1">
          <span data-ttu-id="75438-182">要组合的第一个路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-182">The first path to combine.</span>
          </span>
        </param>
        <param name="path2">
          <span data-ttu-id="75438-183">要组合的第二个路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-183">The second path to combine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="75438-184">将两个字符串组合成一个路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-184">Combines two strings into a path.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-185">已组合的路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-185">The combined paths.</span>
          </span>
          <span data-ttu-id="75438-186">如果指定的路径之一是零长度字符串，则该方法返回其他路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-186">If one of the specified paths is a zero-length string, this method returns the other path.</span>
          </span>
          <span data-ttu-id="75438-187">如果 <paramref name="path2" /> 包含绝对路径，则该方法返回 <paramref name="path2" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-187">If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-188">如果`path1`不是驱动器引用 （即，"c:"或"d:"） 和定义中不会结束以有效分隔符<xref:System.IO.Path.DirectorySeparatorChar>， <xref:System.IO.Path.AltDirectorySeparatorChar>，或<xref:System.IO.Path.VolumeSeparatorChar>，<xref:System.IO.Path.DirectorySeparatorChar>追加到`path1`在串联前。</span><span class="sxs-lookup"><span data-stu-id="75438-188">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span>  
  
 <span data-ttu-id="75438-189">如果`path2`不包括根 (例如，如果`path2`不以分隔符字符或指定驱动器)，结果将是两个路径，以允许插入分隔符的串联。</span><span class="sxs-lookup"><span data-stu-id="75438-189">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="75438-190">如果`path2`包含一个根`path2`返回。</span><span class="sxs-lookup"><span data-stu-id="75438-190">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="75438-191">参数不进行分析，如果它们具有空白区域。</span><span class="sxs-lookup"><span data-stu-id="75438-191">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="75438-192">因此，如果`path2`包括空格 (例如，"\file.txt")，<xref:System.IO.Path.Combine%2A>方法将追加`path2`到`path1`而不是仅返回`path2`。</span><span class="sxs-lookup"><span data-stu-id="75438-192">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1` instead of returning only `path2`.</span></span>  
  
 <span data-ttu-id="75438-193">对于目录和文件名称不是所有无效的字符被解释为不可接受的`Combine`方法，因为您可以将这些字符用于搜索通配符字符。</span><span class="sxs-lookup"><span data-stu-id="75438-193">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="75438-194">例如，虽然`Path.Combine("c:\\", "*.txt")`也可能是无效如果您打算从它创建一个文件，它是作为搜索字符串有效。</span><span class="sxs-lookup"><span data-stu-id="75438-194">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="75438-195">因此成功解释通过`Combine`方法。</span><span class="sxs-lookup"><span data-stu-id="75438-195">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
 <span data-ttu-id="75438-196">通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="75438-196">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-197">下面的代码示例演示了如何使用`Combine`基于 Windows 的桌面平台上的方法。</span><span class="sxs-lookup"><span data-stu-id="75438-197">The following code example demonstrates using the `Combine` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="75438-198">
            <paramref name="path1" /> 或 <paramref name="path2" /> 包含一个或多个在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定义的无效字符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-198">
              <paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="75438-199">
            <paramref name="path1" /> 或 <paramref name="path2" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-199">
              <paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" />
        <Parameter Name="path2" Type="System.String" />
        <Parameter Name="path3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path1">
          <span data-ttu-id="75438-200">要组合的第一个路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-200">The first path to combine.</span>
          </span>
        </param>
        <param name="path2">
          <span data-ttu-id="75438-201">要组合的第二个路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-201">The second path to combine.</span>
          </span>
        </param>
        <param name="path3">
          <span data-ttu-id="75438-202">要组合的第三个路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-202">The third path to combine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="75438-203">将三个字符串组合成一个路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-203">Combines three strings into a path.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-204">已组合的路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-204">The combined paths.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-205">`path1` 应为绝对路径 (例如，"d:\archives"或"\\\archives\public")。</span><span class="sxs-lookup"><span data-stu-id="75438-205">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").</span></span> <span data-ttu-id="75438-206">如果`path2`或`path3`也是绝对路径，合并操作将放弃所有先前合并路径和重置为该绝对路径。</span><span class="sxs-lookup"><span data-stu-id="75438-206">If `path2` or `path3` is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="75438-207">组合路径中省略了长度为零的字符串。</span><span class="sxs-lookup"><span data-stu-id="75438-207">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="75438-208">如果`path1`不是驱动器引用 （即，"c:"或"d:"） 和定义中不会结束以有效分隔符<xref:System.IO.Path.DirectorySeparatorChar>， <xref:System.IO.Path.AltDirectorySeparatorChar>，或<xref:System.IO.Path.VolumeSeparatorChar>，<xref:System.IO.Path.DirectorySeparatorChar>追加到`path1`在串联前。</span><span class="sxs-lookup"><span data-stu-id="75438-208">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span>  
  
 <span data-ttu-id="75438-209">如果`path2`不包括根 (例如，如果`path2`不以分隔符字符或指定驱动器)，结果将是两个路径，以允许插入分隔符的串联。</span><span class="sxs-lookup"><span data-stu-id="75438-209">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="75438-210">如果`path2`包含一个根`path2`返回。</span><span class="sxs-lookup"><span data-stu-id="75438-210">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="75438-211">参数不进行分析，如果它们具有空白区域。</span><span class="sxs-lookup"><span data-stu-id="75438-211">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="75438-212">因此，如果`path2`包括空格 (例如，"\file.txt")，<xref:System.IO.Path.Combine%2A>方法将追加`path2`到`path1`。</span><span class="sxs-lookup"><span data-stu-id="75438-212">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="75438-213">对于目录和文件名称不是所有无效的字符被解释为不可接受的`Combine`方法，因为您可以将这些字符用于搜索通配符字符。</span><span class="sxs-lookup"><span data-stu-id="75438-213">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="75438-214">例如，虽然`Path.Combine("c:\\", "*.txt")`也可能是无效如果您打算从它创建一个文件，它是作为搜索字符串有效。</span><span class="sxs-lookup"><span data-stu-id="75438-214">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="75438-215">因此成功解释通过`Combine`方法。</span><span class="sxs-lookup"><span data-stu-id="75438-215">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-216">下面的示例将三个路径合并。</span><span class="sxs-lookup"><span data-stu-id="75438-216">The following example combines three paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="75438-217">
            <paramref name="path1" />、<paramref name="path2" /> 或 <paramref name="path3" /> 包含一个或多个在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定义的无效字符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-217">
              <paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="75438-218">
            <paramref name="path1" />、<paramref name="path2" /> 或 <paramref name="path3" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-218">
              <paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" />
        <Parameter Name="path2" Type="System.String" />
        <Parameter Name="path3" Type="System.String" />
        <Parameter Name="path4" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path1">
          <span data-ttu-id="75438-219">要组合的第一个路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-219">The first path to combine.</span>
          </span>
        </param>
        <param name="path2">
          <span data-ttu-id="75438-220">要组合的第二个路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-220">The second path to combine.</span>
          </span>
        </param>
        <param name="path3">
          <span data-ttu-id="75438-221">要组合的第三个路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-221">The third path to combine.</span>
          </span>
        </param>
        <param name="path4">
          <span data-ttu-id="75438-222">要组合的第四个路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-222">The fourth path to combine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="75438-223">将四个字符串组合成一个路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-223">Combines four strings into a path.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-224">已组合的路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-224">The combined paths.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-225">`path1` 应为绝对路径 (例如，"d:\archives"或"\\\archives\public")。如果其中一个后续路径也是绝对路径，合并操作将放弃所有以前合并的路径，并将重置为绝对路径的。</span><span class="sxs-lookup"><span data-stu-id="75438-225">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="75438-226">组合路径中省略了长度为零的字符串。</span><span class="sxs-lookup"><span data-stu-id="75438-226">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="75438-227">如果`path1`不是驱动器引用 （即，"c:"或"d:"） 和定义中不会结束以有效分隔符<xref:System.IO.Path.DirectorySeparatorChar>， <xref:System.IO.Path.AltDirectorySeparatorChar>，或<xref:System.IO.Path.VolumeSeparatorChar>，<xref:System.IO.Path.DirectorySeparatorChar>追加到`path1`在串联前。</span><span class="sxs-lookup"><span data-stu-id="75438-227">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span>  
  
 <span data-ttu-id="75438-228">如果`path2`不包括根 (例如，如果`path2`不以分隔符字符或指定驱动器)，结果将是两个路径，以允许插入分隔符的串联。</span><span class="sxs-lookup"><span data-stu-id="75438-228">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="75438-229">如果`path2`包含一个根`path2`返回。</span><span class="sxs-lookup"><span data-stu-id="75438-229">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="75438-230">参数不进行分析，如果它们具有空白区域。</span><span class="sxs-lookup"><span data-stu-id="75438-230">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="75438-231">因此，如果`path2`包括空格 (例如，"\file.txt")，<xref:System.IO.Path.Combine%2A>方法将追加`path2`到`path1`。</span><span class="sxs-lookup"><span data-stu-id="75438-231">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="75438-232">对于目录和文件名称不是所有无效的字符被解释为不可接受的`Combine`方法，因为您可以将这些字符用于搜索通配符字符。</span><span class="sxs-lookup"><span data-stu-id="75438-232">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="75438-233">例如，虽然`Path.Combine("c:\\", "*.txt")`也可能是无效如果您打算从它创建一个文件，它是作为搜索字符串有效。</span><span class="sxs-lookup"><span data-stu-id="75438-233">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="75438-234">因此成功解释通过`Combine`方法。</span><span class="sxs-lookup"><span data-stu-id="75438-234">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-235">下面的示例将四个路径合并。</span><span class="sxs-lookup"><span data-stu-id="75438-235">The following example combines four paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="75438-236">
            <paramref name="path1" />、<paramref name="path2" />、<paramref name="path3" /> 或 <paramref name="path4" /> 包含一个或多个在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定义的无效字符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-236">
              <paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="75438-237">
            <paramref name="path1" />、<paramref name="path2" />、<paramref name="path3" /> 或 <paramref name="path4" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-237">
              <paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="75438-238">提供平台特定的字符，该字符用于在反映分层文件系统组织的路径字符串中分隔目录级别。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-238">Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-239">在此字段中存储的字符不能在<xref:System.IO.Path.InvalidPathChars>。</span><span class="sxs-lookup"><span data-stu-id="75438-239">The character stored in this field cannot be in <xref:System.IO.Path.InvalidPathChars>.</span></span> <span data-ttu-id="75438-240"><xref:System.IO.Path.AltDirectorySeparatorChar> 和`DirectorySeparatorChar`都是可用于分隔的路径字符串中的目录级别。</span><span class="sxs-lookup"><span data-stu-id="75438-240"><xref:System.IO.Path.AltDirectorySeparatorChar> and `DirectorySeparatorChar` are both valid for separating directory levels in a path string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-241">下面的代码示例演示如何将`DirectorySeparatorChar`字段。</span><span class="sxs-lookup"><span data-stu-id="75438-241">The following code example demonstrates the use of the `DirectorySeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="75438-242">文件或目录的路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-242">The path of a file or directory.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="75438-243">返回指定路径字符串的目录信息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-243">Returns the directory information for the specified path string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-244">
            <paramref name="path" /> 的目录信息；如果 <paramref name="path" /> 表示根目录或为 null，则为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-244">Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null.</span>
          </span>
          <span data-ttu-id="75438-245">如果 <paramref name="path" /> 不包含目录信息，则返回 <see cref="F:System.String.Empty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-245">Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-246">在大多数情况下，此方法返回的字符串包含的路径，但不是包括最后一个中的所有字符<xref:System.IO.Path.DirectorySeparatorChar>或<xref:System.IO.Path.AltDirectorySeparatorChar>。</span><span class="sxs-lookup"><span data-stu-id="75438-246">In most cases, the string returned by this method consists of all characters in the path up to but not including the last <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span> <span data-ttu-id="75438-247">如果路径包括的根目录，例如"c:\\"，则返回 null。</span><span class="sxs-lookup"><span data-stu-id="75438-247">If the path consists of a root directory, such as "c:\\", null is returned.</span></span> <span data-ttu-id="75438-248">请注意，此方法不支持使用路径"文件:"。</span><span class="sxs-lookup"><span data-stu-id="75438-248">Note that this method does not support paths using "file:".</span></span> <span data-ttu-id="75438-249">因为返回的路径不包括<xref:System.IO.Path.DirectorySeparatorChar>或<xref:System.IO.Path.AltDirectorySeparatorChar>，将返回的路径传递回<xref:System.IO.Path.GetDirectoryName%2A>方法将导致每次在结果字符串的后续调用的一个文件夹级别的截断。</span><span class="sxs-lookup"><span data-stu-id="75438-249">Because the returned path does not include the <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, passing the returned path back into the <xref:System.IO.Path.GetDirectoryName%2A> method will result in the truncation of one folder level per subsequent call on the result string.</span></span> <span data-ttu-id="75438-250">例如，将"C:\Directory\SubDirectory\test.txt"的路径传递到<xref:System.IO.Path.GetDirectoryName%2A>方法将返回"C:\Directory\SubDirectory"。</span><span class="sxs-lookup"><span data-stu-id="75438-250">For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <xref:System.IO.Path.GetDirectoryName%2A> method will return "C:\Directory\SubDirectory".</span></span> <span data-ttu-id="75438-251">将该字符串，"C:\Directory\SubDirectory"传递到<xref:System.IO.Path.GetDirectoryName%2A>将导致"C:\Directory"。</span><span class="sxs-lookup"><span data-stu-id="75438-251">Passing that string, "C:\Directory\SubDirectory", into <xref:System.IO.Path.GetDirectoryName%2A> will result in "C:\Directory".</span></span>  
  
 <span data-ttu-id="75438-252">通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="75438-252">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-253">下面的代码示例演示了如何使用`GetDirectoryName`基于 Windows 的桌面平台上的方法。</span><span class="sxs-lookup"><span data-stu-id="75438-253">The following code example demonstrates using the `GetDirectoryName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="75438-254">该 <paramref name="path" /> 参数包含无效字符，为空，或仅包含空格。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-254">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="75438-255">
            <block subset="none" type="note">
              <para>改为在 [用于 Windows 应用商店应用的 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) 或 [可移植类库](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) 中捕获基类异常 <see cref="T:System.IO.IOException" />。</para>
            </block>
            <paramref name="path" /> 参数超过系统定义的最大长度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-255">
              <block subset="none" type="note">
                <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException" />, instead.  </para>
              </block>  The <paramref name="path" /> parameter is longer than the system-defined maximum length.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="75438-256">从中获取扩展名的路径字符串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-256">The path string from which to get the extension.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="75438-257">返回指定的路径字符串的扩展名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-257">Returns the extension of the specified path string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-258">指定路径的扩展名（包含句点“.”）、或 <see langword="null" />、或 <see cref="F:System.String.Empty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-258">The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />.</span>
          </span>
          <span data-ttu-id="75438-259">如果 <paramref name="path" /> 为 <see langword="null" />，则 <see cref="M:System.IO.Path.GetExtension(System.String)" /> 返回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-259">If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />.</span>
          </span>
          <span data-ttu-id="75438-260">如果 <paramref name="path" /> 不具有扩展名信息，则 <see cref="M:System.IO.Path.GetExtension(System.String)" /> 返回 <see cref="F:System.String.Empty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-260">If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-261">扩展`path`获取通过搜索`path`为句点 （.） 开头的路径和路径的开头继续中的最后一个字符。</span><span class="sxs-lookup"><span data-stu-id="75438-261">The extension of `path` is obtained by searching `path` for a period (.), starting with the last character in path and continuing toward the start of path.</span></span> <span data-ttu-id="75438-262">如果之前找到一段<xref:System.IO.Path.DirectorySeparatorChar>或<xref:System.IO.Path.AltDirectorySeparatorChar>字符，返回的字符串包含该句点以及字符后它; 否则为<xref:System.String.Empty>返回。</span><span class="sxs-lookup"><span data-stu-id="75438-262">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned string contains the period and the characters after it; otherwise, <xref:System.String.Empty> is returned.</span></span>  
  
 <span data-ttu-id="75438-263">通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="75438-263">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-264">下面的代码示例演示了如何使用`GetExtension`基于 Windows 的桌面平台上的方法。</span><span class="sxs-lookup"><span data-stu-id="75438-264">The following code example demonstrates using the `GetExtension` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="75438-265">
            <paramref name="path" /> 包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中已定义的一个或多个无效字符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-265">
              <paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="75438-266">从中获取文件名和扩展名的路径字符串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-266">The path string from which to obtain the file name and extension.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="75438-267">返回指定路径字符串的文件名和扩展名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-267">Returns the file name and extension of the specified path string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-268">
            <paramref name="path" /> 中最后一个目录字符后的字符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-268">The characters after the last directory character in <paramref name="path" />.</span>
          </span>
          <span data-ttu-id="75438-269">如果 <paramref name="path" /> 的最后一个字符是目录或卷分隔符，则此方法返回 <see cref="F:System.String.Empty" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-269">If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />.</span>
          </span>
          <span data-ttu-id="75438-270">如果 <paramref name="path" /> 为 <see langword="null" />，则此方法返回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-270">If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-271">返回的值是`null`如果文件路径`null`。</span><span class="sxs-lookup"><span data-stu-id="75438-271">The returned value is `null` if the file path is `null`.</span></span>  
  
 <span data-ttu-id="75438-272">用于确定文件名称的开头的分隔符字符<xref:System.IO.Path.DirectorySeparatorChar>和<xref:System.IO.Path.AltDirectorySeparatorChar>。</span><span class="sxs-lookup"><span data-stu-id="75438-272">The separator characters used to determine the start of the file name are <xref:System.IO.Path.DirectorySeparatorChar> and <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span>  
  
 <span data-ttu-id="75438-273">通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="75438-273">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-274">下面的代码示例演示的行为`GetFileName`基于 Windows 的桌面平台上的方法。</span><span class="sxs-lookup"><span data-stu-id="75438-274">The following code example demonstrates the behavior of the `GetFileName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="75438-275">
            <paramref name="path" /> 包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中已定义的一个或多个无效字符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-275">
              <paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="75438-276">文件的路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-276">The path of the file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="75438-277">返回不具有扩展名的指定路径字符串的文件名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-277">Returns the file name of the specified path string without the extension.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-278">由 <see cref="M:System.IO.Path.GetFileName(System.String)" /> 返回的字符串，但不包括最后的句点 (.) 以及之后的所有字符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-278">The string returned by <see cref="M:System.IO.Path.GetFileName(System.String)" />, minus the last period (.) and all characters following it.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-279">此方法不会验证路径或文件名称存在。</span><span class="sxs-lookup"><span data-stu-id="75438-279">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="75438-280">通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="75438-280">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-281">下面的代码示例演示如何使用`GetFileNameWithoutExtension`方法。</span><span class="sxs-lookup"><span data-stu-id="75438-281">The following code example demonstrates a use of the `GetFileNameWithoutExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="75438-282">
            <paramref name="path" /> 包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中已定义的一个或多个无效字符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-282">
              <paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="75438-283">要获取其绝对路径信息的文件或目录。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-283">The file or directory for which to obtain absolute path information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="75438-284">返回指定路径字符串的绝对路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-284">Returns the absolute path for the specified path string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-285">
            <paramref name="path" /> 的完全限定的位置，例如“C:\MyFile.txt”。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-285">The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-286">.NET Framework 不支持直接访问通过路径是设备名称，如物理磁盘"\\\\。 \PHYSICALDRIVE0"。</span><span class="sxs-lookup"><span data-stu-id="75438-286">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="75438-287">绝对路径包括所需的系统上查找文件或目录的所有信息。</span><span class="sxs-lookup"><span data-stu-id="75438-287">The absolute path includes all information required to locate a file or directory on a system.</span></span>  
  
 <span data-ttu-id="75438-288">指定目录的文件`path`不需要存在。</span><span class="sxs-lookup"><span data-stu-id="75438-288">The file or directory specified by `path` is not required to exist.</span></span> <span data-ttu-id="75438-289">例如，如果 c:\temp\newdir 是当前目录，则调用`GetFullPath`文件名称，例如 test.txt 返回 c:\temp\newdir\test.txt。</span><span class="sxs-lookup"><span data-stu-id="75438-289">For example, if c:\temp\newdir is the current directory, calling `GetFullPath` on a file name such as test.txt returns c:\temp\newdir\test.txt.</span></span> <span data-ttu-id="75438-290">不需要存在该文件。</span><span class="sxs-lookup"><span data-stu-id="75438-290">The file need not exist.</span></span>  
  
 <span data-ttu-id="75438-291">但是，如果`path`确实存在，调用方必须有权获取路径信息`path`。</span><span class="sxs-lookup"><span data-stu-id="75438-291">However, if `path` does exist, the caller must have permission to obtain path information for `path`.</span></span> <span data-ttu-id="75438-292">请注意，与不同的大多数成员<xref:System.IO.Path>类，此方法访问文件系统。</span><span class="sxs-lookup"><span data-stu-id="75438-292">Note that unlike most members of the <xref:System.IO.Path> class, this method accesses the file system.</span></span>  
  
 <span data-ttu-id="75438-293">此方法使用当前目录和卷的当前信息进行完全限定`path`。</span><span class="sxs-lookup"><span data-stu-id="75438-293">This method uses current directory and current volume information to fully qualify `path`.</span></span> <span data-ttu-id="75438-294">如果指定的文件命名为仅在`path`，`GetFullPath`返回当前目录的完全限定的路径。</span><span class="sxs-lookup"><span data-stu-id="75438-294">If you specify a file name only in `path`, `GetFullPath` returns the fully qualified path of the current directory.</span></span>  
  
 <span data-ttu-id="75438-295">如果您通过短文件名中，它将扩展为长文件名。</span><span class="sxs-lookup"><span data-stu-id="75438-295">If you pass in a short file name, it is expanded to a long file name.</span></span>  
  
 <span data-ttu-id="75438-296">如果路径不包含任何重要的字符无效，除非它包含一个或多个"。"字符后跟任意数目的空格，则它将分析为"。".."。</span><span class="sxs-lookup"><span data-stu-id="75438-296">If a path contains no significant characters it is invalid unless it contains one or more "." characters followed by any number of spaces, then it will be parsed as either "." or "..".</span></span>  
  
 <span data-ttu-id="75438-297">通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="75438-297">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-298">下面的代码示例演示了`GetFullPath`基于 Windows 的桌面平台上的方法。</span><span class="sxs-lookup"><span data-stu-id="75438-298">The following code example demonstrates the `GetFullPath` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="75438-299">
            <paramref name="path" /> 是一个零长度字符串，仅包含空格或者包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中已定义一个或多个无效字符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-299">
              <paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span>
          </span>
          <span data-ttu-id="75438-300">- 或 -  系统无法检索绝对路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-300">-or-  The system could not retrieve the absolute path.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="75438-301">调用方没有所需的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-301">The caller does not have the required permissions.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="75438-302">
            <paramref name="path" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-302">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="75438-303">
            <paramref name="path" /> 包含一个冒号（“:”），此冒号不是卷标识符（如，“c:\\”）的一部分。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-303">
              <paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="75438-304">指定的路径和/或文件名超过了系统定义的最大长度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-304">The specified path, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="75438-305">用于访问该路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-305">for access to the path.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="basePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="basePath">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="75438-306">获取包含不允许在文件名中使用的字符的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-306">Gets an array containing the characters that are not allowed in file names.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-307">包含不允许在文件名中使用的字符的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-307">An array containing the characters that are not allowed in file names.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-308">不保证此方法返回的数组以包含在文件和目录名称中无效的字符的完整集合。</span><span class="sxs-lookup"><span data-stu-id="75438-308">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="75438-309">无效的字符的完整集可能会因文件系统。</span><span class="sxs-lookup"><span data-stu-id="75438-309">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="75438-310">例如，在基于 Windows 的桌面平台上无效路径字符可能包括 ASCII/Unicode 字符 1 到 31 之间，以及用引号括起来 （"）、 小于 (\<)、 大于号 (>)、 竖线 (&#124;)，退格符 (\b)、 null (\0) 和制表符 (\t)。</span><span class="sxs-lookup"><span data-stu-id="75438-310">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-311">下面的代码示例演示<xref:System.IO.Path.GetInvalidFileNameChars%2A>方法和<xref:System.IO.Path.GetInvalidPathChars%2A>方法来检索无效的字符。</span><span class="sxs-lookup"><span data-stu-id="75438-311">The following code example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="75438-312">获取包含不允许在路径名中使用的字符的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-312">Gets an array containing the characters that are not allowed in path names.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-313">包含不允许在路径名中使用的字符的数组。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-313">An array containing the characters that are not allowed in path names.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-314">不保证此方法返回的数组以包含在文件和目录名称中无效的字符的完整集合。</span><span class="sxs-lookup"><span data-stu-id="75438-314">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="75438-315">无效的字符的完整集可能会因文件系统。</span><span class="sxs-lookup"><span data-stu-id="75438-315">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="75438-316">例如，在基于 Windows 的桌面平台上无效路径字符可能包括 ASCII/Unicode 字符 1 到 31 之间，以及用引号括起来 （"）、 小于 (\<)、 大于号 (>)、 竖线 (&#124;)，退格符 (\b)、 null (\0) 和制表符 (\t)。</span><span class="sxs-lookup"><span data-stu-id="75438-316">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-317">下面的代码示例演示<xref:System.IO.Path.GetInvalidFileNameChars%2A>方法和<xref:System.IO.Path.GetInvalidPathChars%2A>方法来检索无效的字符。</span><span class="sxs-lookup"><span data-stu-id="75438-317">The following code example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="75438-318">从中获取根目录信息的路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-318">The path from which to obtain root directory information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="75438-319">获取指定路径的根目录信息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-319">Gets the root directory information of the specified path.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-320">
            <paramref name="path" /> 的根目录，例如“C:\\”；如果 <paramref name="path" /> 为 <see langword="null" />，则为 <see langword="null" />；如果 <paramref name="path" /> 不包含根目录信息，则为空字符串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-320">The root directory of <paramref name="path" />, such as "C:\\", or <see langword="null" /> if <paramref name="path" /> is <see langword="null" />, or an empty string if <paramref name="path" /> does not contain root directory information.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-321">此方法不会验证路径或文件名称存在。</span><span class="sxs-lookup"><span data-stu-id="75438-321">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="75438-322">此方法返回的字符串的可能模式如下所示：</span><span class="sxs-lookup"><span data-stu-id="75438-322">Possible patterns for the string returned by this method are as follows:</span></span>  
  
-   <span data-ttu-id="75438-323">空字符串 (`path`当前驱动器或卷上指定了相对路径)。</span><span class="sxs-lookup"><span data-stu-id="75438-323">An empty string (`path` specified a relative path on the current drive or volume).</span></span>  
  
-   <span data-ttu-id="75438-324">"/"(`path`当前驱动器上指定的绝对路径)。</span><span class="sxs-lookup"><span data-stu-id="75438-324">"/" (`path` specified an absolute path on the current drive).</span></span>  
  
-   <span data-ttu-id="75438-325">"X:"(`path`上的驱动器，其中 X 表示驱动器或卷的号指定的相对路径)。</span><span class="sxs-lookup"><span data-stu-id="75438-325">"X:" (`path` specified a relative path on a drive, where X represents a drive or volume letter).</span></span>  
  
-   <span data-ttu-id="75438-326">"X: /"(`path`给定驱动器上指定的绝对路径)。</span><span class="sxs-lookup"><span data-stu-id="75438-326">"X:/" (`path` specified an absolute path on a given drive).</span></span>  
  
-   <span data-ttu-id="75438-327">"\\\ComputerName\SharedFolder"（UNC 路径）。</span><span class="sxs-lookup"><span data-stu-id="75438-327">"\\\ComputerName\SharedFolder" (a UNC path).</span></span>  
  
 <span data-ttu-id="75438-328">.NET Framework 不支持直接访问通过路径是设备名称，如物理磁盘"\\\\。 \PHYSICALDRIVE0"。</span><span class="sxs-lookup"><span data-stu-id="75438-328">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="75438-329">通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="75438-329">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-330">下面的代码示例演示如何使用`GetPathRoot`方法。</span><span class="sxs-lookup"><span data-stu-id="75438-330">The following code example demonstrates a use of the `GetPathRoot` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="75438-331">
            <paramref name="path" /> 包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中已定义的一个或多个无效字符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-331">
              <paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span>
          </span>
          <span data-ttu-id="75438-332">- 或 -  <see cref="F:System.String.Empty" /> 被传递到 <paramref name="path" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-332">-or-  <see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="75438-333">返回随机文件夹名或文件名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-333">Returns a random folder name or file name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-334">随机文件夹名或文件名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-334">A random folder name or file name.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-335"><xref:System.IO.Path.GetRandomFileName%2A>方法返回加密型强随机字符串可用作文件夹名称或文件名称。</span><span class="sxs-lookup"><span data-stu-id="75438-335">The <xref:System.IO.Path.GetRandomFileName%2A> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</span></span> <span data-ttu-id="75438-336">与不同<xref:System.IO.Path.GetTempFileName%2A>，<xref:System.IO.Path.GetRandomFileName%2A>不会创建一个文件。</span><span class="sxs-lookup"><span data-stu-id="75438-336">Unlike <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> does not create a file.</span></span> <span data-ttu-id="75438-337">当您的文件系统的安全性是至关重要的时而不是应使用此方法<xref:System.IO.Path.GetTempFileName%2A>。</span><span class="sxs-lookup"><span data-stu-id="75438-337">When the security of your file system is paramount, this method should be used instead of <xref:System.IO.Path.GetTempFileName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-338">下面的示例显示的输出<xref:System.IO.Path.GetRandomFileName%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="75438-338">The following example show output from the <xref:System.IO.Path.GetRandomFileName%2A> method.</span></span>  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeTo">To be added.</param>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="75438-339">在磁盘上创建磁唯一命名的零字节的临时文件并返回该文件的完整路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-339">Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-340">临时文件的完整路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-340">The full path of the temporary file.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-341">此方法创建的临时文件。TMP 文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="75438-341">This method creates a temporary file with a .TMP file extension.</span></span> <span data-ttu-id="75438-342">在用户的临时文件夹中，是的路径创建临时文件返回<xref:System.IO.Path.GetTempPath%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="75438-342">The temporary file is created within the user’s temporary folder, which is the path returned by the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
 <span data-ttu-id="75438-343"><xref:System.IO.Path.GetTempFileName%2A>方法将引发<xref:System.IO.IOException>如果它用于创建多个 65535 个文件而不会删除以前的临时文件。</span><span class="sxs-lookup"><span data-stu-id="75438-343">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if it is used to create more than 65535 files without deleting previous temporary files.</span></span>  
  
 <span data-ttu-id="75438-344"><xref:System.IO.Path.GetTempFileName%2A>方法将引发<xref:System.IO.IOException>没有唯一的临时文件名称是否可用。</span><span class="sxs-lookup"><span data-stu-id="75438-344">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if no unique temporary file name is available.</span></span> <span data-ttu-id="75438-345">若要解决此错误，删除所有不需要的临时文件。</span><span class="sxs-lookup"><span data-stu-id="75438-345">To resolve this error, delete all unneeded temporary files.</span></span>  
  
 <span data-ttu-id="75438-346">通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="75438-346">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="75438-347">发生 I/O 错误，例如没有提供唯一的临时文件名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-347">An I/O error occurs, such as no unique temporary file name is available.</span>
          </span>
          <span data-ttu-id="75438-348">\- 或 -  此方法无法创建临时文件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-348">\- or -  This method was unable to create a temporary file.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="75438-349">用于写入到临时目录。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-349">for writing to the temporary directory.</span>
          </span>
          <span data-ttu-id="75438-350">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-350">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="75438-351">返回当前用户的临时文件夹的路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-351">Returns the path of the current user's temporary folder.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-352">临时文件夹的路径，以反斜杠结尾。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-352">The path to the temporary folder, ending with a backslash.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-353">此方法检查存在以下顺序中的环境变量，并使用找到的第一个路径：</span><span class="sxs-lookup"><span data-stu-id="75438-353">This method checks for the existence of environment variables in the following order and uses the first path found:</span></span>  
  
1.  <span data-ttu-id="75438-354">TMP 环境变量指定的路径。</span><span class="sxs-lookup"><span data-stu-id="75438-354">The path specified by the TMP environment variable.</span></span>  
  
2.  <span data-ttu-id="75438-355">由 TEMP 环境变量指定的路径。</span><span class="sxs-lookup"><span data-stu-id="75438-355">The path specified by the TEMP environment variable.</span></span>  
  
3.  <span data-ttu-id="75438-356">由用户配置文件环境变量指定的路径。</span><span class="sxs-lookup"><span data-stu-id="75438-356">The path specified by the USERPROFILE environment variable.</span></span>  
  
4.  <span data-ttu-id="75438-357">Windows 目录中。</span><span class="sxs-lookup"><span data-stu-id="75438-357">The Windows directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-358">下面的代码演示如何调用 <xref:System.IO.Path.GetTempPath%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="75438-358">The following code shows how to call the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 <span data-ttu-id="75438-359">此示例生成类似于以下输出。</span><span class="sxs-lookup"><span data-stu-id="75438-359">This example produces output similar to the following.</span></span>  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="75438-360">调用方没有所需的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-360">The caller does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">
          <span data-ttu-id="75438-361">有关不受限制访问环境变量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-361">for unrestricted access to environment variables.</span>
          </span>
          <span data-ttu-id="75438-362">关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-362">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="75438-363">用于搜索扩展名的路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-363">The path to search for an extension.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="75438-364">确定路径是否包括文件扩展名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-364">Determines whether a path includes a file name extension.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-365">如果路径中最后一个目录分隔符（\\\ 或 /）或卷分隔符 (:) 之后的字符包括句点 (.)，并且后面跟有一个或多个字符，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-365">
              <see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-366">从末尾开始`path`，此方法搜索的句点 （.） 后, 跟至少一个字符。</span><span class="sxs-lookup"><span data-stu-id="75438-366">Starting from the end of `path`, this method searches for a period (.) followed by at least one character.</span></span> <span data-ttu-id="75438-367">如果之前找到此模式<xref:System.IO.Path.DirectorySeparatorChar>， <xref:System.IO.Path.AltDirectorySeparatorChar>，或<xref:System.IO.Path.VolumeSeparatorChar>遇到字符时，此方法返回`true`。</span><span class="sxs-lookup"><span data-stu-id="75438-367">If this pattern is found before a <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar> character is encountered, this method returns `true`.</span></span>  
  
 <span data-ttu-id="75438-368">通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="75438-368">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-369">下面的代码示例演示如何将`HasExtension`方法。</span><span class="sxs-lookup"><span data-stu-id="75438-369">The following code example demonstrates the use of the `HasExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="75438-370">
            <paramref name="path" /> 包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中已定义的一个或多个无效字符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-370">
              <paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="75438-371">提供平台特定的字符数组，这些字符不能在传递到 <see cref="T:System.IO.Path" /> 类的成员的路径字符串参数中指定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-371">Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-372">不保证此方法返回的数组以包含在文件和目录名称中无效的字符的完整集合。</span><span class="sxs-lookup"><span data-stu-id="75438-372">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="75438-373">无效的字符的完整集可能会因文件系统。</span><span class="sxs-lookup"><span data-stu-id="75438-373">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="75438-374">例如，在基于 Windows 的桌面平台上无效路径字符可能包括 ASCII/Unicode 字符 1 到 31 之间，以及用引号括起来 （"）、 小于 (\<)、 大于号 (>)、 竖线 (&#124;)，退格符 (\b)、 null (\0) 和制表符 (\t)。</span><span class="sxs-lookup"><span data-stu-id="75438-374">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="75438-375">不要使用<xref:System.IO.Path.InvalidPathChars>如果您认为您的代码可能不受信任的代码相同的应用程序域中执行。</span><span class="sxs-lookup"><span data-stu-id="75438-375">Do not use <xref:System.IO.Path.InvalidPathChars> if you think your code might execute in the same application domain as untrusted code.</span></span> <span data-ttu-id="75438-376"><xref:System.IO.Path.InvalidPathChars> 是一个数组，以便可以覆盖它的元素。</span><span class="sxs-lookup"><span data-stu-id="75438-376"><xref:System.IO.Path.InvalidPathChars> is an array, so its elements can be overwritten.</span></span> <span data-ttu-id="75438-377">如果不受信任的代码覆盖的元素<xref:System.IO.Path.InvalidPathChars>，它可能会导致代码无法正常工作的可能被利用的方式。</span><span class="sxs-lookup"><span data-stu-id="75438-377">If untrusted code overwrites elements of <xref:System.IO.Path.InvalidPathChars>, it might cause your code to malfunction in ways that could be exploited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-378">下面的代码示例演示如何将`InvalidPathChars`属性。</span><span class="sxs-lookup"><span data-stu-id="75438-378">The following code example demonstrates the use of the `InvalidPathChars` property.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="75438-379">要测试的路径。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-379">The path to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="75438-380">获取一个值，该值指示指定的路径字符串是否包含根。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-380">Gets a value indicating whether the specified path string contains a root.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="75438-381">如果 <paramref name="path" /> 包含一个根，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-381">
              <see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-382"><xref:System.IO.Path.IsPathRooted%2A>方法将返回`true`如果第一个字符是目录分隔符字符如"\\"，或如果路径以驱动器号和冒号 （:） 开头。</span><span class="sxs-lookup"><span data-stu-id="75438-382">The <xref:System.IO.Path.IsPathRooted%2A> method returns `true` if the first character is a directory separator character such as "\\", or if the path starts with a drive letter and colon (:).</span></span> <span data-ttu-id="75438-383">例如，它将返回`true`有关`path`如字符串"\\\MyDir\\\MyFile.txt"，"c:\\\MyDir"，或"C:MyDir"。</span><span class="sxs-lookup"><span data-stu-id="75438-383">For example, it returns `true` for `path` strings such as "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", or "C:MyDir".</span></span> <span data-ttu-id="75438-384">它将返回`false`为`path`如"MyDir"的字符串。</span><span class="sxs-lookup"><span data-stu-id="75438-384">It returns `false` for `path` strings such as "MyDir".</span></span>  
  
 <span data-ttu-id="75438-385">此方法不会验证路径或文件名称存在。</span><span class="sxs-lookup"><span data-stu-id="75438-385">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="75438-386">通用 I/O 任务的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="75438-386">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-387">下面的代码示例演示如何将`IsPathRooted`方法可用于测试的三个字符串。</span><span class="sxs-lookup"><span data-stu-id="75438-387">The following code example demonstrates how the `IsPathRooted` method can be used to test three strings.</span></span>  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="75438-388">
            <paramref name="path" /> 包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中已定义的一个或多个无效字符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-388">
              <paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="75438-389">用于在环境变量中分隔路径字符串的平台特定的分隔符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-389">A platform-specific separator character used to separate path strings in environment variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-390">在基于 Windows 的桌面平台上，此字段的值是以分号 （;） 默认情况下，但在其他平台上可能会有所不同。</span><span class="sxs-lookup"><span data-stu-id="75438-390">On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-391">下面的代码示例演示如何将`PathSeparator`字段。</span><span class="sxs-lookup"><span data-stu-id="75438-391">The following code example demonstrates the use of the `PathSeparator` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="75438-392">提供平台特定的卷分隔符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="75438-392">Provides a platform-specific volume separator character.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75438-393">此字段的值是冒号 （:） 在 Windows 和 Macintosh 和 UNIX 操作系统上的以斜杠 （/）。</span><span class="sxs-lookup"><span data-stu-id="75438-393">The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</span></span> <span data-ttu-id="75438-394">这是最适用于分析路径，例如"c:\windows"或"MacVolume:System 文件夹"。</span><span class="sxs-lookup"><span data-stu-id="75438-394">This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75438-395">下面的代码示例演示如何将`VolumeSeparatorChar`字段。</span><span class="sxs-lookup"><span data-stu-id="75438-395">The following code example demonstrates the use of the `VolumeSeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>