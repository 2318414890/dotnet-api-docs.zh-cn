<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f524b1e2438cea1c3c824aa9514a36244ccff373" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30420551" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>侦听文件系统更改通知，并在目录或目录中的文件发生更改时引发事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileSystemWatcher>若要监视的指定目录中的更改。 你可以监视文件和子目录的指定目录中的更改。 你可以创建一个组件来监视本地计算机、 网络驱动器或远程计算机上的文件。  
  
 若要监视的所有文件中的更改，请设置<xref:System.IO.FileSystemWatcher.Filter%2A>属性为空字符串 ("") 或使用通配符 ("*。\*")。 若要监视的特定文件，<xref:System.IO.FileSystemWatcher.Filter%2A>到的文件名称的属性。 例如，若要监视的文件 MyDoc.txt 中的更改，请设置<xref:System.IO.FileSystemWatcher.Filter%2A>"MyDoc.txt"的属性。 你也可以观看某种类型的文件中的更改。 例如，若要监视的文本文件中的更改，请设置<xref:System.IO.FileSystemWatcher.Filter%2A>属性设置为"\*.txt"。  
  
 有几种类型的可监视的目录或文件中的更改。 例如，你可以监视中的更改`Attributes`、`LastWrite`日期和时间，或`Size`的文件或目录。 这可通过设置<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>属性之一<xref:System.IO.NotifyFilters>值。 你可以观看上的更改类型的详细信息，请参阅<xref:System.IO.NotifyFilters>。  
  
 你可以监视重命名，删除或创建文件或目录。 例如，若要监视的文本文件的重命名，请设置<xref:System.IO.FileSystemWatcher.Filter%2A>属性设置为"*.txt"并调用<xref:System.IO.FileSystemWatcher.WaitForChanged%2A>方法替换<xref:System.IO.WatcherChangeTypes.Renamed>指定为其参数。  
  
 Windows 操作系统会通知你组件创建的缓冲区中的文件发生更改<xref:System.IO.FileSystemWatcher>。 如果在短时间内有很多更改，则缓冲区可能溢出。 这将导致无法继续在目录中，更改跟踪的组件，它将仅向提供全面通知。 增加使用缓冲区的大小<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>属性开销较大，因为它来自无法换出到磁盘，因此尚未保持缓冲区尽可能小的非分页内存大型足以不会丢失任何文件更改事件。 若要避免缓冲区溢出，使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>和<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>属性，以便你可以筛选掉不需要更改通知。  
  
 有关的实例的初始属性值的列表<xref:System.IO.FileSystemWatcher>，请参阅<xref:System.IO.FileSystemWatcher.%23ctor%2A>构造函数。  
  
 请注意以下，当使用<xref:System.IO.FileSystemWatcher>类。  
  
-   不忽略隐藏的文件。  
  
-   在某些系统中，<xref:System.IO.FileSystemWatcher>报告使用短 8.3 文件名格式的文件更改。 例如，对"LongFileName.LongExtension"的更改可能被报告为"LongFil ~。Lon"。  
  
-   此类包含链接要求，并且在类级别应用于所有成员继承要求。 A<xref:System.Security.SecurityException>直接调用方或派生的类没有完全信任权限时，将引发。 有关安全要求的详细信息，请参阅[链接需求](~/docs/framework/misc/link-demands.md)。  
  
-   你可以为设置的最大大小<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>通过网络监视目录的属性为 64 KB。  
  
> [!NOTE]
>  运行<xref:System.IO.FileSystemWatcher>不支持在 Windows 98 上。  
  
## <a name="copying-and-moving-folders"></a>复制和移动文件夹  
 操作系统和<xref:System.IO.FileSystemWatcher>对象解释某个剪切和粘贴操作，或者作为文件夹及其内容的重命名操作的移动操作。 如果将剪切并粘贴到所监视的文件夹的文件的文件夹<xref:System.IO.FileSystemWatcher>对象报告仅为新的该文件夹，但而非其内容，因为它们仅实质上是重命名。  
  
 若要得到通知文件夹的内容已移动或复制到受监视的文件夹，请提供<xref:System.IO.FileSystemWatcher.OnChanged%2A>和<xref:System.IO.FileSystemWatcher.OnRenamed%2A>根据下表中的建议的事件处理程序方法。  
  
|事件处理程序|处理事件|执行|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|报告中文件属性、 创建的文件和已删除的文件的更改。|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|列出的旧和新路径的重命名的文件和文件夹，如果需要扩展以递归方式。|  
  
## <a name="events-and-buffer-sizes"></a>事件和缓冲区大小  
 请注意，几个因素可以影响引发哪些文件系统更改事件，如以下所述：  
  
-   常见的文件系统操作可能会引发多个事件。 例如，当文件从一个目录移到另一个、 几个<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引发事件。 移动文件一个复杂的操作的多个简单操作组成，因此会引发多个事件。 同样，某些应用程序 （例如，防病毒软件） 可能会导致检测到的其他文件系统事件<xref:System.IO.FileSystemWatcher>。  
  
-   <xref:System.IO.FileSystemWatcher>可以观看磁盘，只要它们不会切换或删除。 <xref:System.IO.FileSystemWatcher>不会引发事件 Cd 和 Dvd，由于不能更改时间戳和属性。 远程计算机必须具有以正常组件的安装的所需平台之一。  
  
-   如果选择多个<xref:System.IO.FileSystemWatcher>对象正在监视的相同的 UNC 路径，在 Service Pack 1 之前的 Windows XP 或 Windows 2000 SP2 或更早版本，则仅之一对象将引发事件。 在计算机上运行 Windows XP SP1 和更高版本，Windows 2000 SP3 或更高版本或 Windows Server 2003 中，所有<xref:System.IO.FileSystemWatcher>对象将引发相应的事件。  
  
 请注意，<xref:System.IO.FileSystemWatcher>可能会丢失超出缓冲区大小时发生的事件。 若要避免丢失事件，请遵循以下准则：  
  
-   增加缓冲区大小设置<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>属性。  
  
-   避免监视具有长文件名的文件，因为分配给填满缓冲区的长文件名。 请考虑重命名这些文件使用较短名称。  
  
-   保持您的事件处理代码尽可能短。  
  
   
  
## Examples  
 下面的示例创建<xref:System.IO.FileSystemWatcher>监视在运行时指定的目录。 该组件设置以监视中的更改`LastWrite`和`LastAccess`时间、 创建、 删除或重命名的目录中的文本文件。 如果文件是更改、 创建，或删除，该文件的路径将打印到控制台。 当文件已重命名，旧的和新路径打印到控制台。  
  
 使用<xref:System.Diagnostics>和<xref:System.IO>对于此示例的命名空间。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">为派生自<see cref="T:System.Diagnostics.ProcessStartInfo" />类。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />;命名权限集： <see langword="FullTrust" />。</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.IO.FileSystemWatcher" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.IO.FileSystemWatcher" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 没有 Windows NT 或 Windows 2000 的远程计算机，则无法将其收看。 从 Windows NT 4.0 的计算机的远程 Windows NT 4.0 计算机，则无法将其收看。  
  
 下表显示的实例的初始属性值<xref:System.IO.FileSystemWatcher>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|按位 OR 组合`LastWrite`， `FileName`，和 `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*.\*"（监视所有文件。）|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|空字符串 ("")|  
  
> [!NOTE]
>  该组件将不监视指定的目录，直到<xref:System.IO.FileSystemWatcher.Path%2A>设置，和<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
   
  
## Examples  
 下面的示例创建<xref:System.IO.FileSystemWatcher>要监视在运行时指定的目录对象。 <xref:System.IO.FileSystemWatcher>对象监视中的更改`LastWrite`和`LastAccess`时间，以及创建、 删除或重命名的文本将文件目录中。 如果更改文件、 将其创建，或删除，将显示在控制台文件的路径。 当文件已重命名时，则向控制台显示的旧和新路径。  
  
 此示例使用<xref:System.Diagnostics>和<xref:System.IO>命名空间。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要监视的目录，以标准表示法或通用命名约定 (UNC) 表示法表示。</param>
        <summary>在给定要监视的指定目录的情况下，初始化 <see cref="T:System.IO.FileSystemWatcher" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  该组件将不监视指定的目录，直到<xref:System.IO.FileSystemWatcher.Path%2A>设置，和<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
 该组件可以监视你的个人计算机、 网络驱动器或远程计算机上的文件。  
  
 没有 Windows NT 或 Windows 2000 的远程计算机，则无法将其收看。 从 Windows NT 4.0 的计算机的远程 Windows NT 4.0 计算机，则无法将其收看。 <xref:System.IO.FileSystemWatcher.Filter%2A>默认设置属性来监视所有文件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 参数为空字符串 ("")。  
  
 或  
  
 通过 <paramref name="path" /> 参数指定的路径不存在。</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> 过长。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要监视的目录，以标准表示法或通用命名约定 (UNC) 表示法表示。</param>
        <param name="filter">要监视的文件的类型。 例如，“*.txt”监视所有文本文件的更改。</param>
        <summary>在给定要监视的指定目录和文件类型的情况下，初始化 <see cref="T:System.IO.FileSystemWatcher" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  该组件将不监视指定的目录，直到<xref:System.IO.FileSystemWatcher.Path%2A>设置，和<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
 该组件可以监视你的个人计算机、 网络驱动器或远程计算机上的文件。  
  
 没有 Windows NT 或 Windows 2000 的远程计算机，则无法将其收看。 从 Windows NT 4.0 的计算机的远程 Windows NT 4.0 计算机，则无法将其收看。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 参数为 <see langword="null" />。  
  
 或  
  
 <paramref name="filter" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 参数为空字符串 ("")。  
  
 或  
  
 通过 <paramref name="path" /> 参数指定的路径不存在。</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> 过长。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始初始化在窗体上使用或由另一个组件使用的 <see cref="T:System.IO.FileSystemWatcher" />。 初始化发生在运行时。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]设计环境使用此方法来启动的组件初始化窗体上使用或由另一个组件。 <xref:System.IO.FileSystemWatcher.EndInit%2A>方法初始化已结束。 使用<xref:System.IO.FileSystemWatcher.BeginInit%2A>和<xref:System.IO.FileSystemWatcher.EndInit%2A>方法阻止控件完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当更改指定 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中的文件和目录时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.Changed>大小发生更改时引发事件时，系统属性，上次写入时间、 上次访问时间或文件或目录的安全权限在所监视的目录中。  
  
> [!NOTE]
>  常见的文件系统操作可能会引发多个事件。 例如，当文件从一个目录移到另一个、 几个<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引发事件。 移动文件一个复杂的操作的多个简单操作组成，因此会引发多个事件。 同样，某些应用程序 （例如，防病毒软件） 可能会导致检测到的其他文件系统事件<xref:System.IO.FileSystemWatcher>。  
  
 使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>来限制在处理此事件时引发的通知数。  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Changed>时某个文件被重命名，但重命名目录时，则不会引发意外引发事件。 若要监视的重命名，请使用<xref:System.IO.FileSystemWatcher.Renamed>事件。  
  
> [!NOTE]
>  顺序<xref:System.IO.FileSystemWatcher.Changed>相对于其他引发事件<xref:System.IO.FileSystemWatcher>事件可能会更改时<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>属性不是`null`。  
  
   
  
## Examples  
 下面的示例使用<xref:System.IO.FileSystemWatcher.Changed>事件来监视的文件更改时向控制台显示的文件路径。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在指定 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中创建文件和目录时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一些常见的事件，例如复制或移动文件或目录，直接与某个事件，并不对应，但这些匹配项便会导致要引发事件。 复制文件或目录时，系统将引发<xref:System.IO.FileSystemWatcher.Created>文件被复制到，如果该目录正在受监视的目录中的事件。 如果正在由另一个实例的监视从中复制的目录<xref:System.IO.FileSystemWatcher>，会引发任何事件。 例如，你创建的两个实例<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 设置为监视"C:\My Documents"和 FileSystemWatcher2 设置为监视"C:\Your 文档"。 如果你将文件从"我的文档"复制到"你的文档"， <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2，将引发事件，但对于 FileSystemWatcher1 引发任何事件。 与复制不同，移动文件或目录将引发两个事件。 从前面的示例中，如果从"我的文档"文件移至"您的文档"， <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2 时将引发事件和一个<xref:System.IO.FileSystemWatcher.Deleted>FileSystemWatcher1 时将引发事件。  
  
> [!NOTE]
>  常见的文件系统操作可能会引发多个事件。 例如，当文件从一个目录移到另一个、 几个<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引发事件。 移动文件一个复杂的操作的多个简单操作组成，因此会引发多个事件。 同样，某些应用程序 （例如，防病毒软件） 可能会导致检测到的其他文件系统事件<xref:System.IO.FileSystemWatcher>。  
  
> [!NOTE]
>  顺序<xref:System.IO.FileSystemWatcher.Created>相对于其他引发事件<xref:System.IO.FileSystemWatcher>事件可能会更改时<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>属性不是`null`。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>创建一个文件时，就会立即引发事件。 如果文件正在复制或传输到受监视的目录，<xref:System.IO.FileSystemWatcher.OnCreated%2A>将立即引发事件后, 跟一个或多个<xref:System.IO.FileSystemWatcher.OnChanged%2A>事件。  
  
   
  
## Examples  
 下面的示例使用<xref:System.IO.FileSystemWatcher.Created>事件，以向控制台显示的文件路径，每当创建监视的文件。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>删除指定 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中的文件或目录时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一些常见的事件，例如复制或移动文件或目录，直接与某个事件，并不对应，但这些匹配项便会导致要引发事件。 复制文件或目录时，系统将引发<xref:System.IO.FileSystemWatcher.Created>文件被复制到，如果该目录正在受监视的目录中的事件。 如果正在由另一个实例的监视从中复制的目录<xref:System.IO.FileSystemWatcher>，会引发任何事件。 例如，你创建的两个实例<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 设置为监视"C:\My Documents"和 FileSystemWatcher2 设置为监视"C:\Your 文档"。 如果你将文件从"我的文档"复制到"你的文档"， <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2，将引发事件，但对于 FileSystemWatcher1 引发任何事件。 与复制不同，移动文件或目录将引发两个事件。 从前面的示例中，如果从"我的文档"文件移至"您的文档"， <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2 时将引发事件和一个<xref:System.IO.FileSystemWatcher.Deleted>FileSystemWatcher1 时将引发事件。  
  
> [!NOTE]
>  常见的文件系统操作可能会引发多个事件。 例如，当文件从一个目录移到另一个、 几个<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引发事件。 移动文件一个复杂的操作的多个简单操作组成，因此会引发多个事件。 同样，某些应用程序 （例如，防病毒软件） 可能会导致检测到的其他文件系统事件<xref:System.IO.FileSystemWatcher>。  
  
> [!NOTE]
>  顺序<xref:System.IO.FileSystemWatcher.Deleted>相对于其他引发事件<xref:System.IO.FileSystemWatcher>事件可能会更改时<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>属性不是`null`。  
  
   
  
## Examples  
 下面的示例使用<xref:System.IO.FileSystemWatcher.Deleted>事件，以删除监视的文件时，向控制台显示的文件路径。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放由 <see cref="T:System.IO.FileSystemWatcher" /> 占用的非托管资源，还可以另外再释放托管资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法称为由公共<xref:System.ComponentModel.Component.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。 <xref:System.ComponentModel.Component.Dispose%2A> 调用受保护<xref:System.IO.FileSystemWatcher.Dispose%2A>方法替换`disposing`参数设置为`true`。 <xref:System.Object.Finalize%2A> 调用<xref:System.IO.FileSystemWatcher.Dispose%2A>与`disposing`设置为`false`。  
  
 当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.IO.Compression.DeflateStream> 引用的、由任何托管对象持有的全部资源。 此方法调用每个引用对象的 <xref:System.ComponentModel.Component.Dispose%2A> 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> 可以由其他对象多次调用。 在重写<see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />请注意不要引用已释放的以前调用中的对象<see cref="M:System.ComponentModel.Component.Dispose" />。 有关如何实现详细信息<see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />，请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
 有关详细信息<see cref="M:System.ComponentModel.Component.Dispose" />和<see cref="M:System.Object.Finalize" />，请参阅[清洗向上非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否启用此组件。</summary>
        <value>
          如果启用此组件，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。 如果在 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 的设计器上使用该组件，则默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 组件将不会引发事件，除非你设置<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>到`true`。  
  
> [!NOTE]
>  该组件将不监视指定的目录，直到<xref:System.IO.FileSystemWatcher.Path%2A>设置属性和<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
 <xref:System.IO.FileSystemWatcher.WaitForChanged%2A>方法允许将调用响应文件更改，即使此属性设置为事件处理程序`false`。  
  
   
  
## Examples  
 下面的示例创建<xref:System.IO.FileSystemWatcher>监视在运行时指定的目录。 该组件设置以监视中的更改`LastWrite`和`LastAccess`时间、 创建、 删除或重命名的目录中的文本文件。 如果文件是更改、 创建，或删除，该文件的路径将打印到控制台。 当文件已重命名，旧的和新路径打印到控制台。  
  
 使用<xref:System.Diagnostics>和<xref:System.IO>对于此示例的命名空间。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.IO.FileSystemWatcher" /> 对象已释放。</exception>
        <exception cref="T:System.PlatformNotSupportedException">当前操作系统不是 Microsoft Windows NT 或更高版本。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未能找到 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中指定的目录。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.IO.FileSystemWatcher.Path" /> 尚未设置或无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>结束在窗体上使用或由另一个组件使用的 <see cref="T:System.IO.FileSystemWatcher" /> 的初始化。 初始化发生在运行时。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]设计环境使用此方法来结束的组件初始化窗体上使用或由另一个组件。 <xref:System.IO.FileSystemWatcher.BeginInit%2A>方法开始初始化。 使用<xref:System.IO.FileSystemWatcher.BeginInit%2A>和<xref:System.IO.FileSystemWatcher.EndInit%2A>方法阻止控件完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.IO.FileSystemWatcher" /> 的实例无法继续监视更改或内部缓冲区溢出时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些内容阻止时将引发此事件<xref:System.IO.FileSystemWatcher>从监视更改的对象。 例如，如果对象正在监视远程目录中的更改，而与该目录的连接已丢失，<xref:System.IO.FileSystemWatcher.Error>引发事件。  
  
 系统会通知你的文件发生更改，并将那些更改存储的缓冲区中，在组件创建并传递给 Api。 如果在短时间内有很多更改，则缓冲区可能溢出。 这将导致无法继续在目录中，更改跟踪的组件，它将仅向提供全面通知。 增加缓冲区的大小将占用大量资源，因为它是来自非分页内存无法换出到磁盘，因此保持缓冲区尽可能小。 若要避免缓冲区溢出，使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>， <xref:System.IO.FileSystemWatcher.Filter%2A>，和<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>属性筛选掉不需要的更改通知。  
  
> [!NOTE]
>  常见的文件系统操作可能会引发多个事件。 例如，当文件从一个目录移到另一个、 几个<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引发事件。 移动文件一个复杂的操作的多个简单操作组成，因此会引发多个事件。 同样，某些应用程序 （例如，防病毒软件） 可能会导致检测到的其他文件系统事件<xref:System.IO.FileSystemWatcher>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于确定在目录中监视哪些文件的筛选器字符串。</summary>
        <value>筛选器字符串。 默认值为"*。\*"（监视所有文件。）</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要监视的所有文件中的更改，将设置<xref:System.IO.FileSystemWatcher.Filter%2A>属性为空字符串 ("")。 若要监视的特定文件，<xref:System.IO.FileSystemWatcher.Filter%2A>到的文件名称的属性。 例如，若要监视的文件 MyDoc.txt 中的更改，请设置<xref:System.IO.FileSystemWatcher.Filter%2A>"MyDoc.txt"的属性。 你也可以观看某种类型的文件中的更改。 例如，若要监视的任何文本文件中的更改，请设置<xref:System.IO.FileSystemWatcher.Filter%2A>属性设置为"*.txt"。 使用多个筛选器，如"\*.txt&#124;\*.doc"不支持。  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A>后可以更改属性<xref:System.IO.FileSystemWatcher>对象已开始接收事件。  
  
 有关筛选掉不需要的通知的详细信息，请参阅<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>， <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>，和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>属性。  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> 接受通配符匹配的文件，如下面的示例中所示。  
  
|筛选器字符串|监视以下文件|  
|-------------------|---------------------------------|  
|*.\*|所有文件 （默认值）。 空字符串 ("") 还监视所有文件。|  
|*.txt|具有"txt"扩展名的所有文件。|  
|*recipe.doc|以"配方"扩展名"文档"结尾的所有文件。|  
|win*.xml|使用"win"开头的"xml"扩展的所有文件。|  
|Sales*200?.xls|匹配下列文件：<br /><br /> 销售年 7 月 2001.xlsSales 日 2002.xlsSales 年 3 月 2004.xls<br /><br /> 但不匹配：<br /><br /> 销售年 11 月 1999.xls|  
|MyReport.Doc|监视仅 MyReport.doc|  
  
   
  
## Examples  
 下面的示例创建<xref:System.IO.FileSystemWatcher>监视在运行时指定的目录。 该组件设置以监视中的更改`LastWrite`和`LastAccess`时间、 创建、 删除或重命名的目录中的文本文件。 如果文件是更改、 创建，或删除，该文件的路径将打印到控制台。 当文件已重命名，旧的和新路径打印到控制台。  
  
 使用<xref:System.Diagnostics>和<xref:System.IO>对于此示例的命名空间。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否应监视指定路径中的子目录。</summary>
        <value>
          如果要监视子目录，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>到`true`如果想要监视的文件和通过指定的目录中包含的目录更改通知<xref:System.IO.FileSystemWatcher.Path%2A>属性，并且及其子目录。 设置<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>属性`false`，从而降低了的通知发送到内部缓冲区数。 筛选掉不需要通知的详细信息，请参阅<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>属性。  
  
 当`true`，<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>是访问整个子树，而不仅仅是直接子目录递归。 文件或目录子树内的相对路径返回中<xref:System.IO.FileSystemEventArgs.Name%2A>属性<xref:System.IO.FileSystemEventArgs>和<xref:System.IO.RenamedEventArgs.OldName%2A>属性<xref:System.IO.RenamedEventArgs>，取决于正在监视的更改。 你可以从的完全限定的路径<xref:System.IO.FileSystemEventArgs.FullPath%2A>属性<xref:System.IO.FileSystemEventArgs>和<xref:System.IO.RenamedEventArgs.OldFullPath%2A>属性<xref:System.IO.RenamedEventArgs>，取决于正在监视的更改。  
  
 如果正在监视的目录的子树中创建一个目录和<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>是`true`，将自动监视该目录。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置内部缓冲区的大小（以字节为单位）。</summary>
        <value>内部缓冲区的大小（以字节为单位）。 默认值为 8192 (8 KB)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以设置缓冲区，为 4 KB 或更大，但它不能超过 64 KB。 如果你尝试设置<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>属性为少于 4096 个字节，你的值将被丢弃和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>属性设置为 4096 个字节。 为了获得最佳性能，在基于 Intel 的计算机上使用 4 KB 的倍数。  
  
 系统通知文件更改时，组件并将那些更改存储在缓冲区的组件创建，并且传递给 Api。 每个事件可以使用最多 16 个字节的内存，不包括文件的名称。 如果在短时间内有很多更改，则缓冲区可能溢出。 这将导致无法继续在目录中，更改跟踪的组件，它将仅向提供全面通知。 增加缓冲区的大小可以防止丢失文件系统更改事件。 但是，增加缓冲区大小是占用大量资源的因为它的来源无法换出到磁盘中，因此保持缓冲区尽可能小的非分页内存。 若要避免缓冲区溢出，使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>和<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>属性筛选掉不需要的更改通知。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要监视的更改的类型。</summary>
        <value>
          <see cref="T:System.IO.NotifyFilters" /> 值之一。 默认值为 <see langword="LastWrite" />、<see langword="FileName" /> 和 <see langword="DirectoryName" /> 的按位“或”组合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以组合的成员<xref:System.IO.NotifyFilters>要监视的一次更改多个类型的枚举。 例如，可以监视方面的更改中的文件的大小的更改和`LastWrite`时间。 这就提高了事件没有文件或文件夹大小更改或中的更改的任何时候`LastWrite`文件或文件夹的时间。  
  
 这是一种方式筛选掉不需要的通知。 筛选掉不需要通知的详细信息，请参阅<xref:System.IO.FileSystemWatcher.Filter%2A>， <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>，和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>属性。  
  
   
  
## Examples  
 下面的示例创建<xref:System.IO.FileSystemWatcher>监视在运行时指定的目录。 该组件设置以监视中的更改`LastWrite`和`LastAccess`时间、 创建、 删除或重命名的目录中的文本文件。 如果文件是更改、 创建，或删除，该文件的路径将打印到控制台。 当文件已重命名，旧的和新路径打印到控制台。  
  
 使用<xref:System.Diagnostics>和<xref:System.IO>对于此示例的命名空间。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该值不是 <see cref="T:System.IO.NotifyFilters" /> 值的有效按位“或”组合。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">正在设置的值无效。</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.IO.FileSystemEventArgs" />。</param>
        <summary>引发 <see cref="E:System.IO.FileSystemWatcher.Changed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> 对大小、 系统属性、 上次写入时间、 上次访问时间或安全权限的文件或目录正在监视的目录中进行更改时调用。  
  
 使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>属性来限制事件的数目时引发<xref:System.IO.FileSystemWatcher.Changed>处理事件。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>创建一个文件时，就会立即引发事件。 如果文件正在复制或传输到受监视的目录，<xref:System.IO.FileSystemWatcher.OnCreated%2A>将立即引发事件后, 跟一个或多个<xref:System.IO.FileSystemWatcher.OnChanged%2A>事件。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />方法。</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.IO.FileSystemEventArgs" />。</param>
        <summary>引发 <see cref="E:System.IO.FileSystemWatcher.Created" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> 在所监视的目录中创建文件或目录时调用。  
  
 一些常见的事件，例如复制或移动文件或目录，直接与某个事件，并不对应，但这些匹配项便会导致要引发事件。 复制文件或目录时，系统将引发<xref:System.IO.FileSystemWatcher.Created>文件被复制到，如果该目录正在受监视的目录中的事件。 如果正在由另一个实例的监视从中复制的目录<xref:System.IO.FileSystemWatcher>，会引发任何事件。 例如，你创建的两个实例<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 设置为监视"C:\My Documents"和 FileSystemWatcher2 设置为监视"C:\Your 文档"。 如果你从"我的文档"复制文件并将其粘贴到"你的文档"，<xref:System.IO.FileSystemWatcher.Created>中 FileSystemWatcher2，将引发事件，但对于 FileSystemWatcher1 引发任何事件。 与复制不同，移动文件或目录将引发两个事件。 从前面的示例中，如果从"我的文档"文件移至"您的文档"，<xref:System.IO.FileSystemWatcher.Created>将在 FileSystemWatcher2 中引发事件和一个<xref:System.IO.FileSystemWatcher.Deleted>将在 FileSystemWatcher1 中引发事件。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>创建一个文件时，就会立即引发事件。 如果文件正在复制或传输到受监视的目录，<xref:System.IO.FileSystemWatcher.OnCreated%2A>将立即引发事件后, 跟一个或多个<xref:System.IO.FileSystemWatcher.OnChanged%2A>事件。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />方法。</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.IO.FileSystemEventArgs" />。</param>
        <summary>引发 <see cref="E:System.IO.FileSystemWatcher.Deleted" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> 删除文件或目录，在所监视的目录中时调用。  
  
 一些常见的事件，例如复制或移动文件或目录，直接与某个事件，并不对应，但这些匹配项便会导致要引发事件。 复制文件或目录时，系统将引发<xref:System.IO.FileSystemWatcher.Created>文件被复制到，如果该目录正在受监视的目录中的事件。 如果正在由另一个实例的监视从中复制的目录<xref:System.IO.FileSystemWatcher>，会引发任何事件。 例如，你创建的两个实例<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 设置为监视"C:\My Documents"和 FileSystemWatcher2 设置为监视"C:\Your 文档"。 如果你将文件从"我的文档"复制到"你的文档"， <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2，将引发事件，但对于 FileSystemWatcher1 引发任何事件。 与复制不同，移动文件或目录将引发两个事件。 从前面的示例中，如果从"我的文档"文件移至"您的文档"， <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2 时将引发事件和一个<xref:System.IO.FileSystemWatcher.Deleted>FileSystemWatcher1 时将引发事件。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />方法。</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.IO.ErrorEventArgs" />。</param>
        <summary>引发 <see cref="E:System.IO.FileSystemWatcher.Error" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> 发生错误时调用。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />方法。</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.IO.RenamedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.IO.FileSystemWatcher.Renamed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> 重命名文件或正在监视的目录中目录时调用。 其<xref:System.IO.RenamedEventArgs>自变量包含有关操作的重命名操作，如更改、 旧的和新路径和旧的和新名称的类型的信息。 请注意，其<xref:System.IO.FileSystemEventArgs.Name>属性可以是空如果重命名事件<xref:System.IO.FileSystemWatcher>不获取匹配从操作系统的旧和新事件。 
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />方法。</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要监视的目录的路径。</summary>
        <value>要监视的路径。 默认值为空字符串("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个目录的完全限定的路径。 如果<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>属性是`true`，此目录是系统监视的更改的根目录; 否则它是受监视的唯一目录。 若要监视的特定文件，<xref:System.IO.FileSystemWatcher.Path%2A>属性的完全限定的正确的目录，和<xref:System.IO.FileSystemWatcher.Filter%2A>到的文件名称的属性。  
  
 <xref:System.IO.FileSystemWatcher.Path%2A>属性支持通用命名约定 (UNC) 路径。  
  
> [!NOTE]
>  组件可以监视的更改之前，必须设置此属性。  
  
 当目录重命名时，<xref:System.IO.FileSystemWatcher>自动将自身重新附加到刚刚重命名项。 例如，如果你设置<xref:System.IO.FileSystemWatcher.Path%2A>属性设置为"C:\My Documents"和"C:\Your 文档"到的目录，手动重命名，该组件将继续侦听刚刚重命名目录上的更改通知。 但是，当你请求<xref:System.IO.FileSystemWatcher.Path%2A>属性，它包含旧路径。 这是因为组件确定所监视基于该句柄，而不是目录的名称。 重命名并不影响句柄。 因此，如果销毁该组件，以及然后重新创建它而无需更新<xref:System.IO.FileSystemWatcher.Path%2A>属性，你的应用程序将失败，因为目录不再存在。  
  
   
  
## Examples  
 下面的示例创建<xref:System.IO.FileSystemWatcher>监视在运行时指定的目录。 该组件设置以监视中的更改`LastWrite`和`LastAccess`时间、 创建、 删除或重命名的目录中的文本文件。 如果文件是更改、 创建，或删除，该文件的路径将打印到控制台。 当文件已重命名，旧的和新路径打印到控制台。  
  
 使用<xref:System.Diagnostics>和<xref:System.IO>对于此示例的命名空间。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定的路径不存在或找不到。  
  
 或  
  
 指定的路径包含通配符。  
  
 或  
  
 指定的路径包含无效路径字符。</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>重命名指定 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中的文件或目录时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Renamed`事件是<xref:System.IO.RenamedEventHandler>具有以下签名的委托：

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 <xref:System.IO.RenamedEventArgs>对象提供了有关重命名操作，例如重命名类型的信息 (<xref:System.IO.FileSystemEventArgs.ChangeType>属性)，旧的和新名称和旧的和新路径。 请注意，<xref:System.IO.FileSystemEventArgs.Name>属性可以是空如果重命名事件<xref:System.IO.FileSystemWatcher>不获取匹配从操作系统的旧和新事件。

 重命名所监视的目录不会引发通知。 正在监视的目录内部的条目仅会引发通知。  
  
   
  
## Examples  
 下面的示例使用<xref:System.IO.FileSystemWatcher.Renamed>事件监视的文件已重命名时向控制台显示的文件路径。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.IO.FileSystemWatcher" /> 的 <see cref="T:System.ComponentModel.ISite" />。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> 的一个 <see cref="T:System.IO.FileSystemWatcher" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 站点绑定<xref:System.ComponentModel.Component>到<xref:System.ComponentModel.Design.IDesignerHost.Container%2A>和启用它们之间的通信，以及为要管理其组件的容器提供的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于封送因目录更改而发出的事件处理程序调用的对象。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" />，表示一个对象，该对象用于封送因目录更改而发出的事件处理程序调用。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>是`null`，方法处理<xref:System.IO.FileSystemWatcher.Changed>， <xref:System.IO.FileSystemWatcher.Created>， <xref:System.IO.FileSystemWatcher.Deleted>，和<xref:System.IO.FileSystemWatcher.Renamed>事件称为系统线程池中的线程上。 系统线程池的详细信息，请参阅<xref:System.Threading.ThreadPool>。  
  
 当<xref:System.IO.FileSystemWatcher.Changed>， <xref:System.IO.FileSystemWatcher.Created>， <xref:System.IO.FileSystemWatcher.Deleted>，和<xref:System.IO.FileSystemWatcher.Renamed>事件由 visual 的 Windows 窗体组件，如处理<xref:System.Windows.Forms.Button>，通过系统线程池访问组件可能不起作用，或者可能会导致异常。 通过设置来避免这<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>到 Windows 窗体组件时，这将导致产生方法，用于处理<xref:System.IO.FileSystemWatcher.Changed>， <xref:System.IO.FileSystemWatcher.Created>， <xref:System.IO.FileSystemWatcher.Deleted>，和<xref:System.IO.FileSystemWatcher.Renamed>事件在其创建该组件在同一线程上调用。  
  
 如果<xref:System.IO.FileSystemWatcher>在内部使用[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]在 Windows 窗体设计器中，<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>自动设置为包含的控件<xref:System.IO.FileSystemWatcher>。 例如，如果你将放置<xref:System.IO.FileSystemWatcher>form1 设计器上 (其继承自<xref:System.Windows.Forms.Form>)<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>属性<xref:System.IO.FileSystemWatcher>被设置为 form1 的实例。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>一种同步方法，该方法会返回包含已发生的更改上的特定信息的结构。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">要监视的 <see cref="T:System.IO.WatcherChangeTypes" />。</param>
        <summary>一种同步方法，在给定要监视的更改的类型情况下，它会返回包含已发生的更改上的特定信息的结构。</summary>
        <returns>
          <see cref="T:System.IO.WaitForChangedResult" />，包含关于已发生的更改的特定信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法一直等到无限期第一次更改发生，并返回。 这是与使用相同<xref:System.IO.FileSystemWatcher.WaitForChanged%2A>与`timeout`参数设置为-1。  
  
> [!NOTE]
>  此方法允许事件处理程序将调用以响应文件更改，即使<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>属性设置为`false`。  
  
 在某些系统中，<xref:System.IO.FileSystemWatcher>报告使用短 8.3 文件名格式的文件更改。 例如，对"LongFileName.LongExtension"的更改可能被报告为"LongFi ~。Lon"。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">要监视的 <see cref="T:System.IO.WatcherChangeTypes" />。</param>
        <param name="timeout">超时前等待的时间（以毫秒表示）。</param>
        <summary>一种同步方法，在给定要监视的更改的类型以及在超时前等待的时间（以毫秒表示）的情况下，它会返回包含已发生的更改上的特定信息的结构。</summary>
        <returns>
          <see cref="T:System.IO.WaitForChangedResult" />，包含关于已发生的更改的特定信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法等待，直到发生更改或已超时。值为-1`timeout`参数表示无限期地等待。  
  
> [!NOTE]
>  此方法允许事件处理程序将调用以响应文件更改，即使<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>属性设置为`false`。  
  
 在某些系统中，<xref:System.IO.FileSystemWatcher>报告使用短 8.3 文件名格式的文件更改。 例如，对"LongFileName.LongExtension"的更改可能被报告为"LongFi ~。Lon"。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>