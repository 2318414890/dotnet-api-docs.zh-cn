<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="dcfd61af2ebaa502d576b0c9b8678e446f13ce2b" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36484689" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type FileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>为文件提供 <see cref="T:System.IO.Stream" />，既支持同步读写操作，也支持异步读写操作。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileStream>类来读取、 写入来，打开和关闭文件在文件系统中，并操纵其他与文件相关的操作系统句柄，包括管道、 标准输入和标准输出。 你可以使用<xref:System.IO.FileStream.Read%2A>， <xref:System.IO.FileStream.Write%2A>， <xref:System.IO.Stream.CopyTo%2A>，和<xref:System.IO.FileStream.Flush%2A>方法执行同步操作时，或<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>执行异步方法操作。 使用异步方法而不会阻止主线程中执行资源密集型文件操作。 在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。 <xref:System.IO.FileStream> 缓冲输入和输出以提高性能。  
  
> [!IMPORTANT]
>  此类型实现<xref:System.IDisposable>接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，调用其<xref:System.IDisposable.Dispose%2A>中的方法`try` / `catch`块。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅中的"使用实现 IDisposable 的对象"部分<xref:System.IDisposable>接口主题。  
  
 <xref:System.IO.FileStream.IsAsync%2A>属性检测是否异步打开的文件句柄。 在创建的实例时指定此值<xref:System.IO.FileStream>类使用的构造函数`isAsync`， `useAsync`，或`options`参数。 当该属性是`true`，流利用重叠的 I/O，异步执行文件操作。 但是，<xref:System.IO.FileStream.IsAsync%2A>属性不具有要`true`调用<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。 当<xref:System.IO.FileStream.IsAsync%2A>属性是`false`和调用异步读取和写入操作，仍未被阻止 UI 线程、，但同步执行实际的 I/O 操作。  
  
 <xref:System.IO.FileStream.Seek%2A>方法支持随机访问文件。 <xref:System.IO.FileStream.Seek%2A> 允许读/写位置移动到文件中的任意位置。 这是使用字节偏移量的引用点参数进行的。 字节偏移量是相对于查找引用点，可以是开头、 当前的位置或基础的文件中，末尾的三个成员由表示<xref:System.IO.SeekOrigin>枚举。  
  
> [!NOTE]
>  磁盘文件始终支持随机访问。 构造，次<xref:System.IO.FileStream.CanSeek%2A>属性值设置为`true`或`false`具体取决于基础的文件类型。如果基础的文件类型 FILE_TYPE_DISK 中 winbase.h，, 定义<xref:System.IO.FileStream.CanSeek%2A>属性值是`true`。 否则为<xref:System.IO.FileStream.CanSeek%2A>属性值是`false`。  
  
 如果进程终止，并显示锁定文件的一部分或关闭具有未完成的锁的文件，该行为不确定。  
  
 目录操作和其他文件操作，请参阅<xref:System.IO.File>， <xref:System.IO.Directory>，和<xref:System.IO.Path>类。 <xref:System.IO.File>类是一个实用工具类具有静态方法主要用于创建<xref:System.IO.FileStream>对象，基于文件路径。 <xref:System.IO.MemoryStream>类从字节数组创建一个流，它类似于<xref:System.IO.FileStream>类。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
## <a name="detection-of-stream-position-changes"></a>检测到的流位置更改  
 当<xref:System.IO.FileStream>对象不具有独占持有其句柄，另一个线程无法同时访问的文件句柄并且无法更改与文件句柄关联的操作系统的文件指针的位置。 在此情况下中的缓存位置<xref:System.IO.FileStream>可能危及对象和缓冲区中的缓存的数据。 <xref:System.IO.FileStream>对象定期执行的方法的访问缓存的缓冲区，以确保操作系统的句柄位置使用的缓存位置相同的检查<xref:System.IO.FileStream>对象。  
  
 如果在句柄位置中的发生意外的更改对的调用中检测到<xref:System.IO.FileStream.Read%2A>方法，.NET Framework 放弃缓冲区的内容，并再次从文件读取流。 这可能会影响性能，具体取决于文件和可能影响的文件流的位置的任何其他进程的大小。  
  
 如果在句柄位置中的发生意外的更改对的调用中检测到<xref:System.IO.FileStream.Write%2A>方法，缓冲区的内容将被丢弃和<xref:System.IO.IOException>引发异常。  
  
 A<xref:System.IO.FileStream>对象将不具有独占持有其句柄时任一<xref:System.IO.FileStream.SafeFileHandle%2A>访问属性时要公开句柄或<xref:System.IO.FileStream>对象都提供了<xref:System.IO.FileStream.SafeFileHandle%2A>其构造函数中的属性。  
  
   
  
## Examples  
 下面的示例演示的一些<xref:System.IO.FileStream>构造函数。  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 下面的示例演示如何以异步方式写入到的文件。 此代码具有名为 UserInput 和挂钩到名为 Button_Click 一个 Click 事件处理程序按钮 TextBlock 的 WPF 应用中运行。 需要更改为不是在计算机上存在的文件的文件路径。  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">当前 <see langword="FileStream" /> 对象将封装的文件的文件句柄。</param>
        <param name="access">一个常数，用于设置 <see langword="FileStream" /> 对象的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 属性。</param>
        <summary>使用指定的读/写权限为指定的文件句柄初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.IO.Stream.Close%2A>是调用，还关闭此句柄和文件的句柄计数会递减。  
  
 `FileStream` 假定它具有对该句柄的独有控制。 读取、 写入或查找时`FileStream`也持有句柄可能会导致数据损坏。 为了数据安全，调用<xref:System.IO.FileStream.Flush%2A>之前使用该句柄，并避免之外调用任何方法`Close`完成后使用此句柄。  
  
> [!CAUTION]
>  当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。  
  
 `FileShare.Read` 下面的代码示例演示如何将数据异步写入到文件，然后验证数据是否被正确写入。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> 不是 <see cref="T:System.IO.FileAccess" /> 的字段。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误，例如磁盘错误。  - 或 -  流已关闭。</exception>
        <exception cref="T:System.UnauthorizedAccessException">对于指定的文件句柄，操作系统不允许所请求的 <paramref name="access" />，例如，当 <paramref name="access" /> 为 <see langword="Write" /> 或 <see langword="ReadWrite" /> 而文件句柄设置为只读访问时。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">下面的示例将数据写入文件，然后读取数据使用对象。 使用此<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />构造函数将访问权限在创建文件。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">当前 <see langword="FileStream" /> 对象将封装的文件的文件句柄。</param>
        <param name="access">一个常数，用于设置 <see langword="FileStream" /> 对象的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 属性。</param>
        <summary>使用指定的读/写权限为指定的文件句柄初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.IO.Stream.Close%2A>是调用，还关闭此句柄和文件的句柄计数会递减。  
  
 `FileStream` 假定它具有对该句柄的独有控制。 读取、 写入或查找时`FileStream`也持有句柄可能会导致数据损坏。 为了数据安全，调用<xref:System.IO.FileStream.Flush%2A>之前使用该句柄，并避免之外调用任何方法`Close`完成后使用此句柄。  
  
> [!CAUTION]
>  当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。  
  
 `FileShare.Read` 下面的代码示例演示如何将数据异步写入到文件，然后验证数据是否被正确写入。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> 不是 <see cref="T:System.IO.FileAccess" /> 的字段。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误，例如磁盘错误。  - 或 -  流已关闭。</exception>
        <exception cref="T:System.UnauthorizedAccessException">对于指定的文件句柄，操作系统不允许所请求的 <paramref name="access" />，例如，当 <paramref name="access" /> 为 <see langword="Write" /> 或 <see langword="ReadWrite" /> 而文件句柄设置为只读访问时。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">下面的示例将数据写入文件，然后读取数据使用对象。 使用此<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />构造函数将访问权限在创建文件。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">当前 <see langword="FileStream" /> 对象将封装的文件的相对路径或绝对路径。</param>
        <param name="mode">一个确定如何打开或创建文件的常数。</param>
        <summary>使用指定的路径和创建模式初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"\\\\。 \PHYSICALDRIVE0"。  
  
 `path`参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。  
  
 若要访问或修改现有文件上的权限，请考虑使用`FileStream`和方法。  
  
 不能使用此构造函数可用来打开只读文件;相反，你必须使用接受一个构造函数`FileAccess`参数值设置为`FileAccess.Read`。  
  
 缓冲区大小设置为 4096 个字节 (4 KB) 的默认大小。  
  
> [!NOTE]
>  `path` 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。 例如，具体取决于系统中，此类可以访问物理设备。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封装文件的对象。 如果`path`指示不支持查找，设备<xref:System.IO.FileStream.CanSeek%2A>所产生的属性<xref:System.IO.FileStream>是`false`。 有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。  
  
 `FileShare.Read` 下面的代码示例演示如何将数据异步写入到文件，然后验证数据是否被正确写入。  
  
 构造函数，而无需<xref:System.IO.FileAccess>参数，如果`mode`参数设置为<xref:System.IO.FileMode.Append>，<xref:System.IO.FileAccess.Write>是默认访问权限。 否则，将访问权限设置为<xref:System.IO.FileAccess.ReadWrite>。  
  
> [!CAUTION]
>  当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将数据写入到文件，逐字节，然后验证数据是否被正确写入。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。  - 或 -  <paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到文件，比如当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" /> 而 <paramref name="path" /> 指定的文件不存在时。 该文件必须以这些模式存在。</exception>
        <exception cref="T:System.IO.IOException">发生 I/O 错误，比如指定 <see langword="FileMode.CreateNew" /> 而 <paramref name="path" /> 指定的文件已存在。  - 或 -  流已关闭。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，例如位于未映射的驱动器上。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路径和/或文件名超过了系统定义的最大长度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> 包含无效值。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">下面的示例将数据写入文件，然后读取数据使用对象。 使用此<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />构造函数将访问权限在创建文件。</permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">当前 <see langword="FileStream" /> 对象将封装的文件的文件句柄。</param>
        <param name="access">一个 <see cref="T:System.IO.FileAccess" /> 常数，它设置 <see langword="FileStream" /> 对象的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 属性。</param>
        <param name="bufferSize">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。 默认缓冲区大小为 4096。</param>
        <summary>使用指定的读/写权限和缓冲区大小为指定的文件句柄初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` 假定它具有对该句柄的独有控制。 读取、 写入或查找时`FileStream`也持有句柄可能会导致数据损坏。 为了数据安全，调用<xref:System.IO.FileStream.Flush%2A>之前使用该句柄，并避免之外调用任何方法`Close`完成后使用此句柄。 或者，对读取和写入句柄之前调用此`FileStream`构造函数。  
  
 `FileShare.Read` 下面的代码示例演示如何将数据异步写入到文件，然后验证数据是否被正确写入。  
  
> [!CAUTION]
>  当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> 参数是无效的句柄。  - 或 -  <paramref name="handle" /> 参数是同步句柄，但被异步使用。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 参数为负数。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误，例如磁盘错误。  - 或 -  流已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">对于指定的文件句柄，操作系统不允许所请求的 <paramref name="access" />，例如，当 <paramref name="access" /> 为 <see langword="Write" /> 或 <see langword="ReadWrite" /> 而文件句柄设置为只读访问时。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">下面的示例将数据写入文件，然后读取数据使用对象。 使用此<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />构造函数将访问权限在创建文件。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示调用非托管的代码的权限。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">当前 <see langword="FileStream" /> 对象将封装的文件的文件句柄。</param>
        <param name="access">一个常数，用于设置 <see langword="FileStream" /> 对象的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 属性。</param>
        <param name="ownsHandle">如果文件句柄将由此 <see langword="FileStream" /> 实例所有，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用指定的读/写权限和 <see langword="FileStream" /> 实例所属权为指定的文件句柄初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream`对象为文件指定指定的访问权限。 句柄的所有权将按指定方式。 如果此进程拥有句柄调用<xref:System.IO.Stream.Close%2A>方法也将关闭句柄和文件的句柄计数会递减。 `FileStream`对象都提供了默认缓冲区大小 （4096 字节）。  
  
 `FileStream` 假定它具有对该句柄的独有控制。 读取、 写入或查找时`FileStream`也持有句柄可能会导致数据损坏。 为了数据安全，调用<xref:System.IO.FileStream.Flush%2A>之前使用该句柄，并避免调用的方法以外`Close`完成后使用此句柄。  
  
 `FileShare.Read` 下面的代码示例演示如何将数据异步写入到文件，然后验证数据是否被正确写入。  
  
> [!CAUTION]
>  当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> 不是 <see cref="T:System.IO.FileAccess" /> 的字段。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误，例如磁盘错误。  - 或 -  流已关闭。</exception>
        <exception cref="T:System.UnauthorizedAccessException">对于指定的文件句柄，操作系统不允许所请求的 <paramref name="access" />，例如，当 <paramref name="access" /> 为 <see langword="Write" /> 或 <see langword="ReadWrite" /> 而文件句柄设置为只读访问时。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">下面的示例将数据写入文件，然后读取数据使用对象。 使用此<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />构造函数将访问权限在创建文件。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">当前 <see langword="FileStream" /> 对象将封装的文件的相对路径或绝对路径。</param>
        <param name="mode">一个确定如何打开或创建文件的常数。</param>
        <param name="access">一个常数，用于确定 <see langword="FileStream" /> 对象访问文件的方式。 该常数还可以确定由 <see langword="FileStream" /> 对象的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 属性返回的值。 如果 <c>path</c> 指定磁盘文件，则 <see cref="P:System.IO.FileStream.CanSeek" /> 为 <see langword="true" />。</param>
        <summary>使用指定的路径、创建模式和读/写权限初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"\\\\。 \PHYSICALDRIVE0"。  
  
 `path`参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。  
  
 若要访问或修改现有文件上的权限，请考虑使用`FileStream`和方法。 缓冲区大小设置为 4096 个字节 (4 KB) 的默认大小。  
  
> [!NOTE]
>  `path` 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。 例如，具体取决于系统中，此类可以访问物理设备。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封装文件的对象。 如果`path`指示不支持查找，设备<xref:System.IO.FileStream.CanSeek%2A>所产生的属性<xref:System.IO.FileStream>是`false`。 有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。  
  
 `FileShare.Read` 下面的代码示例演示如何将数据异步写入到文件，然后验证数据是否被正确写入。  
  
> [!CAUTION]
>  当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。  - 或 -  <paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到文件，比如当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" /> 而 <paramref name="path" /> 指定的文件不存在时。 该文件必须以这些模式存在。</exception>
        <exception cref="T:System.IO.IOException">发生 I/O 错误，比如指定 <see langword="FileMode.CreateNew" /> 而 <paramref name="path" /> 指定的文件已存在。  - 或 -  流已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，例如位于未映射的驱动器上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">对于指定的 <paramref name="access" /> 操作系统不允许所请求的 <paramref name="path" />，比如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" /> 而文件或目录设置为只读访问时。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路径和/或文件名超过了系统定义的最大长度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> 包含无效值。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">下面的示例将数据写入文件，然后读取数据使用对象。 使用此<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />构造函数将访问权限在创建文件。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">此 <see langword="FileStream" /> 对象将封装的文件的文件句柄。</param>
        <param name="access">一个常数，用于设置 <see langword="FileStream" /> 对象的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 属性。</param>
        <param name="bufferSize">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。 默认缓冲区大小为 4096。</param>
        <param name="isAsync">如果异步打开句柄（即以重叠的 I/O 模式），则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用指定的读/写权限、缓冲区大小和同步或异步状态为指定的文件句柄初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你设置`isAsync`参数`true`以异步方式打开的文件句柄。 当该参数是`true`，流利用重叠的 I/O，异步执行文件操作。 但是，该参数不一定要`true`调用<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。 当`isAsync`参数是`false`和调用异步读取和写入操作，仍未被阻止 UI 线程、，但同步执行实际的 I/O 操作。  
  
 `FileStream` 假定它具有对该句柄的独有控制。 读取、 写入或查找时`FileStream`也持有句柄可能会导致数据损坏。 为了数据安全，调用<xref:System.IO.FileStream.Flush%2A>之前使用该句柄，并避免之外调用任何方法`Close`完成后使用此句柄。 或者，对读取和写入句柄之前调用此`FileStream`构造函数。  
  
 `FileShare.Read` 下面的代码示例演示如何将数据异步写入到文件，然后验证数据是否被正确写入。  
  
> [!CAUTION]
>  当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> 参数是无效的句柄。  - 或 -  <paramref name="handle" /> 参数是同步句柄，但被异步使用。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 参数为负数。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误，例如磁盘错误。  - 或 -  流已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">对于指定的文件句柄，操作系统不允许所请求的 <paramref name="access" />，例如，当 <paramref name="access" /> 为 <see langword="Write" /> 或 <see langword="ReadWrite" /> 而文件句柄设置为只读访问时。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">下面的示例将数据写入文件，然后读取数据使用对象。 使用此<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />构造函数将访问权限在创建文件。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示调用非托管的代码的权限。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">此 <see langword="FileStream" /> 对象将封装的文件的文件句柄。</param>
        <param name="access">一个常数，用于设置 <see langword="FileStream" /> 对象的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 属性。</param>
        <param name="ownsHandle">如果文件句柄将由此 <see langword="FileStream" /> 实例所有，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="bufferSize">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。 默认缓冲区大小为 4096。</param>
        <summary>使用指定的读/写权限、<see langword="FileStream" /> 实例所属权和缓冲区大小为指定的文件句柄初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream`对象为文件指定指定的访问权限。 句柄的所有权将按指定方式。 如果此`FileStream`拥有句柄，调用<xref:System.IO.Stream.Close%2A>方法也将关闭句柄。 具体而言，该文件的句柄计数会递减。 `FileStream`对象都提供了指定的缓冲区大小。  
  
 `FileStream` 假定它具有对该句柄的独有控制。 读取、 写入或查找时`FileStream`也持有句柄可能会导致数据损坏。 为了数据安全，调用<xref:System.IO.FileStream.Flush%2A>之前使用该句柄，并避免之外调用任何方法`Close`完成后使用此句柄。 或者，对读取和写入句柄之前调用此`FileStream`构造函数。  
  
 `FileShare.Read` 下面的代码示例演示如何将数据异步写入到文件，然后验证数据是否被正确写入。  
  
> [!CAUTION]
>  当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 为负数。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误，例如磁盘错误。  - 或 -  流已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">对于指定的文件句柄，操作系统不允许所请求的 <paramref name="access" />，例如，当 <paramref name="access" /> 为 <see langword="Write" /> 或 <see langword="ReadWrite" /> 而文件句柄设置为只读访问时。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">下面的示例将数据写入文件，然后读取数据使用对象。 使用此<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />构造函数将访问权限在创建文件。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">当前 <see langword="FileStream" /> 对象将封装的文件的相对路径或绝对路径。</param>
        <param name="mode">一个确定如何打开或创建文件的常数。</param>
        <param name="access">一个常数，用于确定 <see langword="FileStream" /> 对象访问文件的方式。 该常数还可以确定由 <see langword="FileStream" /> 对象的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 属性返回的值。 如果 <c>path</c> 指定磁盘文件，则 <see cref="P:System.IO.FileStream.CanSeek" /> 为 <see langword="true" />。</param>
        <param name="share">一个常数，确定文件将如何由进程共享。</param>
        <summary>使用指定的路径、创建模式、读/写权限和共享权限创建 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"\\\\。 \PHYSICALDRIVE0"。  
  
 `path`参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。  
  
 若要访问或修改现有文件上的权限，请考虑使用`FileStream`和方法。 缓冲区大小设置为 4096 个字节 (4 KB) 的默认大小。  
  
> [!NOTE]
>  `path` 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。 例如，具体取决于系统中，此类可以访问物理设备。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封装文件的对象。 如果`path`指示不支持查找，设备<xref:System.IO.FileStream.CanSeek%2A>所产生的属性<xref:System.IO.FileStream>是`false`。 有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.FileStream.Lock%2A>方法。  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。  - 或 -  <paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到文件，比如当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" /> 而 <paramref name="path" /> 指定的文件不存在时。 该文件必须以这些模式存在。</exception>
        <exception cref="T:System.IO.IOException">发生 I/O 错误，比如指定 <see langword="FileMode.CreateNew" /> 而 <paramref name="path" /> 指定的文件已存在。  - 或 -  系统正在运行 Windows 98 或 Windows 98 Second Edition，并将 <paramref name="share" /> 设置为 <see langword="FileShare.Delete" />。  - 或 -  流已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，例如位于未映射的驱动器上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">对于指定的 <paramref name="access" /> 操作系统不允许所请求的 <paramref name="path" />，比如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" /> 而文件或目录设置为只读访问时。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路径和/或文件名超过了系统定义的最大长度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> 包含无效值。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">下面的示例将数据写入文件，然后读取数据使用对象。 使用此<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />构造函数将访问权限在创建文件。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">此 <see langword="FileStream" /> 对象将封装的文件的文件句柄。</param>
        <param name="access">一个常数，用于设置 <see langword="FileStream" /> 对象的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 属性。</param>
        <param name="ownsHandle">如果文件句柄将由此 <see langword="FileStream" /> 实例所有，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="bufferSize">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。 默认缓冲区大小为 4096。</param>
        <param name="isAsync">如果异步打开句柄（即以重叠的 I/O 模式），则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用指定的读/写权限、<see langword="FileStream" /> 实例所属权、缓冲区大小和同步或异步状态为指定的文件句柄初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream`对象为文件指定指定的访问权限。 句柄的所有权将按指定方式。 如果此`FileStream`拥有句柄，调用<xref:System.IO.Stream.Close%2A>方法也将关闭句柄。 具体而言，该文件的句柄计数会递减。 `FileStream`对象都提供了指定的缓冲区大小。  
  
 `FileStream` 假定它具有对该句柄的独有控制。 读取、 写入或查找时`FileStream`也持有句柄可能会导致数据损坏。 为了数据安全，调用<xref:System.IO.FileStream.Flush%2A>之前使用该句柄，并避免之外调用任何方法`Close`完成后使用此句柄。 或者，对读取和写入句柄之前调用此`FileStream`构造函数。  
  
 `FileShare.Read` 下面的代码示例演示如何将数据异步写入到文件，然后验证数据是否被正确写入。  
  
> [!CAUTION]
>  当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="access" /> 小于 <see langword="FileAccess.Read" /> 或大于 <see langword="FileAccess.ReadWrite" />，或者 <paramref name="bufferSize" /> 小于或等于 0。</exception>
        <exception cref="T:System.ArgumentException">该句柄无效。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误，例如磁盘错误。  - 或 -  流已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">对于指定的文件句柄，操作系统不允许所请求的 <paramref name="access" />，例如，当 <paramref name="access" /> 为 <see langword="Write" /> 或 <see langword="ReadWrite" /> 而文件句柄设置为只读访问时。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于访问非托管代码。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">当前 <see langword="FileStream" /> 对象将封装的文件的相对路径或绝对路径。</param>
        <param name="mode">一个确定如何打开或创建文件的常数。</param>
        <param name="access">一个常数，用于确定 <see langword="FileStream" /> 对象访问文件的方式。 该常数还可以确定由 <see langword="FileStream" /> 对象的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 属性返回的值。 如果 <c>path</c> 指定磁盘文件，则 <see cref="P:System.IO.FileStream.CanSeek" /> 为 <see langword="true" />。</param>
        <param name="share">一个常数，确定文件将如何由进程共享。</param>
        <param name="bufferSize">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。 默认缓冲区大小为 4096。</param>
        <summary>用指定的路径、创建模式、读/写及共享权限和缓冲区大小初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"\\\\。 \PHYSICALDRIVE0"。  
  
 `path`参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。  
  
> [!NOTE]
>  `path` 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。 例如，具体取决于系统中，此类可以访问物理设备。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封装文件的对象。 如果`path`指示不支持查找，设备<xref:System.IO.FileStream.CanSeek%2A>所产生的属性<xref:System.IO.FileStream>是`false`。 有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。  - 或 -  <paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 为负数或零。  - 或 -  <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含无效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到文件，比如当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" /> 而 <paramref name="path" /> 指定的文件不存在时。 该文件必须以这些模式存在。</exception>
        <exception cref="T:System.IO.IOException">发生 I/O 错误，比如指定 <see langword="FileMode.CreateNew" /> 而 <paramref name="path" /> 指定的文件已存在。  - 或 -  系统正在运行 Windows 98 或 Windows 98 Second Edition，并将 <paramref name="share" /> 设置为 <see langword="FileShare.Delete" />。  - 或 -  流已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，例如位于未映射的驱动器上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">对于指定的 <paramref name="access" /> 操作系统不允许所请求的 <paramref name="path" />，比如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" /> 而文件或目录设置为只读访问时。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路径和/或文件名超过了系统定义的最大长度。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">下面的示例将数据写入文件，然后读取数据使用对象。 使用此<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />构造函数将访问权限在创建文件。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, useAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">当前 <see langword="FileStream" /> 对象将封装的文件的相对路径或绝对路径。</param>
        <param name="mode">一个确定如何打开或创建文件的常数。</param>
        <param name="access">一个常数，用于确定 <see langword="FileStream" /> 对象访问文件的方式。 该常数还可以确定由 <see langword="FileStream" /> 对象的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 属性返回的值。 如果 <c>path</c> 指定磁盘文件，则 <see cref="P:System.IO.FileStream.CanSeek" /> 为 <see langword="true" />。</param>
        <param name="share">一个常数，确定文件将如何由进程共享。</param>
        <param name="bufferSize">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。 默认缓冲区大小为 4096。</param>
        <param name="useAsync">指定使用异步 I/O 还是同步 I/O。 但是，请注意，基础操作系统可能不支持异步 I/O，因此在指定 <see langword="true" /> 后，根据所用平台，句柄可能同步打开。 当异步打开时，<see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 和 <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 方法在执行大量读或写时效果更好，但对于少量的读/写，这些方法速度可能要慢得多。 如果应用程序打算利用异步 I/O，将 <c>useAsync</c> 参数设置为 <see langword="true" />。 正确使用异步 I/O 可以使应用程序的速度加快 10 倍，但是如果在没有为异步 I/O 重新设计应用程序的情况下使用异步 I/O，则可能使性能降低 10 倍。</param>
        <summary>使用指定的路径、创建模式、读/写和共享权限、缓冲区大小和同步或异步状态初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"\\\\。 \PHYSICALDRIVE0"。  
  
 `path`参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。  
  
> [!NOTE]
>  `path` 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。 例如，具体取决于系统中，此类可以访问物理设备。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封装文件的对象。 如果`path`指示不支持查找，设备<xref:System.IO.FileStream.CanSeek%2A>所产生的属性<xref:System.IO.FileStream>是`false`。 有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将数据异步写入到文件，然后验证数据是否被正确写入。 A`State`创建对象将信息从主线程传递`EndReadCallback`和`EndWriteCallback`方法。  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。  - 或 -  <paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 为负数或零。  - 或 -  <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含无效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到文件，比如当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" /> 而 <paramref name="path" /> 指定的文件不存在时。 该文件必须以这些模式存在。</exception>
        <exception cref="T:System.IO.IOException">发生 I/O 错误，比如指定 <see langword="FileMode.CreateNew" /> 而 <paramref name="path" /> 指定的文件已存在。  - 或 -  系统正在运行 Windows 98 或 Windows 98 Second Edition，并将 <paramref name="share" /> 设置为 <see langword="FileShare.Delete" />。  - 或 -  流已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，例如位于未映射的驱动器上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">对于指定的 <paramref name="access" /> 操作系统不允许所请求的 <paramref name="path" />，比如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" /> 而文件或目录设置为只读访问时。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路径和/或文件名超过了系统定义的最大长度。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">下面的示例将数据写入文件，然后读取数据使用对象。 使用此<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />构造函数将访问权限在创建文件。</permission>
        <altmember cref="T:System.IO.File" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">当前 <see langword="FileStream" /> 对象将封装的文件的相对路径或绝对路径。</param>
        <param name="mode">一个确定如何打开或创建文件的常数。</param>
        <param name="access">一个常数，用于确定 <see langword="FileStream" /> 对象访问文件的方式。 该常数还可以确定由 <see langword="FileStream" /> 对象的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 属性返回的值。 如果 <c>path</c> 指定磁盘文件，则 <see cref="P:System.IO.FileStream.CanSeek" /> 为 <see langword="true" />。</param>
        <param name="share">一个常数，确定文件将如何由进程共享。</param>
        <param name="bufferSize">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。 默认缓冲区大小为 4096。</param>
        <param name="options">一个指定附加文件选项的值。</param>
        <summary>使用指定的路径、创建模式、读/写和共享权限、其他 FileStreams 可以具有的对此文件的访问权限、缓冲区大小和附加文件选项初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"\\\\。 \PHYSICALDRIVE0"。  
  
 `fileOptions`参数用于提供对在创建时可以利用的更高级操作访问<xref:System.IO.FileStream>对象。  
  
 `path`参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。  
  
> [!NOTE]
>  `path` 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。 例如，具体取决于系统中，此类可以访问物理设备。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封装文件的对象。 如果`path`指示不支持查找，设备<xref:System.IO.FileStream.CanSeek%2A>所产生的属性<xref:System.IO.FileStream>是`false`。 有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下面的示例将数据写入文件，然后读取数据使用<xref:System.IO.FileStream>对象。  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。  - 或 -  <paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 为负数或零。  - 或 -  <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含无效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到文件，比如当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" /> 而 <paramref name="path" /> 指定的文件不存在时。 该文件必须以这些模式存在。</exception>
        <exception cref="T:System.IO.IOException">发生 I/O 错误，比如指定 <see langword="FileMode.CreateNew" /> 而 <paramref name="path" /> 指定的文件已存在。  - 或 -  流已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，例如位于未映射的驱动器上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">对于指定的 <paramref name="access" /> 操作系统不允许所请求的 <paramref name="path" />，比如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" /> 而文件或目录设置为只读访问时。  - 或 -  <see cref="F:System.IO.FileOptions.Encrypted" /> 被指定用于 <paramref name="options" />，但在当前平台上不支持文件加密。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路径和/或文件名超过了系统定义的最大长度。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">下面的示例将数据写入文件，然后读取数据使用对象。 使用此<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />构造函数将访问权限在创建文件。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">当前 <see cref="T:System.IO.FileStream" /> 对象将封装的文件的相对路径或绝对路径。</param>
        <param name="mode">一个确定如何打开或创建文件的常数。</param>
        <param name="rights">一个常数，确定为文件创建访问和审核规则时要使用的访问权。</param>
        <param name="share">一个常数，确定文件将如何由进程共享。</param>
        <param name="bufferSize">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。 默认缓冲区大小为 4096。</param>
        <param name="options">一个指定附加文件选项的常数。</param>
        <summary>使用指定的路径、创建模式、访问权限和共享权限、缓冲区大小和附加文件选项初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"\\\\。 \PHYSICALDRIVE0"。  
  
 使用此<xref:System.IO.FileStream.%23ctor%2A>构造函数将访问权限在创建文件。 若要访问或修改现有文件上的权限，请考虑使用<xref:System.IO.File.GetAccessControl%2A>和<xref:System.IO.File.SetAccessControl%2A>方法。  
  
 `fileOptions`参数用于提供对在创建时可以利用的更高级操作访问<xref:System.IO.FileStream>对象。  
  
 `path`参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。  
  
> [!NOTE]
>  `path` 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。 例如，具体取决于系统中，此类可以访问物理设备。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封装文件的对象。 如果`path`指示不支持查找，设备<xref:System.IO.FileStream.CanSeek%2A>所产生的属性<xref:System.IO.FileStream>是`false`。 有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。  - 或 -  <paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 为负数或零。  - 或 -  <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含无效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到文件，比如当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" /> 而 <paramref name="path" /> 指定的文件不存在时。 该文件必须以这些模式存在。</exception>
        <exception cref="T:System.PlatformNotSupportedException">当前操作系统不是 Windows NT 或更高版本。</exception>
        <exception cref="T:System.IO.IOException">发生 I/O 错误，比如指定 <see langword="FileMode.CreateNew" /> 而 <paramref name="path" /> 指定的文件已存在。  - 或 -  流已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，例如位于未映射的驱动器上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">对于指定的 <paramref name="access" /> 操作系统不允许所请求的 <paramref name="path" />，比如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" /> 而文件或目录设置为只读访问时。  - 或 -  <see cref="F:System.IO.FileOptions.Encrypted" /> 被指定用于 <paramref name="options" />，但在当前平台上不支持文件加密。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的 <paramref name="path" />、文件名或者两者都超出了系统定义的最大长度。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">下面的示例将数据写入文件，然后读取数据使用对象。 使用此<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />构造函数将访问权限在创建文件。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">当前 <see cref="T:System.IO.FileStream" /> 对象将封装的文件的相对路径或绝对路径。</param>
        <param name="mode">一个确定如何打开或创建文件的常数。</param>
        <param name="rights">一个常数，确定为文件创建访问和审核规则时要使用的访问权。</param>
        <param name="share">一个常数，确定文件将如何由进程共享。</param>
        <param name="bufferSize">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。 默认缓冲区大小为 4096。</param>
        <param name="options">一个指定附加文件选项的常数。</param>
        <param name="fileSecurity">一个常数，确定文件的访问控制和审核安全。</param>
        <summary>使用指定的路径、创建模式、访问权限和共享权限、缓冲区大小、附加文件选项、访问控制和审核安全初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"\\\\。 \PHYSICALDRIVE0"。  
  
 使用此<xref:System.IO.FileStream.%23ctor%2A>构造函数将访问权限在创建文件。 若要访问或修改现有文件上的权限，请考虑使用<xref:System.IO.File.GetAccessControl%2A>和<xref:System.IO.File.SetAccessControl%2A>方法。  
  
 `fileOptions`参数用于提供对在创建时可以利用的更高级操作访问<xref:System.IO.FileStream>对象。  
  
 `path`参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。  
  
> [!NOTE]
>  `path` 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。 例如，具体取决于系统中，此类可以访问物理设备。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封装文件的对象。 如果`path`指示不支持查找，设备<xref:System.IO.FileStream.CanSeek%2A>所产生的属性<xref:System.IO.FileStream>是`false`。 有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下面的示例将数据写入文件，然后读取数据使用<xref:System.IO.FileStream>对象。  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。  - 或 -  <paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 为负数或零。  - 或 -  <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含无效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到文件，比如当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" /> 而 <paramref name="path" /> 指定的文件不存在时。 该文件必须以这些模式存在。</exception>
        <exception cref="T:System.IO.IOException">发生 I/O 错误，比如指定 <see langword="FileMode.CreateNew" /> 而 <paramref name="path" /> 指定的文件已存在。  - 或 -  流已关闭。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，例如位于未映射的驱动器上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">对于指定的 <paramref name="access" /> 操作系统不允许所请求的 <paramref name="path" />，比如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" /> 而文件或目录设置为只读访问时。  - 或 -  <see cref="F:System.IO.FileOptions.Encrypted" /> 被指定用于 <paramref name="options" />，但在当前平台上不支持文件加密。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的 <paramref name="path" />、文件名或者两者都超出了系统定义的最大长度。</exception>
        <exception cref="T:System.PlatformNotSupportedException">当前操作系统不是 Windows NT 或更高版本。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">下面的示例将数据写入文件，然后读取数据使用对象。 使用此<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />构造函数将访问权限在创建文件。</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="array">将数据读入的缓冲区。</param>
        <param name="buffer">To be added.</param>
        <param name="offset">
          <c>array</c> 中的字节偏移量，从此处开始读取。</param>
        <param name="numBytes">最多读取的字节数。</param>
        <param name="count">To be added.</param>
        <param name="userCallback">异步读操作完成后调用的方法。</param>
        <param name="callback">To be added.</param>
        <param name="stateObject">一个用户提供的对象，它将该特定的异步读取请求与其他请求区别开来。</param>
        <param name="state">To be added.</param>
        <summary>开始异步读操作。 （请考虑改用 <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />。）</summary>
        <returns>引用异步读取的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在.NET Framework 4 和更早版本中，你必须使用方法，如<xref:System.IO.FileStream.BeginRead%2A>和<xref:System.IO.FileStream.EndRead%2A>来实现异步文件操作。 这些方法是在中仍然可用[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以支持旧版代码; 但是，新的异步方法，如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，帮助你更轻松地实现异步文件操作。  
  
 <xref:System.IO.FileStream.EndRead%2A> 必须为对每个调用一次调用<xref:System.IO.FileStream.BeginRead%2A>。 如果在开始另一个读取之前，结束读取的进程可能会导致意外行为，如死锁。  
  
 <xref:System.IO.FileStream> 提供两个不同的操作模式： I/O 同步和异步 I/O。 尽管可以使用任一，基础的操作系统资源可能允许访问，只有其中一种模式中。 默认情况下，<xref:System.IO.FileStream>同步打开的操作系统句柄。 在 Windows 中，这将降低异步方法。 如果使用异步方法，使用<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>构造函数。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanRead%2A>属性来确定当前实例是否支持读取。 有关附加信息，请参见 <xref:System.IO.Stream.CanRead%2A>。  
  
 如果流已关闭或传递了无效参数，将立即引发异常从<xref:System.IO.FileStream.BeginRead%2A>。 异步读取请求，例如 IO 请求过程的磁盘故障过程中发生的错误发生在线程池线程和调用时变得可见<xref:System.IO.FileStream.EndRead%2A>。  
  
 <xref:System.IO.Stream.EndRead%2A> 必须与此调用<xref:System.IAsyncResult>若要了解读取的多少字节数。  
  
 多个同时进行的异步请求呈现请求完成顺序不确定。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>构造函数。  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">数组长度减去 <paramref name="offset" /> 小于 <paramref name="numBytes" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="numBytes" /> 为负数。</exception>
        <exception cref="T:System.IO.IOException">尝试在文件的末尾后进行异步读取。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="array">包含要写入当前流的数据的缓冲区。</param>
        <param name="buffer">To be added.</param>
        <param name="offset">
          <c>array</c> 中的从零开始的字节偏移量，从此处开始将字节复制到当前流。</param>
        <param name="numBytes">最多写入的字节数。</param>
        <param name="count">To be added.</param>
        <param name="userCallback">异步写操作完成后调用的方法。</param>
        <param name="callback">To be added.</param>
        <param name="stateObject">一个用户提供的对象，它将该特定的异步写入请求与其他请求区别开来。</param>
        <param name="state">To be added.</param>
        <summary>开始异步写操作。 （请考虑改用 <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />。）</summary>
        <returns>引用异步写入的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在.NET Framework 4 和更早版本中，你必须使用方法，如<xref:System.IO.FileStream.BeginWrite%2A>和<xref:System.IO.FileStream.EndWrite%2A>来实现异步文件操作。 这些方法是在中仍然可用[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以支持旧版代码; 但是，新的异步方法，如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，帮助你更轻松地实现异步文件操作。  
  
 <xref:System.IO.FileStream.EndWrite%2A> 必须在上一次调用每个<xref:System.IAsyncResult>从<xref:System.IO.FileStream.BeginWrite%2A>。 <xref:System.IO.FileStream.EndWrite%2A> 将阻止，直到 I/O 操作已完成。  
  
 此方法重写 <xref:System.IO.Stream.BeginWrite%2A>。  
  
 <xref:System.IO.FileStream> 提供两个不同的操作模式： I/O 同步和异步 I/O。 尽管可以使用任一，基础的操作系统资源可能允许访问，只有其中一种模式中。 默认情况下，<xref:System.IO.FileStream>同步打开的操作系统句柄。 在 Windows 中，这将降低异步方法。 如果使用异步方法，使用<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>构造函数。  
  
 如果流已关闭或传递了无效参数，将立即引发异常从<xref:System.IO.FileStream.BeginWrite%2A>。 异步写入请求，例如 IO 请求过程的磁盘故障过程中发生的错误发生在线程池线程和调用时变得可见<xref:System.IO.FileStream.EndWrite%2A>。  
  
 多个同时进行的异步请求呈现请求完成顺序不确定。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>构造函数。  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> 长度减去 <paramref name="offset" /> 小于 <paramref name="numBytes" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="numBytes" /> 为负数。</exception>
        <exception cref="T:System.NotSupportedException">流不支持写入。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前流是否支持读取。</summary>
        <value>如果流支持读取，则为 <see langword="true" />；如果流已关闭或是通过只写访问方式打开的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果从派生的类<xref:System.IO.Stream>不支持读取，则调用<xref:System.IO.FileStream.Read%2A>， <xref:System.IO.FileStream.ReadByte%2A>，和<xref:System.IO.FileStream.BeginRead%2A>方法将引发<xref:System.NotSupportedException>。  
  
 如果流已关闭，则此属性返回`false`。  
  
   
  
## Examples  
 下面的示例演示使用`CanRead`属性。 此代码的输出是"MyFile.txt 不是可写。" 若要获取输出消息"MyFile.txt 可以同时为读取和写入从。"，更改`FileAccess`参数`ReadWrite`中`FileStream`构造函数。  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前流是否支持查找。</summary>
        <value>如果流支持查找，则为 <see langword="true" />；如果流已关闭或者如果 <see langword="FileStream" /> 是从操作系统句柄（如管道或到控制台的输出）构造的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果从派生的类<xref:System.IO.Stream>不支持查找，则调用<xref:System.IO.FileStream.Length%2A>， <xref:System.IO.FileStream.SetLength%2A>， <xref:System.IO.FileStream.Position%2A>，和<xref:System.IO.FileStream.Seek%2A>引发<xref:System.NotSupportedException>。  
  
 如果流已关闭，则此属性返回`false`。  
  
   
  
## Examples  
 下面的示例使用`CanSeek`属性检查流是否支持查找。  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前流是否支持写入。</summary>
        <value>如果流支持写入，则为 <see langword="true" />；如果流已关闭或是通过只读访问方式打开的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果从派生的类<xref:System.IO.Stream>不支持写入，调用<xref:System.IO.FileStream.SetLength%2A>， <xref:System.IO.FileStream.Write%2A>， <xref:System.IO.FileStream.BeginWrite%2A>，或<xref:System.IO.FileStream.WriteByte%2A>引发<xref:System.NotSupportedException>。  
  
 如果流已关闭，则此属性返回`false`。  
  
   
  
## Examples  
 下面的示例使用`CanWrite`属性检查流是否支持写入。  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 以下是一个示例使用`CanWrite`属性。 此代码的输出为"可写 ' MyFile.txt"。 若要获取输出消息"MyFile.txt 可以同时为读取和写入从。"，更改`FileAccess`参数`ReadWrite`中`FileStream`构造函数。  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放由 <see cref="T:System.IO.FileStream" /> 占用的非托管资源，还可以另外再释放托管资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法称为由公共<xref:System.ComponentModel.Component.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。 <xref:System.ComponentModel.Component.Dispose%2A> 调用受保护<xref:System.IO.FileStream.Dispose%2A>方法替换`disposing`参数设置为`true`。 <xref:System.Object.Finalize%2A> 调用<xref:System.IO.FileStream.Dispose%2A>与`disposing`设置为`false`。  
  
 当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.IO.FileStream> 引用的、由任何托管对象持有的全部资源。 此方法调用每个引用对象的 <xref:System.ComponentModel.Component.Dispose%2A> 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> 可以多次调用由其他对象。在重写<see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />请注意不要引用已释放的以前调用中的对象<see cref="M:System.ComponentModel.Component.Dispose" />。有关如何实现详细信息<see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />，请参阅 [实现释放 Method](~/docs/standard/garbage-collection/implementing-dispose.md)。有关详细信息<see cref="M:System.ComponentModel.Component.Dispose" />和<see cref="M:System.Object.Finalize" />，请参阅 [清洗向上非托管 Resources](~/docs/standard/garbage-collection/unmanaged.md)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="fileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">对所等待的挂起异步请求的引用。</param>
        <summary>等待挂起的异步读操作完成。 （请考虑改用 <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />。）</summary>
        <returns>从流中读取的字节数，介于 0 和所请求的字节数之间。 流仅在流结尾返回 0，否则在至少有 1 个字节可用之前应一直进行阻止。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在.NET Framework 4 和更早版本中，你必须使用方法，如<xref:System.IO.FileStream.BeginRead%2A>和<xref:System.IO.FileStream.EndRead%2A>来实现异步文件操作。 这些方法是在中仍然可用[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以支持旧版代码; 但是，新的异步方法，如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，帮助你更轻松地实现异步文件操作。  
  
 <xref:System.IO.FileStream.EndRead%2A> 必须正好为对每个调用调用<xref:System.IO.FileStream.BeginRead%2A>。 如果在开始另一个读取之前，结束读取的进程可能会导致意外行为，如死锁。  
  
 此方法重写 <xref:System.IO.Stream.EndRead%2A>。  
  
 <xref:System.IO.FileStream.EndRead%2A> 可以在调用每个<xref:System.IAsyncResult>从<xref:System.IO.FileStream.BeginRead%2A>。 调用<xref:System.IO.FileStream.EndRead%2A>告知你已从流中读取字节数。 <xref:System.IO.FileStream.EndRead%2A> 将阻止，直到 I/O 操作已完成。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>构造函数。  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">此 <see cref="T:System.IAsyncResult" /> 对象不是通过对该类调用 <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 来创建的。</exception>
        <exception cref="T:System.InvalidOperationException">多次调用了 <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.IO.IOException">流已关闭或出现了内部错误。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="fileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">挂起的异步 I/O 请求。</param>
        <summary>结束异步写入操作，在 I/O 操作完成之前一直阻止。 （请考虑改用 <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />。）</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在.NET Framework 4 和更早版本中，你必须使用方法，如<xref:System.IO.FileStream.BeginWrite%2A>和<xref:System.IO.FileStream.EndWrite%2A>来实现异步文件操作。 这些方法是在中仍然可用[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以支持旧版代码; 但是，新的异步方法，如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，帮助你更轻松地实现异步文件操作。  
  
 此方法重写 <xref:System.IO.Stream.EndWrite%2A>。  
  
 <xref:System.IO.FileStream.EndWrite%2A> 必须在上一次调用每个<xref:System.IAsyncResult>从<xref:System.IO.FileStream.BeginWrite%2A>。 <xref:System.IO.FileStream.EndWrite%2A> 将阻止，直到 I/O 操作已完成。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>构造函数。  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">此 <see cref="T:System.IAsyncResult" /> 对象不是通过对该类调用 <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 来创建的。</exception>
        <exception cref="T:System.InvalidOperationException">多次调用了 <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.IO.IOException">流已关闭或出现了内部错误。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>确保垃圾回收器回收 <see langword="FileStream" /> 时释放资源并执行其他清理操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 垃圾回收器调用`Finalize`何时准备好完成当前的对象。 `Finalize` 关闭`FileStream`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>清除此流的缓冲区，使得所有缓冲数据都写入到文件中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="fileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除此流的缓冲区，使得所有缓冲数据都写入到文件中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>。  
  
 当调用<xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType>方法，操作系统 I/O 缓冲区，也会刷新。  
  
 除非你明确地调用不会刷新流的编码器<xref:System.IO.FileStream.Flush%2A>或释放对象。 设置<xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType>到`true`意味着数据从缓冲区刷新到流中，但不是会刷新编码器状态。 这将允许编码器，以便它可以正确编码的字符的下一步块保持其状态 （部分字符）。 这种情况下会影响 UTF8 和 UTF7 其中某些字符仅后才能进行编码的编码器收到的相邻字符。  
  
 因为缓冲区可以用于读取或写入，<xref:System.IO.FileStream.Flush>执行以下两个功能：  
  
-   以前向缓冲区写入任何数据复制到文件和其编码器状态除外清除缓冲区。  
  
-   如果<xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType>是`true`和以前将数据从文件复制到缓冲区以进行读取，该文件中的当前位置将减少的缓冲区中的未读字节数。 然后清除缓冲区。  
  
 使用<xref:System.IO.FileStream.Flush%28System.Boolean%29>方法重载时你想要确保中间文件缓冲区中的所有缓冲数据写入到磁盘。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.FileStream.Lock%2A>方法。  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="fileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">如果刷新所有中间文件缓冲区，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>清除此流的缓冲区，将所有缓冲数据都写入到文件中，并且也清除所有中间文件缓冲区。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载时你想要确保中间文件缓冲区中的所有缓冲数据写入到磁盘。  
  
 当调用<xref:System.IO.FileStream.Flush%2A>方法，操作系统 I/O 缓冲区，也会刷新。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">要监视取消请求的标记。</param>
        <summary>异步清理这个流的所有缓冲区，并使所有缓冲数据写入基础设备，并且监控取消请求。</summary>
        <returns>表示异步刷新操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用<xref:System.IO.FileStream.FlushAsync%2A>方法，操作系统 I/O 缓冲区，也会刷新。  
  
 如果在完成之前，将取消该操作，返回的任务包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>属性。 如果文件句柄将被释放，则返回的任务包含<xref:System.ObjectDisposedException>中的异常<xref:System.Threading.Tasks.Task.Exception%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">已释放流。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取 <see cref="T:System.Security.AccessControl.FileSecurity" /> 对象，该对象封装当前 <see cref="T:System.IO.FileStream" /> 对象所描述的文件的访问控制列表 (ACL) 项。</summary>
        <returns>一个对象，该对象封装当前 <see cref="T:System.IO.FileStream" /> 对象所描述的文件的访问控制设置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 虽然<xref:System.IO.FileStream>类和<xref:System.IO.FileStream.GetAccessControl%2A>可以用于检索现有文件的访问控制列表 (ACL) 项，请考虑使用<xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType>方法，因为它是使用起来更为简便。  
  
 使用<xref:System.IO.FileStream.GetAccessControl%2A>方法来检索文件的 ACL 项。  
  
 ACL 描述个人和/或组具有或没有执行到给定的文件上的特定操作的权限。 有关详细信息，请参阅[如何：添加或移除访问控制列表项](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">文件关闭。</exception>
        <exception cref="T:System.IO.IOException">打开文件时发生 I/O 错误。</exception>
        <exception cref="T:System.SystemException">找不到文件。</exception>
        <exception cref="T:System.UnauthorizedAccessException">当前平台不支持此操作。  - 或 -  调用方没有所需权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see langword="FileStream" /> 对象所封装文件的操作系统文件句柄。</summary>
        <value>此 <see langword="FileStream" /> 对象所封装文件的操作系统文件句柄；如果 <see langword="FileStream" /> 已关闭，则为 -1。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是与操作系统的系统提供的系统调用一起使用的操作系统句柄 (如`ReadFile`Windows 上)。 它不会使用 C 库函数，如预期的文件描述符， `fread`。  
  
 操作系统句柄可能打开过同步或异步，具体取决于`FileStream`已调用构造函数。 使用<xref:System.IO.FileStream.IsAsync%2A>属性来发现是否以异步方式打开此句柄。 在 Win32 中，这意味着句柄已打开为重叠的 IO，并且它要求在不同的参数到`ReadFile`和`WriteFile`。  
  
> [!CAUTION]
>  如果可能发生数据损坏`FileStream`是创建，其句柄传递、 某些操作移动句柄的文件指针，然后`FileStream`会再次使用。 多个线程不能同时安全地写入到相同文件，和`FileStream`缓冲代码假定它以独占方式控制该句柄。 `FileStream` 可能引发<xref:System.IO.IOException>如果`FileStream`检测到某些其他进程已移动的文件指针。 若要避免此问题，不写入任何数据到文件的一部分，`FileStream`可能具有缓冲，并将文件指针还原到在上一次调用方法时的位置`FileStream`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要访问非托管的代码的功能。 关联的枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />安全操作： <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see langword="FileStream" /> 是异步还是同步打开的。</summary>
        <value>如果 <see langword="FileStream" /> 是异步打开的，则为 <see langword="true" />，否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsAsync`属性检测是否`FileStream`句柄已异步打开的使代码能够使用<xref:System.IO.FileStream.Handle%2A>属性正确。 在 Win32 中，`IsAsync`正在 true 表示句柄为重叠 I/O 打开并因而需要不同的参数到`ReadFile`和`WriteFile`。  
  
 在创建的实例时指定此值<xref:System.IO.FileStream>类使用的构造函数`isAsync`， `useAsync`，或`options`参数。 当该属性是`true`，流利用重叠的 I/O，异步执行文件操作。 但是，<xref:System.IO.FileStream.IsAsync%2A>属性不具有要`true`调用<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。 当<xref:System.IO.FileStream.IsAsync%2A>属性是`false`和调用异步读取和写入操作，仍未被阻止 UI 线程、，但同步执行实际的 I/O 操作。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>构造函数。  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用字节表示的流长度。</summary>
        <value>表示流长度（以字节为单位）的长值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下面的示例使用`Length`和`Position`属性，以检查文件尾条件。  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">该流的 <see cref="P:System.IO.FileStream.CanSeek" /> 为 <see langword="false" />。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误，例如文件被关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Lock : int64 * int64 -&gt; unit&#xA;override this.Lock : int64 * int64 -&gt; unit" Usage="fileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">要锁定的范围的起始处。 此参数的值必须大于或等于零 (0)。</param>
        <param name="length">要锁定的范围。</param>
        <summary>防止其他进程读取或写入 <see cref="T:System.IO.FileStream" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文件流的范围锁定赋予该区域的文件流的锁定的进程独占访问的线程。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何锁定文件的一部分，因此另一个进程不能访问该文件的一部分，即使它有访问该文件的读/写访问。 同时在不同的命令窗口中运行程序，并调查使用不同的控制台输入的选项。  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> 或 <paramref name="length" /> 为负数。</exception>
        <exception cref="T:System.ObjectDisposedException">文件关闭。</exception>
        <exception cref="T:System.IO.IOException">另一个进程已锁定了文件的一部分，因此进程无法访问该文件。</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取传递给构造函数的 <see langword="FileStream" /> 的名称。</summary>
        <value>一个字符串，它是 <see langword="FileStream" /> 的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>构造函数。  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此流的当前位置。</summary>
        <value>此流的当前位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 支持查找到流的长度超出任何位置。  当您寻求超出长度的文件时，文件大小就会增加。  在 Microsoft Windows NT 和更高，则将添加到文件末尾的任何数据设置为零。  在 Microsoft Windows 98 或更早版本，添加到文件末尾的任何数据未设置为零，这意味着，先前删除的数据是可见写入流。 将流的当前位置设置为较大的值超出在 Windows 98 或更早版本的流的末尾，则可能会导致正在引发的异常。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下面的示例使用`Length`和`Position`属性，以检查文件尾条件。  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">流不支持查找。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。  \- 或 -  位置已设置为非常大的值，此值超出 Windows 98 或更早版本中的流的末尾。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">试图将位置设置为负值。</exception>
        <exception cref="T:System.IO.EndOfStreamException">试图越过不支持此值的流的末尾进行查找。</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="fileStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">此方法返回时，包含指定的字节数组，该数组的 <c>offset</c> 和 (<c>offset</c> + <c>count</c> - 1<c>)</c> 之间的值由从当前源中读取的字节替换。</param>
        <param name="offset">
          <c>array</c> 中的字节偏移量，将在此处放置读取的字节。</param>
        <param name="count">最多读取的字节数。</param>
        <summary>从流中读取字节块并将该数据写入给定缓冲区中。</summary>
        <returns>读入缓冲区中的总字节数。 如果字节数当前不可用，则总字节数可能小于所请求的字节数；如果已到达流结尾，则为零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.IO.Stream.Read%2A>。  
  
 `offset`参数指定了中的字节的偏移量`array`（缓冲区索引） 在此处开始读取，和`count`参数指定了最大要从此流中读取的字节数。 如果已到达流结尾，则返回的值是实际数字节，则为零。 如果读取的操作成功，是通过读取的字节数高级流的当前位置。 如果发生异常，则流的当前位置不变。  
  
 <xref:System.IO.FileStream.Read%2A>方法返回仅在到达流的末尾后的零。 否则为<xref:System.IO.FileStream.Read%2A>始终至少 1 个字节从流中读取在返回之前。 如果不会提供数据时调用流中<xref:System.IO.FileStream.Read%2A>，该方法将一直阻止到至少一个字节的数据可以返回。 实现可以自由地返回少于所请求的字节，即使尚未达到流结尾。  
  
 使用<xref:System.IO.BinaryReader>读取基元数据类型。  
  
 不会中断正在执行读取的操作的线程。 尽管应用程序可能看起来后取消阻止该线程尚未成功运行，但中断会降低应用程序的性能和可靠性。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下面的示例读取从内容<xref:System.IO.FileStream>并将其写入到另一个<xref:System.IO.FileStream>。  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="count" /> 为负数。</exception>
        <exception cref="T:System.NotSupportedException">流不支持读取。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> 和 <paramref name="count" /> 描述 <paramref name="array" /> 中的无效范围。</exception>
        <exception cref="T:System.ObjectDisposedException">在流关闭后调用方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">数据写入的缓冲区。</param>
        <param name="offset">
          <c>buffer</c> 中的字节偏移量，从该偏移量开始写入流中的数据。</param>
        <param name="count">最多读取的字节数。</param>
        <param name="cancellationToken">要监视取消请求的标记。</param>
        <summary>从当前流异步读取字节的序列，将流中的位置提升读取的字节数，并监视取消请求。</summary>
        <returns>表示异步读取操作的任务。 <paramref name="TResult" /> 参数的值包含读入缓冲区的总字节数。 如果当前可用字节数少于所请求的字节数，则该结果值可小于所请求的字节数；如果已到达流结尾时，则为 0（零）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.ReadAsync%2A>方法使您能够在不阻塞主线程的情况下执行占用大量资源的文件操作。 在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。 结合使用异步方法`async`和`await`Visual Basic 和 C# 中的关键字。  
  
 使用<xref:System.IO.FileStream.CanRead%2A>属性来确定当前实例是否支持读取。  
  
 如果在完成之前，将取消该操作，返回的任务包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>属性。 如果文件句柄将被释放，则返回的任务包含<xref:System.ObjectDisposedException>中的异常<xref:System.Threading.Tasks.Task.Exception%2A>属性。  
  
   
  
## Examples  
 下面的示例演示如何以异步方式从文件读取。  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="count" /> 为负数。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</exception>
        <exception cref="T:System.NotSupportedException">流不支持读取。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放流。</exception>
        <exception cref="T:System.InvalidOperationException">之前的读取操作当前正在使用流。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="fileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从文件中读取一个字节，并将读取位置提升一个字节。</summary>
        <returns>强制转换为 <see cref="T:System.Int32" /> 的字节；或者如果已到达流的末尾，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.IO.Stream.ReadByte%2A>。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanRead%2A>属性来确定当前实例是否支持读取。 有关附加信息，请参见 <xref:System.IO.Stream.CanRead%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何将数据写入到文件，逐字节，然后验证数据是否被正确写入。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">当前流不支持读取。</exception>
        <exception cref="T:System.ObjectDisposedException">当前流已关闭。</exception>
        <block subset="none" type="overrides">
          <para>上的默认实现<see langword="Stream" />创建一个新的单字节数组，然后调用<see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />。虽然这是正式正确的效率低。所有具有内部缓冲区的流应重写此方法，并提供一个要高效得多的读取缓冲区直接，避免额外的数组分配每次调用的版本。通用文件和目录操作的列表，请参阅 [常见 I/O Tasks](~/docs/standard/io/common-i-o-tasks.md)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> 对象，它代表当前 <see cref="T:System.IO.FileStream" /> 对象所封装的文件的操作系统文件句柄。</summary>
        <value>一个对象，该对象表示当前 <see cref="T:System.IO.FileStream" /> 对象封装的文件的操作系统文件句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.SafeFileHandle%2A>属性自动刷新流，并将当前流位置设置为 0。  这允许要移动文件或流的位置来重置另一个流使用<xref:System.IO.FileStream.SafeFileHandle%2A>此属性返回。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">表示调用非托管的代码的权限。  安全操作： 链接需关联枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="fileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">相对于 <c>origin</c> 的点，从此处开始查找。</param>
        <param name="origin">使用 <see cref="T:System.IO.SeekOrigin" /> 类型的值，将开始位置、结束位置或当前位置指定为 <c>offset</c> 的参考点。</param>
        <summary>将该流的当前位置设置为给定值。</summary>
        <returns>流中的新位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType>属性来确定当前实例是否支持查找。 有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>。  
  
 您可以搜索到流的长度超出任何位置。 当您寻求超出长度的文件时，文件大小就会增加。 在 Windows NT 和更高版本中，添加到文件末尾的数据设置为零。 在 Windows 98 或更早版本中，添加到文件末尾的数据未设置为零，这意味着，先前删除的数据是可见写入流。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下面的示例演示如何将数据写入到文件，逐字节，然后验证数据是否被正确写入。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 下面的示例读取中文相反的方向，从文件末尾到开头的文件，使用各种<xref:System.IO.SeekOrigin>值与<xref:System.IO.FileStream.Seek%2A>方法。  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。</exception>
        <exception cref="T:System.NotSupportedException">流不支持查找，例如，如果 <see langword="FileStream" /> 是由管道或控制台输出构造的。</exception>
        <exception cref="T:System.ArgumentException">试图在流的开始位置之前进行查找。</exception>
        <exception cref="T:System.ObjectDisposedException">在流关闭后调用方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileStream.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">描述要应用于当前文件的 ACL 项的对象。</param>
        <summary>将 <see cref="T:System.Security.AccessControl.FileSecurity" /> 对象所描述的访问控制列表 (ACL) 项应用于当前 <see cref="T:System.IO.FileStream" /> 对象所描述的文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 虽然<xref:System.IO.FileStream>类和<xref:System.IO.FileStream.SetAccessControl%2A>可对现有文件，请考虑使用<xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType>作为它的方法是使用起来更为简便。  
  
 <xref:System.IO.FileStream.SetAccessControl%2A>方法适用于表示非继承的 ACL 列表的文件的访问控制列表 (ACL) 项。  
  
> [!CAUTION]
>  为 ACL 指定`fileSecurity`参数替换现有文件 ACL。 若要添加的新用户的权限，请使用<xref:System.IO.FileStream.GetAccessControl%2A>方法来获取现有的 ACL，对其进行修改，然后使用<xref:System.IO.FileStream.SetAccessControl%2A>以将其应用回的文件。  
  
 ACL 描述个人和/或组具有或没有执行到给定的文件上的特定操作的权限。 有关详细信息，请参阅[如何：添加或移除访问控制列表项](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">文件关闭。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileSecurity" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.SystemException">未能找到或修改该文件。</exception>
        <exception cref="T:System.UnauthorizedAccessException">当前进程不具有打开该文件的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="fileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">流的新长度。</param>
        <summary>将该流的长度设置为给定值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.IO.Stream.SetLength%2A>。  
  
 如果给定的值小于当前流的长度，则流将被截断。 在此方案中，如果当前的位置大于的新长度当前位置移至最后一字节的流。 如果给定的值大于当前流的长度，则流扩展，并当前位置保持不变。 如果流已展开，旧和新的长度之间流的内容是不确定的。  
  
 流必须支持写入和查找有关`SetLength`工作。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanWrite%2A>属性来确定当前实例是否支持写入，和<xref:System.IO.FileStream.CanSeek%2A>属性来确定是否支持查找。 有关更多信息，请参阅 <xref:System.IO.Stream.CanWrite%2A> 和 <xref:System.IO.Stream.CanSeek%2A>。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">发生了 I/O 错误。</exception>
        <exception cref="T:System.NotSupportedException">该流不支持写入和查找。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">试图将 <paramref name="value" /> 参数设置为小于 0。</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Unlock : int64 * int64 -&gt; unit&#xA;override this.Unlock : int64 * int64 -&gt; unit" Usage="fileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">要取消锁定的范围的开始处。</param>
        <param name="length">要取消锁定的范围。</param>
        <summary>允许其他进程访问以前锁定的某个文件的全部或部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何锁定文件的一部分，因此另一个进程不能访问该文件的一部分，即使它有访问该文件的读/写访问，然后解锁该文件的指定的部分。 同时在不同的命令窗口中运行程序，并调查使用不同的控制台输入的选项。  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> 或 <paramref name="length" /> 为负数。</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="fileStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">包含要写入该流的数据的缓冲区。</param>
        <param name="offset">
          <c>array</c> 中的从零开始的字节偏移量，从此处开始将字节复制到流。</param>
        <param name="count">最多写入的字节数。</param>
        <summary>将字节块写入文件流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.IO.Stream.Write%2A>。  
  
 `offset`参数指定了中的字节的偏移量`array`（缓冲区索引） 从此处开始复制，和`count`参数指定了将写入到流的字节数。 如果写入操作成功，流的当前位置被高级通过写入的字节数。 如果发生异常，则流的当前位置不变。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanWrite%2A>属性来确定当前实例是否支持写入。 有关附加信息，请参见 <xref:System.IO.Stream.CanWrite%2A>。  
  
 不会中断正在执行的写入操作的线程。 尽管应用程序可能看起来后取消阻止该线程尚未成功运行，但中断会降低应用程序的性能和可靠性。  
  
 通用文件和目录操作的列表，请参阅[通用 I/O 任务](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 此代码示例摘自更大的示例为提供<xref:System.IO.FileStream.Lock%2A>方法。  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> 和 <paramref name="count" /> 描述 <paramref name="array" /> 中的无效范围。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="count" /> 为负数。</exception>
        <exception cref="T:System.IO.IOException">出现 I/O 错误。  \- 或 -  另一个线程可能导致操作系统的文件句柄的位置发生意外更改。</exception>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.NotSupportedException">当前的流实例不支持写入。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">从中写入数据的缓冲区。</param>
        <param name="offset">
          <c>buffer</c> 中的从零开始的字节偏移量，从此处开始将字节复制到该流。</param>
        <param name="count">最多写入的字节数。</param>
        <param name="cancellationToken">要监视取消请求的标记。</param>
        <summary>将字节的序列异步写入当前流，将该流中的当前位置提升写入的字节数，并监视取消请求。</summary>
        <returns>表示异步写入操作的任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.WriteAsync%2A>方法使您能够在不阻塞主线程的情况下执行占用大量资源的文件操作。 在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。 结合使用异步方法`async`和`await`Visual Basic 和 C# 中的关键字。  
  
 使用<xref:System.IO.FileStream.CanWrite%2A>属性来确定当前实例是否支持写入。  
  
 如果在完成之前，将取消该操作，返回的任务包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>属性。 如果文件句柄将被释放，则返回的任务包含<xref:System.ObjectDisposedException>中的异常<xref:System.Threading.Tasks.Task.Exception%2A>属性。  
  
   
  
## Examples  
 下面的示例演示如何以异步方式写入到的文件。  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="count" /> 为负数。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</exception>
        <exception cref="T:System.NotSupportedException">流不支持写入。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放流。</exception>
        <exception cref="T:System.InvalidOperationException">流正在由前一次写操作使用。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="fileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">要写入流的字节。</param>
        <summary>一个字节写入文件流中的当前位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.IO.Stream.WriteByte%2A>。  
  
 使用`WriteByte`写入到一个字节`FileStream`有效。 如果流已关闭，或者不可写，则将引发异常。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanWrite%2A>属性来确定当前实例是否支持写入。 有关附加信息，请参见 <xref:System.IO.Stream.CanWrite%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何将数据写入到文件，逐字节，然后验证数据是否被正确写入。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">流已关闭。</exception>
        <exception cref="T:System.NotSupportedException">流不支持写入。</exception>
        <block subset="none" type="overrides">
          <para>上的默认实现<see langword="Stream" />创建一个新的单字节数组，然后调用<see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />。虽然这是正式正确的效率低。所有具有内部缓冲区的流应重写此方法，并提供一个要高效得多的读取缓冲区直接，避免额外的数组分配每次调用的版本。通用文件和目录操作的列表，请参阅 [常见 I/O Tasks](~/docs/standard/io/common-i-o-tasks.md)。</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>