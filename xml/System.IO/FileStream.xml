<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FileStream.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86ca1270f501ef9faaea438d5520f0e0455a33f21ad.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a1270f501ef9faaea438d5520f0e0455a33f21ad</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.FileStream">
          <source>Provides a <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> for a file, supporting both synchronous and asynchronous read and write operations.</source>
          <target state="translated">为文件提供 <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>，既支持同步读写操作，也支持异步读写操作。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>类来读取、 写入来，打开和关闭文件在文件系统中，并操纵其他与文件相关的操作系统句柄，包括管道、 标准输入和标准输出。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>You can use the <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Stream.CopyTo%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> methods to perform synchronous operations, or the <ph id="ph5">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph8">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph> methods to perform asynchronous operations.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.IO.Stream.CopyTo%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph>方法执行同步操作时，或<ph id="ph5">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>， <ph id="ph6">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>， <ph id="ph7">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>，和<ph id="ph8">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>执行异步方法操作。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread.</source>
          <target state="translated">使用异步方法而不会阻止主线程中执行资源密集型文件操作。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>This performance consideration is particularly important in a <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> app or <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</source>
          <target state="translated">在 <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> 应用或 <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> buffers input and output for better performance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> 缓冲输入和输出以提高性能。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">此类型实现<ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>接口。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">在使用完类型后，您应直接或间接释放类型。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">若要直接释放类型，调用其<ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>中的方法<ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph>块。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">若要间接释放类型，请使用 <ph id="ph1">`using`</ph>（在 C# 中）或 <ph id="ph2">`Using`</ph>（在 Visual Basic 中）等语言构造。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">有关详细信息，请参阅中的"使用实现 IDisposable 的对象"部分<ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>接口主题。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property detects whether the file handle was opened asynchronously.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph>属性检测是否异步打开的文件句柄。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>You specify this value when you create an instance of the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class using a constructor that has an <ph id="ph2">`isAsync`</ph>, <ph id="ph3">`useAsync`</ph>, or <ph id="ph4">`options`</ph> parameter.</source>
          <target state="translated">在创建的实例时指定此值<ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>类使用的构造函数<ph id="ph2">`isAsync`</ph>， <ph id="ph3">`useAsync`</ph>，或<ph id="ph4">`options`</ph>参数。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>When the property is <ph id="ph1">`true`</ph>, the stream utilizes overlapped I/O to perform file operations asynchronously.</source>
          <target state="translated">当该属性是<ph id="ph1">`true`</ph>，流利用重叠的 I/O，异步执行文件操作。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>However, the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property does not have to be <ph id="ph2">`true`</ph> to call the <ph id="ph3">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> method.</source>
          <target state="translated">但是，<ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph>属性不具有要<ph id="ph2">`true`</ph>调用<ph id="ph3">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>When the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property is <ph id="ph2">`false`</ph> and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph>属性是<ph id="ph2">`false`</ph>和调用异步读取和写入操作，仍未被阻止 UI 线程、，但同步执行实际的 I/O 操作。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> method supports random access to files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph>方法支持随机访问文件。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> allows the read/write position to be moved to any position within the file.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> 允许读/写位置移动到文件中的任意位置。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>This is done with byte offset reference point parameters.</source>
          <target state="translated">这是使用字节偏移量的引用点参数进行的。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <ph id="ph1">&lt;xref:System.IO.SeekOrigin&gt;</ph> enumeration.</source>
          <target state="translated">字节偏移量是相对于查找引用点，可以是开头、 当前的位置或基础的文件中，末尾的三个成员由表示<ph id="ph1">&lt;xref:System.IO.SeekOrigin&gt;</ph>枚举。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>Disk files always support random access.</source>
          <target state="translated">磁盘文件始终支持随机访问。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>At the time of construction, the <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property value is set to <ph id="ph2">`true`</ph> or <ph id="ph3">`false`</ph> depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <ph id="ph4">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property value is <ph id="ph5">`true`</ph>.</source>
          <target state="translated">构造，次<ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph>属性值设置为<ph id="ph2">`true`</ph>或<ph id="ph3">`false`</ph>具体取决于基础的文件类型。如果基础的文件类型 FILE_TYPE_DISK 中 winbase.h，, 定义<ph id="ph4">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph>属性值是<ph id="ph5">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>Otherwise, the <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property value is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">否则为<ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph>属性值是<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.</source>
          <target state="translated">如果进程终止，并显示锁定文件的一部分或关闭具有未完成的锁的文件，该行为不确定。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>For directory operations and other file operations, see the <ph id="ph1">&lt;xref:System.IO.File&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Directory&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.Path&gt;</ph> classes.</source>
          <target state="translated">目录操作和其他文件操作，请参阅<ph id="ph1">&lt;xref:System.IO.File&gt;</ph>， <ph id="ph2">&lt;xref:System.IO.Directory&gt;</ph>，和<ph id="ph3">&lt;xref:System.IO.Path&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.File&gt;</ph> class is a utility class that has static methods primarily for the creation of <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> objects based on file paths.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.File&gt;</ph>类是一个实用工具类具有静态方法主要用于创建<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>对象，基于文件路径。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class creates a stream from a byte array and is similar to the <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph>类从字节数组创建一个流，它类似于<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>Detection of Stream Position Changes</source>
          <target state="translated">检测到的流位置更改</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>When a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>对象不具有独占持有其句柄，另一个线程无法同时访问的文件句柄并且无法更改与文件句柄关联的操作系统的文件指针的位置。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>In this case, the cached position in the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object and the cached data in the buffer could be compromised.</source>
          <target state="translated">在此情况下中的缓存位置<ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>可能危及对象和缓冲区中的缓存的数据。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>对象定期执行的方法的访问缓存的缓冲区，以确保操作系统的句柄位置使用的缓存位置相同的检查<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>If an unexpected change in the handle position is detected in a call to the <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again.</source>
          <target state="translated">如果在句柄位置中的发生意外的更改对的调用中检测到<ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>方法，.NET Framework 放弃缓冲区的内容，并再次从文件读取流。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.</source>
          <target state="translated">这可能会影响性能，具体取决于文件和可能影响的文件流的位置的任何其他进程的大小。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>If an unexpected change in the handle position is detected in a call to the <ph id="ph1">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph> method, the contents of the buffer are discarded and an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> exception is thrown.</source>
          <target state="translated">如果在句柄位置中的发生意外的更改对的调用中检测到<ph id="ph1">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph>方法，缓冲区的内容将被丢弃和<ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph>引发异常。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>A <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object will not have an exclusive hold on its handle when either the <ph id="ph2">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> property is accessed to expose the handle or the <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> object is given the <ph id="ph4">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> property in its constructor.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>对象将不具有独占持有其句柄时任一<ph id="ph2">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph>访问属性时要公开句柄或<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>对象都提供了<ph id="ph4">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph>其构造函数中的属性。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The following example demonstrates some of the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> constructors.</source>
          <target state="translated">下面的示例演示的一些<ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The following example shows how to write to a file asynchronously.</source>
          <target state="translated">下面的示例演示如何以异步方式写入到的文件。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click.</source>
          <target state="translated">此代码具有名为 UserInput 和挂钩到名为 Button_Click 一个 Click 事件处理程序按钮 TextBlock 的 WPF 应用中运行。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The file path needs to be changed to a file than exits on the computer.</source>
          <target state="translated">需要更改为不是在计算机上存在的文件的文件路径。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="T:System.IO.FileStream">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>A file handle for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象将封装的文件的文件句柄。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">一个常数，用于设置 <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> 对象的 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> 和 <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission.</source>
          <target state="translated">使用指定的读/写权限为指定的文件句柄初始化 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>When <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> is called, the handle is also closed and the file's handle count is decremented.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph>是调用，还关闭此句柄和文件的句柄计数会递减。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> 假定它具有对该句柄的独有控制。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">读取、 写入或查找时<ph id="ph1">`FileStream`</ph>也持有句柄可能会导致数据损坏。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">为了数据安全，调用<ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph>之前使用该句柄，并避免之外调用任何方法<ph id="ph2">`Close`</ph>完成后使用此句柄。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> 默认值为那些<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>构造函数，而无需<ph id="ph3">`FileShare`</ph>参数。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="access" /&gt;</ph> is not a field of <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="access" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> 的字段。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">出现 I/O 错误，例如磁盘错误。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>The stream has been closed.</source>
          <target state="translated">已关闭流。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">对于指定的文件句柄，操作系统不允许所请求的 <ph id="ph1">&lt;paramref name="access" /&gt;</ph>，例如，当 <ph id="ph2">&lt;paramref name="access" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="Write" /&gt;</ph> 或 <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> 而文件句柄设置为只读访问时。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">为读取、 写入和追加到文件。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>，和<ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>A file handle for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象将封装的文件的文件句柄。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">一个常数，用于设置 <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> 对象的 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> 和 <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission.</source>
          <target state="translated">使用指定的读/写权限为指定的文件句柄初始化 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>When <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> is called, the handle is also closed and the file's handle count is decremented.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph>是调用，还关闭此句柄和文件的句柄计数会递减。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> 假定它具有对该句柄的独有控制。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">读取、 写入或查找时<ph id="ph1">`FileStream`</ph>也持有句柄可能会导致数据损坏。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">为了数据安全，调用<ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph>之前使用该句柄，并避免之外调用任何方法<ph id="ph2">`Close`</ph>完成后使用此句柄。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> 默认值为那些<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>构造函数，而无需<ph id="ph3">`FileShare`</ph>参数。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="access" /&gt;</ph> is not a field of <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="access" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> 的字段。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">出现 I/O 错误，例如磁盘错误。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>The stream has been closed.</source>
          <target state="translated">已关闭流。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">对于指定的文件句柄，操作系统不允许所请求的 <ph id="ph1">&lt;paramref name="access" /&gt;</ph>，例如，当 <ph id="ph2">&lt;paramref name="access" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="Write" /&gt;</ph> 或 <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> 而文件句柄设置为只读访问时。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">为读取、 写入和追加到文件。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>，和<ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象将封装的文件的相对路径或绝对路径。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">一个确定如何打开或创建文件的常数。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path and creation mode.</source>
          <target state="translated">使用指定的路径和创建模式初始化 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"<ph id="ph1">\\</ph><ph id="ph2">\\</ph>。 \PHYSICALDRIVE0"。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated"><ph id="ph1">`path`</ph>参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the <ph id="ph1">`FileStream`</ph> object has been closed, but read attempts will succeed).</source>
          <target state="translated">构造函数被授予读/写访问权限，对该文件，并且打开共享读访问权限 (即，请求打开文件进行写入的这个或另一个进程之前，无法<ph id="ph1">`FileStream`</ph>对象已关闭，但读取尝试将成功)。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a <ph id="ph1">`FileAccess`</ph> parameter with the value set to <ph id="ph2">`FileAccess.Read`</ph>.</source>
          <target state="translated">不能使用此构造函数可用来打开只读文件;相反，你必须使用接受一个构造函数<ph id="ph1">`FileAccess`</ph>参数值设置为<ph id="ph2">`FileAccess.Read`</ph>。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The buffer size is set to the default size of 4096 bytes (4 KB).</source>
          <target state="translated">缓冲区大小设置为 4096 个字节 (4 KB) 的默认大小。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">例如，具体取决于系统中，此类可以访问物理设备。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> 是<ph id="ph2">`true`</ph>所有<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>封装文件的对象。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`path`</ph>指示不支持查找，设备<ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph>所产生的属性<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>是<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">有关附加信息，请参见 <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> 默认值为那些<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>构造函数，而无需<ph id="ph3">`FileShare`</ph>参数。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>For constructors without a <ph id="ph1">&lt;xref:System.IO.FileAccess&gt;</ph> parameter, if the <ph id="ph2">`mode`</ph> parameter is set to <ph id="ph3">&lt;xref:System.IO.FileMode.Append&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileAccess.Write&gt;</ph> is the default access.</source>
          <target state="translated">构造函数，而无需<ph id="ph1">&lt;xref:System.IO.FileAccess&gt;</ph>参数，如果<ph id="ph2">`mode`</ph>参数设置为<ph id="ph3">&lt;xref:System.IO.FileMode.Append&gt;</ph>，<ph id="ph4">&lt;xref:System.IO.FileAccess.Write&gt;</ph>是默认访问权限。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>Otherwise, the access is set to <ph id="ph1">&lt;xref:System.IO.FileAccess.ReadWrite&gt;</ph>.</source>
          <target state="translated">否则，将访问权限设置为<ph id="ph1">&lt;xref:System.IO.FileAccess.ReadWrite&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</source>
          <target state="translated">下面的代码示例演示如何将数据写入到文件，逐字节，然后验证数据是否被正确写入。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">找不到文件，比如当 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 是 <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> 或 <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> 而 <ph id="ph4">&lt;paramref name="path" /&gt;</ph> 指定的文件不存在时。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">该文件必须以这些模式存在。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">发生 I/O 错误，比如指定 <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> 而 <ph id="ph2">&lt;paramref name="path" /&gt;</ph> 指定的文件已存在。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The stream has been closed.</source>
          <target state="translated">已关闭流。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">指定的路径无效，例如位于未映射的驱动器上。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">指定的路径和/或文件名超过了系统定义的最大长度。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">例如，在基于 Windows 的平台上，路径必须少于 248 个字符，且文件名必须少于 260 个字符。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 包含无效值。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">为读取、 写入和追加到文件。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>，和<ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>A file handle for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象将封装的文件的文件句柄。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> constant that sets the <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph3">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph4">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> 常数，它设置 <ph id="ph4">&lt;see langword="FileStream" /&gt;</ph> 对象的 <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> 和 <ph id="ph3">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">一个大于零的正 <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> 值，表示缓冲区大小。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">默认缓冲区大小为 4096。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission, and buffer size.</source>
          <target state="translated">使用指定的读/写权限和缓冲区大小为指定的文件句柄初始化 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> 假定它具有对该句柄的独有控制。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">读取、 写入或查找时<ph id="ph1">`FileStream`</ph>也持有句柄可能会导致数据损坏。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">为了数据安全，调用<ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph>之前使用该句柄，并避免之外调用任何方法<ph id="ph2">`Close`</ph>完成后使用此句柄。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
          <target state="translated">或者，对读取和写入句柄之前调用此<ph id="ph1">`FileStream`</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> 默认值为那些<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>构造函数，而无需<ph id="ph3">`FileShare`</ph>参数。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> parameter is an invalid handle.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> 参数是无效的句柄。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> parameter is a synchronous handle and it was used asynchronously.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> 参数是同步句柄，但被异步使用。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> parameter is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> 参数为负数。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">出现 I/O 错误，例如磁盘错误。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The stream has been closed.</source>
          <target state="translated">已关闭流。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">对于指定的文件句柄，操作系统不允许所请求的 <ph id="ph1">&lt;paramref name="access" /&gt;</ph>，例如，当 <ph id="ph2">&lt;paramref name="access" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="Write" /&gt;</ph> 或 <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> 而文件句柄设置为只读访问时。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">为读取、 写入和追加到文件。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>，和<ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">表示调用非托管的代码的权限。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>A file handle for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象将封装的文件的文件句柄。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">一个常数，用于设置 <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> 对象的 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> 和 <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the file handle will be owned by this <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果文件句柄将由此 <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> 实例所有，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission and <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance ownership.</source>
          <target state="translated">使用指定的读/写权限和 <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> 实例所属权为指定的文件句柄初始化 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified access to the file.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph>对象为文件指定指定的访问权限。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The ownership of the handle will be as specified.</source>
          <target state="translated">句柄的所有权将按指定方式。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>If this process owns the handle, a call to the <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> method will also close the handle and the file's handle count is decremented.</source>
          <target state="translated">如果此进程拥有句柄调用<ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph>方法也将关闭句柄和文件的句柄计数会递减。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the default buffer size of 4096 bytes.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph>对象都提供了默认缓冲区大小 （4096 字节）。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> 假定它具有对该句柄的独有控制。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">读取、 写入或查找时<ph id="ph1">`FileStream`</ph>也持有句柄可能会导致数据损坏。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">为了数据安全，调用<ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph>之前使用该句柄，并避免调用的方法以外<ph id="ph2">`Close`</ph>完成后使用此句柄。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> 默认值为那些<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>构造函数，而无需<ph id="ph3">`FileShare`</ph>参数。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="access" /&gt;</ph> is not a field of <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="access" /&gt;</ph> 不是 <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> 的字段。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">出现 I/O 错误，例如磁盘错误。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The stream has been closed.</source>
          <target state="translated">已关闭流。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">对于指定的文件句柄，操作系统不允许所请求的 <ph id="ph1">&lt;paramref name="access" /&gt;</ph>，例如，当 <ph id="ph2">&lt;paramref name="access" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="Write" /&gt;</ph> 或 <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> 而文件句柄设置为只读访问时。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">为读取、 写入和追加到文件。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>，和<ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象将封装的文件的相对路径或绝对路径。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">一个确定如何打开或创建文件的常数。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">一个常数，用于确定 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象访问文件的方式。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>This also determines the values returned by the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">该常数还可以确定由 <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> 对象的 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> 和 <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> 属性返回的值。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> specifies a disk file.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> 指定磁盘文件，则 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, and read/write permission.</source>
          <target state="translated">使用指定的路径、创建模式和读/写权限初始化 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"<ph id="ph1">\\</ph><ph id="ph2">\\</ph>。 \PHYSICALDRIVE0"。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated"><ph id="ph1">`path`</ph>参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the <ph id="ph1">`FileStream`</ph> object has been closed, but read attempts will succeed).</source>
          <target state="translated">构造函数被授予读/写访问权限，对该文件，并且打开共享读访问权限 (即，请求打开文件进行写入的这个或另一个进程之前，无法<ph id="ph1">`FileStream`</ph>对象已关闭，但读取尝试将成功)。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The buffer size is set to the default size of 4096 bytes (4 KB).</source>
          <target state="translated">缓冲区大小设置为 4096 个字节 (4 KB) 的默认大小。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">例如，具体取决于系统中，此类可以访问物理设备。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> 是<ph id="ph2">`true`</ph>所有<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>封装文件的对象。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`path`</ph>指示不支持查找，设备<ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph>所产生的属性<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>是<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">有关附加信息，请参见 <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> 默认值为那些<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>构造函数，而无需<ph id="ph3">`FileShare`</ph>参数。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">找不到文件，比如当 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 是 <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> 或 <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> 而 <ph id="ph4">&lt;paramref name="path" /&gt;</ph> 指定的文件不存在时。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">该文件必须以这些模式存在。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">发生 I/O 错误，比如指定 <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> 而 <ph id="ph2">&lt;paramref name="path" /&gt;</ph> 指定的文件已存在。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The stream has been closed.</source>
          <target state="translated">已关闭流。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">指定的路径无效，例如位于未映射的驱动器上。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">对于指定的 <ph id="ph1">&lt;paramref name="access" /&gt;</ph> 操作系统不允许所请求的 <ph id="ph2">&lt;paramref name="path" /&gt;</ph>，比如当 <ph id="ph3">&lt;paramref name="access" /&gt;</ph> 是 <ph id="ph4">&lt;see langword="Write" /&gt;</ph> 或 <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> 而文件或目录设置为只读访问时。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">指定的路径和/或文件名超过了系统定义的最大长度。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">例如，在基于 Windows 的平台上，路径必须少于 248 个字符，且文件名必须少于 260 个字符。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 包含无效值。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">为读取、 写入和追加到文件。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>，和<ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>A file handle for the file that this <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">此 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象将封装的文件的文件句柄。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">一个常数，用于设置 <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> 对象的 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> 和 <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">一个大于零的正 <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> 值，表示缓冲区大小。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">默认缓冲区大小为 4096。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果异步打开句柄（即以重叠的 I/O 模式），则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission, buffer size, and synchronous or asynchronous state.</source>
          <target state="translated">使用指定的读/写权限、缓冲区大小和同步或异步状态为指定的文件句柄初始化 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>You set the <ph id="ph1">`isAsync`</ph> parameter to <ph id="ph2">`true`</ph> to open the file handle asynchronously.</source>
          <target state="translated">你设置<ph id="ph1">`isAsync`</ph>参数<ph id="ph2">`true`</ph>以异步方式打开的文件句柄。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>When the parameter is <ph id="ph1">`true`</ph>, the stream utilizes overlapped I/O to perform file operations asynchronously.</source>
          <target state="translated">当该参数是<ph id="ph1">`true`</ph>，流利用重叠的 I/O，异步执行文件操作。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>However, the parameter does not have to be <ph id="ph1">`true`</ph> to call the <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> method.</source>
          <target state="translated">但是，该参数不一定要<ph id="ph1">`true`</ph>调用<ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>，或<ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>When the <ph id="ph1">`isAsync`</ph> parameter is <ph id="ph2">`false`</ph> and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</source>
          <target state="translated">当<ph id="ph1">`isAsync`</ph>参数是<ph id="ph2">`false`</ph>和调用异步读取和写入操作，仍未被阻止 UI 线程、，但同步执行实际的 I/O 操作。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> 假定它具有对该句柄的独有控制。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">读取、 写入或查找时<ph id="ph1">`FileStream`</ph>也持有句柄可能会导致数据损坏。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">为了数据安全，调用<ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph>之前使用该句柄，并避免之外调用任何方法<ph id="ph2">`Close`</ph>完成后使用此句柄。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
          <target state="translated">或者，对读取和写入句柄之前调用此<ph id="ph1">`FileStream`</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> 默认值为那些<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>构造函数，而无需<ph id="ph3">`FileShare`</ph>参数。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> parameter is an invalid handle.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> 参数是无效的句柄。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> parameter is a synchronous handle and it was used asynchronously.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> 参数是同步句柄，但被异步使用。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> parameter is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> 参数为负数。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">出现 I/O 错误，例如磁盘错误。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The stream has been closed.</source>
          <target state="translated">已关闭流。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">对于指定的文件句柄，操作系统不允许所请求的 <ph id="ph1">&lt;paramref name="access" /&gt;</ph>，例如，当 <ph id="ph2">&lt;paramref name="access" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="Write" /&gt;</ph> 或 <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> 而文件句柄设置为只读访问时。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">为读取、 写入和追加到文件。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>，和<ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">表示调用非托管的代码的权限。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>A file handle for the file that this <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">此 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象将封装的文件的文件句柄。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">一个常数，用于设置 <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> 对象的 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> 和 <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the file handle will be owned by this <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果文件句柄将由此 <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> 实例所有，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">一个大于零的正 <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> 值，表示缓冲区大小。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">默认缓冲区大小为 4096。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission, <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance ownership, and buffer size.</source>
          <target state="translated">使用指定的读/写权限、<ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> 实例所属权和缓冲区大小为指定的文件句柄初始化 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified access to the file.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph>对象为文件指定指定的访问权限。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The ownership of the handle will be as specified.</source>
          <target state="translated">句柄的所有权将按指定方式。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>If this <ph id="ph1">`FileStream`</ph> owns the handle, a call to the <ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> method will also close the handle.</source>
          <target state="translated">如果此<ph id="ph1">`FileStream`</ph>拥有句柄，调用<ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph>方法也将关闭句柄。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>In particular, the file's handle count is decremented.</source>
          <target state="translated">具体而言，该文件的句柄计数会递减。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified buffer size.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph>对象都提供了指定的缓冲区大小。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> 假定它具有对该句柄的独有控制。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">读取、 写入或查找时<ph id="ph1">`FileStream`</ph>也持有句柄可能会导致数据损坏。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">为了数据安全，调用<ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph>之前使用该句柄，并避免之外调用任何方法<ph id="ph2">`Close`</ph>完成后使用此句柄。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
          <target state="translated">或者，对读取和写入句柄之前调用此<ph id="ph1">`FileStream`</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> 默认值为那些<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>构造函数，而无需<ph id="ph3">`FileShare`</ph>参数。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> 为负数。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">出现 I/O 错误，例如磁盘错误。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The stream has been closed.</source>
          <target state="translated">已关闭流。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">对于指定的文件句柄，操作系统不允许所请求的 <ph id="ph1">&lt;paramref name="access" /&gt;</ph>，例如，当 <ph id="ph2">&lt;paramref name="access" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="Write" /&gt;</ph> 或 <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> 而文件句柄设置为只读访问时。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">为读取、 写入和追加到文件。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>，和<ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象将封装的文件的相对路径或绝对路径。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">一个确定如何打开或创建文件的常数。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">一个常数，用于确定 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象访问文件的方式。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>This also determines the values returned by the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">该常数还可以确定由 <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> 对象的 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> 和 <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> 属性返回的值。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> specifies a disk file.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> 指定磁盘文件，则 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">一个常数，确定文件将如何由进程共享。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, read/write permission, and sharing permission.</source>
          <target state="translated">使用指定的路径、创建模式、读/写权限和共享权限创建 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"<ph id="ph1">\\</ph><ph id="ph2">\\</ph>。 \PHYSICALDRIVE0"。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated"><ph id="ph1">`path`</ph>参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the <ph id="ph1">`FileStream`</ph> object has been closed, but read attempts will succeed).</source>
          <target state="translated">构造函数被授予读/写访问权限，对该文件，并且打开共享读访问权限 (即，请求打开文件进行写入的这个或另一个进程之前，无法<ph id="ph1">`FileStream`</ph>对象已关闭，但读取尝试将成功)。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The buffer size is set to the default size of 4096 bytes (4 KB).</source>
          <target state="translated">缓冲区大小设置为 4096 个字节 (4 KB) 的默认大小。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">例如，具体取决于系统中，此类可以访问物理设备。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> 是<ph id="ph2">`true`</ph>所有<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>封装文件的对象。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`path`</ph>指示不支持查找，设备<ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph>所产生的属性<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>是<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">有关附加信息，请参见 <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph> method.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">找不到文件，比如当 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 是 <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> 或 <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> 而 <ph id="ph4">&lt;paramref name="path" /&gt;</ph> 指定的文件不存在时。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">该文件必须以这些模式存在。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">发生 I/O 错误，比如指定 <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> 而 <ph id="ph2">&lt;paramref name="path" /&gt;</ph> 指定的文件已存在。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The system is running Windows 98 or Windows 98 Second Edition and <ph id="ph1">&lt;paramref name="share" /&gt;</ph> is set to <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>.</source>
          <target state="translated">系统正在运行 Windows 98 或 Windows 98 Second Edition，并且 <ph id="ph1">&lt;paramref name="share" /&gt;</ph> 设置为 <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The stream has been closed.</source>
          <target state="translated">已关闭流。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">指定的路径无效，例如位于未映射的驱动器上。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">对于指定的 <ph id="ph1">&lt;paramref name="access" /&gt;</ph> 操作系统不允许所请求的 <ph id="ph2">&lt;paramref name="path" /&gt;</ph>，比如当 <ph id="ph3">&lt;paramref name="access" /&gt;</ph> 是 <ph id="ph4">&lt;see langword="Write" /&gt;</ph> 或 <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> 而文件或目录设置为只读访问时。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">指定的路径和/或文件名超过了系统定义的最大长度。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">例如，在基于 Windows 的平台上，路径必须少于 248 个字符，且文件名必须少于 260 个字符。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 包含无效值。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">为读取、 写入和追加到文件。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>，和<ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>A file handle for the file that this <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">此 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象将封装的文件的文件句柄。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">一个常数，用于设置 <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> 对象的 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> 和 <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the file handle will be owned by this <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果文件句柄将由此 <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> 实例所有，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">一个大于零的正 <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> 值，表示缓冲区大小。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">默认缓冲区大小为 4096。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果异步打开句柄（即以重叠的 I/O 模式），则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission, <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance ownership, buffer size, and synchronous or asynchronous state.</source>
          <target state="translated">使用指定的读/写权限、<ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> 实例所属权、缓冲区大小和同步或异步状态为指定的文件句柄初始化 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified access to the file.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph>对象为文件指定指定的访问权限。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The ownership of the handle will be as specified.</source>
          <target state="translated">句柄的所有权将按指定方式。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>If this <ph id="ph1">`FileStream`</ph> owns the handle, a call to the <ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> method will also close the handle.</source>
          <target state="translated">如果此<ph id="ph1">`FileStream`</ph>拥有句柄，调用<ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph>方法也将关闭句柄。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>In particular, the file's handle count is decremented.</source>
          <target state="translated">具体而言，该文件的句柄计数会递减。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified buffer size.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph>对象都提供了指定的缓冲区大小。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> 假定它具有对该句柄的独有控制。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">读取、 写入或查找时<ph id="ph1">`FileStream`</ph>也持有句柄可能会导致数据损坏。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">为了数据安全，调用<ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph>之前使用该句柄，并避免之外调用任何方法<ph id="ph2">`Close`</ph>完成后使用此句柄。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
          <target state="translated">或者，对读取和写入句柄之前调用此<ph id="ph1">`FileStream`</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> 默认值为那些<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>构造函数，而无需<ph id="ph3">`FileShare`</ph>参数。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="access" /&gt;</ph> is less than <ph id="ph2">&lt;see langword="FileAccess.Read" /&gt;</ph> or greater than <ph id="ph3">&lt;see langword="FileAccess.ReadWrite" /&gt;</ph> or <ph id="ph4">&lt;paramref name="bufferSize" /&gt;</ph> is less than or equal to 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="access" /&gt;</ph> 小于 <ph id="ph2">&lt;see langword="FileAccess.Read" /&gt;</ph> 或大于 <ph id="ph3">&lt;see langword="FileAccess.ReadWrite" /&gt;</ph>，或者 <ph id="ph4">&lt;paramref name="bufferSize" /&gt;</ph> 小于或等于 0。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The handle is invalid.</source>
          <target state="translated">该句柄无效。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">出现 I/O 错误，例如磁盘错误。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The stream has been closed.</source>
          <target state="translated">已关闭流。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">对于指定的文件句柄，操作系统不允许所请求的 <ph id="ph1">&lt;paramref name="access" /&gt;</ph>，例如，当 <ph id="ph2">&lt;paramref name="access" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="Write" /&gt;</ph> 或 <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> 而文件句柄设置为只读访问时。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>for access to unmanaged code.</source>
          <target state="translated">用于访问非托管代码。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">关联枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象将封装的文件的相对路径或绝对路径。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">一个确定如何打开或创建文件的常数。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">一个常数，用于确定 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象访问文件的方式。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>This also determines the values returned by the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">该常数还可以确定由 <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> 对象的 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> 和 <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> 属性返回的值。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> specifies a disk file.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> 指定磁盘文件，则 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">一个常数，确定文件将如何由进程共享。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">一个大于零的正 <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> 值，表示缓冲区大小。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">默认缓冲区大小为 4096。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, read/write and sharing permission, and buffer size.</source>
          <target state="translated">用指定的路径、创建模式、读/写及共享权限和缓冲区大小初始化 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"<ph id="ph1">\\</ph><ph id="ph2">\\</ph>。 \PHYSICALDRIVE0"。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated"><ph id="ph1">`path`</ph>参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">例如，具体取决于系统中，此类可以访问物理设备。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> 是<ph id="ph2">`true`</ph>所有<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>封装文件的对象。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`path`</ph>指示不支持查找，设备<ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph>所产生的属性<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>是<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">有关附加信息，请参见 <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> 为负数或零。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contain an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>、<ph id="ph2">&lt;paramref name="access" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="share" /&gt;</ph> 包含无效值。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">找不到文件，比如当 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 是 <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> 或 <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> 而 <ph id="ph4">&lt;paramref name="path" /&gt;</ph> 指定的文件不存在时。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">该文件必须以这些模式存在。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">发生 I/O 错误，比如指定 <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> 而 <ph id="ph2">&lt;paramref name="path" /&gt;</ph> 指定的文件已存在。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The system is running Windows 98 or Windows 98 Second Edition and <ph id="ph1">&lt;paramref name="share" /&gt;</ph> is set to <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>.</source>
          <target state="translated">系统正在运行 Windows 98 或 Windows 98 Second Edition，并且 <ph id="ph1">&lt;paramref name="share" /&gt;</ph> 设置为 <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The stream has been closed.</source>
          <target state="translated">已关闭流。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">指定的路径无效，例如位于未映射的驱动器上。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">对于指定的 <ph id="ph1">&lt;paramref name="access" /&gt;</ph> 操作系统不允许所请求的 <ph id="ph2">&lt;paramref name="path" /&gt;</ph>，比如当 <ph id="ph3">&lt;paramref name="access" /&gt;</ph> 是 <ph id="ph4">&lt;see langword="Write" /&gt;</ph> 或 <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> 而文件或目录设置为只读访问时。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">指定的路径和/或文件名超过了系统定义的最大长度。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">例如，在基于 Windows 的平台上，路径必须少于 248 个字符，且文件名必须少于 260 个字符。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">为读取、 写入和追加到文件。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>，和<ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象将封装的文件的相对路径或绝对路径。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">一个确定如何打开或创建文件的常数。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">一个常数，用于确定 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象访问文件的方式。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>This also determines the values returned by the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">该常数还可以确定由 <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> 对象的 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> 和 <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> 属性返回的值。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> specifies a disk file.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> 指定磁盘文件，则 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">一个常数，确定文件将如何由进程共享。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">一个大于零的正 <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> 值，表示缓冲区大小。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The default buffer size is 4096..</source>
          <target state="translated">默认缓冲区大小为 4096。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>Specifies whether to use asynchronous I/O or synchronous I/O.</source>
          <target state="translated">指定使用异步 I/O 还是同步 I/O。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>However, note that the underlying operating system might not support asynchronous I/O, so when specifying <ph id="ph1">&lt;see langword="true" /&gt;</ph>, the handle might be opened synchronously depending on the platform.</source>
          <target state="translated">但是，请注意，基础操作系统可能不支持异步 I/O，因此在指定 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 后，根据所用平台，句柄可能同步打开。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>When opened asynchronously, the <ph id="ph1">&lt;see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> methods perform better on large reads or writes, but they might be much slower for small reads or writes.</source>
          <target state="translated">当异步打开时，<ph id="ph1">&lt;see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> 和 <ph id="ph2">&lt;see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> 方法在执行大量读或写时效果更好，但对于少量的读/写，这些方法速度可能要慢得多。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>If the application is designed to take advantage of asynchronous I/O, set the <bpt id="p1">&lt;c&gt;</bpt>useAsync<ept id="p1">&lt;/c&gt;</ept> parameter to <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">如果应用程序打算利用异步 I/O，将 <bpt id="p1">&lt;c&gt;</bpt>useAsync<ept id="p1">&lt;/c&gt;</ept> 参数设置为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>Using asynchronous I/O correctly can speed up applications by as much as a factor of 10, but using it without redesigning the application for asynchronous I/O can decrease performance by as much as a factor of 10.</source>
          <target state="translated">正确使用异步 I/O 可以使应用程序的速度加快 10 倍，但是如果在没有为异步 I/O 重新设计应用程序的情况下使用异步 I/O，则可能使性能降低 10 倍。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, read/write and sharing permission, buffer size, and synchronous or asynchronous state.</source>
          <target state="translated">使用指定的路径、创建模式、读/写和共享权限、缓冲区大小和同步或异步状态初始化 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"<ph id="ph1">\\</ph><ph id="ph2">\\</ph>。 \PHYSICALDRIVE0"。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated"><ph id="ph1">`path`</ph>参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">例如，具体取决于系统中，此类可以访问物理设备。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> 是<ph id="ph2">`true`</ph>所有<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>封装文件的对象。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`path`</ph>指示不支持查找，设备<ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph>所产生的属性<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>是<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">有关附加信息，请参见 <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly.</source>
          <target state="translated">下面的代码示例演示如何将数据异步写入到文件，然后验证数据是否被正确写入。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A <ph id="ph1">`State`</ph> object is created to pass information from the main thread to the <ph id="ph2">`EndReadCallback`</ph> and <ph id="ph3">`EndWriteCallback`</ph> methods.</source>
          <target state="translated">A<ph id="ph1">`State`</ph>创建对象将信息从主线程传递<ph id="ph2">`EndReadCallback`</ph>和<ph id="ph3">`EndWriteCallback`</ph>方法。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> 为负数或零。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contain an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>、<ph id="ph2">&lt;paramref name="access" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="share" /&gt;</ph> 包含无效值。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">找不到文件，比如当 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 是 <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> 或 <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> 而 <ph id="ph4">&lt;paramref name="path" /&gt;</ph> 指定的文件不存在时。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">该文件必须以这些模式存在。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">发生 I/O 错误，比如指定 <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> 而 <ph id="ph2">&lt;paramref name="path" /&gt;</ph> 指定的文件已存在。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The system is running Windows 98 or Windows 98 Second Edition and <ph id="ph1">&lt;paramref name="share" /&gt;</ph> is set to <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>.</source>
          <target state="translated">系统正在运行 Windows 98 或 Windows 98 Second Edition，并且 <ph id="ph1">&lt;paramref name="share" /&gt;</ph> 设置为 <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The stream has been closed.</source>
          <target state="translated">已关闭流。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">指定的路径无效，例如位于未映射的驱动器上。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">对于指定的 <ph id="ph1">&lt;paramref name="access" /&gt;</ph> 操作系统不允许所请求的 <ph id="ph2">&lt;paramref name="path" /&gt;</ph>，比如当 <ph id="ph3">&lt;paramref name="access" /&gt;</ph> 是 <ph id="ph4">&lt;see langword="Write" /&gt;</ph> 或 <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> 而文件或目录设置为只读访问时。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">指定的路径和/或文件名超过了系统定义的最大长度。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">例如，在基于 Windows 的平台上，路径必须少于 248 个字符，且文件名必须少于 260 个字符。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">为读取、 写入和追加到文件。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>，和<ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象将封装的文件的相对路径或绝对路径。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">一个确定如何打开或创建文件的常数。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">一个常数，用于确定 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象访问文件的方式。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>This also determines the values returned by the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">该常数还可以确定由 <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> 对象的 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> 和 <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> 属性返回的值。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> specifies a disk file.</source>
          <target state="translated">如果 <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> 指定磁盘文件，则 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">一个常数，确定文件将如何由进程共享。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">一个大于零的正 <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> 值，表示缓冲区大小。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">默认缓冲区大小为 4096。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A value that specifies additional file options.</source>
          <target state="translated">一个指定附加文件选项的值。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, read/write and sharing permission, the access other FileStreams can have to the same file, the buffer size, and additional file options.</source>
          <target state="translated">使用指定的路径、创建模式、读/写和共享权限、其他 FileStreams 可以具有的对此文件的访问权限、缓冲区大小和附加文件选项初始化 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"<ph id="ph1">\\</ph><ph id="ph2">\\</ph>。 \PHYSICALDRIVE0"。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">`fileOptions`</ph> parameter is used to provide access to more advanced operations that can be leveraged when creating a <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">`fileOptions`</ph>参数用于提供对在创建时可以利用的更高级操作访问<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated"><ph id="ph1">`path`</ph>参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">例如，具体取决于系统中，此类可以访问物理设备。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> 是<ph id="ph2">`true`</ph>所有<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>封装文件的对象。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`path`</ph>指示不支持查找，设备<ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph>所产生的属性<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>是<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">有关附加信息，请参见 <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The following example writes data to a file and then reads the data using the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">下面的示例将数据写入文件，然后读取数据使用<ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> 为负数或零。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contain an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>、<ph id="ph2">&lt;paramref name="access" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="share" /&gt;</ph> 包含无效值。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">找不到文件，比如当 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 是 <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> 或 <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> 而 <ph id="ph4">&lt;paramref name="path" /&gt;</ph> 指定的文件不存在时。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">该文件必须以这些模式存在。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">发生 I/O 错误，比如指定 <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> 而 <ph id="ph2">&lt;paramref name="path" /&gt;</ph> 指定的文件已存在。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The stream has been closed.</source>
          <target state="translated">已关闭流。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">指定的路径无效，例如位于未映射的驱动器上。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">对于指定的 <ph id="ph1">&lt;paramref name="access" /&gt;</ph> 操作系统不允许所请求的 <ph id="ph2">&lt;paramref name="path" /&gt;</ph>，比如当 <ph id="ph3">&lt;paramref name="access" /&gt;</ph> 是 <ph id="ph4">&lt;see langword="Write" /&gt;</ph> 或 <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> 而文件或目录设置为只读访问时。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph> is specified for <ph id="ph2">&lt;paramref name="options" /&gt;</ph>, but file encryption is not supported on the current platform.</source>
          <target state="translated">为 <ph id="ph2">&lt;paramref name="options" /&gt;</ph> 指定了 <ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph>，但是当前平台不支持文件加密。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">指定的路径和/或文件名超过了系统定义的最大长度。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">例如，在基于 Windows 的平台上，路径必须少于 248 个字符，且文件名必须少于 260 个字符。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">为读取、 写入和追加到文件。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>，和<ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 对象将封装的文件的相对路径或绝对路径。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">一个确定如何打开或创建文件的常数。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines the access rights to use when creating access and audit rules for the file.</source>
          <target state="translated">一个常数，确定为文件创建访问和审核规则时要使用的访问权。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">一个常数，确定文件将如何由进程共享。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">一个大于零的正 <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> 值，表示缓冲区大小。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">默认缓冲区大小为 4096。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that specifies additional file options.</source>
          <target state="translated">一个指定附加文件选项的常数。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, access rights and sharing permission, the buffer size, and additional file options.</source>
          <target state="translated">使用指定的路径、创建模式、访问权限和共享权限、缓冲区大小和附加文件选项初始化 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"<ph id="ph1">\\</ph><ph id="ph2">\\</ph>。 \PHYSICALDRIVE0"。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>Use this <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%2A&gt;</ph> constructor to apply access rights at the point of creation of a file.</source>
          <target state="translated">使用此<ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%2A&gt;</ph>构造函数将访问权限在创建文件。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>To access or modify rights on an existing file, consider using the <ph id="ph1">&lt;xref:System.IO.File.GetAccessControl%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.File.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">若要访问或修改现有文件上的权限，请考虑使用<ph id="ph1">&lt;xref:System.IO.File.GetAccessControl%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.IO.File.SetAccessControl%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">`fileOptions`</ph> parameter is used to provide access to more advanced operations that can be leveraged when creating a <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">`fileOptions`</ph>参数用于提供对在创建时可以利用的更高级操作访问<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated"><ph id="ph1">`path`</ph>参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">例如，具体取决于系统中，此类可以访问物理设备。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> 是<ph id="ph2">`true`</ph>所有<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>封装文件的对象。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`path`</ph>指示不支持查找，设备<ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph>所产生的属性<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>是<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">有关附加信息，请参见 <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> 为负数或零。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contain an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>、<ph id="ph2">&lt;paramref name="access" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="share" /&gt;</ph> 包含无效值。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">找不到文件，比如当 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 是 <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> 或 <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> 而 <ph id="ph4">&lt;paramref name="path" /&gt;</ph> 指定的文件不存在时。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">该文件必须以这些模式存在。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The current operating system is not Windows NT or later.</source>
          <target state="translated">当前操作系统不是 Windows NT 或更高版本。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">发生 I/O 错误，比如指定 <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> 而 <ph id="ph2">&lt;paramref name="path" /&gt;</ph> 指定的文件已存在。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The stream has been closed.</source>
          <target state="translated">已关闭流。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">指定的路径无效，例如位于未映射的驱动器上。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">对于指定的 <ph id="ph1">&lt;paramref name="access" /&gt;</ph> 操作系统不允许所请求的 <ph id="ph2">&lt;paramref name="path" /&gt;</ph>，比如当 <ph id="ph3">&lt;paramref name="access" /&gt;</ph> 是 <ph id="ph4">&lt;see langword="Write" /&gt;</ph> 或 <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> 而文件或目录设置为只读访问时。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph> is specified for <ph id="ph2">&lt;paramref name="options" /&gt;</ph>, but file encryption is not supported on the current platform.</source>
          <target state="translated">为 <ph id="ph2">&lt;paramref name="options" /&gt;</ph> 指定了 <ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph>，但是当前平台不支持文件加密。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The specified <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">指定的 <ph id="ph1">&lt;paramref name="path" /&gt;</ph>、文件名或者两者都超出了系统定义的最大长度。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">例如，在基于 Windows 的平台上，路径必须少于 248 个字符，且文件名必须少于 260 个字符。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">为读取、 写入和追加到文件。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>，和<ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">当前 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 对象将封装的文件的相对路径或绝对路径。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">一个确定如何打开或创建文件的常数。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A constant that determines the access rights to use when creating access and audit rules for the file.</source>
          <target state="translated">一个常数，确定为文件创建访问和审核规则时要使用的访问权。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">一个常数，确定文件将如何由进程共享。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">一个大于零的正 <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> 值，表示缓冲区大小。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">默认缓冲区大小为 4096。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A constant that specifies additional file options.</source>
          <target state="translated">一个指定附加文件选项的常数。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A constant that determines the access control and audit security for the file.</source>
          <target state="translated">一个常数，确定文件的访问控制和审核安全。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, access rights and sharing permission, the buffer size, additional file options, access control and audit security.</source>
          <target state="translated">使用指定的路径、创建模式、访问权限和共享权限、缓冲区大小、附加文件选项、访问控制和审核安全初始化 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework 不支持直接访问通过是设备名称，如的路径的物理磁盘"<ph id="ph1">\\</ph><ph id="ph2">\\</ph>。 \PHYSICALDRIVE0"。</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>Use this <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%2A&gt;</ph> constructor to apply access rights at the point of creation of a file.</source>
          <target state="translated">使用此<ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%2A&gt;</ph>构造函数将访问权限在创建文件。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>To access or modify rights on an existing file, consider using the <ph id="ph1">&lt;xref:System.IO.File.GetAccessControl%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.File.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">若要访问或修改现有文件上的权限，请考虑使用<ph id="ph1">&lt;xref:System.IO.File.GetAccessControl%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.IO.File.SetAccessControl%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The <ph id="ph1">`fileOptions`</ph> parameter is used to provide access to more advanced operations that can be leveraged when creating a <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">`fileOptions`</ph>参数用于提供对在创建时可以利用的更高级操作访问<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated"><ph id="ph1">`path`</ph>参数可以为文件名，包括通用命名约定 (UNC) 共享上的文件。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> 不需要是存储在磁盘; 上的文件它可以是系统的支持通过流访问的任何部分。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">例如，具体取决于系统中，此类可以访问物理设备。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> 是<ph id="ph2">`true`</ph>所有<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>封装文件的对象。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">如果<ph id="ph1">`path`</ph>指示不支持查找，设备<ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph>所产生的属性<ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>是<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">有关附加信息，请参见 <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">当你使用特定的区域性设置进行编译的一组字符，并检索这些具有不同的区域性设置的相同字符时，字符可能无法解释，并可能会导致引发异常。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The following example writes data to a file and then reads the data using the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">下面的示例将数据写入文件，然后读取数据使用<ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 引用一个非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> 为负数或零。</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contain an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>、<ph id="ph2">&lt;paramref name="access" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="share" /&gt;</ph> 包含无效值。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">找不到文件，比如当 <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 是 <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> 或 <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph> 而 <ph id="ph4">&lt;paramref name="path" /&gt;</ph> 指定的文件不存在时。</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">该文件必须以这些模式存在。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">发生 I/O 错误，比如指定 <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> 而 <ph id="ph2">&lt;paramref name="path" /&gt;</ph> 指定的文件已存在。</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The stream has been closed.</source>
          <target state="translated">已关闭流。</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">指定的路径无效，例如位于未映射的驱动器上。</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">对于指定的 <ph id="ph1">&lt;paramref name="access" /&gt;</ph> 操作系统不允许所请求的 <ph id="ph2">&lt;paramref name="path" /&gt;</ph>，比如当 <ph id="ph3">&lt;paramref name="access" /&gt;</ph> 是 <ph id="ph4">&lt;see langword="Write" /&gt;</ph> 或 <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> 而文件或目录设置为只读访问时。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph> is specified for <ph id="ph2">&lt;paramref name="options" /&gt;</ph>, but file encryption is not supported on the current platform.</source>
          <target state="translated">为 <ph id="ph2">&lt;paramref name="options" /&gt;</ph> 指定了 <ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph>，但是当前平台不支持文件加密。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The specified <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">指定的 <ph id="ph1">&lt;paramref name="path" /&gt;</ph>、文件名或者两者都超出了系统定义的最大长度。</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">例如，在基于 Windows 的平台上，路径必须少于 248 个字符，且文件名必须少于 260 个字符。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The current operating system is not Windows NT or later.</source>
          <target state="translated">当前操作系统不是 Windows NT 或更高版本。</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">为读取、 写入和追加到文件。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>， <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>，和<ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The buffer to read data into.</source>
          <target state="translated">将数据读入的缓冲区。</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The byte offset in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which to begin reading.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> 中的字节偏移量，从此处开始读取。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">最多读取的字节数。</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The method to be called when the asynchronous read operation is completed.</source>
          <target state="translated">异步读操作完成后调用的方法。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous read request from other requests.</source>
          <target state="translated">一个用户提供的对象，它将该特定的异步读取请求与其他请求区别开来。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous read operation.</source>
          <target state="translated">开始异步读操作。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">（请考虑改用 <ph id="ph1">&lt;see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph>。）</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that references the asynchronous read.</source>
          <target state="translated">引用异步读取的对象。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">在.NET Framework 4 和更早版本中，你必须使用方法，如<ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph>来实现异步文件操作。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">这些方法是在中仍然可用<ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>以支持旧版代码; 但是，新的异步方法，如<ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>，和<ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>，帮助你更轻松地实现异步文件操作。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> must be called exactly once for every call to <ph id="ph2">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> 必须为对每个调用一次调用<ph id="ph2">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</source>
          <target state="translated">如果在开始另一个读取之前，结束读取的进程可能会导致意外行为，如死锁。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> provides two different modes of operation: synchronous I/O and asynchronous I/O.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> 提供两个不同的操作模式： I/O 同步和异步 I/O。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>While either can be used, the underlying operating system resources might allow access in only one of these modes.</source>
          <target state="translated">尽管可以使用任一，基础的操作系统资源可能允许访问，只有其中一种模式中。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>By default, <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> opens the operating system handle synchronously.</source>
          <target state="translated">默认情况下，<ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>同步打开的操作系统句柄。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>In Windows, this slows down asynchronous methods.</source>
          <target state="translated">在 Windows 中，这将降低异步方法。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>If asynchronous methods are used, use the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">如果使用异步方法，使用<ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph>属性来确定当前实例是否支持读取。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanRead%2A&gt;</ph>.</source>
          <target state="translated">有关附加信息，请参见 <ph id="ph1">&lt;xref:System.IO.Stream.CanRead%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
          <target state="translated">如果流已关闭或传递了无效参数，将立即引发异常从<ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Errors that occur during an asynchronous read request, such as a disk failure during the IO request, occur on the thread pool thread and become visible upon a call to <ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph>.</source>
          <target state="translated">异步读取请求，例如 IO 请求过程的磁盘故障过程中发生的错误发生在线程池线程和调用时变得可见<ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph> must be called with this <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to find out how many bytes were read.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph> 必须与此调用<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>若要了解读取的多少字节数。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Multiple simultaneous asynchronous requests render the request completion order uncertain.</source>
          <target state="translated">多个同时进行的异步请求呈现请求完成顺序不确定。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The array length minus <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph>.</source>
          <target state="translated">数组长度减去 <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 小于 <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph> 为负数。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>An asynchronous read was attempted past the end of the file.</source>
          <target state="translated">尝试在文件的末尾后进行异步读取。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The buffer containing data to write to the current stream.</source>
          <target state="translated">包含要写入当前流的数据的缓冲区。</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which to begin copying bytes to the current stream.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> 中的从零开始的字节偏移量，从此处开始将字节复制到当前流。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">最多写入的字节数。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The method to be called when the asynchronous write operation is completed.</source>
          <target state="translated">异步写操作完成后调用的方法。</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous write request from other requests.</source>
          <target state="translated">一个用户提供的对象，它将该特定的异步写入请求与其他请求区别开来。</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous write operation.</source>
          <target state="translated">开始异步写操作。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">（请考虑改用 <ph id="ph1">&lt;see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph>。）</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that references the asynchronous write.</source>
          <target state="translated">引用异步写入的对象。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">在.NET Framework 4 和更早版本中，你必须使用方法，如<ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph>来实现异步文件操作。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">这些方法是在中仍然可用<ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>以支持旧版代码; 但是，新的异步方法，如<ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>，和<ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>，帮助你更轻松地实现异步文件操作。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> must be called exactly once on every <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> from <ph id="ph3">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> 必须在上一次调用每个<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>从<ph id="ph3">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> will block until the I/O operation has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> 将阻止，直到 I/O 操作已完成。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.BeginWrite%2A&gt;</ph>.</source>
          <target state="translated">此方法重写 <ph id="ph1">&lt;xref:System.IO.Stream.BeginWrite%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> provides two different modes of operation: synchronous I/O and asynchronous I/O.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> 提供两个不同的操作模式： I/O 同步和异步 I/O。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>While either can be used, the underlying operating system resources might allow access in only one of these modes.</source>
          <target state="translated">尽管可以使用任一，基础的操作系统资源可能允许访问，只有其中一种模式中。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>By default, <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> opens the operating system handle synchronously.</source>
          <target state="translated">默认情况下，<ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>同步打开的操作系统句柄。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>In Windows, this slows down asynchronous methods.</source>
          <target state="translated">在 Windows 中，这将降低异步方法。</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>If asynchronous methods are used, use the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">如果使用异步方法，使用<ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</source>
          <target state="translated">如果流已关闭或传递了无效参数，将立即引发异常从<ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the IO request, occur on the thread pool thread and become visible upon a call to <ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph>.</source>
          <target state="translated">异步写入请求，例如 IO 请求过程的磁盘故障过程中发生的错误发生在线程池线程和调用时变得可见<ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Multiple simultaneous asynchronous requests render the request completion order uncertain.</source>
          <target state="translated">多个同时进行的异步请求呈现请求完成顺序不确定。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> length minus <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> is less than <ph id="ph3">&lt;paramref name="numBytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> 长度减去 <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> 小于 <ph id="ph3">&lt;paramref name="numBytes" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph> 为负数。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The stream does not support writing.</source>
          <target state="translated">流不支持写入。</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The stream is closed.</source>
          <target state="translated">流已关闭。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>An I/O error occurred.</source>
          <target state="translated">出现 I/O 错误。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.CanRead">
          <source>Gets a value indicating whether the current stream supports reading.</source>
          <target state="translated">获取一个值，该值指示当前流是否支持读取。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream supports reading; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the stream is closed or was opened with write-only access.</source>
          <target state="translated">如果流支持读取，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；如果流已关闭或是通过只写访问方式打开的，则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support reading, calls to the <ph id="ph2">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.ReadByte%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> methods throw a <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">如果从派生的类<ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph>不支持读取，则调用<ph id="ph2">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.IO.FileStream.ReadByte%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>方法将引发<ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">如果流已关闭，则此属性返回<ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source>The following example demonstrates a use of the <ph id="ph1">`CanRead`</ph> property.</source>
          <target state="translated">下面的示例演示使用<ph id="ph1">`CanRead`</ph>属性。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source>The output of this code is "MyFile.txt is not writable."</source>
          <target state="translated">此代码的输出是"MyFile.txt 不是可写。"</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source>To get the output message "MyFile.txt can be both written to and read from.", change the <ph id="ph1">`FileAccess`</ph> parameter to <ph id="ph2">`ReadWrite`</ph> in the <ph id="ph3">`FileStream`</ph> constructor.</source>
          <target state="translated">若要获取输出消息"MyFile.txt 可以同时为读取和写入从。"，更改<ph id="ph1">`FileAccess`</ph>参数<ph id="ph2">`ReadWrite`</ph>中<ph id="ph3">`FileStream`</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.CanSeek">
          <source>Gets a value indicating whether the current stream supports seeking.</source>
          <target state="translated">获取一个值，该值指示当前流是否支持查找。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanSeek">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream supports seeking; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the stream is closed or if the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> was constructed from an operating-system handle such as a pipe or output to the console.</source>
          <target state="translated">如果流支持查找，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；如果流已关闭或者如果 <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> 是从操作系统句柄（如管道或到控制台的输出）构造的，则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanSeek">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support seeking, calls to <ph id="ph2">&lt;xref:System.IO.FileStream.Length%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.SetLength%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.Position%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> throw a <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">如果从派生的类<ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph>不支持查找，则调用<ph id="ph2">&lt;xref:System.IO.FileStream.Length%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.IO.FileStream.SetLength%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.IO.FileStream.Position%2A&gt;</ph>，和<ph id="ph5">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph>引发<ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanSeek">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">如果流已关闭，则此属性返回<ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanSeek">
          <source>The following example uses the <ph id="ph1">`CanSeek`</ph> property to check whether a stream supports seeking.</source>
          <target state="translated">下面的示例使用<ph id="ph1">`CanSeek`</ph>属性检查流是否支持查找。</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.CanWrite">
          <source>Gets a value indicating whether the current stream supports writing.</source>
          <target state="translated">获取一个值，该值指示当前流是否支持写入。</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream supports writing; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the stream is closed or was opened with read-only access.</source>
          <target state="translated">如果流支持写入，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；如果流已关闭或是通过只读访问方式打开的，则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support writing, a call to <ph id="ph2">&lt;xref:System.IO.FileStream.SetLength%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.IO.FileStream.WriteByte%2A&gt;</ph> throws a <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">如果从派生的类<ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph>不支持写入，调用<ph id="ph2">&lt;xref:System.IO.FileStream.SetLength%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.IO.FileStream.WriteByte%2A&gt;</ph>引发<ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">如果流已关闭，则此属性返回<ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>The following example uses the <ph id="ph1">`CanWrite`</ph> property to check whether a stream supports writing.</source>
          <target state="translated">下面的示例使用<ph id="ph1">`CanWrite`</ph>属性检查流是否支持写入。</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>The following is an example using the <ph id="ph1">`CanWrite`</ph> property.</source>
          <target state="translated">以下是一个示例使用<ph id="ph1">`CanWrite`</ph>属性。</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>The output of this code is "MyFile.txt is writable."</source>
          <target state="translated">此代码的输出为"可写 ' MyFile.txt"。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>To get the output message "MyFile.txt can be both written to and read from.", change the <ph id="ph1">`FileAccess`</ph> parameter to <ph id="ph2">`ReadWrite`</ph> in the <ph id="ph3">`FileStream`</ph> constructor.</source>
          <target state="translated">若要获取输出消息"MyFile.txt 可以同时为读取和写入从。"，更改<ph id="ph1">`FileAccess`</ph>参数<ph id="ph2">`ReadWrite`</ph>中<ph id="ph3">`FileStream`</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated">若要释放托管资源和非托管资源，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；若仅释放非托管资源，则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> and optionally releases the managed resources.</source>
          <target state="translated">释放由 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 占用的非托管资源，还可以另外再释放托管资源。</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">此方法称为由公共<ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph>方法和<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> invokes the protected <ph id="ph2">&lt;xref:System.IO.FileStream.Dispose%2A&gt;</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> 调用受保护<ph id="ph2">&lt;xref:System.IO.FileStream.Dispose%2A&gt;</ph>方法替换<ph id="ph3">`disposing`</ph>参数设置为<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id="ph2">&lt;xref:System.IO.FileStream.Dispose%2A&gt;</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> 调用<ph id="ph2">&lt;xref:System.IO.FileStream.Dispose%2A&gt;</ph>与<ph id="ph3">`disposing`</ph>设置为<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> references.</source>
          <target state="translated">当 <ph id="ph1">`disposing`</ph> 参数为 <ph id="ph2">`true`</ph> 时，此方法释放该 <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> 引用的、由任何托管对象持有的全部资源。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method of each referenced object.</source>
          <target state="translated">此方法调用每个引用对象的 <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> 可以由其他对象多次调用。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /&gt;</ph> be careful not to reference objects that have been previously disposed of in an earlier call to <ph id="ph2">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>.</source>
          <target state="translated">在重写<ph id="ph1">&lt;see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /&gt;</ph>请注意不要引用已释放的以前调用中的对象<ph id="ph2">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">有关如何实现详细信息<ph id="ph1">&lt;see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /&gt;</ph>，请参阅<bpt id="p1">[</bpt>实现 Dispose 方法<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">有关详细信息<ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>和<ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>，请参阅<bpt id="p1">[</bpt>清洗向上非托管资源<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>The reference to the pending asynchronous request to wait for.</source>
          <target state="translated">对所等待的挂起异步请求的引用。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>Waits for the pending asynchronous read operation to complete.</source>
          <target state="translated">等待挂起的异步读操作完成。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">（请考虑改用 <ph id="ph1">&lt;see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph>。）</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>The number of bytes read from the stream, between 0 and the number of bytes you requested.</source>
          <target state="translated">从流中读取的字节数，介于 0 和所请求的字节数之间。</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>Streams only return 0 at the end of the stream, otherwise, they should block until at least 1 byte is available.</source>
          <target state="translated">流仅在流结尾返回 0，否则在至少有 1 个字节可用之前应一直进行阻止。</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">在.NET Framework 4 和更早版本中，你必须使用方法，如<ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph>来实现异步文件操作。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">这些方法是在中仍然可用<ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>以支持旧版代码; 但是，新的异步方法，如<ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>，和<ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>，帮助你更轻松地实现异步文件操作。</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> must be called exactly for every call to <ph id="ph2">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> 必须正好为对每个调用调用<ph id="ph2">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</source>
          <target state="translated">如果在开始另一个读取之前，结束读取的进程可能会导致意外行为，如死锁。</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph>.</source>
          <target state="translated">此方法重写 <ph id="ph1">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> can be called on every <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> from <ph id="ph3">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> 可以在调用每个<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>从<ph id="ph3">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>Calling <ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> tells you how many bytes were read from the stream.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph>告知你已从流中读取字节数。</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> will block until the I/O operation has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> 将阻止，直到 I/O 操作已完成。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>This <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object was not created by calling <ph id="ph2">&lt;see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> on this class.</source>
          <target state="translated">此 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> 对象不是通过对该类调用 <ph id="ph2">&lt;see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> 来创建的。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /&gt;</ph> is called multiple times.</source>
          <target state="translated">多次调用了 <ph id="ph1">&lt;see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>The stream is closed or an internal error has occurred.</source>
          <target state="translated">流已关闭或出现了内部错误。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>The pending asynchronous I/O request.</source>
          <target state="translated">挂起的异步 I/O 请求。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>Ends an asynchronous write operation and blocks until the I/O operation is complete.</source>
          <target state="translated">结束异步写入操作，在 I/O 操作完成之前一直阻止。</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">（请考虑改用 <ph id="ph1">&lt;see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph>。）</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">在.NET Framework 4 和更早版本中，你必须使用方法，如<ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph>来实现异步文件操作。</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">这些方法是在中仍然可用<ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>以支持旧版代码; 但是，新的异步方法，如<ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>，和<ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>，帮助你更轻松地实现异步文件操作。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.EndWrite%2A&gt;</ph>.</source>
          <target state="translated">此方法重写 <ph id="ph1">&lt;xref:System.IO.Stream.EndWrite%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> must be called exactly once on every <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> from <ph id="ph3">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> 必须在上一次调用每个<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>从<ph id="ph3">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> will block until the I/O operation has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> 将阻止，直到 I/O 操作已完成。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>This <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object was not created by calling <ph id="ph2">&lt;see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> on this class.</source>
          <target state="translated">此 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> 对象不是通过对该类调用 <ph id="ph2">&lt;see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> 来创建的。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /&gt;</ph> is called multiple times.</source>
          <target state="translated">多次调用了 <ph id="ph1">&lt;see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>The stream is closed or an internal error has occurred.</source>
          <target state="translated">流已关闭或出现了内部错误。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Finalize">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</source>
          <target state="translated">确保垃圾回收器回收 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 时释放资源并执行其他清理操作。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Finalize">
          <source>The garbage collector calls <ph id="ph1">`Finalize`</ph> when the current object is ready to be finalized.</source>
          <target state="translated">垃圾回收器调用<ph id="ph1">`Finalize`</ph>何时准备好完成当前的对象。</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Finalize">
          <source><ph id="ph1">`Finalize`</ph> closes the <ph id="ph2">`FileStream`</ph>.</source>
          <target state="translated"><ph id="ph1">`Finalize`</ph> 关闭<ph id="ph2">`FileStream`</ph>。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="T:System.IO.FileStream">
          <source>Clears buffers for this stream and causes any buffered data to be written to the file.</source>
          <target state="translated">清除此流的缓冲区，使得所有缓冲数据都写入到文件中。</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Flush">
          <source>Clears buffers for this stream and causes any buffered data to be written to the file.</source>
          <target state="translated">清除此流的缓冲区，使得所有缓冲数据都写入到文件中。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">此方法重写 <ph id="ph1">&lt;xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>When you call the <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType&gt;</ph> method, the operating system I/O buffer is also flushed.</source>
          <target state="translated">当调用<ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType&gt;</ph>方法，操作系统 I/O 缓冲区，也会刷新。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>A stream’s encoder is not flushed unless you explicitly call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> or dispose of the object.</source>
          <target state="translated">除非你明确地调用不会刷新流的编码器<ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph>或释放对象。</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>Setting <ph id="ph1">&lt;xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType&gt;</ph> to <ph id="ph2">`true`</ph> means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</source>
          <target state="translated">设置<ph id="ph1">&lt;xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType&gt;</ph>到<ph id="ph2">`true`</ph>意味着数据从缓冲区刷新到流中，但不是会刷新编码器状态。</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</source>
          <target state="translated">这将允许编码器，以便它可以正确编码的字符的下一步块保持其状态 （部分字符）。</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</source>
          <target state="translated">这种情况下会影响 UTF8 和 UTF7 其中某些字符仅后才能进行编码的编码器收到的相邻字符。</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>Because a buffer can be used for either reading or writing, <ph id="ph1">&lt;xref:System.IO.FileStream.Flush&gt;</ph> performs the following two functions:</source>
          <target state="translated">因为缓冲区可以用于读取或写入，<ph id="ph1">&lt;xref:System.IO.FileStream.Flush&gt;</ph>执行以下两个功能：</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>Any data previously written to the buffer is copied to the file and the buffer is cleared except for its encoder state.</source>
          <target state="translated">以前向缓冲区写入任何数据复制到文件和其编码器状态除外清除缓冲区。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>If <ph id="ph1">&lt;xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType&gt;</ph> is <ph id="ph2">`true`</ph> and data was previously copied from the file to the buffer for reading, the current position within the file is decremented by the number of unread bytes in the buffer.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType&gt;</ph>是<ph id="ph2">`true`</ph>和以前将数据从文件复制到缓冲区以进行读取，该文件中的当前位置将减少的缓冲区中的未读字节数。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>The buffer is then cleared.</source>
          <target state="translated">然后清除缓冲区。</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%28System.Boolean%29&gt;</ph> method overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.IO.FileStream.Flush%28System.Boolean%29&gt;</ph>方法重载时你想要确保中间文件缓冲区中的所有缓冲数据写入到磁盘。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph> method.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Flush">
          <source>An I/O error occurred.</source>
          <target state="translated">出现 I/O 错误。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Flush">
          <source>The stream is closed.</source>
          <target state="translated">流已关闭。</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Flush(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to flush all intermediate file buffers; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果刷新所有中间文件缓冲区，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Flush(System.Boolean)">
          <source>Clears buffers for this stream and causes any buffered data to be written to the file, and also clears all intermediate file buffers.</source>
          <target state="translated">清除此流的缓冲区，将所有缓冲数据都写入到文件中，并且也清除所有中间文件缓冲区。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush(System.Boolean)">
          <source>Use this overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.</source>
          <target state="translated">使用此重载时你想要确保中间文件缓冲区中的所有缓冲数据写入到磁盘。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush(System.Boolean)">
          <source>When you call the <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> method, the operating system I/O buffer is also flushed.</source>
          <target state="translated">当调用<ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph>方法，操作系统 I/O 缓冲区，也会刷新。</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">要监视取消请求的标记。</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</source>
          <target state="translated">异步清理这个流的所有缓冲区，并使所有缓冲数据写入基础设备，并且监控取消请求。</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous flush operation.</source>
          <target state="translated">表示异步刷新操作的任务。</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>When you call the <ph id="ph1">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph> method, the operating system I/O buffer is also flushed.</source>
          <target state="translated">当调用<ph id="ph1">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>方法，操作系统 I/O 缓冲区，也会刷新。</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">如果在完成之前，将取消该操作，返回的任务包含<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>值<ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>If the handle to the file is disposed, the returned task contains the <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> exception in the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
          <target state="translated">如果文件句柄将被释放，则返回的任务包含<ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph>中的异常<ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">已释放流。</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> object that encapsulates the access control list (ACL) entries for the file described by the current <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object.</source>
          <target state="translated">获取 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> 对象，该对象封装当前 <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 对象所描述的文件的访问控制列表 (ACL) 项。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>An object that encapsulates the access control settings for the file described by the current <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object.</source>
          <target state="translated">一个对象，该对象封装当前 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 对象所描述的文件的访问控制设置。</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.GetAccessControl">
          <source>While the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class and <ph id="ph2">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> can be used to retrieve the access control list (ACL) entries of an existing file, consider using <ph id="ph3">&lt;xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> method, as it is easier to use.</source>
          <target state="translated">虽然<ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>类和<ph id="ph2">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph>可以用于检索现有文件的访问控制列表 (ACL) 项，请考虑使用<ph id="ph3">&lt;xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph>方法，因为它是使用起来更为简便。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.GetAccessControl">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> method to retrieve the ACL entries for a file.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph>方法来检索文件的 ACL 项。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.GetAccessControl">
          <source>An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file.</source>
          <target state="translated">ACL 描述个人和/或组具有或没有执行到给定的文件上的特定操作的权限。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.GetAccessControl">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Add or Remove Access Control List Entries<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>如何：添加或移除访问控制列表项<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>The file is closed.</source>
          <target state="translated">文件关闭。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>An I/O error occurred while opening the file.</source>
          <target state="translated">打开文件时发生 I/O 错误。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>The file could not be found.</source>
          <target state="translated">找不到文件。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>This operation is not supported on the current platform.</source>
          <target state="translated">当前平台不支持此操作。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Handle">
          <source>Gets the operating system file handle for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object encapsulates.</source>
          <target state="translated">获取当前 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象所封装文件的操作系统文件句柄。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>The operating system file handle for the file encapsulated by this <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object, or -1 if the <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> has been closed.</source>
          <target state="translated">此 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 对象所封装文件的操作系统文件句柄；如果 <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> 已关闭，则为 -1。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>This property is an operating system handle for use with operating-system-provided system calls (such as <ph id="ph1">`ReadFile`</ph> on Windows).</source>
          <target state="translated">此属性是与操作系统的系统提供的系统调用一起使用的操作系统句柄 (如<ph id="ph1">`ReadFile`</ph>Windows 上)。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>It will not work with C library functions that expect a file descriptor, such as <ph id="ph1">`fread`</ph>.</source>
          <target state="translated">它不会使用 C 库函数，如预期的文件描述符， <ph id="ph1">`fread`</ph>。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>The operating system handle might have been opened synchronously or asynchronously, depending on which <ph id="ph1">`FileStream`</ph> constructor was called.</source>
          <target state="translated">操作系统句柄可能打开过同步或异步，具体取决于<ph id="ph1">`FileStream`</ph>已调用构造函数。</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property to discover whether this handle was opened asynchronously.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph>属性来发现是否以异步方式打开此句柄。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>In Win32, this means the handle was opened for overlapped IO, and it requires different parameters to <ph id="ph1">`ReadFile`</ph> and <ph id="ph2">`WriteFile`</ph>.</source>
          <target state="translated">在 Win32 中，这意味着句柄已打开为重叠的 IO，并且它要求在不同的参数到<ph id="ph1">`ReadFile`</ph>和<ph id="ph2">`WriteFile`</ph>。</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>Data corruption might occur if a <ph id="ph1">`FileStream`</ph> is created, its handle is passed, some operation moves the handle's file pointer, and then the <ph id="ph2">`FileStream`</ph> is used again.</source>
          <target state="translated">如果可能发生数据损坏<ph id="ph1">`FileStream`</ph>是创建，其句柄传递、 某些操作移动句柄的文件指针，然后<ph id="ph2">`FileStream`</ph>会再次使用。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>Multiple threads cannot safely write to the same file simultaneously, and <ph id="ph1">`FileStream`</ph> buffering code assumes that it exclusively controls the handle.</source>
          <target state="translated">多个线程不能同时安全地写入到相同文件，和<ph id="ph1">`FileStream`</ph>缓冲代码假定它以独占方式控制该句柄。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source><ph id="ph1">`FileStream`</ph> might throw an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> if <ph id="ph3">`FileStream`</ph> detects that some other process has moved the file pointer.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> 可能引发<ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph>如果<ph id="ph3">`FileStream`</ph>检测到某些其他进程已移动的文件指针。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>To avoid this, do not write any data into a portion of the file that <ph id="ph1">`FileStream`</ph> might have buffered, and restore the file pointer to the location it had when methods were last called on <ph id="ph2">`FileStream`</ph>.</source>
          <target state="translated">若要避免此问题，不写入任何数据到文件的一部分，<ph id="ph1">`FileStream`</ph>可能具有缓冲，并将文件指针还原到在上一次调用方法时的位置<ph id="ph2">`FileStream`</ph>。</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Handle">
          <source>The caller does not have the required permission.</source>
          <target state="translated">调用方没有所要求的权限。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>for the ability to access unmanaged code.</source>
          <target state="translated">若要访问非托管的代码的功能。</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph> Security action: <ph id="ph2">&lt;see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /&gt;</ph>.</source>
          <target state="translated">关联的枚举：<ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>安全操作： <ph id="ph2">&lt;see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.IsAsync">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> was opened asynchronously or synchronously.</source>
          <target state="translated">获取一个值，该值指示 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 是异步还是同步打开的。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> was opened asynchronously; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> 是异步打开的，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>The <ph id="ph1">`IsAsync`</ph> property detects whether the <ph id="ph2">`FileStream`</ph> handle was opened asynchronously, enabling your code to use the <ph id="ph3">&lt;xref:System.IO.FileStream.Handle%2A&gt;</ph> property correctly.</source>
          <target state="translated"><ph id="ph1">`IsAsync`</ph>属性检测是否<ph id="ph2">`FileStream`</ph>句柄已异步打开的使代码能够使用<ph id="ph3">&lt;xref:System.IO.FileStream.Handle%2A&gt;</ph>属性正确。</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>In Win32, <ph id="ph1">`IsAsync`</ph> being true means the handle was opened for overlapped I/O, and thus requires different parameters to <ph id="ph2">`ReadFile`</ph> and <ph id="ph3">`WriteFile`</ph>.</source>
          <target state="translated">在 Win32 中，<ph id="ph1">`IsAsync`</ph>正在 true 表示句柄为重叠 I/O 打开并因而需要不同的参数到<ph id="ph2">`ReadFile`</ph>和<ph id="ph3">`WriteFile`</ph>。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>You specify this value when you create an instance of the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class using a constructor that has an <ph id="ph2">`isAsync`</ph>, <ph id="ph3">`useAsync`</ph>, or <ph id="ph4">`options`</ph> parameter.</source>
          <target state="translated">在创建的实例时指定此值<ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>类使用的构造函数<ph id="ph2">`isAsync`</ph>， <ph id="ph3">`useAsync`</ph>，或<ph id="ph4">`options`</ph>参数。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>When the property is <ph id="ph1">`true`</ph>, the stream utilizes overlapped I/O to perform file operations asynchronously.</source>
          <target state="translated">当该属性是<ph id="ph1">`true`</ph>，流利用重叠的 I/O，异步执行文件操作。</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>However, the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property does not have to be <ph id="ph2">`true`</ph> to call the <ph id="ph3">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> method.</source>
          <target state="translated">但是，<ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph>属性不具有要<ph id="ph2">`true`</ph>调用<ph id="ph3">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>，或<ph id="ph5">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>When the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property is <ph id="ph2">`false`</ph> and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph>属性是<ph id="ph2">`false`</ph>和调用异步读取和写入操作，仍未被阻止 UI 线程、，但同步执行实际的 I/O 操作。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Length">
          <source>Gets the length in bytes of the stream.</source>
          <target state="translated">获取用字节表示的流长度。</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Length">
          <source>A long value representing the length of the stream in bytes.</source>
          <target state="translated">表示流长度（以字节为单位）的长值。</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Length">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Length">
          <source>The following example uses the <ph id="ph1">`Length`</ph> and <ph id="ph2">`Position`</ph> properties to check for an end-of-file condition.</source>
          <target state="translated">下面的示例使用<ph id="ph1">`Length`</ph>和<ph id="ph2">`Position`</ph>属性，以检查文件尾条件。</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Length">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> for this stream is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">该流的 <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Length">
          <source>An I/O error, such as the file being closed, occurred.</source>
          <target state="translated">出现 I/O 错误，例如文件被关闭。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The beginning of the range to lock.</source>
          <target state="translated">要锁定的范围的起始处。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The value of this parameter must be equal to or greater than zero (0).</source>
          <target state="translated">此参数的值必须大于或等于零 (0)。</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The range to be locked.</source>
          <target state="translated">要锁定的范围。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>Prevents other processes from reading from or writing to the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph>.</source>
          <target state="translated">防止其他进程读取或写入 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>Locking a range of a file stream gives the threads of the locking process exclusive access to that range of the file stream.</source>
          <target state="translated">文件流的范围锁定赋予该区域的文件流的锁定的进程独占访问的线程。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file.</source>
          <target state="translated">下面的代码示例演示如何锁定文件的一部分，因此另一个进程不能访问该文件的一部分，即使它有访问该文件的读/写访问。</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>Run the program simultaneously in different command windows and investigate using the different console input options.</source>
          <target state="translated">同时在不同的命令窗口中运行程序，并调查使用不同的控制台输入的选项。</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 为负数。</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The file is closed.</source>
          <target state="translated">文件关闭。</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The process cannot access the file because another process has locked a portion of the file.</source>
          <target state="translated">另一个进程已锁定了文件的一部分，因此进程无法访问该文件。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Name">
          <source>Gets the name of the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> that was passed to the constructor.</source>
          <target state="translated">获取传递给构造函数的 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 的名称。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Name">
          <source>A string that is the name of the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</source>
          <target state="translated">一个字符串，它是 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 的名称。</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Name">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Name">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Name">
          <source>for access to the path.</source>
          <target state="translated">用于访问路径。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Name">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>Gets or sets the current position of this stream.</source>
          <target state="translated">获取或设置此流的当前位置。</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>The current position of this stream.</source>
          <target state="translated">此流的当前位置。</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>Seeking to any location beyond the length of the stream is supported.</source>
          <target state="translated">支持查找到流的长度超出任何位置。</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>When you seek beyond the length of the file, the file size grows.</source>
          <target state="translated">当您寻求超出长度的文件时，文件大小就会增加。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>In Microsoft Windows NT and newer, any data added to the end of the file is set to zero.</source>
          <target state="translated">在 Microsoft Windows NT 和更高，则将添加到文件末尾的任何数据设置为零。</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>In Microsoft Windows 98 or earlier, any data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream.</source>
          <target state="translated">在 Microsoft Windows 98 或更早版本，添加到文件末尾的任何数据未设置为零，这意味着，先前删除的数据是可见写入流。</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>Setting the position of the stream to a large value beyond the end of the stream in Windows 98 or earlier may result in an exception being raised.</source>
          <target state="translated">将流的当前位置设置为较大的值超出在 Windows 98 或更早版本的流的末尾，则可能会导致正在引发的异常。</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>The following example uses the <ph id="ph1">`Length`</ph> and <ph id="ph2">`Position`</ph> properties to check for an end-of-file condition.</source>
          <target state="translated">下面的示例使用<ph id="ph1">`Length`</ph>和<ph id="ph2">`Position`</ph>属性，以检查文件尾条件。</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>The stream does not support seeking.</source>
          <target state="translated">流不支持查找。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>An I/O error occurred.</source>
          <target state="translated">出现 I/O 错误。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> 或 -</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>The position was set to a very large value beyond the end of the stream in Windows 98 or earlier.</source>
          <target state="translated">将位置设置为非常大的值，此值超出 Windows 98 或更早版本中的流的末尾。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>Attempted to set the position to a negative value.</source>
          <target state="translated">试图将位置设置为负值。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>Attempted seeking past the end of a stream that does not support this.</source>
          <target state="translated">试图越过不支持此值的流的末尾进行查找。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>When this method returns, contains the specified byte array with the values between <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept> and (<bpt id="p2">&lt;c&gt;</bpt>offset<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1<bpt id="p4">&lt;c&gt;</bpt>)<ept id="p4">&lt;/c&gt;</ept> replaced by the bytes read from the current source.</source>
          <target state="translated">此方法返回时，包含指定的字节数组，该数组的 <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept> 和 (<bpt id="p2">&lt;c&gt;</bpt>offset<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1<bpt id="p4">&lt;c&gt;</bpt>)<ept id="p4">&lt;/c&gt;</ept> 之间的值由从当前源中读取的字节替换。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The byte offset in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which the read bytes will be placed.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> 中的字节偏移量，将在此处放置读取的字节。</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">最多读取的字节数。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Reads a block of bytes from the stream and writes the data in a given buffer.</source>
          <target state="translated">从流中读取字节块并将该数据写入给定缓冲区中。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The total number of bytes read into the buffer.</source>
          <target state="translated">读入缓冲区中的总字节数。</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This might be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached.</source>
          <target state="translated">如果字节数当前不可用，则总字节数可能小于所请求的字节数；如果已到达流结尾，则为零。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Read%2A&gt;</ph>.</source>
          <target state="translated">此方法重写 <ph id="ph1">&lt;xref:System.IO.Stream.Read%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`offset`</ph> parameter gives the offset of the byte in <ph id="ph2">`array`</ph> (the buffer index) at which to begin reading, and the <ph id="ph3">`count`</ph> parameter gives the maximum number of bytes to be read from this stream.</source>
          <target state="translated"><ph id="ph1">`offset`</ph>参数指定了中的字节的偏移量<ph id="ph2">`array`</ph>（缓冲区索引） 在此处开始读取，和<ph id="ph3">`count`</ph>参数指定了最大要从此流中读取的字节数。</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</source>
          <target state="translated">如果已到达流结尾，则返回的值是实际数字节，则为零。</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If the read operation is successful, the current position of the stream is advanced by the number of bytes read.</source>
          <target state="translated">如果读取的操作成功，是通过读取的字节数高级流的当前位置。</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If an exception occurs, the current position of the stream is unchanged.</source>
          <target state="translated">如果发生异常，则流的当前位置不变。</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> method returns zero only after reaching the end of the stream.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>方法返回仅在到达流的末尾后的零。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Otherwise, <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> always reads at least one byte from the stream before returning.</source>
          <target state="translated">否则为<ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>始终至少 1 个字节从流中读取在返回之前。</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If no data is available from the stream upon a call to <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, the method will block until at least one byte of data can be returned.</source>
          <target state="translated">如果不会提供数据时调用流中<ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>，该方法将一直阻止到至少一个字节的数据可以返回。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</source>
          <target state="translated">实现可以自由地返回少于所请求的字节，即使尚未达到流结尾。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> for reading primitive data types.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph>读取基元数据类型。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Do not interrupt a thread that is performing a read operation.</source>
          <target state="translated">不会中断正在执行读取的操作的线程。</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability.</source>
          <target state="translated">尽管应用程序可能看起来后取消阻止该线程尚未成功运行，但中断会降低应用程序的性能和可靠性。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The following example reads the contents from a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> and writes it into another <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>.</source>
          <target state="translated">下面的示例读取从内容<ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>并将其写入到另一个<ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 为负数。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The stream does not support reading.</source>
          <target state="translated">流不支持读取。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>An I/O error occurred.</source>
          <target state="translated">出现 I/O 错误。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> describe an invalid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 描述 <ph id="ph3">&lt;paramref name="array" /&gt;</ph> 中的无效范围。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Methods were called after the stream was closed.</source>
          <target state="translated">在流关闭后调用方法。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write the data into.</source>
          <target state="translated">数据写入的缓冲区。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin writing data from the stream.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> 中的字节偏移量，从该偏移量开始写入流中的数据。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">最多读取的字节数。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">要监视取消请求的标记。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</source>
          <target state="translated">从当前流异步读取字节的序列，将流中的位置提升读取的字节数，并监视取消请求。</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous read operation.</source>
          <target state="translated">表示异步读取操作的任务。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The value of the <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> parameter contains the total number of bytes read into the buffer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> 参数的值包含读入缓冲区的总字节数。</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</source>
          <target state="translated">如果当前可用字节数少于所请求的字节数，则该结果值可小于所请求的字节数；如果已到达流结尾时，则为 0（零）。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph> method enables you to perform resource-intensive file operations without blocking the main thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>方法使您能够在不阻塞主线程的情况下执行占用大量资源的文件操作。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>This performance consideration is particularly important in a <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> app or <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</source>
          <target state="translated">在 <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> 应用或 <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The async methods are used in conjunction with the <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> keywords in Visual Basic and C#.</source>
          <target state="translated">结合使用异步方法<ph id="ph1">`async`</ph>和<ph id="ph2">`await`</ph>Visual Basic 和 C# 中的关键字。</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph>属性来确定当前实例是否支持读取。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">如果在完成之前，将取消该操作，返回的任务包含<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>值<ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the handle to the file is disposed, the returned task contains the <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> exception in the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
          <target state="translated">如果文件句柄将被释放，则返回的任务包含<ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph>中的异常<ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The following example shows how to read from a file asynchronously.</source>
          <target state="translated">下面的示例演示如何以异步方式从文件读取。</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 为负数。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 的总和大于缓冲区长度。</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream does not support reading.</source>
          <target state="translated">流不支持读取。</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">已释放流。</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream is currently in use by a previous read operation.</source>
          <target state="translated">之前的读取操作当前正在使用流。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadByte">
          <source>Reads a byte from the file and advances the read position one byte.</source>
          <target state="translated">从文件中读取一个字节，并将读取位置提升一个字节。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadByte">
          <source>The byte, cast to an <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>, or -1 if the end of the stream has been reached.</source>
          <target state="translated">强制转换为 <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> 的字节；或者如果已到达流的末尾，则为 -1。</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.ReadByte%2A&gt;</ph>.</source>
          <target state="translated">此方法重写 <ph id="ph1">&lt;xref:System.IO.Stream.ReadByte%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph>属性来确定当前实例是否支持读取。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanRead%2A&gt;</ph>.</source>
          <target state="translated">有关附加信息，请参见 <ph id="ph1">&lt;xref:System.IO.Stream.CanRead%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</source>
          <target state="translated">下面的代码示例演示如何将数据写入到文件，逐字节，然后验证数据是否被正确写入。</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadByte">
          <source>The current stream does not support reading.</source>
          <target state="translated">当前流不支持读取。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadByte">
          <source>The current stream is closed.</source>
          <target state="translated">当前流已关闭。</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>The default implementation on <ph id="ph1">&lt;see langword="Stream" /&gt;</ph> creates a new single-byte array and then calls <ph id="ph2">&lt;see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /&gt;</ph>.</source>
          <target state="translated">上的默认实现<ph id="ph1">&lt;see langword="Stream" /&gt;</ph>创建一个新的单字节数组，然后调用<ph id="ph2">&lt;see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>While this is formally correct, it is inefficient.</source>
          <target state="translated">虽然这是正式正确的效率低。</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</source>
          <target state="translated">所有具有内部缓冲区的流应重写此方法，并提供一个要高效得多的读取缓冲区直接，避免额外的数组分配每次调用的版本。</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>Gets a <ph id="ph1">&lt;see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /&gt;</ph> object that represents the operating system file handle for the file that the current <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object encapsulates.</source>
          <target state="translated">获取 <ph id="ph1">&lt;see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /&gt;</ph> 对象，它代表当前 <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 对象所封装的文件的操作系统文件句柄。</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>An object that represents the operating system file handle for the file that the current <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object encapsulates.</source>
          <target state="translated">一个对象，该对象表示当前 <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 对象封装的文件的操作系统文件句柄。</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> property automatically flushes the stream and sets the current stream position to 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph>属性自动刷新流，并将当前流位置设置为 0。</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>This allows the file to be moved or the stream position to be reset by another stream using the <ph id="ph1">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> returned by this property.</source>
          <target state="translated">这允许要移动文件或流的位置来重置另一个流使用<ph id="ph1">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph>此属性返回。</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">表示调用非托管的代码的权限。</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>Security action: Link Demand</source>
          <target state="translated">安全操作： 链接要求</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">关联的枚举： <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The point relative to <bpt id="p1">&lt;c&gt;</bpt>origin<ept id="p1">&lt;/c&gt;</ept> from which to begin seeking.</source>
          <target state="translated">相对于 <bpt id="p1">&lt;c&gt;</bpt>origin<ept id="p1">&lt;/c&gt;</ept> 的点，从此处开始查找。</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Specifies the beginning, the end, or the current position as a reference point for <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept>, using a value of type <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>.</source>
          <target state="translated">使用 <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph> 类型的值，将开始位置、结束位置或当前位置指定为 <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept> 的参考点。</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Sets the current position of this stream to the given value.</source>
          <target state="translated">将该流的当前位置设置为给定值。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The new position in the stream.</source>
          <target state="translated">流中的新位置。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">此方法重写 <ph id="ph1">&lt;xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType&gt;</ph> property to determine whether the current instance supports seeking.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType&gt;</ph>属性来确定当前实例是否支持查找。</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">有关附加信息，请参见 <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>You can seek to any location beyond the length of the stream.</source>
          <target state="translated">您可以搜索到流的长度超出任何位置。</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>When you seek beyond the length of the file, the file size grows.</source>
          <target state="translated">当您寻求超出长度的文件时，文件大小就会增加。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>In Windows NT and later versions, data added to the end of the file is set to zero.</source>
          <target state="translated">在 Windows NT 和更高版本中，添加到文件末尾的数据设置为零。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>In Windows 98 or earlier versions, data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream.</source>
          <target state="translated">在 Windows 98 或更早版本中，添加到文件末尾的数据未设置为零，这意味着，先前删除的数据是可见写入流。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</source>
          <target state="translated">下面的示例演示如何将数据写入到文件，逐字节，然后验证数据是否被正确写入。</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <ph id="ph1">&lt;xref:System.IO.SeekOrigin&gt;</ph> values with the <ph id="ph2">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例读取中文相反的方向，从文件末尾到开头的文件，使用各种<ph id="ph1">&lt;xref:System.IO.SeekOrigin&gt;</ph>值与<ph id="ph2">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>An I/O error occurred.</source>
          <target state="translated">出现 I/O 错误。</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The stream does not support seeking, such as if the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> is constructed from a pipe or console output.</source>
          <target state="translated">流不支持查找，例如，如果 <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> 是由管道或控制台输出构造的。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Seeking is attempted before the beginning of the stream.</source>
          <target state="translated">试图在流的开始位置之前进行查找。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Methods were called after the stream was closed.</source>
          <target state="translated">在流关闭后调用方法。</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>An object that describes an ACL entry to apply to the current file.</source>
          <target state="translated">描述要应用于当前文件的 ACL 项的对象。</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>Applies access control list (ACL) entries described by a <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> object to the file described by the current <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object.</source>
          <target state="translated">将 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> 对象所描述的访问控制列表 (ACL) 项应用于当前 <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> 对象所描述的文件。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>While the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class and <ph id="ph2">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> can be used on an existing file, consider using the <ph id="ph3">&lt;xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph> method as it is easier to use.</source>
          <target state="translated">虽然<ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph>类和<ph id="ph2">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph>可对现有文件，请考虑使用<ph id="ph3">&lt;xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph>作为它的方法是使用起来更为简便。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> method applies access control list (ACL) entries to a file that represents the noninherited ACL list.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph>方法适用于表示非继承的 ACL 列表的文件的访问控制列表 (ACL) 项。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The ACL specified for the <ph id="ph1">`fileSecurity`</ph> parameter replaces the existing ACL for the file.</source>
          <target state="translated">为 ACL 指定<ph id="ph1">`fileSecurity`</ph>参数替换现有文件 ACL。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>To add permissions for a new user, use the <ph id="ph1">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> method to obtain the existing ACL, modify it, and then use <ph id="ph2">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> to apply it back to the file.</source>
          <target state="translated">若要添加的新用户的权限，请使用<ph id="ph1">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph>方法来获取现有的 ACL，对其进行修改，然后使用<ph id="ph2">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph>以将其应用回的文件。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file.</source>
          <target state="translated">ACL 描述个人和/或组具有或没有执行到给定的文件上的特定操作的权限。</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Add or Remove Access Control List Entries<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>如何：添加或移除访问控制列表项<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The file is closed.</source>
          <target state="translated">文件关闭。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The <ph id="ph1">&lt;paramref name="fileSecurity" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fileSecurity" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The file could not be found or modified.</source>
          <target state="translated">未能找到或修改该文件。</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The current process does not have access to open the file.</source>
          <target state="translated">当前进程不具有打开该文件的权限。</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>The new length of the stream.</source>
          <target state="translated">流的新长度。</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>Sets the length of this stream to the given value.</source>
          <target state="translated">将该流的长度设置为给定值。</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>.</source>
          <target state="translated">此方法重写 <ph id="ph1">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>If the given value is less than the current length of the stream, the stream is truncated.</source>
          <target state="translated">如果给定的值小于当前流的长度，则流将被截断。</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>In this scenario, if the current position is greater than the new length, the current position is moved to the last byte of the stream.</source>
          <target state="translated">在此方案中，如果当前的位置大于的新长度当前位置移至最后一字节的流。</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>If the given value is larger than the current length of the stream, the stream is expanded, and the current position remains the same.</source>
          <target state="translated">如果给定的值大于当前流的长度，则流扩展，并当前位置保持不变。</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>If the stream is expanded, the contents of the stream between the old and the new length are undefined.</source>
          <target state="translated">如果流已展开，旧和新的长度之间流的内容是不确定的。</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>A stream must support both writing and seeking for <ph id="ph1">`SetLength`</ph> to work.</source>
          <target state="translated">流必须支持写入和查找有关<ph id="ph1">`SetLength`</ph>工作。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports writing, and the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property to determine whether seeking is supported.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph>属性来确定当前实例是否支持写入，和<ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph>属性来确定是否支持查找。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">有关更多信息，请参阅 <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph> 和 <ph id="ph2">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>An I/O error has occurred.</source>
          <target state="translated">发生了 I/O 错误。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>The stream does not support both writing and seeking.</source>
          <target state="translated">该流不支持写入和查找。</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>Attempted to set the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter to less than 0.</source>
          <target state="translated">试图将 <ph id="ph1">&lt;paramref name="value" /&gt;</ph> 参数设置为小于 0。</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>The beginning of the range to unlock.</source>
          <target state="translated">要取消锁定的范围的开始处。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>The range to be unlocked.</source>
          <target state="translated">要取消锁定的范围。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>Allows access by other processes to all or part of a file that was previously locked.</source>
          <target state="translated">允许其他进程访问以前锁定的某个文件的全部或部分。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file .</source>
          <target state="translated">下面的代码示例演示如何锁定文件的一部分，因此另一个进程不能访问该文件的一部分，即使它有访问该文件的读/写访问，然后解锁该文件的指定的部分。</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>Run the program simultaneously in different command windows and investigate using the different console input options.</source>
          <target state="translated">同时在不同的命令窗口中运行程序，并调查使用不同的控制台输入的选项。</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 为负数。</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The buffer containing data to write to the stream.</source>
          <target state="translated">包含要写入该流的数据的缓冲区。</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> from which to begin copying bytes to the stream.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> 中的从零开始的字节偏移量，从此处开始将字节复制到流。</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">最多写入的字节数。</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Writes a block of bytes to the file stream.</source>
          <target state="translated">将字节块写入文件流。</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>.</source>
          <target state="translated">此方法重写 <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`offset`</ph> parameter gives the offset of the byte in <ph id="ph2">`array`</ph> (the buffer index) at which to begin copying, and the <ph id="ph3">`count`</ph> parameter gives the number of bytes that will be written to the stream.</source>
          <target state="translated"><ph id="ph1">`offset`</ph>参数指定了中的字节的偏移量<ph id="ph2">`array`</ph>（缓冲区索引） 从此处开始复制，和<ph id="ph3">`count`</ph>参数指定了将写入到流的字节数。</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>If the write operation is successful, the current position of the stream is advanced by the number of bytes written.</source>
          <target state="translated">如果写入操作成功，流的当前位置被高级通过写入的字节数。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>If an exception occurs, the current position of the stream is unchanged.</source>
          <target state="translated">如果发生异常，则流的当前位置不变。</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports writing.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph>属性来确定当前实例是否支持写入。</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</source>
          <target state="translated">有关附加信息，请参见 <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Do not interrupt a thread that is performing a write operation.</source>
          <target state="translated">不会中断正在执行的写入操作的线程。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability.</source>
          <target state="translated">尽管应用程序可能看起来后取消阻止该线程尚未成功运行，但中断会降低应用程序的性能和可靠性。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph> method.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> describe an invalid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 描述 <ph id="ph3">&lt;paramref name="array" /&gt;</ph> 中的无效范围。</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 为负数。</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>An I/O error occurred.</source>
          <target state="translated">出现 I/O 错误。</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> 或 -</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Another thread may have caused an unexpected change in the position of the operating system's file handle.</source>
          <target state="translated">另一个线程可能导致操作系统的文件句柄的位置发生意外更改。</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The stream is closed.</source>
          <target state="translated">流已关闭。</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The current stream instance does not support writing.</source>
          <target state="translated">当前的流实例不支持写入。</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write data from.</source>
          <target state="translated">从中写入数据的缓冲区。</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> from which to begin copying bytes to the stream.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> 中的从零开始的字节偏移量，从此处开始将字节复制到该流。</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">最多写入的字节数。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">要监视取消请求的标记。</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</source>
          <target state="translated">将字节的序列异步写入当前流，将该流中的当前位置提升写入的字节数，并监视取消请求。</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous write operation.</source>
          <target state="translated">表示异步写入操作的任务。</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph> method enables you to perform resource-intensive file operations without blocking the main thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>方法使您能够在不阻塞主线程的情况下执行占用大量资源的文件操作。</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>This performance consideration is particularly important in a <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> app or <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</source>
          <target state="translated">在 <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> 应用或 <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The async methods are used in conjunction with the <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> keywords in Visual Basic and C#.</source>
          <target state="translated">结合使用异步方法<ph id="ph1">`async`</ph>和<ph id="ph2">`await`</ph>Visual Basic 和 C# 中的关键字。</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph>属性来确定当前实例是否支持读取。</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">如果在完成之前，将取消该操作，返回的任务包含<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>值<ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the handle to the file is disposed, the returned task contains the <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> exception in the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
          <target state="translated">如果文件句柄将被释放，则返回的任务包含<ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph>中的异常<ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The following example shows how to write asynchronously to a file.</source>
          <target state="translated">下面的示例演示如何以异步方式写入到的文件。</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 为负数。</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="count" /&gt;</ph> 的总和大于缓冲区长度。</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream does not support writing.</source>
          <target state="translated">流不支持写入。</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">已释放流。</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream is currently in use by a previous write operation.</source>
          <target state="translated">流正在由前一次写操作使用。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>A byte to write to the stream.</source>
          <target state="translated">要写入流的字节。</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>Writes a byte to the current position in the file stream.</source>
          <target state="translated">一个字节写入文件流中的当前位置。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph>.</source>
          <target state="translated">此方法重写 <ph id="ph1">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>Use <ph id="ph1">`WriteByte`</ph> to write a byte to a <ph id="ph2">`FileStream`</ph> efficiently.</source>
          <target state="translated">使用<ph id="ph1">`WriteByte`</ph>写入到一个字节<ph id="ph2">`FileStream`</ph>有效。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>If the stream is closed or not writable, an exception will be thrown.</source>
          <target state="translated">如果流已关闭，或者不可写，则将引发异常。</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports writing.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph>属性来确定当前实例是否支持写入。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</source>
          <target state="translated">有关附加信息，请参见 <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</source>
          <target state="translated">下面的代码示例演示如何将数据写入到文件，逐字节，然后验证数据是否被正确写入。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>The stream is closed.</source>
          <target state="translated">流已关闭。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>The stream does not support writing.</source>
          <target state="translated">流不支持写入。</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>The default implementation on <ph id="ph1">&lt;see langword="Stream" /&gt;</ph> creates a new single-byte array and then calls <ph id="ph2">&lt;see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /&gt;</ph>.</source>
          <target state="translated">上的默认实现<ph id="ph1">&lt;see langword="Stream" /&gt;</ph>创建一个新的单字节数组，然后调用<ph id="ph2">&lt;see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>While this is formally correct, it is inefficient.</source>
          <target state="translated">虽然这是正式正确的效率低。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</source>
          <target state="translated">所有具有内部缓冲区的流应重写此方法，并提供一个要高效得多的读取缓冲区直接，避免额外的数组分配每次调用的版本。</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">通用文件和目录操作的列表，请参阅<bpt id="p1">[</bpt>通用 I/O 任务<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>