<Type Name="FileInfo" FullName="System.IO.FileInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1f0d011c9c577137483d916f25bad41c64c765c5" />
    <Meta Name="ms.sourcegitcommit" Value="29c771f79cf4eac4f49e5fae5f1aa8b457acf146" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/21/2018" />
    <Meta Name="ms.locfileid" Value="36298880" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit FileInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FileInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileInfo sealed : System::IO::FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供用于创建、复制、删除、移动和打开文件的属性和实例方法，并且帮助创建 <see cref="T:System.IO.FileStream" /> 对象。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileInfo>类用于典型操作，如复制、 移动、 重命名、 创建、 打开、 删除和追加到文件。  
  
 如果您正在执行同一个文件上的多个操作，它可以是使用更加高效<xref:System.IO.FileInfo>实例而不是静态方法的相应方法<xref:System.IO.File>类，因为安全检查不会总是有必要。  
  
 许多<xref:System.IO.FileInfo>方法返回其他 I/O 类型，创建或打开文件时。 你可以使用这些其他类型来进一步处理文件。 有关详细信息，请参阅特定<xref:System.IO.FileInfo>成员，如<xref:System.IO.FileInfo.Open%2A>， <xref:System.IO.FileInfo.OpenRead%2A>， <xref:System.IO.FileInfo.OpenText%2A>， <xref:System.IO.FileInfo.CreateText%2A>，或<xref:System.IO.FileInfo.Create%2A>。  
  
 默认情况下，对新文件的完全读/写访问权限授予所有用户。  
  
 下表描述了用于自定义的各种行为的枚举<xref:System.IO.FileInfo>方法。  
  
|枚举|描述|  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|指定读取和写入到文件的访问。|  
|<xref:System.IO.FileShare>|指定允许已在使用的文件的访问级别。|  
|<xref:System.IO.FileMode>|指定现有文件的内容是保留还是覆盖，以及请求创建现有文件是否会导致异常。|  
  
> [!NOTE]
>  在接受将路径作为输入字符串的成员，该路径必须是格式正确，或引发异常。 例如，如果路径是完全限定的但以空格开始，在类的方法不修整路径。 因此，该路径格式不正确并且引发异常。 同样，路径或组合的路径不能完全限定两次。 例如，"c:\temp c:\windows"也会引发异常在大多数情况下。 确保使用接受将路径字符串的方法时，你的路径格式正确。  
  
 在接受路径的成员，路径可以引用一个文件或仅是目录。 指定的路径也可以指相对路径或服务器和共享名称的通用命名约定 (UNC) 路径。 例如，以下所有条件都可接受的路径：  
  
-   "c:\\\MyDir\\\MyFile.txt"在 C# 或 Visual Basic 中的"c:\MyDir\MyFile.txt"。  
  
-   "c:\\\MyDir"在 C# 或 Visual Basic 中的"c:\MyDir"。  
  
-   "MyDir\\\MySubdir"在 C# 或 Visual Basic 中的"MyDir\MySubDir"。  
  
-   "\\\\\\\MyServer\\\MyShare"在 C# 中，或"\\\MyServer\MyShare"在 Visual Basic 中。  
  
 <xref:System.IO.FileInfo>类提供的以下属性，使你能够检索有关文件的信息。 有关如何使用每个属性的示例，请参阅属性页。  
  
-   <xref:System.IO.FileInfo.Directory%2A>属性检索一个对象，表示文件的父目录。  
  
-   <xref:System.IO.FileInfo.DirectoryName%2A>属性检索文件的父目录的完整路径。  
  
-   <xref:System.IO.FileInfo.Exists%2A>属性在其上操作之前检查文件是否存在。  
  
-   <xref:System.IO.FileInfo.IsReadOnly%2A>属性检索或设置一个值，指定是否可以修改一个文件。  
  
-   <xref:System.IO.FileInfo.Length%2A>检索文件的大小。  
  
-   <xref:System.IO.FileInfo.Name%2A>检索文件的名称。  
  
   
  
## Examples  
 下面的示例演示的一些主要成员`FileInfo`类。  
  
 当第一次检索属性时，<xref:System.IO.FileInfo>调用<xref:System.IO.FileSystemInfo.Refresh%2A>文件的方法和缓存信息。 在后续调用中，必须调用<xref:System.IO.FileSystemInfo.Refresh%2A>以获取信息的最新副本。  
  
 [!code-cpp[FInfo Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Class/CPP/finfo class.cpp#1)]
 [!code-csharp[FInfo Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Class/CS/finfo class.cs#1)]
 [!code-vb[FInfo Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Class/VB/finfo class.vb#1)]  
  
 此示例生成类似于下面的输出。  
  
```  
Hello  
And  
Welcome  
C:\Users\userName\AppData\Local\Temp\tmp70AB.tmp was copied to C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp.  
C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp was successfully deleted.  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.DriveInfo" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileInfo (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileInfo(System::String ^ fileName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">新文件的完全限定名或相对文件名。 路径不要以目录分隔符结尾。</param>
        <summary>初始化作为文件路径的包装的 <see cref="T:System.IO.FileInfo" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以指定完全限定或相对文件名，但安全检查获取完全限定的名称。  
  
   
  
## Examples  
 下面的示例使用此构造函数来创建两个文件，然后再写入、 读取、 复制，并删除。  
  
 [!code-cpp[finfo ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Ctor/CPP/finfo ctor.cpp#1)]
 [!code-csharp[finfo ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Ctor/CS/finfo ctor.cs#1)]
 [!code-vb[finfo ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Ctor/VB/finfo ctor.vb#1)]  
  
 下面的示例打开一个现有文件或创建一个文件，将文本追加到文件，并显示结果。  
  
 [!code-cpp[fileinfomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfomain/CPP/fileinfomain.cpp#1)]
 [!code-csharp[fileinfomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfomain/CS/fileinfomain.cs#1)]
 [!code-vb[fileinfomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfomain/VB/fileinfomain.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.ArgumentException">文件名为空，仅包含空格，或包含无效字符。</exception>
        <exception cref="T:System.UnauthorizedAccessException">拒绝访问 <paramref name="fileName" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路径和/或文件名超过了系统定义的最大长度。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="fileName" /> 在字符串中间包含一个冒号 (:)。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter AppendText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamWriter AppendText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.AppendText" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendText () As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ AppendText();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建一个 <see cref="T:System.IO.StreamWriter" />，它向 <see cref="T:System.IO.FileInfo" /> 的此实例表示的文件追加文本。</summary>
        <returns>一个新的 <see langword="StreamWriter" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例将文本追加到文件，并从文件中读取。  
  
 [!code-cpp[finfo appendtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo AppendText/CPP/finfo appendtext.cpp#1)]
 [!code-csharp[finfo appendtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo AppendText/CS/finfo appendtext.cs#1)]
 [!code-vb[finfo appendtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo AppendText/VB/finfo appendtext.vb#1)]  
  
 以下示例演示如何将文本追加到文件末尾，并还向控制台显示的结果追加操作。 第一次调用此例程时，如果它不存在，则创建该文件。 之后，指定的文本追加到文件中。  
  
 [!code-cpp[fileinfoappendtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoappendtext/CPP/fileinfoappendtext.cpp#1)]
 [!code-csharp[fileinfoappendtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoappendtext/CS/fileinfoappendtext.cs#1)]
 [!code-vb[fileinfoappendtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoappendtext/VB/fileinfoappendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取和追加到文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将现有文件复制到新文件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo CopyTo (string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo CopyTo(string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CopyTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destFileName As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ CopyTo(System::String ^ destFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destFileName">要复制到的新文件的名称。</param>
        <summary>将现有文件复制到新文件，不允许覆盖现有文件。</summary>
        <returns>带有完全限定路径的新文件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileInfo.CopyTo%2A>方法，以便允许覆盖现有文件。  
  
> [!CAUTION]
>  只要有可能，避免在使用此方法 （如 XXXXXX~1.XXX) 的短文件名。 如果两个文件都有等效项短文件名，则此方法可能失败并引发异常和/或导致意外行为  
  
   
  
## Examples  
 下面的示例演示这两个重载`CopyTo`方法。  
  
 [!code-cpp[finfo copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CopyTo2/CPP/finfo copyto2.cpp#1)]
 [!code-csharp[finfo copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CopyTo2/CS/program.cs#1)]
 [!code-vb[finfo copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CopyTo2/VB/program.vb#1)]  
  
 下面的示例演示如何将一个文件复制到另一个文件，如果目标文件已存在，则引发异常。  
  
 [!code-cpp[FileInfoCopyTo1#1](~/samples/snippets/cpp/VS_Snippets_CLR/FileInfoCopyTo1/CPP/fileinfocopyto1.cpp#1)]
 [!code-csharp[FileInfoCopyTo1#1](~/samples/snippets/csharp/VS_Snippets_CLR/FileInfoCopyTo1/CS/fileinfocopyto1.cs#1)]
 [!code-vb[FileInfoCopyTo1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FileInfoCopyTo1/VB/fileinfocopyto1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> 为空，仅包含空格，或包含无效字符。</exception>
        <exception cref="T:System.IO.IOException">出现错误，或目标文件已存在。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.UnauthorizedAccessException">传入一个目录路径或此文件将被移至其他驱动器。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">在 <paramref name="destFileName" /> 中指定的此目录不存在。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路径和/或文件名超过了系统定义的最大长度。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="destFileName" /> 在其字符串中包含冒号 (:) ，但并未指定卷。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取和写入文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo CopyTo (string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo CopyTo(string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CopyTo(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destFileName As String, overwrite As Boolean) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ CopyTo(System::String ^ destFileName, bool overwrite);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destFileName">要复制到的新文件的名称。</param>
        <param name="overwrite">若为 <see langword="true" />，则允许覆盖现有文件；否则为 <see langword="false" />。</param>
        <summary>将现有文件复制到新文件，允许覆盖现有文件。</summary>
        <returns>为新文件；如果 <paramref name="overwrite" /> 是 <see langword="true" />，则为现有文件的覆盖。 如果文件存在且 <paramref name="overwrite" /> 为 <see langword="false" />，则引发 <see cref="T:System.IO.IOException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法允许或阻止覆盖现有文件。 使用<xref:System.IO.FileInfo.CopyTo%2A>方法，以防止覆盖现有文件的默认情况下。  
  
> [!CAUTION]
>  只要有可能，避免在使用此方法 （如 XXXXXX~1.XXX) 的短文件名。 如果两个文件都有等效项短文件名，则此方法可能失败并引发异常和/或导致意外行为  
  
   
  
## Examples  
 下面的示例演示这两个重载`CopyTo`方法。  
  
 [!code-cpp[finfo copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CopyTo2/CPP/finfo copyto2.cpp#1)]
 [!code-csharp[finfo copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CopyTo2/CS/program.cs#1)]
 [!code-vb[finfo copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CopyTo2/VB/program.vb#1)]  
  
 下面的示例演示如何将一个文件复制到另一个文件，指定是否覆盖已存在的文件。  
  
 [!code-cpp[fileinfocopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfocopyto/CPP/fileinfocopyto.cpp#1)]
 [!code-csharp[fileinfocopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfocopyto/CS/fileinfocopyto.cs#1)]
 [!code-vb[fileinfocopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfocopyto/VB/fileinfocopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> 为空，仅包含空格，或包含无效字符。</exception>
        <exception cref="T:System.IO.IOException">出现错误，或目标文件已存在，且 <paramref name="overwrite" /> 为 <see langword="false" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">在 <paramref name="destFileName" /> 中指定的此目录不存在。</exception>
        <exception cref="T:System.UnauthorizedAccessException">传入一个目录路径或此文件将被移至其他驱动器。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路径和/或文件名超过了系统定义的最大长度。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="destFileName" /> 在字符串中间包含一个冒号 (:)。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取和写入文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Function Create () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Create();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建文件。</summary>
        <returns>新文件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，对新文件的完全读/写访问权限授予所有用户。  
  
 此方法是提供的功能的包装器<xref:System.IO.File.Create%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例创建对文件的引用，然后创建使用磁盘上的文件`FileInfo.Create()`。  
  
 [!code-cpp[fileinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodelete/CPP/fileinfodelete.cpp#1)]
 [!code-csharp[fileinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodelete/CS/fileinfodelete.cs#1)]
 [!code-vb[fileinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodelete/VB/fileinfodelete.vb#1)]  
  
 下面的示例创建一个文件、 将一些文本添加到其中，和从文件中读取。  
  
 [!code-cpp[finfo create#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Create/CPP/finfo create.cpp#1)]
 [!code-csharp[finfo create#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Create/CS/finfo create.cs#1)]
 [!code-vb[finfo create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Create/VB/finfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取和写入文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter CreateText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamWriter CreateText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CreateText" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateText () As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ CreateText();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建写入新文本文件的 <see cref="T:System.IO.StreamWriter" />。</summary>
        <returns>一个新的 <see langword="StreamWriter" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，对新文件的完全读/写访问权限授予所有用户。  
  
   
  
## Examples  
 下面的示例演示`CreateText`方法。  
  
 [!code-cpp[finfo createtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CreateText/CPP/finfo createtext.cpp#1)]
 [!code-csharp[finfo createtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CreateText/CS/finfo createtext.cs#1)]
 [!code-vb[finfo createtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CreateText/VB/finfo createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">文件名是目录。</exception>
        <exception cref="T:System.IO.IOException">此盘为只读。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取和写入文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public void Decrypt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Decrypt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Decrypt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Decrypt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Decrypt();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使用 <see cref="M:System.IO.FileInfo.Encrypt" /> 方法解密由当前帐户加密的文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.Decrypt%2A>方法允许你使用加密文件进行解密<xref:System.IO.FileInfo.Encrypt%2A>方法。  <xref:System.IO.FileInfo.Decrypt%2A>方法可以解密使用当前用户帐户加密的文件。  
  
 这两个<xref:System.IO.FileInfo.Encrypt%2A>方法和<xref:System.IO.FileInfo.Decrypt%2A>方法使用安装在计算机和调用方法的过程的文件加密密钥的加密服务提供程序 (CSP)。  
  
 当前的文件系统必须格式化为 NTFS 和当前的操作系统必须是 Microsoft Windows NT 或更高版本。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.IO.FileInfo.Encrypt%2A>方法和<xref:System.IO.FileInfo.Decrypt%2A>方法加密，然后将解密文件。  
  
 [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DriveNotFoundException">指定了无效的驱动器。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到当前 <see cref="T:System.IO.FileInfo" /> 对象描述的文件。</exception>
        <exception cref="T:System.IO.IOException">打开文件时发生 I/O 错误。</exception>
        <exception cref="T:System.NotSupportedException">文件系统不是 NTFS。</exception>
        <exception cref="T:System.PlatformNotSupportedException">当前操作系统不是 Microsoft Windows NT 或更高版本。</exception>
        <exception cref="T:System.UnauthorizedAccessException">当前 <see cref="T:System.IO.FileInfo" /> 对象描述的文件为只读文件。  - 或 -  当前平台不支持此操作。  - 或 -  调用方没有所需权限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />，<see cref="F:System.Security.AccessControl.FileSystemRights.Write" />安全操作： 需。  权限读取和写入当前所描述的文件<see cref="T:System.IO.FileInfo" />对象。</permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>永久删除文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果文件不存在，则此方法没有任何影响。  
  
   
  
## Examples  
 下面的示例演示`Delete`方法。  
  
 [!code-cpp[finfo delete#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Delete/CPP/finfo delete.cpp#1)]
 [!code-csharp[finfo delete#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Delete/CS/finfo delete.cs#1)]
 [!code-vb[finfo delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Delete/VB/finfo delete.vb#1)]  
  
 下面的示例创建、 将关闭，并删除的文件。  
  
 [!code-cpp[fileinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodelete/CPP/fileinfodelete.cpp#1)]
 [!code-csharp[fileinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodelete/CS/fileinfodelete.cs#1)]
 [!code-vb[fileinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodelete/VB/fileinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">目标文件打开或在运行 Microsoft Windows NT 的计算机上进行内存映射。  - 或 -  在文件中存在开放句柄，并且操作系统是 Windows XP 或更早的版本。 枚举目录和文件可能会导致此开放句柄出现。 有关详细信息，请参阅 [如何：枚举目录和文件](~/docs/standard/io/how-to-enumerate-directories-and-files.md)。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">路径是一个目录。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取和写入文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Directory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Directory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Directory" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Directory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Directory As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Directory { System::IO::DirectoryInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取父目录的实例。</summary>
        <value>表示此文件父目录的 <see cref="T:System.IO.DirectoryInfo" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取字符串形式的父目录，请使用<xref:System.IO.FileInfo.DirectoryName%2A>属性。  
  
   
  
## Examples  
 下面的示例打开或创建一个文件，确定其完整路径，并确定并显示目录的完整内容。  
  
 [!code-cpp[fileinfodirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodirectory/CPP/fileinfodirectory.cpp#1)]
 [!code-csharp[fileinfodirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodirectory/CS/fileinfodirectory.cs#1)]
 [!code-vb[fileinfodirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodirectory/VB/fileinfodirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，例如位于未映射的驱动器上。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DirectoryName">
      <MemberSignature Language="C#" Value="public string DirectoryName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DirectoryName" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.DirectoryName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DirectoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DirectoryName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取表示目录的完整路径的字符串。</summary>
        <value>表示目录的完整路径的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取形式的父目录<xref:System.IO.DirectoryInfo>对象，请使用<xref:System.IO.FileInfo.Directory%2A>属性。  
  
 当第一次调用，<xref:System.IO.FileInfo>调用<xref:System.IO.FileSystemInfo.Refresh%2A>和缓存文件的信息。 在后续调用中，必须调用<xref:System.IO.FileSystemInfo.Refresh%2A>以获取信息的最新副本。  
  
   
  
## Examples  
 下面的示例检索指定的文件的完整路径。  
  
 [!code-cpp[System.IO.FileInfo members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileInfo members/CPP/fileinfomembers.cpp#3)]
 [!code-csharp[System.IO.FileInfo members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileInfo members/CS/fileinfomembers.cs#3)]
 [!code-vb[System.IO.FileInfo members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileInfo members/VB/fileinfomembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">为目录名传入 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">完全限定路径名称的长度超出系统定义的最大长度。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取文件。 关联的枚举： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public void Encrypt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Encrypt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Encrypt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Encrypt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Encrypt();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将某个文件加密，使得只有加密该文件的帐户才能将其解密。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.Encrypt%2A>方法可用于加密文件，以便仅用来调用此方法的帐户可以对其进行解密。  使用<xref:System.IO.FileInfo.Decrypt%2A>方法以解密加密的文件<xref:System.IO.FileInfo.Encrypt%2A>方法。  
  
 这两个<xref:System.IO.FileInfo.Encrypt%2A>方法和<xref:System.IO.FileInfo.Decrypt%2A>方法使用安装在计算机和调用方法的过程的文件加密密钥的加密服务提供程序 (CSP)。  
  
 当前的文件系统必须格式化为 NTFS 和当前的操作系统必须是 Microsoft Windows NT 或更高版本。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.IO.FileInfo.Encrypt%2A>方法和<xref:System.IO.FileInfo.Decrypt%2A>方法加密文件，然后将其解密。  
  
 [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DriveNotFoundException">指定了无效的驱动器。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到当前 <see cref="T:System.IO.FileInfo" /> 对象描述的文件。</exception>
        <exception cref="T:System.IO.IOException">打开文件时发生 I/O 错误。</exception>
        <exception cref="T:System.NotSupportedException">文件系统不是 NTFS。</exception>
        <exception cref="T:System.PlatformNotSupportedException">当前操作系统不是 Microsoft Windows NT 或更高版本。</exception>
        <exception cref="T:System.UnauthorizedAccessException">当前 <see cref="T:System.IO.FileInfo" /> 对象描述的文件为只读文件。  - 或 -  当前平台不支持此操作。  - 或 -  调用方没有所需权限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />，<see cref="F:System.Security.AccessControl.FileSystemRights.Write" />安全操作： 需。  权限读取和写入当前所描述的文件<see cref="T:System.IO.FileInfo" />对象。</permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示文件是否存在的值。</summary>
        <value>如果该文件存在，则为 <see langword="true" />；如果文件不存在或文件即是目录，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当第一次调用，<xref:System.IO.FileInfo>调用<xref:System.IO.FileSystemInfo.Refresh%2A>和缓存文件的信息。 在后续调用中，必须调用<xref:System.IO.FileSystemInfo.Refresh%2A>以获取信息的最新副本。  
  
 <xref:System.IO.FileInfo.Exists%2A>属性返回`false`如果在尝试确定指定的文件是否存在任何错误时发生。 在引发异常，例如传递具有无效的字符或太多字符，磁盘失效或缺失的文件名的情况下可能发生这或如果调用方没有权限读取此文件。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.IO.FileInfo.Exists%2A>属性确保在打开之前存在的文件。  此方法可用于引发自定义异常，找不到文件时。  
  
 [!code-cpp[IO.FileInfo.Exists#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Exists/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Exists/cs/sample.cs#1)]
 [!code-vb[IO.FileInfo.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Exists/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取 <see cref="T:System.Security.AccessControl.FileSecurity" /> 对象，该对象封装当前 <see cref="T:System.IO.FileInfo" /> 对象所描述的文件的访问控制列表 (ACL) 项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileInfo.GetAccessControl%2A>方法来检索访问控制的当前文件的列表 (ACL) 项。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取 <see cref="T:System.Security.AccessControl.FileSecurity" /> 对象，该对象封装当前 <see cref="T:System.IO.FileInfo" /> 对象所描述的文件的访问控制列表 (ACL) 项。</summary>
        <returns>一个 <see cref="T:System.Security.AccessControl.FileSecurity" /> 对象，该对象封装当前文件的访问控制规则。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileInfo.GetAccessControl%2A>方法来检索当前文件的访问控制列表 (ACL) 项。  
  
 ACL 描述个人和/或组具有或没有执行到给定的文件上的特定操作的权限。 有关详细信息，请参阅[如何：添加或移除访问控制列表项](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.IO.FileInfo.GetAccessControl%2A>方法和<xref:System.IO.FileInfo.SetAccessControl%2A>方法添加，然后从文件中删除的访问控制列表 (ACL) 项。  你必须提供有效的用户或组帐户以运行此示例。  
  
 [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">打开文件时发生 I/O 错误。</exception>
        <exception cref="T:System.PlatformNotSupportedException">当前操作系统不是 Microsoft Windows 2000 或更高版本。</exception>
        <exception cref="T:System.Security.AccessControl.PrivilegeNotHeldException">当前的系统帐户没有管理权限。</exception>
        <exception cref="T:System.SystemException">找不到文件。</exception>
        <exception cref="T:System.UnauthorizedAccessException">当前平台不支持此操作。  - 或 -  调用方没有所需权限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />，<see cref="F:System.Security.AccessControl.AccessControlActions.View" />安全操作： 需。  若要读取的访问控制列表的权限。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">
          <see cref="T:System.Security.AccessControl.AccessControlSections" /> 值之一，该值指定要检索的访问控制项组。</param>
        <summary>获取一个 <see cref="T:System.Security.AccessControl.FileSecurity" /> 对象，该对象封装当前 <see cref="T:System.IO.FileInfo" /> 对象所描述的文件的指定类型的访问控制列表 (ACL) 项。</summary>
        <returns>一个 <see cref="T:System.Security.AccessControl.FileSecurity" /> 对象，该对象封装当前文件的访问控制规则。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileInfo.GetAccessControl%2A>方法来检索当前文件的访问控制列表 (ACL) 项。  
  
 ACL 描述个人和/或组具有或没有执行到给定的文件上的特定操作的权限。 有关详细信息，请参阅[如何：添加或移除访问控制列表项](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">打开文件时发生 I/O 错误。</exception>
        <exception cref="T:System.PlatformNotSupportedException">当前操作系统不是 Microsoft Windows 2000 或更高版本。</exception>
        <exception cref="T:System.Security.AccessControl.PrivilegeNotHeldException">当前的系统帐户没有管理权限。</exception>
        <exception cref="T:System.SystemException">找不到文件。</exception>
        <exception cref="T:System.UnauthorizedAccessException">当前平台不支持此操作。  - 或 -  调用方没有所需权限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />，<see cref="F:System.Security.AccessControl.AccessControlActions.View" />安全操作： 需。  若要读取的访问控制列表的权限。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置确定当前文件是否为只读的值。</summary>
        <value>如果当前文件为只读，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileInfo.IsReadOnly%2A>属性来快速确定或更改是否当前文件为只读。  
  
 当第一次调用，<xref:System.IO.FileInfo>调用<xref:System.IO.FileSystemInfo.Refresh%2A>和缓存文件的信息。 在后续调用中，必须调用<xref:System.IO.FileSystemInfo.Refresh%2A>以获取信息的最新副本。  
  
   
  
## Examples  
 下面的示例使用<xref:System.IO.FileInfo.IsReadOnly%2A>要将文件标记为只读并且然后将其标记为读写属性。  
  
 [!code-cpp[IO.FileInfo.IsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.isReadOnly/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.IsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.isReadOnly/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.IsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.isReadOnly/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">找不到当前 <see cref="T:System.IO.FileInfo" /> 对象描述的文件。</exception>
        <exception cref="T:System.IO.IOException">打开文件时发生 I/O 错误。</exception>
        <exception cref="T:System.UnauthorizedAccessException">当前平台不支持此操作。  - 或 -  调用方没有所需权限。</exception>
        <exception cref="T:System.ArgumentException">此用户没有写入权限，但尝试将此属性设置为 <see langword="false" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />，<see cref="F:System.Security.AccessControl.FileSystemRights.Write" />安全操作： 需。  权限读取和写入当前所描述的文件<see cref="T:System.IO.FileInfo" />对象。</permission>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前文件的大小（以字节为单位）。</summary>
        <value>当前文件的大小（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.IO.FileInfo.Length%2A>属性会预先缓存，如果当前实例的<xref:System.IO.FileInfo>从以下任一返回了对象<xref:System.IO.DirectoryInfo>方法：  
  
-   <xref:System.IO.DirectoryInfo.GetDirectories%2A>  
  
-   <xref:System.IO.DirectoryInfo.GetFiles%2A>  
  
-   <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>  
  
 若要获取最新值，请调用<xref:System.IO.FileSystemInfo.Refresh%2A>方法。  
  
   
  
## Examples  
 下面的示例显示指定的文件的大小。  
  
 [!code-cpp[FileLength#1](~/samples/snippets/cpp/VS_Snippets_CLR/FileLength/CPP/filelength.cpp#1)]
 [!code-csharp[FileLength#1](~/samples/snippets/csharp/VS_Snippets_CLR/FileLength/CS/filelength.cs#1)]
 [!code-vb[FileLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FileLength/VB/filelength.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <see cref="M:System.IO.FileSystemInfo.Refresh" /> 无法更新文件或目录的状态。</exception>
        <exception cref="T:System.IO.FileNotFoundException">文件不存在。  - 或 -  针对某个目录调用了 <see langword="Length" /> 属性。</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destFileName">要将文件移动到的路径，可以指定另一个文件名。</param>
        <summary>将指定文件移到新位置，提供要指定新文件名的选项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法适用于整个磁盘卷。 例如，文件 c:\MyFile.txt 可以移到 d:\public，重命名 NewFile.txt。  
  
   
  
## Examples  
 下面的示例演示将文件移动到不同的位置和重命名该文件。  
  
 [!code-csharp[IO.FileInfo.MoveTo#1](~/samples/snippets/csharp/VS_Snippets_Misc/IO.FileInfo.MoveTo/CS/Program.cs#1)]
 [!code-vb[IO.FileInfo.MoveTo#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/IO.FileInfo.MoveTo/VB/Program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">发生 I/O 错误，例如目标文件已存在或目标设备未就绪。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> 为空，仅包含空格，或包含无效字符。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="destFileName" /> 为只读或是目录。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到此文件。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，例如位于未映射的驱动器上。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路径和/或文件名超过了系统定义的最大长度。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="destFileName" /> 在字符串中间包含一个冒号 (:)。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取和写入文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取文件名。</summary>
        <value>文件的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当第一次调用，<xref:System.IO.FileInfo>调用<xref:System.IO.FileSystemInfo.Refresh%2A>和缓存文件的信息。 在后续调用中，必须调用<xref:System.IO.FileSystemInfo.Refresh%2A>以获取信息的最新副本。  
  
 文件的名称包括文件扩展名。  
  
   
  
## Examples  
 下面的示例使用`Name`属性在当前目录中显示的文件的名称。  
  
 [!code-cpp[fileinfoname#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoname/CPP/fileinfoname.cpp#1)]
 [!code-csharp[fileinfoname#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoname/CS/fileinfoname.cs#1)]
 [!code-vb[fileinfoname#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoname/VB/fileinfoname.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>用各种读/写访问权限和共享特权打开文件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="mode">一个 <see cref="T:System.IO.FileMode" /> 常数，它指定打开文件所采用的模式（例如 <see langword="Open" /> 或 <see langword="Append" />）。</param>
        <summary>在指定的模式中打开文件。</summary>
        <returns>在指定模式中打开、具有读/写访问权限且不共享的文件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例打开文件、 将某些信息添加到该文件，并读取文件。  
  
 [!code-cpp[finfo open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Open1/CPP/finfo open1.cpp#1)]
 [!code-csharp[finfo open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Open1/CS/finfo open1.cs#1)]
 [!code-vb[finfo open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Open1/VB/finfo open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">未找到此文件。</exception>
        <exception cref="T:System.UnauthorizedAccessException">文件为只读或是目录。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，例如位于未映射的驱动器上。</exception>
        <exception cref="T:System.IO.IOException">此文件已打开。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于写入和从文件读取。 关联的枚举：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode, access As FileAccess) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">一个 <see cref="T:System.IO.FileMode" /> 常数，它指定打开文件所采用的模式（例如 <see langword="Open" /> 或 <see langword="Append" />）。</param>
        <param name="access">一个 <see cref="T:System.IO.FileAccess" /> 常数，它指定是使用 <see langword="Read" />、<see langword="Write" /> 还是 <see langword="ReadWrite" /> 文件访问来打开文件。</param>
        <summary>用读、写或读/写访问权限在指定模式下打开文件。</summary>
        <returns>用指定模式和访问权限打开的且不共享的 <see cref="T:System.IO.FileStream" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例打开一个文件作为只读的并从文件读取。  
  
 [!code-cpp[finfo open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Open2/CPP/finfo open2.cpp#1)]
 [!code-csharp[finfo open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Open2/CS/finfo open2.cs#1)]
 [!code-vb[finfo open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Open2/VB/finfo open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到此文件。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 为只读或是目录。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，例如位于未映射的驱动器上。</exception>
        <exception cref="T:System.IO.IOException">此文件已打开。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于写入和从文件读取。 关联的枚举：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode, access As FileAccess, share As FileShare) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="mode">一个 <see cref="T:System.IO.FileMode" /> 常数，它指定打开文件所采用的模式（例如 <see langword="Open" /> 或 <see langword="Append" />）。</param>
        <param name="access">一个 <see cref="T:System.IO.FileAccess" /> 常数，它指定是使用 <see langword="Read" />、<see langword="Write" /> 还是 <see langword="ReadWrite" /> 文件访问来打开文件。</param>
        <param name="share">一个 <see cref="T:System.IO.FileShare" /> 常数，它指定其他 <see langword="FileStream" /> 对象对此文件拥有的访问类型。</param>
        <summary>用读、写或读/写访问权限和指定的共享选项在指定的模式中打开文件。</summary>
        <returns>用指定的模式、访问权限和共享选项打开的 <see cref="T:System.IO.FileStream" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示了如何打开用于读取和写入操作，但不允许其他用户或进程访问权限的文件。  
  
 [!code-cpp[fileinfoopen#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoopen/CPP/fileinfoopen.cpp#1)]
 [!code-csharp[fileinfoopen#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoopen/CS/fileinfoopen.cs#1)]
 [!code-vb[fileinfoopen#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoopen/VB/fileinfoopen.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到此文件。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 为只读或是目录。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，例如位于未映射的驱动器上。</exception>
        <exception cref="T:System.IO.IOException">此文件已打开。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于写入和从文件读取。 关联的枚举：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public System.IO.FileStream OpenRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream OpenRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenRead" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenRead () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ OpenRead();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建一个只读的 <see cref="T:System.IO.FileStream" />。</summary>
        <returns>一个新的只读的 <see cref="T:System.IO.FileStream" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的只读<xref:System.IO.FileStream>对象<xref:System.IO.FileShare>模式设置为<xref:System.IO.FileShare.Read>。  
  
   
  
## Examples  
 下面的示例打开一个文件作为只读的并读取它。  
  
 [!code-cpp[finfo openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenRead/CPP/finfo openread.cpp#1)]
 [!code-csharp[finfo openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenRead/CS/finfo openread.cs#1)]
 [!code-vb[finfo openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenRead/VB/finfo openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 为只读或是目录。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，例如位于未映射的驱动器上。</exception>
        <exception cref="T:System.IO.IOException">此文件已打开。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamReader OpenText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenText" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenText () As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenText();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建使用从现有文本文件中读取的 UTF8 编码的 <see cref="T:System.IO.StreamReader" />。</summary>
        <returns>使用 UTF8 编码的新的 <see langword="StreamReader" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例读取文件中的文本。  
  
 [!code-cpp[finfo opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[finfo opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenText/CS/file opentext.cs#1)]
 [!code-vb[finfo opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到此文件。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 为只读或是目录。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路径无效，例如位于未映射的驱动器上。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取和写入文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public System.IO.FileStream OpenWrite ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream OpenWrite() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenWrite" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenWrite () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ OpenWrite();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建一个只写的 <see cref="T:System.IO.FileStream" />。</summary>
        <returns>新的或现有文件的只写非共享的 <see cref="T:System.IO.FileStream" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.OpenWrite%2A>方法打开一个文件，如果一个已存在的文件路径，或创建一个新文件，如果不存在。 对于现有的文件，它不会不新将文本追加到现有的文本。 相反，它将用新的字符覆盖现有的字符。 如果使用较短字符串 （如"第二次运行"） （例如"This is OpenWrite 方法的测试)"覆盖较长的字符串，则文件将包含多种字符串 ("第二个 runtest OpenWrite 方法的")。  
  
   
  
## Examples  
 下面的示例打开用于写入文件，然后从文件中读取。  
  
 [!code-cpp[finfo openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[finfo openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[finfo openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">创建 <see cref="T:System.IO.FileInfo" /> 对象的实例时指定的路径为只读或是目录。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">创建 <see cref="T:System.IO.FileInfo" /> 对象的实例时指定的路径无效，例如此路径位于未映射的驱动器。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取和写入文件。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用当前 <see cref="T:System.IO.FileInfo" /> 对象所描述的文件替换指定文件的内容，这一过程将删除原始文件，并创建被替换文件的备份。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileInfo.Replace%2A>方法需要进行快速替换当前所描述的文件的内容文件时<xref:System.IO.FileInfo>对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (destinationFileName As String, destinationBackupFileName As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ Replace(System::String ^ destinationFileName, System::String ^ destinationBackupFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destinationFileName">要替换为当前文件的文件的名称。</param>
        <param name="destinationBackupFileName">文件的名称，该文件用于创建 <c>destFileName</c> 参数所描述的文件的备份。</param>
        <summary>使用当前 <see cref="T:System.IO.FileInfo" /> 对象所描述的文件替换指定文件的内容，这一过程将删除原始文件，并创建被替换文件的备份。</summary>
        <returns>一个 <see cref="T:System.IO.FileInfo" /> 对象，该对象封装有关 <paramref name="destFileName" /> 参数所描述的文件的信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.Replace%2A>方法会指定文件的内容替换为当前所描述的文件的内容<xref:System.IO.FileInfo>对象。  它还将创建被替换文件的备份。  最后，它返回一个新<xref:System.IO.FileInfo>对象，描述被覆盖的文件。  
  
> [!CAUTION]
>  如果此方法将在 Windows 2000 环境中成功`destFileName`是只读的并且不会引发异常。 使用<xref:System.IO.FileInfo.IsReadOnly%2A>属性检查目标文件然后再尝试将其替换中是否为只读的。  
  
 传递`null`到`destBackupFileName`参数，如果你不想要创建被替换文件的备份。  
  
   
  
## Examples  
 下面的示例使用<xref:System.IO.File.Replace%2A>方法将替换为另一个文件的文件并创建被替换文件的备份。  
  
 [!code-cpp[IO.FileInfo.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Replace/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> 参数描述的路径格式不合法。  - 或 -  <paramref name="destBackupFileName" /> 参数描述的路径格式不合法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到当前 <see cref="T:System.IO.FileInfo" /> 对象描述的文件。  - 或 -  找不到 <paramref name="destinationFileName" /> 参数描述的文件。</exception>
        <exception cref="T:System.PlatformNotSupportedException">当前操作系统不是 Microsoft Windows NT 或更高版本。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">关联的枚举：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />安全操作： 需。  要写入的权限所描述的文件<paramref name="destBackupFileName" />如果指定的参数。</permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Replace(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (destinationFileName As String, destinationBackupFileName As String, ignoreMetadataErrors As Boolean) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ Replace(System::String ^ destinationFileName, System::String ^ destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destinationFileName">要替换为当前文件的文件的名称。</param>
        <param name="destinationBackupFileName">文件的名称，该文件用于创建 <c>destFileName</c> 参数所描述的文件的备份。</param>
        <param name="ignoreMetadataErrors">若要忽略从被替换文件到替换文件的合并错误（例如属性和 ACL），请设置为 <see langword="true" />；否则设置为 <see langword="false" />。</param>
        <summary>使用当前 <see cref="T:System.IO.FileInfo" /> 对象所描述的文件替换指定文件的内容，这一过程将删除原始文件，并创建被替换文件的备份。  还指定是否忽略合并错误。</summary>
        <returns>一个 <see cref="T:System.IO.FileInfo" /> 对象，该对象封装有关 <paramref name="destFileName" /> 参数所描述的文件的信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.Replace%2A>方法会指定文件的内容替换为当前所描述的文件的内容<xref:System.IO.FileInfo>对象。  它还将创建被替换文件的备份。  最后，它返回一个新<xref:System.IO.FileInfo>对象，描述被覆盖的文件。  
  
> [!CAUTION]
>  如果此方法将在 Windows 2000 环境中成功`destFileName`是只读的并且不会引发异常。 使用<xref:System.IO.FileInfo.IsReadOnly%2A>属性检查目标文件然后再尝试将其替换中是否为只读的。  
  
 传递`null`到`destBackupFileName`参数，如果你不想要创建被替换文件的备份。  
  
   
  
## Examples  
 下面的示例使用<xref:System.IO.File.Replace%2A>方法将替换为另一个文件的文件并创建被替换文件的备份。  
  
 [!code-cpp[IO.FileInfo.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Replace/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> 参数描述的路径格式不合法。  - 或 -  <paramref name="destBackupFileName" /> 参数描述的路径格式不合法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到当前 <see cref="T:System.IO.FileInfo" /> 对象描述的文件。  - 或 -  找不到 <paramref name="destinationFileName" /> 参数描述的文件。</exception>
        <exception cref="T:System.PlatformNotSupportedException">当前操作系统不是 Microsoft Windows NT 或更高版本。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">关联的枚举：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />安全操作： 需。  要写入的权限所描述的文件<paramref name="destBackupFileName" />如果指定的参数。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">一个 <see cref="T:System.Security.AccessControl.FileSecurity" /> 对象，该对象描述要应用于当前文件的访问控制列表 (ACL) 项。</param>
        <summary>将 <see cref="T:System.Security.AccessControl.FileSecurity" /> 对象所描述的访问控制列表 (ACL) 项应用于当前 <see cref="T:System.IO.FileInfo" /> 对象所描述的文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.SetAccessControl%2A>方法适用于表示非继承的 ACL 列表的当前文件的访问控制列表 (ACL) 项。  
  
 使用<xref:System.IO.FileInfo.SetAccessControl%2A>方法，无论何时需要添加或删除文件的 ACL 条目。  
  
> [!CAUTION]
>  为 ACL 指定`fileSecurity`参数替换现有文件 ACL。 若要添加的新用户的权限，请使用<xref:System.IO.Directory.GetAccessControl%2A>方法来获取现有的 ACL，对其进行修改，然后使用<xref:System.IO.FileInfo.SetAccessControl%2A>以将其应用回的文件。  
  
 ACL 描述个人和/或组具有或没有执行到给定的文件上的特定操作的权限。 有关详细信息，请参阅[如何：添加或移除访问控制列表项](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
 <xref:System.IO.FileInfo.SetAccessControl%2A>方法仍然仅存在<xref:System.Security.AccessControl.FileSecurity>对象创建后已修改的对象。  如果<xref:System.Security.AccessControl.FileSecurity>尚未修改对象，它不会保留到文件。  因此，不能检索<xref:System.Security.AccessControl.FileSecurity>对象从一个文件，并重新对同一对象应用到另一个文件。  
  
 若要将 ACL 信息从一个文件复制到另一个：  
  
1.  使用<xref:System.IO.FileInfo.GetAccessControl%2A>方法来检索<xref:System.Security.AccessControl.FileSecurity>源文件中的对象。  
  
2.  创建一个新<xref:System.Security.AccessControl.FileSecurity>目标文件的对象。  
  
3.  使用<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A>或<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>方法的源<xref:System.Security.AccessControl.FileSecurity>要检索 ACL 信息对象。  
  
4.  使用<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A>或<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>方法的信息复制到目标的步骤 3 中检索<xref:System.Security.AccessControl.FileSecurity>对象。  
  
5.  设置目标<xref:System.Security.AccessControl.FileSecurity>到目标文件使用的对象<xref:System.IO.FileInfo.SetAccessControl%2A>方法。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.IO.FileInfo.GetAccessControl%2A>方法和<xref:System.IO.FileInfo.SetAccessControl%2A>方法添加，然后从文件中删除的 ACL 项。  你必须提供有效的用户或组帐户以运行此示例。  
  
 [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileSecurity" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.SystemException">未能找到或修改该文件。</exception>
        <exception cref="T:System.UnauthorizedAccessException">当前进程不具有打开该文件的权限。</exception>
        <exception cref="T:System.PlatformNotSupportedException">当前操作系统不是 Microsoft Windows 2000 或更高版本。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />，<see cref="F:System.Security.AccessControl.AccessControlActions.Change" />安全操作： 请求的权限访问该文件。</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以字符串形式返回路径。</summary>
        <returns>一个表示该路径的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的字符串<xref:System.IO.FileInfo.ToString%2A>方法表示传递给构造函数的路径。  当你创建<xref:System.IO.FileInfo>对象使用构造函数，<xref:System.IO.FileInfo.ToString%2A>方法返回的完全限定的路径。  但是，也会通过返回的字符串的情况<xref:System.IO.FileInfo.ToString%2A>方法不表示的完全限定的路径。  例如，当创建<xref:System.IO.FileInfo>对象使用<xref:System.IO.DirectoryInfo.GetFiles%2A>方法，<xref:System.IO.FileInfo.ToString%2A>方法不表示的完全限定的路径。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>