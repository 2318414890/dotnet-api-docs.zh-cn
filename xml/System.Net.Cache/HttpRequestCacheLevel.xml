<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="HttpRequestCacheLevel.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac591085a15958b74e9aa80e37c96eca1cfdd1eb172.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">91085a15958b74e9aa80e37c96eca1cfdd1eb172</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Net.Cache.HttpRequestCacheLevel">
          <source>Specifies caching behavior for resources obtained using the Hypertext Transfer protocol (HTTP).</source>
          <target state="translated">为使用超文本传输协议 (HTTP) 获取的资源指定缓存行为。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Cache.HttpRequestCacheLevel">
          <source>This enumeration is used to set the cache level specified by <ph id="ph1">&lt;xref:System.Net.Cache.HttpRequestCachePolicy&gt;</ph> objects.</source>
          <target state="translated">此枚举用于设置由指定的缓存级别<ph id="ph1">&lt;xref:System.Net.Cache.HttpRequestCachePolicy&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Cache.HttpRequestCacheLevel">
          <source>This BypassCache value is the default cache behavior specified in the machine configuration file that ships with the .NET Framework.</source>
          <target state="translated">BypassCache 该值是在.NET Framework 附带的计算机配置文件中指定的默认缓存行为。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Cache.HttpRequestCacheLevel">
          <source>No entries are taken from caches, added to caches, or removed from caches between the client and server.</source>
          <target state="translated">在客户端和服务器之间没有项从缓存中取出、添加到缓存中或从缓存中移除。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Cache.HttpRequestCacheLevel">
          <source>The <ph id="ph1">&lt;xref:System.Net.HttpWebRequest.DefaultCachePolicy%2A?displayProperty=nameWithType&gt;</ph> property is used to get or set the default cache policy for <ph id="ph2">&lt;xref:System.Net.HttpWebRequest.DefaultCachePolicy%2A?displayProperty=nameWithType&gt;</ph> instances.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.HttpWebRequest.DefaultCachePolicy%2A?displayProperty=nameWithType&gt;</ph>属性用于获取或设置的默认缓存策略<ph id="ph2">&lt;xref:System.Net.HttpWebRequest.DefaultCachePolicy%2A?displayProperty=nameWithType&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Cache.HttpRequestCacheLevel">
          <source>The <ph id="ph1">&lt;xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType&gt;</ph> property is used to get or set the default cache policy for a <ph id="ph2">&lt;xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType&gt;</ph> instances.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType&gt;</ph>属性用于获取或设置的默认缓存策略<ph id="ph2">&lt;xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Cache.HttpRequestCacheLevel">
          <source>The <ph id="ph1">&lt;xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType&gt;</ph> property is used to get or set the cache policy for a specific request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType&gt;</ph>属性用于获取或设置特定请求的缓存策略。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Cache.HttpRequestCacheLevel">
          <source>A copy of a resource is only added to the cache if the response stream for the resource is retrieved and read to the end of the stream.</source>
          <target state="translated">如果资源的响应流是检索，并且读取到流末尾，资源的副本是仅添加到缓存。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Cache.HttpRequestCacheLevel">
          <source>So another request for the same resource could use a cached copy, depending on the default cache policy level for this request.</source>
          <target state="translated">因此相同的资源的另一个请求可以使用缓存的副本，具体取决于此请求的默认缓存策略级别。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Cache.HttpRequestCacheLevel">
          <source>The following code example sets the application domain's caching policy to Default.</source>
          <target state="translated">下面的代码示例将应用程序域的缓存策略设置为默认值。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.BypassCache">
          <source>Satisfies a request by using the server.</source>
          <target state="translated">使用服务器满足请求。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.BypassCache">
          <source>No entries are taken from caches, added to caches, or removed from caches between the client and server.</source>
          <target state="translated">在客户端和服务器之间没有项从缓存中取出、添加到缓存中或从缓存中移除。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.BypassCache">
          <source>No entries are taken from caches, added to caches, or removed from caches between the client and server.</source>
          <target state="translated">在客户端和服务器之间没有项从缓存中取出、添加到缓存中或从缓存中移除。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.BypassCache">
          <source>This is the default cache behavior specified in the machine configuration file that ships with the .NET Framework.</source>
          <target state="translated">这是 .NET Framework 附带的计算机配置文件中指定的默认缓存行为。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.CacheIfAvailable">
          <source>Satisfies a request for a resource from the cache if the resource is available; otherwise, sends a request for a resource to the server.</source>
          <target state="translated">如果资源可用，则从缓存满足资源请求；否则，将资源请求发送到服务器。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.CacheIfAvailable">
          <source>If the requested item is available in any cache between the client and the server, the request might be satisfied by the intermediate cache.</source>
          <target state="translated">如果请求的项在客户端和服务器之间的任何缓存中可用，则可由中间缓存满足请求。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.CacheOnly">
          <source>Satisfies a request using the locally cached resource; does not send a request for an item that is not in the cache.</source>
          <target state="translated">使用本地缓存资源满足请求；不发送对不在缓存中的项的请求。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.CacheOnly">
          <source>When this cache policy level is specified, a <ph id="ph1">&lt;see cref="T:System.Net.WebException" /&gt;</ph> exception is thrown if the item is not in the client cache.</source>
          <target state="translated">当指定此缓存策略级别时，如果项不在客户端缓存中，则引发 <ph id="ph1">&lt;see cref="T:System.Net.WebException" /&gt;</ph> 异常。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.CacheOrNextCacheOnly">
          <source>Satisfies a request for a resource either from the local computer's cache or a remote cache on the local area network.</source>
          <target state="translated">从本地计算机的缓存或局域网上的远程缓存满足资源请求。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.CacheOrNextCacheOnly">
          <source>If the request cannot be satisfied, a <ph id="ph1">&lt;see cref="T:System.Net.WebException" /&gt;</ph> exception is thrown.</source>
          <target state="translated">如果无法满足请求，则引发 <ph id="ph1">&lt;see cref="T:System.Net.WebException" /&gt;</ph> 异常。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.CacheOrNextCacheOnly">
          <source>In the HTTP caching protocol, this is achieved using the <ph id="ph1">&lt;see langword="only-if-cached" /&gt;</ph> cache control directive.</source>
          <target state="translated">在 HTTP 缓存协议中，这是通过 <ph id="ph1">&lt;see langword="only-if-cached" /&gt;</ph> 缓存控制指令实现的。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.Default">
          <source>Satisfies a request for a resource either by using the cached copy of the resource or by sending a request for the resource to the server.</source>
          <target state="translated">通过使用资源的缓存副本或通过将资源请求发送到服务器来满足资源请求。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.Default">
          <source>The action taken is determined by the current cache policy and the age of the content in the cache.</source>
          <target state="translated">采取的操作取决于当前的缓存策略和缓存内容的生存期。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.Default">
          <source>This is the cache level that should be used by most applications.</source>
          <target state="translated">这是大多数应用程序应使用的缓存级别。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.NoCacheNoStore">
          <source>Never satisfies a request by using resources from the cache and does not cache resources.</source>
          <target state="translated">从不通过使用缓存中的资源来满足请求，也不缓存资源。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.NoCacheNoStore">
          <source>If the resource is present in the local cache, it is removed.</source>
          <target state="translated">如果资源在本地缓存中，则会移除该资源。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.NoCacheNoStore">
          <source>This policy level indicates to intermediate caches that they should remove the resource.</source>
          <target state="translated">此策略级别指示中间缓存应移除资源。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.NoCacheNoStore">
          <source>In the HTTP caching protocol, this is achieved using the no-cache cache control directive.</source>
          <target state="translated">在 HTTP 缓存协议中，这是通过 no-cache 缓存控制指令实现的。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.Refresh">
          <source>Satisfies a request by using the server or a cache other than the local cache.</source>
          <target state="translated">通过使用服务器或本地缓存以外的缓存来满足请求。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.Refresh">
          <source>Before the request can be satisfied by an intermediate cache, that cache must revalidate its cached entry with the server.</source>
          <target state="translated">在请求可由中间缓存满足之前，该缓存必须通过服务器重新验证其缓存条目。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.Refresh">
          <source>In the HTTP caching protocol, this is achieved using the max-age = 0 cache control directive and the no-cache <ph id="ph1">&lt;see langword="Pragma" /&gt;</ph> header.</source>
          <target state="translated">在 HTTP 缓存协议中，这是通过 max-age = 0 缓存控制指令和 no-cache <ph id="ph1">&lt;see langword="Pragma" /&gt;</ph> 标头实现的。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.Reload">
          <source>Satisfies a request by using the server.</source>
          <target state="translated">使用服务器满足请求。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.Reload">
          <source>The response might be saved in the cache.</source>
          <target state="translated">响应可能保存在缓存中。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.Reload">
          <source>In the HTTP caching protocol, this is achieved using the no-cache cache control directive and the no-cache <ph id="ph1">&lt;see langword="Pragma" /&gt;</ph> header.</source>
          <target state="translated">在 HTTP 缓存协议中，这是通过 no-cache 缓存控制指令和 no-cache <ph id="ph1">&lt;see langword="Pragma" /&gt;</ph> 标头实现的。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.Revalidate">
          <source>Compares the copy of the resource in the cache with the copy on the server.</source>
          <target state="translated">将缓存中的资源副本与服务器上的副本进行比较。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.Revalidate">
          <source>If the copy on the server is newer, it is used to satisfy the request and replaces the copy in the cache.</source>
          <target state="translated">如果服务器上的副本较新，则用它来满足请求并替换缓存中的副本。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.Revalidate">
          <source>If the copy in the cache is the same as the server copy, the cached copy is used.</source>
          <target state="translated">如果缓存中的副本与服务器副本相同，则使用缓存副本。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="F:System.Net.Cache.HttpRequestCacheLevel.Revalidate">
          <source>In the HTTP caching protocol, this is achieved using a conditional request.</source>
          <target state="translated">在 HTTP 缓存协议中，这是通过条件请求来实现的。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>