<Type Name="MenuItem" FullName="System.Windows.Forms.MenuItem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="daa15abe6c23649f0a8d2f4c3ab68922e71f7c78" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39891964" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MenuItem : System.Windows.Forms.Menu" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MenuItem extends System.Windows.Forms.Menu" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.MenuItem" />
  <TypeSignature Language="VB.NET" Value="Public Class MenuItem&#xA;Inherits Menu" />
  <TypeSignature Language="C++ CLI" Value="public ref class MenuItem : System::Windows::Forms::Menu" />
  <TypeSignature Language="F#" Value="type MenuItem = class&#xA;    inherit Menu" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Menu</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示在 <see cref="T:System.Windows.Forms.MainMenu" /> 或 <see cref="T:System.Windows.Forms.ContextMenu" /> 内显示的单个项。 尽管 <see cref="T:System.Windows.Forms.ToolStripMenuItem" /> 替换了早期版本的 <see cref="T:System.Windows.Forms.MenuItem" /> 控件并添加了功能；但是也可选择保留 <see cref="T:System.Windows.Forms.MenuItem" /> 以备向后兼容和将来使用。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了使<xref:System.Windows.Forms.MenuItem>要显示，您必须将其添加到<xref:System.Windows.Forms.MainMenu>或<xref:System.Windows.Forms.ContextMenu>。 若要创建子菜单，可以添加<xref:System.Windows.Forms.MenuItem>对象添加到<xref:System.Windows.Forms.Menu.MenuItems%2A>的父对象<xref:System.Windows.Forms.MenuItem>。  
  
 <xref:System.Windows.Forms.MenuItem>类提供了可配置的外观和功能的菜单项的属性。 若要显示的菜单项旁边的复选标记，请使用<xref:System.Windows.Forms.MenuItem.Checked%2A>属性。 此功能可用于标识互相排斥的菜单项的列表中选定的菜单项。 例如，如果有一组设置中的文本颜色的菜单项<xref:System.Windows.Forms.TextBox>控件，可以使用<xref:System.Windows.Forms.MenuItem.Checked%2A>属性来标识当前选定的颜色。 <xref:System.Windows.Forms.MenuItem.Shortcut%2A>属性可以用于定义某一键盘组合可以按下选择菜单项。  
  
 有关<xref:System.Windows.Forms.MenuItem>多文档界面 (MDI) 应用程序中显示的对象，则可以使用<xref:System.Windows.Forms.MenuItem.MergeMenu%2A>方法要合并的 MDI 菜单与创建合并的菜单结构及其子窗体的父级。 因为<xref:System.Windows.Forms.MenuItem>不能在多个位置在同一时间，如在中重用<xref:System.Windows.Forms.MainMenu>和一个<xref:System.Windows.Forms.ContextMenu>，可以使用<xref:System.Windows.Forms.MenuItem.CloneMenu%2A>方法来创建一份<xref:System.Windows.Forms.MenuItem>在另一个位置中使用。  
  
 <xref:System.Windows.Forms.MenuItem.Popup>事件使您可以执行任务之前将显示一个菜单。 例如，可以创建此事件来显示或隐藏菜单项根据您的代码状态的事件处理程序。 <xref:System.Windows.Forms.MenuItem.Select>事件使您可以执行任务，例如当用户将鼠标指针放在菜单项上的应用程序的菜单项提供的详细的帮助。  
  
   
  
## Examples  
 下面的代码示例创建一个窗体菜单结构。 示例代码将添加<xref:System.Windows.Forms.MenuItem>来表示顶级菜单项中，选择字体大小，将子菜单项添加到它，然后将两个子菜单项添加到表示应用程序中的大型和小型字体选择该菜单项。 该示例需要有<xref:System.Windows.Forms.MainMenu>名为对象`mainMenu1`和四<xref:System.Windows.Forms.MenuItem>对象命名`menuItem1`， `menuItem2`， `menuItem3`，和`menuItem4`。  
  
 [!code-cpp[Classic Menu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu Example/CS/source.cs#1)]
 [!code-vb[Classic Menu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MainMenu" />
    <altmember cref="T:System.Windows.Forms.Menu" />
    <altmember cref="T:System.Windows.Forms.MenuMerge" />
    <altmember cref="T:System.Windows.Forms.ContextMenu" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Forms.MenuItem" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>使用空白标题初始化 <see cref="T:System.Windows.Forms.MenuItem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 创建空白后<xref:System.Windows.Forms.MenuItem>使用此构造函数，可以使用的属性和方法<xref:System.Windows.Forms.MenuItem>类，以指定的外观和行为在<xref:System.Windows.Forms.MenuItem>。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Windows.Forms.MenuItem>使用此版本的构造函数。  
  
 [!code-cpp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">菜单项的标题。</param>
        <summary>使用菜单项的指定标题初始化 <see cref="T:System.Windows.Forms.MenuItem" /> 类的一个新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为菜单项具有指定标题时`text`参数，您还可以指定访问密钥通过前放置一个 & 字符的字符要用作访问键。 例如，若要指定访问密钥"文件"中的"F"，您将指定为菜单项的标题"和文件"。 此功能可用于提供用于在菜单的键盘导航。  
  
 设置`text`到参数"`-`"导致菜单项显示为分隔符 （一条横线），而不是标准菜单项。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Windows.Forms.MenuItem>，在构造它时指定的菜单项的标题。  
  
 [!code-cpp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, onClick As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="text">菜单项的标题。</param>
        <param name="onClick">处理该菜单项的 <see cref="T:System.EventHandler" /> 事件的 <see cref="E:System.Windows.Forms.MenuItem.Click" />。</param>
        <summary>用指定标题和菜单项的 <see cref="E:System.Windows.Forms.MenuItem.Click" /> 事件的事件处理程序初始化该类的一个新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为菜单项具有指定标题时`text`参数，您还可以指定访问密钥通过前放置一个 & 字符用作访问键。 例如，若要指定访问密钥"文件"中的"F"，您将指定为菜单项的标题"和文件"。 此功能可用于提供用于在菜单的键盘导航。  
  
 设置`text`到参数"`-`"导致菜单项显示为分隔符 （一条横线），而不是标准菜单项。  
  
 此外，可以使用此构造函数指定一个委托，它将处理<xref:System.Windows.Forms.MenuItem.Click>正在创建的菜单项的事件。 <xref:System.EventHandler>传递给此构造函数必须将配置为调用的事件处理程序可以处理<xref:System.Windows.Forms.MenuItem.Click>事件。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例将创建<xref:System.Windows.Forms.MenuItem>用指定标题的对象和一个<xref:System.EventHandler>委托连接到的事件处理程序将处理<xref:System.Windows.Forms.MenuItem.Click>菜单项的事件。  
  
 [!code-cpp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, items As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="text">菜单项的标题。</param>
        <param name="items">包含该菜单项的子菜单项的一组 <see cref="T:System.Windows.Forms.MenuItem" /> 对象。</param>
        <summary>用指定标题和为菜单项定义的一组子菜单项初始化该类的一个新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为菜单项具有指定标题时`text`参数，您还可以指定访问密钥通过前放置一个 & 字符用作访问键。 例如，若要指定访问密钥"文件"中的"F"，您将指定为菜单项的标题"和文件"。 此功能可用于提供用于在菜单的键盘导航。  
  
 设置`text`到参数"`-`"导致菜单项显示为分隔符 （一条横线），而不是标准菜单项。  
  
 `items`参数使你可以分配来定义此菜单项的子菜单的菜单项的数组。 数组中的每个项还可以分配给它的菜单项的数组。 这使您创建完整的菜单结构，并将其分配为菜单项的构造函数。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例创建一个对象用指定标题，连接到将处理的事件的方法的事件处理程序每个菜单项中的子菜单项的数组。  
  
 [!code-cpp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick, System.Windows.Forms.Shortcut shortcut);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick, valuetype System.Windows.Forms.Shortcut shortcut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler,System.Windows.Forms.Shortcut)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick, System::Windows::Forms::Shortcut shortcut);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler * System.Windows.Forms.Shortcut -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick, shortcut)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
      </Parameters>
      <Docs>
        <param name="text">菜单项的标题。</param>
        <param name="onClick">处理该菜单项的 <see cref="T:System.EventHandler" /> 事件的 <see cref="E:System.Windows.Forms.MenuItem.Click" />。</param>
        <param name="shortcut">
          <see cref="T:System.Windows.Forms.Shortcut" /> 值之一。</param>
        <summary>用指定标题、事件处理程序和菜单项的关联快捷键初始化该类的一个新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为菜单项具有指定标题时`text`参数，您还可以指定访问密钥通过前放置一个 & 字符用作访问键。 例如，若要指定访问密钥"文件"中的"F"，您将指定为菜单项的标题"和文件"。 此功能可用于提供用于在菜单的键盘导航。 此构造函数还可以指定除了访问密钥，以提供键盘导航的快捷键。 键盘快捷方式，可以指定可用于激活该菜单项的键的组合。  
  
 设置`text`到参数"`-`"导致菜单项显示为分隔符 （一条横线），而不是标准菜单项。  
  
 此外，可以使用此构造函数指定一个委托，它将处理<xref:System.Windows.Forms.MenuItem.Click>正在创建的菜单项的事件。 <xref:System.EventHandler>传递给此构造函数必须将配置为调用的事件处理程序可以处理<xref:System.Windows.Forms.MenuItem.Click>事件。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例创建一个对象具有指定的标题、 快捷方式键和事件处理程序连接到将处理菜单项的事件的方法。  
  
 [!code-cpp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (System.Windows.Forms.MenuMerge mergeType, int mergeOrder, System.Windows.Forms.Shortcut shortcut, string text, EventHandler onClick, EventHandler onPopup, EventHandler onSelect, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Forms.MenuMerge mergeType, int32 mergeOrder, valuetype System.Windows.Forms.Shortcut shortcut, string text, class System.EventHandler onClick, class System.EventHandler onPopup, class System.EventHandler onSelect, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.Windows.Forms.MenuMerge,System.Int32,System.Windows.Forms.Shortcut,System.String,System.EventHandler,System.EventHandler,System.EventHandler,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::Windows::Forms::MenuMerge mergeType, int mergeOrder, System::Windows::Forms::Shortcut shortcut, System::String ^ text, EventHandler ^ onClick, EventHandler ^ onPopup, EventHandler ^ onSelect, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : System.Windows.Forms.MenuMerge * int * System.Windows.Forms.Shortcut * string * EventHandler * EventHandler * EventHandler * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (mergeType, mergeOrder, shortcut, text, onClick, onPopup, onSelect, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mergeType" Type="System.Windows.Forms.MenuMerge" />
        <Parameter Name="mergeOrder" Type="System.Int32" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="onPopup" Type="System.EventHandler" />
        <Parameter Name="onSelect" Type="System.EventHandler" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="mergeType">
          <see cref="T:System.Windows.Forms.MenuMerge" /> 值之一。</param>
        <param name="mergeOrder">此菜单项在合并菜单中将占有的相对位置。</param>
        <param name="shortcut">
          <see cref="T:System.Windows.Forms.Shortcut" /> 值之一。</param>
        <param name="text">菜单项的标题。</param>
        <param name="onClick">处理该菜单项的 <see cref="T:System.EventHandler" /> 事件的 <see cref="E:System.Windows.Forms.MenuItem.Click" />。</param>
        <param name="onPopup">处理该菜单项的 <see cref="T:System.EventHandler" /> 事件的 <see cref="E:System.Windows.Forms.MenuItem.Popup" />。</param>
        <param name="onSelect">处理该菜单项的 <see cref="T:System.EventHandler" /> 事件的 <see cref="E:System.Windows.Forms.MenuItem.Select" />。</param>
        <param name="items">包含该菜单项的子菜单项的一组 <see cref="T:System.Windows.Forms.MenuItem" /> 对象。</param>
        <summary>用指定标题、为（<see cref="T:System.Windows.Forms.MenuItem" />、<see cref="E:System.Windows.Forms.MenuItem.Click" /> 和 <see cref="E:System.Windows.Forms.MenuItem.Select" />）事件定义的事件处理程序、快捷键、合并类型和为菜单项指定的顺序来初始化 <see cref="E:System.Windows.Forms.MenuItem.Popup" /> 类的一个新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为菜单项具有指定标题时`text`参数，您还可以指定访问密钥通过前放置一个 & 字符用作访问键。 例如，若要指定访问密钥"文件"中的"F"，您将指定为菜单项的标题"和文件"。 此功能可用于提供用于在菜单的键盘导航。  
  
 设置`text`到参数"`-`"导致菜单项显示为分隔符 （一条横线），而不是标准菜单项。  
  
 `items`参数使你可以分配来定义此菜单项的子菜单的菜单项的数组。 数组中的每个项还可以分配给它的菜单项的数组。 这使您创建完整的菜单结构，并将其分配为菜单项的构造函数。  
  
 `mergeType`和`mergeOrder`参数可用于确定此菜单项与另一个菜单合并的菜单项时的行为。 为指定具体取决于值`mergeType`参数，您可以添加、 删除、 替换，或合并的菜单项和与使用合并的菜单及其子菜单项。 `mergeOrder`参数用于确定正在创建的菜单项在菜单合并时的放置位置。  
  
 此外，您可以使用此构造函数创建<xref:System.Windows.Forms.MenuItem>，并将其连接到在代码中的将处理菜单项的单击事件处理程序。 <xref:System.EventHandler>将传入此构造函数应配置为调用的事件处理程序可以处理<xref:System.Windows.Forms.MenuItem.Click>事件。 通过使用此构造函数版本，还可以连接<xref:System.Windows.Forms.MenuItem.Popup>和<xref:System.Windows.Forms.MenuItem.Select>事件，以确定何时选择此菜单项。 这些事件可用于任务，例如确定显示子菜单项旁边的复选标记或以启用或禁用基于应用程序状态的菜单项。 <xref:System.Windows.Forms.MenuItem.Select>并<xref:System.Windows.Forms.MenuItem.Click>将仅对引发事件<xref:System.Windows.Forms.MenuItem>对象不是父菜单项。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例创建具有标题和快捷方式的菜单项。 菜单项还具有为定义的事件处理程序<xref:System.Windows.Forms.MenuItem.Popup>， <xref:System.Windows.Forms.MenuItem.Click>，和<xref:System.Windows.Forms.MenuItem.Select>事件。 如果此菜单项合并，它将具有零的合并顺序菜单添加菜单项。  
  
 [!code-cpp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Popup" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Select" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="BarBreak">
      <MemberSignature Language="C#" Value="public bool BarBreak { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BarBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.BarBreak" />
      <MemberSignature Language="VB.NET" Value="Public Property BarBreak As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BarBreak { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BarBreak : bool with get, set" Usage="System.Windows.Forms.MenuItem.BarBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示是将 <see cref="T:System.Windows.Forms.MenuItem" /> 放在新行上（对于添加到 <see cref="T:System.Windows.Forms.MainMenu" /> 对象的菜单项），还是放在新列中（对于 <see cref="T:System.Windows.Forms.ContextMenu" /> 中显示的子菜单项或菜单项）。</summary>
        <value>如果菜单项放在新行上或新列中，则为 <see langword="true" />；如果菜单项保持在其默认位置，则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用<xref:System.Windows.Forms.MenuItem.BarBreak%2A>属性创建一个菜单，每个菜单项旁边彼此而不是水平放置垂直列表中。 此属性还可用于创建菜单栏包含多个行的顶级菜单项。  
  
 此属性不同于<xref:System.Windows.Forms.MenuItem.Break%2A>属性中每个菜单项的左边缘上会显示一个条形，具有<xref:System.Windows.Forms.MenuItem.Break%2A>属性设置为`true`。 当菜单项不是顶级菜单项时，仅显示在栏。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Windows.Forms.MenuItem>具有两个子菜单项。 这两个子菜单项水平显示而不是使用垂直<xref:System.Windows.Forms.MenuItem.BarBreak%2A>属性。  
  
 [!code-cpp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.BarBreak Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Break" />
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public bool Break { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Break" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Break" />
      <MemberSignature Language="VB.NET" Value="Public Property Break As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Break { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Break : bool with get, set" Usage="System.Windows.Forms.MenuItem.Break" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示是将该项放在新行上（对于添加到 <see cref="T:System.Windows.Forms.MainMenu" /> 对象的菜单项），还是放在新列中（对于 <see cref="T:System.Windows.Forms.ContextMenu" /> 中显示的菜单项或子菜单项）。</summary>
        <value>如果菜单项放在新行上或新列中，则为 <see langword="true" />；如果菜单项保持在其默认位置，则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用<xref:System.Windows.Forms.MenuItem.Break%2A>属性创建一个菜单，每个菜单彼此而不是水平放置垂直列表中。 此属性还可用于创建菜单栏包含多个行的顶级菜单项。  
  
   
  
## Examples  
 下面的代码示例使用两个顶级菜单项在最上面一行和一个菜单项，最后一行上创建一个菜单。  
  
 [!code-cpp[Classic MenuItem.Break Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Break Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Break Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Break Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.BarBreak" />
      </Docs>
    </Member>
    <Member MemberName="Checked">
      <MemberSignature Language="C#" Value="public bool Checked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Checked" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Checked" />
      <MemberSignature Language="VB.NET" Value="Public Property Checked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Checked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Checked : bool with get, set" Usage="System.Windows.Forms.MenuItem.Checked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示选中标记是否出现在菜单项文本的旁边。</summary>
        <value>如果菜单项旁边有一个选中标记，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用<xref:System.Windows.Forms.MenuItem.Checked%2A>组合中具有要提供应用程序状态中的菜单中的其他菜单项的属性。 例如，可以将复选标记放置在一组项以标识要显示的应用程序中的文本的字体大小的菜单项上。 此外可以使用<xref:System.Windows.Forms.MenuItem.Checked%2A>属性标识一组互相排斥的菜单项中的选定的菜单项。  
  
> [!NOTE]
>  无法将此属性设置为`true`对于顶级菜单项。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.Forms.MenuItem.Checked%2A>属性以提供应用程序中的状态。 在此示例中，用一组菜单项来指定中的文本的颜色<xref:System.Windows.Forms.TextBox>控件。 使用提供的事件处理程序<xref:System.Windows.Forms.MenuItem.Click>的三个菜单项的事件。 每个菜单项指定的文本颜色`menuItemRed`（红色）， `menuItemGreen` （绿色），或`menuItemBlue`（蓝色）。 事件处理程序确定被单击的菜单项，将放置到所选的菜单项，一个复选标记并更改窗体的文本颜色<xref:System.Windows.Forms.TextBox>控件。 该示例需要<xref:System.Drawing>命名空间添加到此代码放置在窗体。 该示例还需要<xref:System.Windows.Forms.TextBox>已添加到窗体，此示例代码位于名为`textBox1`。  
  
 [!code-cpp[Classic MenuItem.Checked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Checked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Checked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Checked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Windows.Forms.MenuItem" /> 是顶级菜单，或有子级。</exception>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当单击菜单项或使用为该菜单项定义的快捷键或访问键选择菜单项时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem.Click>事件发生时这<xref:System.Windows.Forms.MenuItem>用户单击。 此事件还会发生，如果用户选择菜单项使用键盘，按 Enter 键。 它也可能按快捷键关联<xref:System.Windows.Forms.MenuItem>。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
> [!NOTE]
>  如果<xref:System.Windows.Forms.Menu.MenuItems%2A>属性<xref:System.Windows.Forms.MenuItem>包含任何项，不会引发此事件。 对于父菜单项不引发此事件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.MenuItem.Click>事件，以便执行任务时<xref:System.Windows.Forms.MenuItem>单击。 此示例将创建<xref:System.Windows.Forms.MainMenu>称为`mainMenu1`并添加两个<xref:System.Windows.Forms.MenuItem>对象， `topMenuItem` (`File`) 和`menuItem1`(`Open`)。 然后它会连接`Click`事件`menuItem1_Click`事件处理程序。 当用户单击`Open`菜单项<xref:System.Windows.Forms.OpenFileDialog>初始化，并且会显示。 该示例需要您已创建<xref:System.Windows.Forms.Form>名为`Form1`。  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CloneMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建 <see cref="T:System.Windows.Forms.MenuItem" /> 的副本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem CloneMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem CloneMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CloneMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ CloneMenu();" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.CloneMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建当前 <see cref="T:System.Windows.Forms.MenuItem" /> 的副本。</summary>
        <returns>表示重复菜单项的 <see cref="T:System.Windows.Forms.MenuItem" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem> 对象不能使用在多个位置中，除非你获取一份<xref:System.Windows.Forms.MenuItem>。 可以调用此方法以创建在中使用此菜单项的副本<xref:System.Windows.Forms.ContextMenu>， <xref:System.Windows.Forms.MainMenu>，或其他<xref:System.Windows.Forms.MenuItem>应用程序中。 当克隆的菜单项时，原始的菜单项中指定任何事件处理程序将继续在菜单项的克隆版本中正常工作。 例如，如果您创建<xref:System.Windows.Forms.MenuItem>并已连接其<xref:System.Windows.Forms.MenuItem.Click>到事件处理程序的事件。 当克隆菜单项时，克隆的菜单项将调用相同的事件处理程序。  
  
   
  
## Examples  
 下面的代码示例克隆<xref:System.Windows.Forms.MenuItem>并将其显示<xref:System.Windows.Forms.ContextMenu>。 该示例需要<xref:System.Windows.Forms.MenuItem>中存在<xref:System.Windows.Forms.MainMenu>上具有的名称的窗体`menuItem1`并且<xref:System.Windows.Forms.ContextMenu>对象名为`contextMenu1`也存在于窗体上。  
  
 [!code-cpp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="protected void CloneMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CloneMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CloneMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CloneMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.CloneMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">表示要复制的菜单项的 <see cref="T:System.Windows.Forms.MenuItem" />。</param>
        <summary>创建指定 <see cref="T:System.Windows.Forms.MenuItem" /> 的副本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法来创建已创建的快捷菜单或另一个菜单结构中使用应用程序中的菜单项的副本。 此版本的<xref:System.Windows.Forms.MenuItem.CloneMenu%2A>可以指定特定<xref:System.Windows.Forms.MenuItem>复制而不是调用方法的菜单项。 可以使用此方法以初始化新<xref:System.Windows.Forms.MenuItem>对象的另一个副本<xref:System.Windows.Forms.MenuItem>。 当克隆的菜单项时，原始的菜单项中指定任何事件处理程序将继续在菜单项的克隆版本中正常工作。 例如，如果您创建<xref:System.Windows.Forms.MenuItem>并已连接其<xref:System.Windows.Forms.MenuItem.Click>到事件处理程序的事件。 当克隆菜单项时，克隆的菜单项将调用相同的事件处理程序。  
  
   
  
## Examples  
 下面的代码示例初始化新<xref:System.Windows.Forms.MenuItem>副本的现有<xref:System.Windows.Forms.MenuItem>中使用的<xref:System.Windows.Forms.MainMenu>窗体上。 然后代码将添加克隆<xref:System.Windows.Forms.MenuItem>到<xref:System.Windows.Forms.ContextMenu>窗体上。 此示例需要<xref:System.Windows.Forms.MenuItem>已创建并命名为`menuItem1`并且<xref:System.Windows.Forms.ContextMenu>创建控件并将其命名为`contextMenu1`。  
  
 [!code-cpp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultItem">
      <MemberSignature Language="C#" Value="public bool DefaultItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DefaultItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultItem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DefaultItem { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultItem : bool with get, set" Usage="System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示菜单项是否为默认菜单项。</summary>
        <value>如果菜单项是菜单中的默认菜单项，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 含有一个菜单的默认菜单项。 当用户双击子菜单，其中包含默认项、 默认项被选定，和子菜单已关闭。 可以使用<xref:System.Windows.Forms.MenuItem.DefaultItem%2A>属性以指示应在菜单或快捷菜单中的默认操作。  
  
   
  
## Examples  
 下面的代码示例创建两个子菜单项与菜单项。 该示例设置`menuItem2`作为默认菜单项使用<xref:System.Windows.Forms.MenuItem.DefaultItem%2A>属性。  
  
 [!code-cpp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="menuItem.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>处置由 <see cref="T:System.Windows.Forms.MenuItem" /> 占用的资源（内存除外）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完成使用 <xref:System.Windows.Forms.MenuItem.Dispose%2A> 后，应调用 <xref:System.Windows.Forms.MenuItem>。 <xref:System.Windows.Forms.MenuItem.Dispose%2A> 方法使 <xref:System.Windows.Forms.MenuItem> 处于不可用状态。 在调用<xref:System.Windows.Forms.MenuItem.Dispose%2A>，必须释放对所有引用<xref:System.Windows.Forms.MenuItem>以便可以通过垃圾回收回收其占用的内存。  
  
> [!NOTE]
>  每次释放对 <xref:System.Windows.Forms.MenuItem.Dispose%2A> 的最后一个引用前，均应调用 <xref:System.Windows.Forms.MenuItem>。 否则为资源<xref:System.Windows.Forms.MenuItem>是使用之前，不会释放垃圾回收调用<xref:System.Windows.Forms.MenuItem>对象的析构函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DrawItemEventHandler DrawItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DrawItemEventHandler DrawItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.DrawItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DrawItem As DrawItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DrawItemEventHandler ^ DrawItem;" />
      <MemberSignature Language="F#" Value="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " Usage="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当菜单项的 <see cref="P:System.Windows.Forms.MenuItem.OwnerDraw" /> 属性设置为 <see langword="true" /> 并且发出绘制菜单项的请求时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DrawItemEventArgs>自变量传递给<xref:System.Windows.Forms.MenuItem.DrawItem>事件处理程序提供了<xref:System.Drawing.Graphics>使您可以执行绘制和图面上的菜单项的其他图形操作的对象。 此事件处理程序可用于创建满足你的应用程序的需求的自定义菜单。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何处理<xref:System.Windows.Forms.MenuItem.DrawItem>事件。 此示例绘制一个菜单项使用<xref:System.Drawing.Brush>和一个<xref:System.Drawing.Font>，，然后绘制<xref:System.Drawing.Rectangle>菜单项的周围。 通过执行绘图<xref:System.Drawing.Graphics>对象传递给事件处理程序中<xref:System.Windows.Forms.DrawItemEventArgs>参数。 此示例要求您已初始化<xref:System.Windows.Forms.MenuItem.OwnerDraw%2A>到项的属性， `true`。 对于 C# 示例中，将窗体的构造函数中的以下代码添加后`InitializeComponent`，以便挂钩事件：  
  
 `this.menuItem1.DrawItem += new DrawItemEventHandler(menuItem1_DrawItem);`  
  
 [!code-cpp[OwnerDraw example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/OwnerDraw example/CPP/form1.cpp#1)]
 [!code-csharp[OwnerDraw example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/OwnerDraw example/CS/form1.cs#1)]
 [!code-vb[OwnerDraw example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/OwnerDraw example/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.MenuItem.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示菜单项是否启用。</summary>
        <value>如果启用菜单项，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Windows.Forms.MenuItem>，它是以灰色，以指示其状态显示已禁用。 当父菜单项被禁用时，不显示所有子菜单项。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.MenuItem.Popup>事件以确定是否<xref:System.Windows.Forms.MenuItem>中所显示的菜单显示之前启用支持剪切、 复制和删除操作的对象。 该示例确定是否`textBox1`、 一个<xref:System.Windows.Forms.TextBox>控制窗体上，启用了、 具有输入焦点，并且具有在启用之前所选文本<xref:System.Windows.Forms.MenuItem>对象。 此示例要求三个<xref:System.Windows.Forms.MenuItem>对象所创建的名为`menuCut`， `menuCopy`，和`menuDelete`已创建。  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Index">
      <MemberSignature Language="C#" Value="public int Index { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Index" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Index" />
      <MemberSignature Language="VB.NET" Value="Public Property Index As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Index { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Index : int with get, set" Usage="System.Windows.Forms.MenuItem.Index" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示菜单项在其父菜单中的位置。</summary>
        <value>表示菜单项在其父菜单中位置的从零开始的索引。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性提供其父菜单的菜单项集合中的菜单项的索引的位置。 可以使用此属性来重新定位其菜单内的不同位置的菜单项。 创建时，还可以使用此属性<xref:System.Windows.Forms.MenuItem>能够在创建时指定其菜单结构中的位置。  
  
   
  
## Examples  
 下面的代码示例会将两个菜单项的菜单中的位置。 下面的代码示例要求将两个<xref:System.Windows.Forms.MenuItem>对象所创建的名为`menuItem1`和`menuItem2`。 `menuItem1`菜单项将下移一个位置的菜单中，而`menuItem2`将上移一个位置。  
  
 [!code-cpp[Classic MenuItem.Index Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Index Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Index Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Index Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">赋值小于零或大于项的数目。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsParent">
      <MemberSignature Language="C#" Value="public override bool IsParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.IsParent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsParent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsParent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsParent : bool" Usage="System.Windows.Forms.MenuItem.IsParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示菜单项是否包含子菜单项。</summary>
        <value>如果菜单项包含子菜单项，则为 <see langword="true" />；如果菜单为独立菜单项，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用此属性与<xref:System.Windows.Forms.MenuItem.Parent%2A>属性以在代码中通过整个菜单结构中导航。  
  
   
  
## Examples  
 下面的代码示例确定是否有任何子菜单与相关联<xref:System.Windows.Forms.MenuItem>名为`menuItem1`。 如果存在任何子菜单，它会禁用它们通过设置<xref:System.Windows.Forms.MenuItem.Enabled%2A>属性设置为`false`。 该示例需要有<xref:System.Windows.Forms.MenuItem>创建的名为`menuItem1`。  
  
 [!code-cpp[Classic MenuItem.IsParent Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.IsParent Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.IsParent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiList">
      <MemberSignature Language="C#" Value="public bool MdiList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MdiList" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MdiList" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MdiList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MdiList : bool with get, set" Usage="System.Windows.Forms.MenuItem.MdiList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示是否使用在关联窗体内显示的多文档界面 (MDI) 子窗口列表来填充菜单项。</summary>
        <value>如果要在此菜单项中显示 MDI 子窗口列表，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 选择菜单项以显示 MDI 子窗口列表，列表显示为子菜单的菜单项。 仅定义为 MDI 子窗体的窗体窗口列表中显示。 仅有九个子窗口可以显示一次。 如果有多个九个显示的子窗口，"更多 Windows..."菜单项显示在窗口列表的末尾。 单击此菜单项显示一个带有的完整列表的子窗口的当前处于活动状态的对话框。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Windows.Forms.MenuItem>，用来显示当前打开的 MDI 子窗体的列表中的 MDI 窗体。  
  
 [!code-cpp[Classic MenuItem.MdiList Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MdiList Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MdiList Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MeasureItemEventHandler MeasureItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MeasureItemEventHandler MeasureItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.MeasureItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MeasureItem As MeasureItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MeasureItemEventHandler ^ MeasureItem;" />
      <MemberSignature Language="F#" Value="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " Usage="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MeasureItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当菜单在绘制菜单项之前需要知道菜单项大小时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了使引发此事件，必须具有<xref:System.Windows.Forms.MenuItem.OwnerDraw%2A>菜单项的属性设置为`true`。 绘制所有者描述的菜单的菜单项的大小允许指定要绘制前引发此事件。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.MenuItem.MeasureItem>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.MenuItem>名为`MenuItem1`。 然后，确保事件处理程序相关联<xref:System.Windows.Forms.MenuItem.MeasureItem>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#499](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#499)]
 [!code-vb[System.Windows.Forms.EventExamples#499](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#499)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="MenuID">
      <MemberSignature Language="C#" Value="protected int MenuID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MenuID" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MenuID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property MenuID As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int MenuID { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MenuID : int" Usage="System.Windows.Forms.MenuItem.MenuID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示此菜单项的 Windows 标识符。</summary>
        <value>此菜单项的 Windows 标识符。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MergeMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此 <see cref="T:System.Windows.Forms.MenuItem" /> 与另一个 <see cref="T:System.Windows.Forms.MenuItem" /> 合并。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem MergeMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem MergeMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MergeMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ MergeMenu();" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.MergeMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此 <see cref="T:System.Windows.Forms.MenuItem" /> 与另一个 <see cref="T:System.Windows.Forms.MenuItem" /> 合并并返回合并后的 <see cref="T:System.Windows.Forms.MenuItem" />。</summary>
        <returns>表示合并菜单项的 <see cref="T:System.Windows.Forms.MenuItem" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用此版本的<xref:System.Windows.Forms.MenuItem.MergeMenu%2A>，则<xref:System.Windows.Forms.MenuItem>返回是当前菜单项可以合并使用而不会影响当前项的功能的另一个菜单项的副本。 此版本的<xref:System.Windows.Forms.MenuItem.MergeMenu%2A>方法是类似于调用<xref:System.Windows.Forms.MenuItem.CloneMenu%2A>不包含任何参数的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public void MergeMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MergeMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MergeMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MergeMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.MergeMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">指定要与该菜单项合并的菜单项的 <see cref="T:System.Windows.Forms.MenuItem" />。</param>
        <summary>将另一菜单项与该菜单项合并。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 菜单项合并的菜单项的值根据<xref:System.Windows.Forms.MenuItem.MergeType%2A>和<xref:System.Windows.Forms.MenuItem.MergeOrder%2A>属性。 此版本的<xref:System.Windows.Forms.MenuItem.MergeMenu%2A>方法，可以合并两个<xref:System.Windows.Forms.MenuItem>为单个菜单对象 （和它们的子菜单）。 多文档界面 (MDI) 父窗体和子级都具有菜单时，将自动处理菜单合并。 可以使用此版本的合并两个方法<xref:System.Windows.Forms.MenuItem>对象 （和及其子菜单项） 中的位置<xref:System.Windows.Forms.MainMenu>为单个菜单中的控件<xref:System.Windows.Forms.ContextMenu>。 例如，可以调用此版本的<xref:System.Windows.Forms.MenuItem.MergeMenu%2A>方法以将文件和编辑菜单的菜单项合并到单个<xref:System.Windows.Forms.MenuItem>，可添加到和显示<xref:System.Windows.Forms.ContextMenu>。  
  
   
  
## Examples  
 下面的代码示例使用此版本的<xref:System.Windows.Forms.MenuItem.MergeMenu%2A>方法来创建一份<xref:System.Windows.Forms.MenuItem>并将其合并与另一个。 合并<xref:System.Windows.Forms.MenuItem>随后将添加到<xref:System.Windows.Forms.ContextMenu>控件。 此示例需要有两个菜单项，称为`menuItem1`并`menuItem2`包含其中的子菜单项和一个<xref:System.Windows.Forms.ContextMenu>名为`contextMenu1`来显示菜单项。 `menuItem1` 和`menuItem2`具有其中所包含的不同的菜单项。 在调用<xref:System.Windows.Forms.MenuItem.MergeMenu%2A>进行时，合并创建菜单。  
  
 [!code-cpp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeOrder">
      <MemberSignature Language="C#" Value="public int MergeOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MergeOrder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeOrder As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MergeOrder { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MergeOrder : int with get, set" Usage="System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示菜单项与另一个项合并时的相对位置。</summary>
        <value>表示该菜单项的合并顺序位置的从零开始的索引。 默认值为 0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 菜单项的合并顺序指定如果菜单结构，将需要此菜单项的相对位置<xref:System.Windows.Forms.MenuItem>包含在合并与另一个。  
  
   
  
## Examples  
 下面的代码示例演示了如何使用<xref:System.Windows.Forms.MenuItem.MergeOrder%2A>属性来控制合并的菜单的显示的方式。 这是一个完整的示例，准备好运行后将其添加到你的项目。  
  
 [!code-cpp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="M:System.Windows.Forms.MenuItem.MergeMenu" />
      </Docs>
    </Member>
    <Member MemberName="MergeType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuMerge MergeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.MenuMerge MergeType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeType" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeType As MenuMerge" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuMerge MergeType { System::Windows::Forms::MenuMerge get(); void set(System::Windows::Forms::MenuMerge value); };" />
      <MemberSignature Language="F#" Value="member this.MergeType : System.Windows.Forms.MenuMerge with get, set" Usage="System.Windows.Forms.MenuItem.MergeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuMerge</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示该菜单项的菜单与另一个菜单合并时该菜单项的行为。</summary>
        <value>一个 <see cref="T:System.Windows.Forms.MenuMerge" /> 值，该值表示菜单项的合并类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 菜单项的合并类型指示菜单项时它具有另一个要合并的菜单项的合并顺序相同的行为。 合并的菜单可用于创建基于两个或多个现有菜单合并的菜单。  
  
   
  
## Examples  
 下面的代码示例将创建<xref:System.Windows.Forms.MenuItem>与<xref:System.Windows.Forms.MenuItem.MergeType%2A>和<xref:System.Windows.Forms.MenuItem.MergeOrder%2A>指定菜单项添加到第一个位置处的合并菜单。  
  
 [!code-cpp[Classic MenuItem.MergeType Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeType Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">分配的值不是 <see cref="T:System.Windows.Forms.MenuMerge" /> 值之一。</exception>
        <altmember cref="T:System.Windows.Forms.MenuMerge" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="Mnemonic">
      <MemberSignature Language="C#" Value="public char Mnemonic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Mnemonic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mnemonic As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char Mnemonic { char get(); };" />
      <MemberSignature Language="F#" Value="member this.Mnemonic : char" Usage="System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示与此菜单项关联的助记字符。</summary>
        <value>表示与此菜单项关联的助记字符的字符。 如果在 <see cref="T:System.Windows.Forms.MenuItem" /> 的文本中没有指定助记字符，则返回空字符（ASCII 值为 0）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 助记键字符等于第一个字符的文本中后一个 & 号字符 (&) <xref:System.Windows.Forms.MenuItem>。 此属性将返回助记键，如果两个 & 符它们放在一起使用 & 符的文本中显示 & 符<xref:System.Windows.Forms.MenuItem>而不是定义助记键字符。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Text" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="menuItem.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.MenuItem.Click" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.MenuItem.Click>事件，以便执行任务时<xref:System.Windows.Forms.MenuItem>单击。 此示例将创建<xref:System.Windows.Forms.MainMenu>称为`mainMenu1`并添加两个<xref:System.Windows.Forms.MenuItem>对象， `topMenuItem` (`File`) 和`menuItem1`(`Open`)。 然后它会连接`Click`事件`menuItem1_Click`事件处理程序。 当用户单击`Open`菜单项<xref:System.Windows.Forms.OpenFileDialog>初始化，并且会显示。 该示例需要您已创建<xref:System.Windows.Forms.Form>名为`Form1`。  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDrawItem">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawItem (System.Windows.Forms.DrawItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawItem(class System.Windows.Forms.DrawItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawItem (e As DrawItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawItem(System::Windows::Forms::DrawItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit&#xA;override this.OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit" Usage="menuItem.OnDrawItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DrawItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.DrawItemEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.MenuItem.DrawItem" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />方法。</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DrawItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInitMenuPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnInitMenuPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitMenuPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnInitMenuPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitMenuPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitMenuPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitMenuPopup : EventArgs -&gt; unit&#xA;override this.OnInitMenuPopup : EventArgs -&gt; unit" Usage="menuItem.OnInitMenuPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.MenuItem.Popup" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMeasureItem">
      <MemberSignature Language="C#" Value="protected virtual void OnMeasureItem (System.Windows.Forms.MeasureItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMeasureItem(class System.Windows.Forms.MeasureItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMeasureItem (e As MeasureItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMeasureItem(System::Windows::Forms::MeasureItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit&#xA;override this.OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit" Usage="menuItem.OnMeasureItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MeasureItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.MeasureItemEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.MenuItem.MeasureItem" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />方法。</para>
        </block>
        <altmember cref="T:System.Windows.Forms.MeasureItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPopup : EventArgs -&gt; unit&#xA;override this.OnPopup : EventArgs -&gt; unit" Usage="menuItem.OnPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.MenuItem.Popup" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.MenuItem.Popup>事件以确定是否<xref:System.Windows.Forms.MenuItem>中所显示的菜单显示之前启用支持剪切、 复制和删除操作的对象。 该示例确定是否`textBox1`、 一个<xref:System.Windows.Forms.TextBox>控制窗体上，启用了、 具有输入焦点，并且具有在启用之前所选文本<xref:System.Windows.Forms.MenuItem>对象。 此示例要求三个<xref:System.Windows.Forms.MenuItem>对象所创建的名为`menuCut`， `menuCopy`，和`menuDelete`已创建。  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSelect">
      <MemberSignature Language="C#" Value="protected virtual void OnSelect (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelect(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelect (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelect(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelect : EventArgs -&gt; unit&#xA;override this.OnSelect : EventArgs -&gt; unit" Usage="menuItem.OnSelect e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.MenuItem.Select" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.MenuItem.Select>的事件<xref:System.Windows.Forms.MenuItem>类，以将分配到的帮助文本<xref:System.Windows.Forms.StatusBarPanel>的<xref:System.Windows.Forms.StatusBar>控件。 此示例需要<xref:System.Windows.Forms.MenuItem>名为的对象`menuOpen`， `menuSave`，和`menuExit`添加到<xref:System.Windows.Forms.MainMenu>窗体上的控件。 该示例还需要<xref:System.Windows.Forms.StatusBar>控件，名为`statusBar1`已添加到窗体。 <xref:System.Windows.Forms.StatusBar>控制应包含<xref:System.Windows.Forms.StatusBarPanel>。  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OwnerDraw">
      <MemberSignature Language="C#" Value="public bool OwnerDraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OwnerDraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberSignature Language="VB.NET" Value="Public Property OwnerDraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OwnerDraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDraw : bool with get, set" Usage="System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个字值，通过该值指示是由所提供的代码绘制菜单项还是由 Windows 绘制菜单项。</summary>
        <value>如果使用代码绘制菜单项，则为 <see langword="true" />；如果由 Windows 绘制菜单项，则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Windows.Forms.MenuItem.OwnerDraw%2A>属性设置为`true`，您需要处理的菜单项的所有绘图。 此功能可用于创建您自己的专用菜单显示。  
  
   
  
## Examples  
 下面的代码示例演示具有一个所有者描述菜单项的菜单。 此示例设置<xref:System.Windows.Forms.MenuItem.OwnerDraw%2A>属性，并使用`AddHandler`语句和`AddressOf`运算符来指定一个委托来处理<xref:System.Windows.Forms.MenuItem.DrawItem>事件。 若要运行该示例，请将其粘贴在导入的窗体<xref:System>， <xref:System.Windows.Forms>，和<xref:System.Drawing>命名空间。 调用`InitializeMenu`从窗体的构造函数或`Load`方法。  
  
 [!code-cpp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Menu Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Menu Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Menu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Menu ^ Parent { System::Windows::Forms::Menu ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Menu" Usage="System.Windows.Forms.MenuItem.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Menu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示包含此菜单项的菜单。</summary>
        <value>表示包含此菜单项的菜单的 <see cref="T:System.Windows.Forms.Menu" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用此属性以获取<xref:System.Windows.Forms.Menu>子菜单的对象。 可以强制转换<xref:System.Windows.Forms.Menu>到此属性返回的对象<xref:System.Windows.Forms.MenuItem>对象对其进行操作。  
  
   
  
## Examples  
 在此示例中，将创建主菜单和一个顶级菜单项， `menuItem1` (`File`)。 你还创建两个菜单项，请`menuItem2`(`New`) 和`menuItem3`(`Open`)，并将其添加到菜单项列表的`menuItem1`。 然后检查以查看是否`menuItem3`有父菜单上，为 true，并显示此父菜单的信息在消息框中。 此示例要求您已创建<xref:System.Windows.Forms.Form>名为`Form1`。  
  
 [!code-cpp[ParentMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentMenu/CPP/form1.cpp#1)]
 [!code-csharp[ParentMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentMenu/CS/form1.cs#1)]
 [!code-vb[ParentMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformClick">
      <MemberSignature Language="C#" Value="public void PerformClick ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformClick" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformClick ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformClick();" />
      <MemberSignature Language="F#" Value="member this.PerformClick : unit -&gt; unit" Usage="menuItem.PerformClick " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为 <see cref="E:System.Windows.Forms.Control.Click" /> 生成一个 <see cref="T:System.Windows.Forms.MenuItem" /> 事件，模拟用户的单击操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此菜单可用于通过代码的菜单项激活而不传递任何事件信息。 例如，如果你想要激活菜单项上发生在应用程序中，可以调用一个操作基于<xref:System.Windows.Forms.MenuItem.PerformClick%2A>方法的<xref:System.Windows.Forms.MenuItem>。  
  
   
  
## Examples  
 在此示例中以编程方式通过单击菜单项`PerformClick`方法。 首先，创建主菜单 (`mainMenu1`) 并向其中添加两个菜单项，请`menuItem1`(`File`) 和`menuItem2`(`Edit`)。 此外使用<xref:System.Windows.Forms.MenuItem.Click>事件以将数据发送到事件处理程序中，单击菜单项时。 然后，使用`PerformClick`方法来单击`File`菜单项。 当启动应用程序，`File`激活菜单项，并且一个消息框包含文本"文件菜单上单击。 在屏幕上显示。 该示例需要您已创建<xref:System.Windows.Forms.Form>名为`Form1`。  
  
 [!code-cpp[PerformClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformClick/CPP/form1.cpp#1)]
 [!code-csharp[PerformClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformClick/CS/form1.cs#1)]
 [!code-vb[PerformClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSelect">
      <MemberSignature Language="C#" Value="public virtual void PerformSelect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformSelect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformSelect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub PerformSelect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PerformSelect();" />
      <MemberSignature Language="F#" Value="abstract member PerformSelect : unit -&gt; unit&#xA;override this.PerformSelect : unit -&gt; unit" Usage="menuItem.PerformSelect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引发该菜单项的 <see cref="E:System.Windows.Forms.MenuItem.Select" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法，可引发<xref:System.Windows.Forms.MenuItem.Select>无需将任何事件信息传递给事件处理程序。  
  
   
  
## Examples  
 在此示例中以编程方式通过使用选择的菜单项`PerformSelect`方法。 首先，创建主菜单 (`mainMenu1`) 并向其中添加两个菜单项，请`menuItem1`(`File`) 和`menuItem2`(`Edit`)。 此外使用<xref:System.Windows.Forms.MenuItem.Select>事件来选择菜单项时，将数据发送到事件处理程序。 然后，使用`PerformSelect`方法来选择`File`菜单项。 当启动应用程序，`File`菜单项被选中，并且一个消息框包含文本"菜单中选定的文件。" 在屏幕上显示。 该示例需要您已创建<xref:System.Windows.Forms.Form>名为`Form1`。  
  
 [!code-cpp[PerformSelect#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformSelect/CPP/form1.cpp#1)]
 [!code-csharp[PerformSelect#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformSelect/CS/form1.cs#1)]
 [!code-vb[PerformSelect#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformSelect/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.MenuItem.PerformClick" />
      </Docs>
    </Member>
    <Member MemberName="Popup">
      <MemberSignature Language="C#" Value="public event EventHandler Popup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Popup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Popup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Popup As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Popup;" />
      <MemberSignature Language="F#" Value="member this.Popup : EventHandler " Usage="member this.Popup : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在显示菜单项的菜单项列表之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件仅当菜单项具有要显示的子菜单项时发生。 此事件处理程序可用于添加、 删除、 启用、 禁用、 检查，或取消选中菜单项显示这些基于应用程序的状态。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.MenuItem.Popup>事件以确定是否<xref:System.Windows.Forms.MenuItem>中所显示的菜单显示之前启用支持剪切、 复制和删除操作的对象。 该示例确定是否`textBox1`、 一个<xref:System.Windows.Forms.TextBox>控制窗体上，启用了、 具有输入焦点，并且具有在启用之前所选文本<xref:System.Windows.Forms.MenuItem>对象。 此示例要求三个<xref:System.Windows.Forms.MenuItem>对象所创建的名为`menuCut`， `menuCopy`，和`menuDelete`已创建。  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RadioCheck">
      <MemberSignature Language="C#" Value="public bool RadioCheck { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RadioCheck" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberSignature Language="VB.NET" Value="Public Property RadioCheck As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RadioCheck { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RadioCheck : bool with get, set" Usage="System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示 <see cref="T:System.Windows.Forms.MenuItem" />（如果已选中）是否显示单选按钮而不是选中标记。</summary>
        <value>如果要使用的是单选按钮而不是选中标记，则为 <see langword="true" />；如果菜单项选中时要显示的是标准选中标记，则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 复选标记不一定意味着一组菜单项的互斥状态。 此属性可用于向用户指示菜单项的复选标记是互相排斥。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.Forms.MenuItem.Checked%2A>属性以更改应用程序的状态。 在示例中，一组菜单项将提供用来指定中的文本的颜色<xref:System.Windows.Forms.TextBox>控件。 在示例中，使用提供的事件处理程序<xref:System.Windows.Forms.MenuItem.Click>的三个菜单项的事件。 每个菜单项指定一种颜色， `menuItemRed`， `menuItemGreen`，或`menuItemBlue`。 事件处理程序确定被单击的菜单项，将放置到所选的菜单项，一个复选标记并更改窗体的文本颜色<xref:System.Windows.Forms.TextBox>控件，名为`textBox1`。 此示例还使用<xref:System.Windows.Forms.MenuItem.RadioCheck%2A>属性演示了如何使用单选按钮检查要显示的是互斥的菜单项。 此示例需要<xref:System.Drawing?displayProperty=nameWithType>命名空间添加到窗体，其中包含此代码。  
  
 [!code-cpp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Checked" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public event EventHandler Select;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Select" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Select" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Select As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Select;" />
      <MemberSignature Language="F#" Value="member this.Select : EventHandler " Usage="member this.Select : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户将指针放在菜单项上时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户将鼠标指针置于菜单项上方时，通常会引发此事件。 当用户突出显示了使用键盘，方法是使用箭头键滚动到菜单项的菜单项时，也可以引发该事件。 此事件可用于显示有关应用程序的状态栏中此菜单项的详细的帮助字符串。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
> [!NOTE]
>  如果<xref:System.Windows.Forms.Menu.MenuItems%2A>属性<xref:System.Windows.Forms.MenuItem>包含任何项，不会引发此事件。 对于父菜单项不引发此事件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.MenuItem.Select>的事件<xref:System.Windows.Forms.MenuItem>类，以将分配到的帮助文本<xref:System.Windows.Forms.StatusBarPanel>的<xref:System.Windows.Forms.StatusBar>控件。 此示例需要<xref:System.Windows.Forms.MenuItem>名为的对象`menuOpen`， `menuSave`，和`menuExit`添加到<xref:System.Windows.Forms.MainMenu>窗体上的控件。 该示例还需要<xref:System.Windows.Forms.StatusBar>控件，名为`statusBar1`已添加到窗体。 <xref:System.Windows.Forms.StatusBar>控制应包含<xref:System.Windows.Forms.StatusBarPanel>。  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
      </Docs>
    </Member>
    <Member MemberName="Shortcut">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Shortcut Shortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Shortcut Shortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Shortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property Shortcut As Shortcut" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Shortcut Shortcut { System::Windows::Forms::Shortcut get(); void set(System::Windows::Forms::Shortcut value); };" />
      <MemberSignature Language="F#" Value="member this.Shortcut : System.Windows.Forms.Shortcut with get, set" Usage="System.Windows.Forms.MenuItem.Shortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Shortcut</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示与菜单项关联的快捷键。</summary>
        <value>
          <see cref="T:System.Windows.Forms.Shortcut" /> 值之一。 默认值为 <see langword="Shortcut.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 键盘快捷方式提供菜单系统中，并提供对你的应用程序为这些用户不具有到鼠标或其他指针设备的访问权限的键盘访问，用户经常激活的方法使用菜单项。  
  
   
  
## Examples  
 下面的代码示例创建菜单项，设置的标题、 将分配快捷键、 使菜单项可见，并显示菜单项的快捷方式键显示。 该示例需要<xref:System.Windows.Forms.MenuItem>，它是已创建名为`menuItem1`。  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">分配的值不是 <see cref="T:System.Windows.Forms.Shortcut" /> 值之一。</exception>
        <altmember cref="T:System.Windows.Forms.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="ShowShortcut">
      <MemberSignature Language="C#" Value="public bool ShowShortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowShortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowShortcut As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowShortcut { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowShortcut : bool with get, set" Usage="System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示与菜单项关联的快捷键是否在菜单项标题的旁边显示。</summary>
        <value>如果快捷组合键在菜单项标题的旁边显示，则为 <see langword="true" />；如果不显示快捷组合键，则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可用于提供用户若要隐藏菜单快捷方式来节省菜单空间或隐藏显示的快捷键的选项。  
  
   
  
## Examples  
 下面的代码示例创建菜单项，设置的标题、 将分配快捷键、 使菜单项可见，并显示菜单项的快捷方式键显示。 该示例需要<xref:System.Windows.Forms.MenuItem>，它是已创建名为`menuItem1`。  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.MenuItem.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示菜单项标题。</summary>
        <value>菜单项的文本标题。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当菜单项指定标题时，还可以通过将放置一个 & 字符用作访问键之前指定的访问密钥。 例如，若要指定访问密钥"文件"中的"F"，您将指定为菜单项的标题"和文件"。 此功能可用于提供用于在菜单的键盘导航。  
  
 此属性设置为"`-`"导致菜单项显示为分隔符 （一条横线），而不是标准菜单项。  
  
   
  
## Examples  
 下面的代码示例创建菜单项，设置的标题、 将分配快捷键、 使菜单项可见，并显示菜单项的快捷方式键显示。 该示例需要<xref:System.Windows.Forms.MenuItem>，它是已创建名为`menuItem1`。  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Mnemonic" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="menuItem.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示 <see cref="T:System.Windows.Forms.MenuItem" /> 的字符串。</summary>
        <returns>表示当前 <see cref="T:System.Windows.Forms.MenuItem" /> 的字符串。 该字符串包括该控件的类型和 <see cref="P:System.Windows.Forms.MenuItem.Text" /> 属性。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.MenuItem.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示菜单项是否可见。</summary>
        <value>如果菜单项在菜单上为可见，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可用于修改而无需合并菜单或禁用菜单的菜单结构。 例如，如果你想要隐藏的应用程序的菜单中的功能完整部分，则可以隐藏它们从用户通过将此属性设置为`false`。  
  
   
  
## Examples  
 下面的代码示例创建菜单项，设置的标题、 将分配快捷键、 使菜单项可见，并显示菜单项的快捷方式键显示。 该示例需要<xref:System.Windows.Forms.MenuItem>，它是已创建名为`menuItem1`。  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>