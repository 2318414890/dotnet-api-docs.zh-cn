<Type Name="MenuItem" FullName="System.Windows.Forms.MenuItem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8a283dcf6b2831ac5f93e9eab903a709ed1e0846" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33659924" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MenuItem : System.Windows.Forms.Menu" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MenuItem extends System.Windows.Forms.Menu" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.MenuItem" />
  <TypeSignature Language="VB.NET" Value="Public Class MenuItem&#xA;Inherits Menu" />
  <TypeSignature Language="C++ CLI" Value="public ref class MenuItem : System::Windows::Forms::Menu" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Menu</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示在 <see cref="T:System.Windows.Forms.MainMenu" /> 或 <see cref="T:System.Windows.Forms.ContextMenu" /> 内显示的单个项。 尽管 <see cref="T:System.Windows.Forms.ToolStripMenuItem" /> 替换了早期版本的 <see cref="T:System.Windows.Forms.MenuItem" /> 控件并添加了功能；但是也可选择保留 <see cref="T:System.Windows.Forms.MenuItem" /> 以备向后兼容和将来使用。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为了使<xref:System.Windows.Forms.MenuItem>若要显示，你必须将其添加到<xref:System.Windows.Forms.MainMenu>或<xref:System.Windows.Forms.ContextMenu>。 若要创建子菜单，可以添加<xref:System.Windows.Forms.MenuItem>对象添加到<xref:System.Windows.Forms.Menu.MenuItems%2A>的父属性<xref:System.Windows.Forms.MenuItem>。  
  
 <xref:System.Windows.Forms.MenuItem>类提供了使你能够配置的外观和功能的菜单项的属性。 若要显示的菜单项旁边的复选标记，请使用<xref:System.Windows.Forms.MenuItem.Checked%2A>属性。 可以使用此功能来确定的互相排斥的菜单项列表中选择的菜单项。 例如，如果你有一组用于设置中文本的颜色的菜单项<xref:System.Windows.Forms.TextBox>控件，你可以使用<xref:System.Windows.Forms.MenuItem.Checked%2A>属性来标识当前选定的颜色。 <xref:System.Windows.Forms.MenuItem.Shortcut%2A>属性可以用于定义某一键盘组合可以按下选择的菜单项。  
  
 有关<xref:System.Windows.Forms.MenuItem>多文档界面 (MDI) 应用程序中显示的对象，则可以使用<xref:System.Windows.Forms.MenuItem.MergeMenu%2A>方法合并的菜单 MDI 父对于为其的子窗体上来创建合并的菜单结构。 因为<xref:System.Windows.Forms.MenuItem>不能重复使用在多个位置在同一时间，如在<xref:System.Windows.Forms.MainMenu>和<xref:System.Windows.Forms.ContextMenu>，你可以使用<xref:System.Windows.Forms.MenuItem.CloneMenu%2A>方法来创建一份<xref:System.Windows.Forms.MenuItem>在另一个位置中使用。  
  
 <xref:System.Windows.Forms.MenuItem.Popup>事件可用于执行任务之前将显示一个菜单。 例如，你可以创建的事件处理程序以显示或隐藏菜单项在你的代码的状态上基于此事件。 <xref:System.Windows.Forms.MenuItem.Select>事件可用于执行任务，例如当用户将鼠标指针放在菜单项的应用程序的菜单项提供详细的帮助。  
  
   
  
## Examples  
 下面的代码示例创建一个窗体的菜单结构。 该示例代码将添加<xref:System.Windows.Forms.MenuItem>表示顶级菜单项，用于选择字体大小，将子菜单项添加到它，然后将两个子菜单项添加到表示应用程序中的大型和小型字体选择该菜单项。 该示例需要有<xref:System.Windows.Forms.MainMenu>对象名为`mainMenu1`和第四个<xref:System.Windows.Forms.MenuItem>对象命名的`menuItem1`， `menuItem2`， `menuItem3`，和`menuItem4`。  
  
 [!code-cpp[Classic Menu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu Example/CS/source.cs#1)]
 [!code-vb[Classic Menu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MainMenu" />
    <altmember cref="T:System.Windows.Forms.Menu" />
    <altmember cref="T:System.Windows.Forms.MenuMerge" />
    <altmember cref="T:System.Windows.Forms.ContextMenu" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Forms.MenuItem" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>使用空白标题初始化 <see cref="T:System.Windows.Forms.MenuItem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 创建空白后<xref:System.Windows.Forms.MenuItem>使用此构造函数，可以使用的属性和方法<xref:System.Windows.Forms.MenuItem>类指定的外观和行为你<xref:System.Windows.Forms.MenuItem>。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Windows.Forms.MenuItem>使用此版本的构造函数。  
  
 [!code-cpp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">菜单项的标题。</param>
        <summary>使用菜单项的指定标题初始化 <see cref="T:System.Windows.Forms.MenuItem" /> 类的一个新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你具有的菜单项指定标题`text`参数，你还可以指定访问密钥由前放置一个 & 字符的字符，用作访问密钥。 例如，若要为访问键指定"文件"中的"F"，你将指定为该菜单项标题"& 文件"。 可以使用此功能可供你菜单的键盘导航。  
  
 设置`text`参数"`-`"会导致菜单项显示为分隔符 （一条横线），而不是标准菜单项。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Windows.Forms.MenuItem>，在构造时指定的菜单项的标题。  
  
 [!code-cpp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, onClick As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="text">菜单项的标题。</param>
        <param name="onClick">处理该菜单项的 <see cref="T:System.EventHandler" /> 事件的 <see cref="E:System.Windows.Forms.MenuItem.Click" />。</param>
        <summary>用指定标题和菜单项的 <see cref="E:System.Windows.Forms.MenuItem.Click" /> 事件的事件处理程序初始化该类的一个新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你具有的菜单项指定标题`text`参数，你还可以指定访问密钥由前放置一个 & 字符用作访问密钥。 例如，若要为访问键指定"文件"中的"F"，你将指定为该菜单项标题"& 文件"。 可以使用此功能可供你菜单的键盘导航。  
  
 设置`text`参数"`-`"会导致菜单项显示为分隔符 （一条横线），而不是标准菜单项。  
  
 此外，你可以使用此构造函数指定一个委托，可将处理<xref:System.Windows.Forms.MenuItem.Click>正在创建的菜单项的事件。 <xref:System.EventHandler>传递给此构造函数必须将配置为调用的事件处理程序可以处理<xref:System.Windows.Forms.MenuItem.Click>事件。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Windows.Forms.MenuItem>用指定标题的对象和<xref:System.EventHandler>委托连接到的事件处理程序将处理<xref:System.Windows.Forms.MenuItem.Click>菜单项的事件。  
  
 [!code-cpp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, items As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="text">菜单项的标题。</param>
        <param name="items">包含该菜单项的子菜单项的一组 <see cref="T:System.Windows.Forms.MenuItem" /> 对象。</param>
        <summary>用指定标题和为菜单项定义的一组子菜单项初始化该类的一个新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你具有的菜单项指定标题`text`参数，你还可以指定访问密钥由前放置一个 & 字符用作访问密钥。 例如，若要为访问键指定"文件"中的"F"，你将指定为该菜单项标题"& 文件"。 可以使用此功能可供你菜单的键盘导航。  
  
 设置`text`参数"`-`"会导致菜单项显示为分隔符 （一条横线），而不是标准菜单项。  
  
 `items`参数使你可以分配来定义该菜单项的子菜单的菜单项的数组。 数组中的每个项还可以分配给它的菜单项的数组。 这使你可以创建完整的菜单结构并将它们分配到的菜单项的构造函数。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例创建一个对象用指定标题，连接到将处理该事件的方法的事件处理程序每个菜单项中子菜单项的数组。  
  
 [!code-cpp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick, System.Windows.Forms.Shortcut shortcut);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick, valuetype System.Windows.Forms.Shortcut shortcut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler,System.Windows.Forms.Shortcut)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick, System::Windows::Forms::Shortcut shortcut);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
      </Parameters>
      <Docs>
        <param name="text">菜单项的标题。</param>
        <param name="onClick">处理该菜单项的 <see cref="T:System.EventHandler" /> 事件的 <see cref="E:System.Windows.Forms.MenuItem.Click" />。</param>
        <param name="shortcut">
          <see cref="T:System.Windows.Forms.Shortcut" /> 值之一。</param>
        <summary>用指定标题、事件处理程序和菜单项的关联快捷键初始化该类的一个新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你具有的菜单项指定标题`text`参数，你还可以指定访问密钥由前放置一个 & 字符用作访问密钥。 例如，若要为访问键指定"文件"中的"F"，你将指定为该菜单项标题"& 文件"。 可以使用此功能可供你菜单的键盘导航。 此构造函数还可以指定除了提供键盘导航的访问密钥的快捷键。 键盘快捷方式，可以指定可用来激活该菜单项的键的组合。  
  
 设置`text`参数"`-`"会导致菜单项显示为分隔符 （一条横线），而不是标准菜单项。  
  
 此外，你可以使用此构造函数指定一个委托，可将处理<xref:System.Windows.Forms.MenuItem.Click>正在创建的菜单项的事件。 <xref:System.EventHandler>传递给此构造函数必须将配置为调用的事件处理程序可以处理<xref:System.Windows.Forms.MenuItem.Click>事件。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例指定的标题、 快捷键，与事件处理程序连接到将处理菜单项的事件的方法创建对象。  
  
 [!code-cpp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (System.Windows.Forms.MenuMerge mergeType, int mergeOrder, System.Windows.Forms.Shortcut shortcut, string text, EventHandler onClick, EventHandler onPopup, EventHandler onSelect, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Forms.MenuMerge mergeType, int32 mergeOrder, valuetype System.Windows.Forms.Shortcut shortcut, string text, class System.EventHandler onClick, class System.EventHandler onPopup, class System.EventHandler onSelect, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.Windows.Forms.MenuMerge,System.Int32,System.Windows.Forms.Shortcut,System.String,System.EventHandler,System.EventHandler,System.EventHandler,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::Windows::Forms::MenuMerge mergeType, int mergeOrder, System::Windows::Forms::Shortcut shortcut, System::String ^ text, EventHandler ^ onClick, EventHandler ^ onPopup, EventHandler ^ onSelect, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mergeType" Type="System.Windows.Forms.MenuMerge" />
        <Parameter Name="mergeOrder" Type="System.Int32" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="onPopup" Type="System.EventHandler" />
        <Parameter Name="onSelect" Type="System.EventHandler" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="mergeType">
          <see cref="T:System.Windows.Forms.MenuMerge" /> 值之一。</param>
        <param name="mergeOrder">此菜单项在合并菜单中将占有的相对位置。</param>
        <param name="shortcut">
          <see cref="T:System.Windows.Forms.Shortcut" /> 值之一。</param>
        <param name="text">菜单项的标题。</param>
        <param name="onClick">处理该菜单项的 <see cref="T:System.EventHandler" /> 事件的 <see cref="E:System.Windows.Forms.MenuItem.Click" />。</param>
        <param name="onPopup">处理该菜单项的 <see cref="T:System.EventHandler" /> 事件的 <see cref="E:System.Windows.Forms.MenuItem.Popup" />。</param>
        <param name="onSelect">处理该菜单项的 <see cref="T:System.EventHandler" /> 事件的 <see cref="E:System.Windows.Forms.MenuItem.Select" />。</param>
        <param name="items">包含该菜单项的子菜单项的一组 <see cref="T:System.Windows.Forms.MenuItem" /> 对象。</param>
        <summary>用指定标题、为（<see cref="T:System.Windows.Forms.MenuItem" />、<see cref="E:System.Windows.Forms.MenuItem.Click" /> 和 <see cref="E:System.Windows.Forms.MenuItem.Select" />）事件定义的事件处理程序、快捷键、合并类型和为菜单项指定的顺序来初始化 <see cref="E:System.Windows.Forms.MenuItem.Popup" /> 类的一个新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你具有的菜单项指定标题`text`参数，你还可以指定访问密钥由前放置一个 & 字符用作访问密钥。 例如，若要为访问键指定"文件"中的"F"，你将指定为该菜单项标题"& 文件"。 可以使用此功能可供你菜单的键盘导航。  
  
 设置`text`参数"`-`"会导致菜单项显示为分隔符 （一条横线），而不是标准菜单项。  
  
 `items`参数使你可以分配来定义该菜单项的子菜单的菜单项的数组。 数组中的每个项还可以分配给它的菜单项的数组。 这使你可以创建完整的菜单结构并将它们分配到的菜单项的构造函数。  
  
 `mergeType`和`mergeOrder`参数允许你确定此菜单项与另一个菜单合并的菜单项时的行为。 你为根据的值的指定`mergeType`参数，你可以添加、 删除、 替换或合并的菜单项和与它合并的菜单及其子菜单项。 `mergeOrder`参数确定正在创建的菜单项在菜单合并时的放置位置。  
  
 此外，你可以使用此构造函数创建<xref:System.Windows.Forms.MenuItem>并将其连接到在代码中将处理菜单项的单击事件处理程序。 <xref:System.EventHandler>将传入此构造函数应配置为调用的事件处理程序可以处理<xref:System.Windows.Forms.MenuItem.Click>事件。 通过使用此构造函数版本，还可以连接<xref:System.Windows.Forms.MenuItem.Popup>和<xref:System.Windows.Forms.MenuItem.Select>事件，以确定何时选择此菜单项。 这些事件可用于任务，例如确定显示子菜单项旁边的复选标记或用于启用或禁用菜单项基于应用程序的状态。 <xref:System.Windows.Forms.MenuItem.Select>和<xref:System.Windows.Forms.MenuItem.Click>将仅对引发事件<xref:System.Windows.Forms.MenuItem>对象不父菜单项。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例创建具有标题和快捷菜单项。 该菜单项还具有为定义的事件处理程序<xref:System.Windows.Forms.MenuItem.Popup>， <xref:System.Windows.Forms.MenuItem.Click>，和<xref:System.Windows.Forms.MenuItem.Select>事件。 如果此菜单项合并时，它会将菜单项添加到具有零的合并顺序菜单。  
  
 [!code-cpp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Popup" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Select" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="BarBreak">
      <MemberSignature Language="C#" Value="public bool BarBreak { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BarBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.BarBreak" />
      <MemberSignature Language="VB.NET" Value="Public Property BarBreak As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BarBreak { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示是将 <see cref="T:System.Windows.Forms.MenuItem" /> 放在新行上（对于添加到 <see cref="T:System.Windows.Forms.MainMenu" /> 对象的菜单项），还是放在新列中（对于 <see cref="T:System.Windows.Forms.ContextMenu" /> 中显示的子菜单项或菜单项）。</summary>
        <value>
          如果菜单项放在新行上或新列中，则为 <see langword="true" />；如果菜单项保持在其默认位置，则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用<xref:System.Windows.Forms.MenuItem.BarBreak%2A>属性创建每个菜单项旁边相互而不是水平放置在垂直列表菜单。 此属性还可用于创建包含多个行的顶级菜单项的菜单栏。  
  
 此属性不同于<xref:System.Windows.Forms.MenuItem.Break%2A>，其属性中的每个菜单项的左边缘显示一个栏<xref:System.Windows.Forms.MenuItem.Break%2A>属性设置为`true`。 在菜单项不是顶级菜单项时，将仅显示栏。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Windows.Forms.MenuItem>包含两个子菜单项。 这两个子菜单项水平显示而不是使用垂直<xref:System.Windows.Forms.MenuItem.BarBreak%2A>属性。  
  
 [!code-cpp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.BarBreak Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Break" />
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public bool Break { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Break" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Break" />
      <MemberSignature Language="VB.NET" Value="Public Property Break As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Break { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示是将该项放在新行上（对于添加到 <see cref="T:System.Windows.Forms.MainMenu" /> 对象的菜单项），还是放在新列中（对于 <see cref="T:System.Windows.Forms.ContextMenu" /> 中显示的菜单项或子菜单项）。</summary>
        <value>
          如果菜单项放在新行上或新列中，则为 <see langword="true" />；如果菜单项保持在其默认位置，则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用<xref:System.Windows.Forms.MenuItem.Break%2A>属性创建每个菜单彼此而不是水平放置在垂直列表菜单。 此属性还可用于创建包含多个行的顶级菜单项的菜单栏。  
  
   
  
## Examples  
 下面的代码示例使用两个顶级菜单项顶部行和一个菜单项底部行上创建一个菜单。  
  
 [!code-cpp[Classic MenuItem.Break Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Break Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Break Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Break Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.BarBreak" />
      </Docs>
    </Member>
    <Member MemberName="Checked">
      <MemberSignature Language="C#" Value="public bool Checked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Checked" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Checked" />
      <MemberSignature Language="VB.NET" Value="Public Property Checked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Checked { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示选中标记是否出现在菜单项文本的旁边。</summary>
        <value>
          如果菜单项旁边有一个选中标记，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用<xref:System.Windows.Forms.MenuItem.Checked%2A>结合与其他菜单提供应用程序的状态中的菜单项的属性。 例如，可以在一组项来标识要为应用程序中的文本显示的字体大小的菜单项上放置一个复选标记。 你还可以使用<xref:System.Windows.Forms.MenuItem.Checked%2A>属性来标识一组互斥菜单项中的所选的菜单项。  
  
> [!NOTE]
>  此属性不能设置为`true`顶级菜单项。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.Forms.MenuItem.Checked%2A>属性，以便在应用程序的状态。 在此示例中，一组菜单项用于指定中的文本的颜色<xref:System.Windows.Forms.TextBox>控件。 通过使用提供的事件处理程序<xref:System.Windows.Forms.MenuItem.Click>的三个菜单项的事件。 每个菜单项指定一种文本颜色， `menuItemRed` （红色） `menuItemGreen` （绿色），或`menuItemBlue`（蓝色）。 事件处理程序确定被单击的菜单项，将放置到选定的菜单项中，选中并更改窗体的文本颜色<xref:System.Windows.Forms.TextBox>控件。 该示例需要<xref:System.Drawing>命名空间添加到此代码放置在窗体。 该示例还要求<xref:System.Windows.Forms.TextBox>已添加到窗体此代码示例将位于名为`textBox1`。  
  
 [!code-cpp[Classic MenuItem.Checked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Checked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Checked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Checked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Windows.Forms.MenuItem" /> 是顶级菜单，或有子级。</exception>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当单击菜单项或使用为该菜单项定义的快捷键或访问键选择菜单项时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem.Click>事件发生时这<xref:System.Windows.Forms.MenuItem>单击用户。 此事件还会发生如果用户选择菜单项使用键盘，按 Enter 键。 也可能发生此如果按下的访问密钥或快捷键关联<xref:System.Windows.Forms.MenuItem>。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
> [!NOTE]
>  如果<xref:System.Windows.Forms.Menu.MenuItems%2A>属性<xref:System.Windows.Forms.MenuItem>包含任何项，则不会引发此事件。 适用于父菜单项不引发此事件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.MenuItem.Click>事件以执行任务时<xref:System.Windows.Forms.MenuItem>单击。 该示例创建<xref:System.Windows.Forms.MainMenu>调用`mainMenu1`并添加两个<xref:System.Windows.Forms.MenuItem>对象， `topMenuItem` (`File`) 和`menuItem1`(`Open`)。 然后它会连接`Click`事件`menuItem1_Click`事件处理程序。 当用户单击`Open`菜单项<xref:System.Windows.Forms.OpenFileDialog>初始化，并且会显示。 该示例需要你已创建了<xref:System.Windows.Forms.Form>名为`Form1`。  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CloneMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建 <see cref="T:System.Windows.Forms.MenuItem" /> 的副本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem CloneMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem CloneMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CloneMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ CloneMenu();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建当前 <see cref="T:System.Windows.Forms.MenuItem" /> 的副本。</summary>
        <returns>表示重复菜单项的 <see cref="T:System.Windows.Forms.MenuItem" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem> 对象无法使用在多个位置中，除非你获取一份<xref:System.Windows.Forms.MenuItem>。 你可以调用此方法以创建一份在中使用此菜单项<xref:System.Windows.Forms.ContextMenu>， <xref:System.Windows.Forms.MainMenu>，或其他<xref:System.Windows.Forms.MenuItem>应用程序中。 当克隆菜单项时，原始的菜单项中指定任何事件处理程序将继续在菜单项的克隆版本中正常工作。 例如，如果你创建<xref:System.Windows.Forms.MenuItem>和连接其<xref:System.Windows.Forms.MenuItem.Click>事件的事件处理程序。 当克隆菜单项时，克隆的菜单项将调用相同的事件处理程序。  
  
   
  
## Examples  
 下面的代码示例克隆<xref:System.Windows.Forms.MenuItem>和将其显示在<xref:System.Windows.Forms.ContextMenu>。 该示例需要<xref:System.Windows.Forms.MenuItem>中存在<xref:System.Windows.Forms.MainMenu>同名的窗体上`menuItem1`且<xref:System.Windows.Forms.ContextMenu>对象名为`contextMenu1`窗体上还存在。  
  
 [!code-cpp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="protected void CloneMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CloneMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CloneMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CloneMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">表示要复制的菜单项的 <see cref="T:System.Windows.Forms.MenuItem" />。</param>
        <summary>创建指定 <see cref="T:System.Windows.Forms.MenuItem" /> 的副本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法以创建你已在你的应用程序中创建的快捷菜单或另一个菜单结构中使用的菜单项的副本。 此版本的<xref:System.Windows.Forms.MenuItem.CloneMenu%2A>允许你指定特定<xref:System.Windows.Forms.MenuItem>复制而不是调用方法的菜单项。 你可以使用此方法以初始化新<xref:System.Windows.Forms.MenuItem>对象与另一个副本<xref:System.Windows.Forms.MenuItem>。 当克隆菜单项时，原始的菜单项中指定任何事件处理程序将继续在菜单项的克隆版本中正常工作。 例如，如果你创建<xref:System.Windows.Forms.MenuItem>和连接其<xref:System.Windows.Forms.MenuItem.Click>事件的事件处理程序。 当克隆菜单项时，克隆的菜单项将调用相同的事件处理程序。  
  
   
  
## Examples  
 下面的代码示例初始化新<xref:System.Windows.Forms.MenuItem>提供的现有副本<xref:System.Windows.Forms.MenuItem>，但中使用<xref:System.Windows.Forms.MainMenu>窗体上。 然后该代码将添加克隆<xref:System.Windows.Forms.MenuItem>到<xref:System.Windows.Forms.ContextMenu>窗体上。 此示例需要<xref:System.Windows.Forms.MenuItem>已被创建并命名为`menuItem1`且<xref:System.Windows.Forms.ContextMenu>创建控件和将其命名`contextMenu1`。  
  
 [!code-cpp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultItem">
      <MemberSignature Language="C#" Value="public bool DefaultItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DefaultItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultItem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DefaultItem { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示菜单项是否为默认菜单项。</summary>
        <value>
          如果菜单项是菜单中的默认菜单项，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 菜单默认菜单项为粗体。 当用户双击子菜单包含默认项、 选择默认项目时，和子菜单已关闭。 你可以使用<xref:System.Windows.Forms.MenuItem.DefaultItem%2A>属性以指示应为菜单或快捷菜单中的默认操作。  
  
   
  
## Examples  
 下面的代码示例创建两个子菜单项与菜单项。 该示例设置`menuItem2`作为默认菜单项使用<xref:System.Windows.Forms.MenuItem.DefaultItem%2A>属性。  
  
 [!code-cpp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>处置由 <see cref="T:System.Windows.Forms.MenuItem" /> 占用的资源（内存除外）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完成使用 <xref:System.Windows.Forms.MenuItem.Dispose%2A> 后，应调用 <xref:System.Windows.Forms.MenuItem>。 <xref:System.Windows.Forms.MenuItem.Dispose%2A> 方法使 <xref:System.Windows.Forms.MenuItem> 处于不可用状态。 在调用<xref:System.Windows.Forms.MenuItem.Dispose%2A>，必须释放对所有引用<xref:System.Windows.Forms.MenuItem>以便可以通过垃圾回收回收其占用的内存。  
  
> [!NOTE]
>  每次释放对 <xref:System.Windows.Forms.MenuItem.Dispose%2A> 的最后一个引用前，均应调用 <xref:System.Windows.Forms.MenuItem>。 否则为资源<xref:System.Windows.Forms.MenuItem>是使用不会被释放之前垃圾集合调用<xref:System.Windows.Forms.MenuItem>对象的析构函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DrawItemEventHandler DrawItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DrawItemEventHandler DrawItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.DrawItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DrawItem As DrawItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DrawItemEventHandler ^ DrawItem;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当菜单项的 <see cref="P:System.Windows.Forms.MenuItem.OwnerDraw" /> 属性设置为 <see langword="true" /> 并且发出绘制菜单项的请求时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DrawItemEventArgs>自变量传递给<xref:System.Windows.Forms.MenuItem.DrawItem>事件处理程序提供<xref:System.Drawing.Graphics>使您可以执行绘制和图面上的菜单项的其他图形操作的对象。 此事件处理程序可用于创建自定义菜单可满足你的应用程序的需求。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何处理<xref:System.Windows.Forms.MenuItem.DrawItem>事件。 此示例绘制菜单项使用<xref:System.Drawing.Brush>和<xref:System.Drawing.Font>，，然后绘制<xref:System.Drawing.Rectangle>菜单项周围。 通过执行绘图<xref:System.Drawing.Graphics>对象传递给事件处理程序中的<xref:System.Windows.Forms.DrawItemEventArgs>参数。 此示例需要您初始化<xref:System.Windows.Forms.MenuItem.OwnerDraw%2A>到项的属性， `true`。 对于 C# 示例中，添加窗体的构造函数，下面的代码之后`InitializeComponent`，以便挂钩事件：  
  
 `this.menuItem1.DrawItem += new DrawItemEventHandler(menuItem1_DrawItem);`  
  
 [!code-cpp[OwnerDraw example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/OwnerDraw example/CPP/form1.cpp#1)]
 [!code-csharp[OwnerDraw example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/OwnerDraw example/CS/form1.cs#1)]
 [!code-vb[OwnerDraw example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/OwnerDraw example/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示菜单项是否启用。</summary>
        <value>
          如果启用菜单项，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Forms.MenuItem> ，它是已禁用显示在相应的灰色颜色指示其状态。 当禁用父菜单项时，不会显示所有子菜单项。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.MenuItem.Popup>事件，以确定是否<xref:System.Windows.Forms.MenuItem>中所显示的菜单显示之前启用提供支持进行剪切、 复制和删除操作的对象。 该示例可确定如果`textBox1`、<xref:System.Windows.Forms.TextBox>控制窗体上，启用了、 具有输入焦点，并且具有在启用之前选择的文本<xref:System.Windows.Forms.MenuItem>对象。 此示例需要三个<xref:System.Windows.Forms.MenuItem>对象创建命名`menuCut`， `menuCopy`，和`menuDelete`已创建。  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Index">
      <MemberSignature Language="C#" Value="public int Index { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Index" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Index" />
      <MemberSignature Language="VB.NET" Value="Public Property Index As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Index { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示菜单项在其父菜单中的位置。</summary>
        <value>表示菜单项在其父菜单中位置的从零开始的索引。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性提供其父菜单的菜单项集合中的菜单项的索引的位置。 此属性可用于重新定位到其菜单内的不同位置的菜单项。 你还可以使用此属性，在创建时<xref:System.Windows.Forms.MenuItem>在创建时指定它的菜单结构中的位置。  
  
   
  
## Examples  
 下面的代码示例将两个菜单项的菜单中的位置。 下面的代码示例要求将两个<xref:System.Windows.Forms.MenuItem>对象创建命名`menuItem1`和`menuItem2`。 `menuItem1`菜单项下移一个位置在菜单中，而`menuItem2`将上移一个位置。  
  
 [!code-cpp[Classic MenuItem.Index Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Index Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Index Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Index Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">赋值小于零或大于项的数目。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsParent">
      <MemberSignature Language="C#" Value="public override bool IsParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.IsParent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsParent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsParent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示菜单项是否包含子菜单项。</summary>
        <value>
          如果菜单项包含子菜单项，则为 <see langword="true" />；如果菜单为独立菜单项，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用此属性与<xref:System.Windows.Forms.MenuItem.Parent%2A>属性在代码中通过整个菜单结构中进行导航。  
  
   
  
## Examples  
 下面的代码示例确定是否存在任何与关联的子菜单<xref:System.Windows.Forms.MenuItem>名为`menuItem1`。 如果存在任何子菜单，它将禁用它们通过设置<xref:System.Windows.Forms.MenuItem.Enabled%2A>属性`false`。 该示例需要有<xref:System.Windows.Forms.MenuItem>创建的名为`menuItem1`。  
  
 [!code-cpp[Classic MenuItem.IsParent Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.IsParent Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.IsParent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiList">
      <MemberSignature Language="C#" Value="public bool MdiList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MdiList" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MdiList" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MdiList { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示是否使用在关联窗体内显示的多文档界面 (MDI) 子窗口列表来填充菜单项。</summary>
        <value>
          如果要在此菜单项中显示 MDI 子窗口列表，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 选中菜单项时要显示 MDI 子窗口列表，列表显示为子菜单的菜单项。 仅定义为 MDI 子窗体的窗体窗口列表中显示。 只有九个子窗口可以显示一次。 如果有多个九个显示的子窗口，"更多 Windows..."菜单项显示在窗口列表的末尾。 单击此菜单项显示一个包含的完整列表的当前处于活动状态的子窗口的对话框。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Windows.Forms.MenuItem>用于的 MDI 窗体中显示当前打开的 MDI 子窗体的列表。  
  
 [!code-cpp[Classic MenuItem.MdiList Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MdiList Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MdiList Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MeasureItemEventHandler MeasureItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MeasureItemEventHandler MeasureItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.MeasureItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MeasureItem As MeasureItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MeasureItemEventHandler ^ MeasureItem;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MeasureItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当菜单在绘制菜单项之前需要知道菜单项大小时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发此事件的顺序，您必须拥有<xref:System.Windows.Forms.MenuItem.OwnerDraw%2A>的菜单项的属性设置为`true`。 绘制所有者描述的菜单允许的菜单项的大小绘制指定之前，将引发此事件。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.MenuItem.MeasureItem>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.MenuItem>名为`MenuItem1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.MenuItem.MeasureItem>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#499](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#499)]
 [!code-vb[System.Windows.Forms.EventExamples#499](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#499)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="MenuID">
      <MemberSignature Language="C#" Value="protected int MenuID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MenuID" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MenuID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property MenuID As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int MenuID { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示此菜单项的 Windows 标识符。</summary>
        <value>此菜单项的 Windows 标识符。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MergeMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此 <see cref="T:System.Windows.Forms.MenuItem" /> 与另一个 <see cref="T:System.Windows.Forms.MenuItem" /> 合并。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem MergeMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem MergeMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MergeMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ MergeMenu();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此 <see cref="T:System.Windows.Forms.MenuItem" /> 与另一个 <see cref="T:System.Windows.Forms.MenuItem" /> 合并并返回合并后的 <see cref="T:System.Windows.Forms.MenuItem" />。</summary>
        <returns>表示合并菜单项的 <see cref="T:System.Windows.Forms.MenuItem" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当调用此版本的<xref:System.Windows.Forms.MenuItem.MergeMenu%2A>、<xref:System.Windows.Forms.MenuItem>返回是当前菜单项可以合并使用而不会影响当前项的功能的另一菜单项的副本。 此版本的<xref:System.Windows.Forms.MenuItem.MergeMenu%2A>方法是类似于调用<xref:System.Windows.Forms.MenuItem.CloneMenu%2A>不包含任何参数的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public void MergeMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MergeMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MergeMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MergeMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">指定要与该菜单项合并的菜单项的 <see cref="T:System.Windows.Forms.MenuItem" />。</param>
        <summary>将另一菜单项与该菜单项合并。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 菜单项合并的菜单项的值根据<xref:System.Windows.Forms.MenuItem.MergeType%2A>和<xref:System.Windows.Forms.MenuItem.MergeOrder%2A>属性。 此版本的<xref:System.Windows.Forms.MenuItem.MergeMenu%2A>方法可以合并两个<xref:System.Windows.Forms.MenuItem>为单个菜单对象 （和它们的子菜单）。 当多文档界面 (MDI) 父窗体和子菜单时，将自动处理菜单合并。 你可以使用此版本的合并两个方法<xref:System.Windows.Forms.MenuItem>对象 （和及其子菜单项） 位于<xref:System.Windows.Forms.MainMenu>为单个菜单内的控件<xref:System.Windows.Forms.ContextMenu>。 例如，你可以调用此版本的<xref:System.Windows.Forms.MenuItem.MergeMenu%2A>方法以将文件和编辑菜单的菜单项合并到单个<xref:System.Windows.Forms.MenuItem>，可以然后要添加到由和显示<xref:System.Windows.Forms.ContextMenu>。  
  
   
  
## Examples  
 下面的代码示例使用此版本的<xref:System.Windows.Forms.MenuItem.MergeMenu%2A>方法来创建一份<xref:System.Windows.Forms.MenuItem>并将它与另一个合并。 合并<xref:System.Windows.Forms.MenuItem>随后添加到<xref:System.Windows.Forms.ContextMenu>控件。 此示例需要有两个菜单项名`menuItem1`和`menuItem2`包含其中的子菜单项和<xref:System.Windows.Forms.ContextMenu>名为`contextMenu1`来显示菜单项。 `menuItem1` 和`menuItem2`具有不同的菜单项包含在它们。 在调用后<xref:System.Windows.Forms.MenuItem.MergeMenu%2A>进行，合并创建菜单。  
  
 [!code-cpp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeOrder">
      <MemberSignature Language="C#" Value="public int MergeOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MergeOrder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeOrder As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MergeOrder { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示菜单项与另一个项合并时的相对位置。</summary>
        <value>表示该菜单项的合并顺序位置的从零开始的索引。 默认值为 0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 菜单项的合并顺序指定如果菜单结构，将需要此菜单项的相对位置<xref:System.Windows.Forms.MenuItem>包含在与另一个合并。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.MenuItem.MergeOrder%2A>属性来控制显示合并的菜单的方式。 这是一个完整的示例，准备好运行后将其添加到你的项目。  
  
 [!code-cpp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="M:System.Windows.Forms.MenuItem.MergeMenu" />
      </Docs>
    </Member>
    <Member MemberName="MergeType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuMerge MergeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.MenuMerge MergeType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeType" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeType As MenuMerge" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuMerge MergeType { System::Windows::Forms::MenuMerge get(); void set(System::Windows::Forms::MenuMerge value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuMerge</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示该菜单项的菜单与另一个菜单合并时该菜单项的行为。</summary>
        <value>一个 <see cref="T:System.Windows.Forms.MenuMerge" /> 值，该值表示菜单项的合并类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 菜单项的合并类型指示菜单项时它具有要合并的另一菜单项的合并顺序相同的行为方式。 合并的菜单可用于创建基于两个或多个现有菜单合并的菜单。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Windows.Forms.MenuItem>与<xref:System.Windows.Forms.MenuItem.MergeType%2A>和<xref:System.Windows.Forms.MenuItem.MergeOrder%2A>指定，这样的菜单项添加到的第一个位置的合并菜单。  
  
 [!code-cpp[Classic MenuItem.MergeType Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeType Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">分配的值不是 <see cref="T:System.Windows.Forms.MenuMerge" /> 值之一。</exception>
        <altmember cref="T:System.Windows.Forms.MenuMerge" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="Mnemonic">
      <MemberSignature Language="C#" Value="public char Mnemonic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Mnemonic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mnemonic As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char Mnemonic { char get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示与此菜单项关联的助记字符。</summary>
        <value>表示与此菜单项关联的助记字符的字符。 如果在 <see cref="T:System.Windows.Forms.MenuItem" /> 的文本中没有指定助记字符，则返回空字符（ASCII 值为 0）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 助记键字符等于第一个字符的文本中后 & 号字符 (&) <xref:System.Windows.Forms.MenuItem>。 此属性将不会返回助记键，如果两个 & 符它们放在一起使用 & 符的文本中显示 and 符<xref:System.Windows.Forms.MenuItem>而不是定义助记键字符。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Text" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.MenuItem.Click" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.MenuItem.Click>事件以执行任务时<xref:System.Windows.Forms.MenuItem>单击。 该示例创建<xref:System.Windows.Forms.MainMenu>调用`mainMenu1`并添加两个<xref:System.Windows.Forms.MenuItem>对象， `topMenuItem` (`File`) 和`menuItem1`(`Open`)。 然后它会连接`Click`事件`menuItem1_Click`事件处理程序。 当用户单击`Open`菜单项<xref:System.Windows.Forms.OpenFileDialog>初始化，并且会显示。 该示例需要你已创建了<xref:System.Windows.Forms.Form>名为`Form1`。  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDrawItem">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawItem (System.Windows.Forms.DrawItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawItem(class System.Windows.Forms.DrawItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawItem (e As DrawItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawItem(System::Windows::Forms::DrawItemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DrawItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.DrawItemEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.MenuItem.DrawItem" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />方法。</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DrawItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInitMenuPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnInitMenuPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitMenuPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnInitMenuPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitMenuPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitMenuPopup(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.MenuItem.Popup" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMeasureItem">
      <MemberSignature Language="C#" Value="protected virtual void OnMeasureItem (System.Windows.Forms.MeasureItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMeasureItem(class System.Windows.Forms.MeasureItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMeasureItem (e As MeasureItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMeasureItem(System::Windows::Forms::MeasureItemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MeasureItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.MeasureItemEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.MenuItem.MeasureItem" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />方法。</para>
        </block>
        <altmember cref="T:System.Windows.Forms.MeasureItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPopup(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.MenuItem.Popup" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.MenuItem.Popup>事件，以确定是否<xref:System.Windows.Forms.MenuItem>中所显示的菜单显示之前启用提供支持进行剪切、 复制和删除操作的对象。 该示例可确定如果`textBox1`、<xref:System.Windows.Forms.TextBox>控制窗体上，启用了、 具有输入焦点，并且具有在启用之前选择的文本<xref:System.Windows.Forms.MenuItem>对象。 此示例需要三个<xref:System.Windows.Forms.MenuItem>对象创建命名`menuCut`， `menuCopy`，和`menuDelete`已创建。  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSelect">
      <MemberSignature Language="C#" Value="protected virtual void OnSelect (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelect(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelect (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelect(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.MenuItem.Select" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.MenuItem.Select>事件<xref:System.Windows.Forms.MenuItem>类将分配到的帮助文本<xref:System.Windows.Forms.StatusBarPanel>的<xref:System.Windows.Forms.StatusBar>控件。 此示例需要<xref:System.Windows.Forms.MenuItem>对象命名的`menuOpen`， `menuSave`，和`menuExit`添加到<xref:System.Windows.Forms.MainMenu>窗体上的控件。 该示例还要求<xref:System.Windows.Forms.StatusBar>控件，名为`statusBar1`已添加到窗体。 <xref:System.Windows.Forms.StatusBar>控件应包含<xref:System.Windows.Forms.StatusBarPanel>。  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OwnerDraw">
      <MemberSignature Language="C#" Value="public bool OwnerDraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OwnerDraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberSignature Language="VB.NET" Value="Public Property OwnerDraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OwnerDraw { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个字值，通过该值指示是由所提供的代码绘制菜单项还是由 Windows 绘制菜单项。</summary>
        <value>
          如果使用代码绘制菜单项，则为 <see langword="true" />；如果由 Windows 绘制菜单项，则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Windows.Forms.MenuItem.OwnerDraw%2A>属性设置为`true`，你需要处理的菜单项的所有绘制。 此功能可用于创建你自己的专用菜单显示。  
  
   
  
## Examples  
 下面的代码示例演示一个菜单，其中一个所有者描述的菜单项。 此示例设置<xref:System.Windows.Forms.MenuItem.OwnerDraw%2A>属性并使用`AddHandler`语句和`AddressOf`运算符指定一个委托来处理<xref:System.Windows.Forms.MenuItem.DrawItem>事件。 若要运行该示例，请将其粘贴在导入的窗体<xref:System>， <xref:System.Windows.Forms>，和<xref:System.Drawing>命名空间。 调用`InitializeMenu`从窗体的构造函数或`Load`方法。  
  
 [!code-cpp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Menu Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Menu Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Menu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Menu ^ Parent { System::Windows::Forms::Menu ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Menu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示包含此菜单项的菜单。</summary>
        <value>表示包含此菜单项的菜单的 <see cref="T:System.Windows.Forms.Menu" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用此属性来获取<xref:System.Windows.Forms.Menu>对于子菜单的对象。 你可以强制转换<xref:System.Windows.Forms.Menu>到此属性返回的对象<xref:System.Windows.Forms.MenuItem>对象对其进行操作。  
  
   
  
## Examples  
 在此示例中，创建一个主菜单和顶级菜单项， `menuItem1` (`File`)。 你还创建两个菜单项， `menuItem2` (`New`) 和`menuItem3`(`Open`)，并将其添加到的菜单项列表`menuItem1`。 然后检查以查看是否`menuItem3`有父菜单上，则为 true，并显示此父菜单的信息在消息框中。 此示例需要你已创建了<xref:System.Windows.Forms.Form>名为`Form1`。  
  
 [!code-cpp[ParentMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentMenu/CPP/form1.cpp#1)]
 [!code-csharp[ParentMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentMenu/CS/form1.cs#1)]
 [!code-vb[ParentMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformClick">
      <MemberSignature Language="C#" Value="public void PerformClick ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformClick" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformClick ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformClick();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为 <see cref="E:System.Windows.Forms.Control.Click" /> 生成一个 <see cref="T:System.Windows.Forms.MenuItem" /> 事件，模拟用户的单击操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用此菜单可以激活菜单项通过代码，而无需任何事件信息。 例如，如果你想要激活菜单项基于操作发生在你的应用程序，你可以调用<xref:System.Windows.Forms.MenuItem.PerformClick%2A>方法， <xref:System.Windows.Forms.MenuItem>。  
  
   
  
## Examples  
 在此示例中以编程方式通过单击菜单项`PerformClick`方法。 首先，创建一个主菜单 (`mainMenu1`) 并向其中添加两个菜单项`menuItem1`(`File`) 和`menuItem2`(`Edit`)。 你还使用<xref:System.Windows.Forms.MenuItem.Click>将数据发送到事件处理程序中，单击菜单项时的事件。 然后，您使用`PerformClick`方法单击`File`菜单项。 当启动应用程序，`File`激活菜单项，并且一个消息框包含文本"单击菜单上的文件。" 屏幕上显示。 该示例需要你已创建了<xref:System.Windows.Forms.Form>名为`Form1`。  
  
 [!code-cpp[PerformClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformClick/CPP/form1.cpp#1)]
 [!code-csharp[PerformClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformClick/CS/form1.cs#1)]
 [!code-vb[PerformClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSelect">
      <MemberSignature Language="C#" Value="public virtual void PerformSelect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformSelect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformSelect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub PerformSelect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PerformSelect();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引发该菜单项的 <see cref="E:System.Windows.Forms.MenuItem.Select" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法允许您以引发<xref:System.Windows.Forms.MenuItem.Select>而无需将任何事件信息传递给事件处理程序的事件。  
  
   
  
## Examples  
 在此示例中以编程方式通过选择菜单项`PerformSelect`方法。 首先，创建一个主菜单 (`mainMenu1`) 并向其中添加两个菜单项`menuItem1`(`File`) 和`menuItem2`(`Edit`)。 你还使用<xref:System.Windows.Forms.MenuItem.Select>事件将选定菜单项时，将数据发送到事件处理程序。 然后，您使用`PerformSelect`方法来选择`File`菜单项。 当启动应用程序，`File`选择菜单项，并且一个消息框包含文本"选定菜单上的文件。" 屏幕上显示。 该示例需要你已创建了<xref:System.Windows.Forms.Form>名为`Form1`。  
  
 [!code-cpp[PerformSelect#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformSelect/CPP/form1.cpp#1)]
 [!code-csharp[PerformSelect#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformSelect/CS/form1.cs#1)]
 [!code-vb[PerformSelect#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformSelect/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.MenuItem.PerformClick" />
      </Docs>
    </Member>
    <Member MemberName="Popup">
      <MemberSignature Language="C#" Value="public event EventHandler Popup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Popup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Popup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Popup As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Popup;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在显示菜单项的菜单项列表之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果菜单项包含子菜单项以显示仅发生此事件。 此事件处理程序可用于添加、 删除、 启用、 禁用、 检查，或取消选中基于你的应用程序的状态之前所显示的菜单项。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.MenuItem.Popup>事件，以确定是否<xref:System.Windows.Forms.MenuItem>中所显示的菜单显示之前启用提供支持进行剪切、 复制和删除操作的对象。 该示例可确定如果`textBox1`、<xref:System.Windows.Forms.TextBox>控制窗体上，启用了、 具有输入焦点，并且具有在启用之前选择的文本<xref:System.Windows.Forms.MenuItem>对象。 此示例需要三个<xref:System.Windows.Forms.MenuItem>对象创建命名`menuCut`， `menuCopy`，和`menuDelete`已创建。  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RadioCheck">
      <MemberSignature Language="C#" Value="public bool RadioCheck { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RadioCheck" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberSignature Language="VB.NET" Value="Public Property RadioCheck As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RadioCheck { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示 <see cref="T:System.Windows.Forms.MenuItem" />（如果已选中）是否显示单选按钮而不是选中标记。</summary>
        <value>
          如果要使用的是单选按钮而不是选中标记，则为 <see langword="true" />；如果菜单项选中时要显示的是标准选中标记，则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 选中标记并不一定表示一组菜单项的互斥状态。 此属性可用于向用户指示菜单项的复选标记是互斥的。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.Forms.MenuItem.Checked%2A>属性来更改应用程序的状态。 在示例中，一组菜单项将提供用于指定中的文本的颜色<xref:System.Windows.Forms.TextBox>控件。 在示例中，使用提供的事件处理程序<xref:System.Windows.Forms.MenuItem.Click>的三个菜单项的事件。 每个菜单项指定一种颜色， `menuItemRed`， `menuItemGreen`，或`menuItemBlue`。 事件处理程序确定被单击的菜单项，将放置到选定的菜单项中，选中并更改窗体的文本颜色<xref:System.Windows.Forms.TextBox>控件，名为`textBox1`。 此示例还使用<xref:System.Windows.Forms.MenuItem.RadioCheck%2A>属性来演示如何使用单选按钮检查来显示菜单项互相排斥。 此示例需要<xref:System.Drawing?displayProperty=nameWithType>命名空间添加到窗体，其中包含此代码。  
  
 [!code-cpp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Checked" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public event EventHandler Select;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Select" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Select" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Select As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Select;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户将指针放在菜单项上时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常，用户将鼠标指针放在菜单项时，将引发此事件。 用户突出显示菜单项使用键盘，使用箭头键滚动到的菜单项时，也可以引发该事件。 此事件可用于显示有关应用程序的状态栏中该菜单项的详细的帮助字符串。 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
> [!NOTE]
>  如果<xref:System.Windows.Forms.Menu.MenuItems%2A>属性<xref:System.Windows.Forms.MenuItem>包含任何项，则不会引发此事件。 适用于父菜单项不引发此事件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.MenuItem.Select>事件<xref:System.Windows.Forms.MenuItem>类将分配到的帮助文本<xref:System.Windows.Forms.StatusBarPanel>的<xref:System.Windows.Forms.StatusBar>控件。 此示例需要<xref:System.Windows.Forms.MenuItem>对象命名的`menuOpen`， `menuSave`，和`menuExit`添加到<xref:System.Windows.Forms.MainMenu>窗体上的控件。 该示例还要求<xref:System.Windows.Forms.StatusBar>控件，名为`statusBar1`已添加到窗体。 <xref:System.Windows.Forms.StatusBar>控件应包含<xref:System.Windows.Forms.StatusBarPanel>。  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
      </Docs>
    </Member>
    <Member MemberName="Shortcut">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Shortcut Shortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Shortcut Shortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Shortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property Shortcut As Shortcut" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Shortcut Shortcut { System::Windows::Forms::Shortcut get(); void set(System::Windows::Forms::Shortcut value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Shortcut</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示与菜单项关联的快捷键。</summary>
        <value>
          <see cref="T:System.Windows.Forms.Shortcut" /> 值之一。 默认值为 <see langword="Shortcut.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 键盘快捷方式提供菜单系统中，并提供对你的应用程序为这些用户不具有到鼠标或其他指针设备的访问权限的键盘访问，用户经常激活的方法使用菜单项。  
  
   
  
## Examples  
 下面的代码示例创建一个菜单项、 设置的标题，将分配的快捷键，进行菜单项可见，并显示菜单项的快捷键显示。 该示例需要<xref:System.Windows.Forms.MenuItem>已创建了名为`menuItem1`。  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">分配的值不是 <see cref="T:System.Windows.Forms.Shortcut" /> 值之一。</exception>
        <altmember cref="T:System.Windows.Forms.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="ShowShortcut">
      <MemberSignature Language="C#" Value="public bool ShowShortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowShortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowShortcut As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowShortcut { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示与菜单项关联的快捷键是否在菜单项标题的旁边显示。</summary>
        <value>
          如果快捷组合键在菜单项标题的旁边显示，则为 <see langword="true" />；如果不显示快捷组合键，则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可用于提供用户隐藏快捷方式菜单中的选项来节省菜单空间或隐藏显示的快捷键。  
  
   
  
## Examples  
 下面的代码示例创建一个菜单项、 设置的标题，将分配的快捷键，进行菜单项可见，并显示菜单项的快捷键显示。 该示例需要<xref:System.Windows.Forms.MenuItem>已创建了名为`menuItem1`。  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示菜单项标题。</summary>
        <value>菜单项的文本标题。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为菜单项指定标题时，还可以通过将一个 & 字符用作访问密钥之前指定的访问密钥。 例如，若要为访问键指定"文件"中的"F"，你将指定为该菜单项标题"& 文件"。 可以使用此功能可供你菜单的键盘导航。  
  
 此属性设置为"`-`"会导致菜单项显示为分隔符 （一条横线），而不是标准菜单项。  
  
   
  
## Examples  
 下面的代码示例创建一个菜单项、 设置的标题，将分配的快捷键，进行菜单项可见，并显示菜单项的快捷键显示。 该示例需要<xref:System.Windows.Forms.MenuItem>已创建了名为`menuItem1`。  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Mnemonic" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示 <see cref="T:System.Windows.Forms.MenuItem" /> 的字符串。</summary>
        <returns>表示当前 <see cref="T:System.Windows.Forms.MenuItem" /> 的字符串。 该字符串包括该控件的类型和 <see cref="P:System.Windows.Forms.MenuItem.Text" /> 属性。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示菜单项是否可见。</summary>
        <value>
          如果菜单项在菜单上为可见，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可用于修改而无需合并菜单或禁用菜单的菜单结构。 例如，如果你想要隐藏完成从你的应用程序的菜单的功能的一部分，您可以隐藏它们从用户通过将此属性设置为`false`。  
  
   
  
## Examples  
 下面的代码示例创建一个菜单项、 设置的标题，将分配的快捷键，进行菜单项可见，并显示菜单项的快捷键显示。 该示例需要<xref:System.Windows.Forms.MenuItem>已创建了名为`menuItem1`。  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>