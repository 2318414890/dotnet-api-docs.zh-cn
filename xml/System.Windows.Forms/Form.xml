<Type Name="Form" FullName="System.Windows.Forms.Form">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1f3fc084a02f774d87fefe2646b5cb5ad6cc9733" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33659937" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Form : System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Form extends System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Form" />
  <TypeSignature Language="VB.NET" Value="Public Class Form&#xA;Inherits ContainerControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Form : System::Windows::Forms::ContainerControl" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.ContainerControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.FormDocumentDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Form")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InitializationEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms.Control.TopLevel")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示组成应用程序的用户界面的窗口或对话框。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Forms.Form>是在你的应用程序中显示任何窗口的表示形式。 <xref:System.Windows.Forms.Form>类可以用于创建标准、 工具中无边框和浮动窗口。 你还可以使用<xref:System.Windows.Forms.Form>类，以创建如对话框中的模式窗口。 一种特殊的窗体中，多文档界面 (MDI) 窗体中，可以包含其他调用 MDI 子窗体的窗体。 通过设置创建的 MDI 窗体<xref:System.Windows.Forms.Form.IsMdiContainer%2A>属性`true`。 通过设置来创建 MDI 子窗体<xref:System.Windows.Forms.Form.MdiParent%2A>到 MDI 父窗体将包含的子窗体的属性。  
  
 使用中可用的属性<xref:System.Windows.Forms.Form>类，你可以确定要创建的窗口或对话框中的外观、 大小、 颜色和窗口管理功能。 <xref:System.Windows.Forms.Control.Text%2A>属性允许你指定的窗口标题的标题栏中。 <xref:System.Windows.Forms.Form.Size%2A>和<xref:System.Windows.Forms.Form.DesktopLocation%2A>属性允许你定义的大小和窗口的位置，它显示时。 你可以使用<xref:System.Windows.Forms.Control.ForeColor%2A>颜色属性可以更改的默认前景色的所有控件置于窗体。 <xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>，和<xref:System.Windows.Forms.Form.MaximizeBox%2A>属性允许您控制是否窗体可以最小化、 最大化时，或在运行时调整大小。  
  
 除了属性外，你可以使用类的方法来操作窗体。 例如，你可以使用<xref:System.Windows.Forms.Form.ShowDialog%2A>方法来显示某个窗体作为模式对话框。 你可以使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>方法在桌面上定位窗体。  
  
 事件<xref:System.Windows.Forms.Form>类可以响应在窗体上执行的操作。 你可以使用<xref:System.Windows.Forms.Form.Activated>事件以执行操作，例如更新时激活该窗体的窗体控件中显示的数据。  
  
 你可以使用窗体作为起始类在你的应用程序通过将调用的方法`Main`类中。 在`Main`方法添加代码以创建并显示窗体。 你还需要添加`STAThread`属性设为`Main`方法按顺序运行的表单。 当启动窗体关闭时，应用程序也将关闭。  
  
 如果你设置<xref:System.Windows.Forms.Control.Enabled%2A>属性`false`之前<xref:System.Windows.Forms.Form>可见 (例如，设置<xref:System.Windows.Forms.Control.Enabled%2A>中为 false[!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)]设计器)，则最小化，使最大化，关闭和的系统按钮，保持启用状态。 如果你设置<xref:System.Windows.Forms.Control.Enabled%2A>到`false`后<xref:System.Windows.Forms.Form>可见 （例如，在负载事件发生时），则禁用此按钮。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>和调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>属性来更改到对话框的外观和表单的功能。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>方法的窗体的<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Form ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Form();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Forms.Form" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 窗体的默认大小为 300 像素高度和宽度的 300 像素。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>和调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>属性来更改到对话框的外观和表单的功能。 该示例还将使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>方法的窗体的<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl AcceptButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl AcceptButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AcceptButton" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptButton As IButtonControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IButtonControl ^ AcceptButton { System::Windows::Forms::IButtonControl ^ get(); void set(System::Windows::Forms::IButtonControl ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当用户按 Enter 键时所单击的窗体上的按钮。</summary>
        <value>
          <see cref="T:System.Windows.Forms.IButtonControl" />，表示要用作窗体的“接受”按钮的按钮。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可指定用户在你的应用程序中按 ENTER 键时要发生的默认操作。 必须是分配给此属性的按钮<xref:System.Windows.Forms.IButtonControl>当前窗体上或位于当前窗体上的容器。  
  
 此属性可用于允许用户能够快速导航是允许他们只需按 ENTER 键，而不是手动单击用鼠标接受按钮完成时的一种简单形式。  
  
 如果窗体上的当前所选的控件截获 ENTER 键，并处理它，可能未激活接受按钮。 例如，多行文本框控件允许选择要在控件中插入新行字符时按 ENTER 键。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>和调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>属性来更改到对话框的外观和表单的功能。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>方法的窗体的<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.CancelButton" />
        <altmember cref="T:System.Windows.Forms.IButtonControl" />
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public void Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Activate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Activate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>激活窗体并给予它焦点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 激活窗体将它置于顶层如果这是活动的应用程序，或如果这不是活动的应用程序，它会闪烁窗口标题。 该窗体必须可见才能产生任何影响此方法。 若要确定活动窗体应用程序中的，使用<xref:System.Windows.Forms.Form.ActiveForm%2A>属性或<xref:System.Windows.Forms.Form.ActiveMdiChild%2A>如果窗体中的多文档界面 (MDI) 应用程序的属性。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>，<xref:System.Windows.Forms.Form.Load>和<xref:System.Windows.Forms.Form.Activate%2A>成员。 若要运行该示例，请将以下代码粘贴在窗体调用`Form1`包含一个按钮调用`Button1`和两个`Label`控件称为`Label1`和`Label2`。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">用于更改焦点。 关联枚举：<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当使用代码激活或用户激活窗体时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  当应用程序处于活动状态，并且具有多个窗体时，活动窗体是具有输入焦点的窗体。 不可见的窗体不能为活动窗体。 激活可见的窗体的最简单方法是单击它或使用相应的键盘组合。  
  
 若要在运行时使用代码激活窗体，调用<xref:System.Windows.Forms.Form.Activate%2A>方法。 例如，更新基于未激活窗体时对窗体的数据所做的更改窗体的内容的任务，你可以使用此事件。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>， <xref:System.Windows.Forms.Form.Closed>， <xref:System.Windows.Forms.Form.Load>， <xref:System.Windows.Forms.Form.Activated>，和<xref:System.Windows.Forms.Form.Activate%2A>成员。 若要运行该示例，请将以下代码粘贴一种称为 form1 包含<xref:System.Windows.Forms.Button>调用`Button1`和两个<xref:System.Windows.Forms.Label>控件称为`Label1`和`Label2`。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ActivateMdiChild">
      <MemberSignature Language="C#" Value="protected void ActivateMdiChild (System.Windows.Forms.Form form);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ActivateMdiChild(class System.Windows.Forms.Form form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ActivateMdiChild(System.Windows.Forms.Form)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ActivateMdiChild(System::Windows::Forms::Form ^ form);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="form">要激活的子窗体。</param>
        <summary>激活窗体的 MDI 子级。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`form`参数已经是活动的 MDI 子窗体，则<xref:System.Windows.Forms.Form.ActivateMdiChild%2A>方法只返回。 如果`form`不`null`，则设置为活动的 MDI 子窗体。  
  
 是否`form`参数是`null`，<xref:System.Windows.Forms.Form.ActivateMdiChild%2A>引发<xref:System.Windows.Forms.Form.MdiChildActivate>事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
        <altmember cref="E:System.Windows.Forms.Form.MdiChildActivate" />
      </Docs>
    </Member>
    <Member MemberName="ActiveForm">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Form ActiveForm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.Form ActiveForm" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveForm" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ActiveForm As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Form ^ ActiveForm { System::Windows::Forms::Form ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此应用程序的当前活动窗体。</summary>
        <value>
          <see cref="T:System.Windows.Forms.Form" />，表示当前活动窗体，或者如果没有活动窗体，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于获取对当前活动窗体在窗体或其控件上执行操作的引用。  
  
 如果你的应用程序的多文档界面 (MDI) 应用程序，请使用<xref:System.Windows.Forms.Form.ActiveMdiChild%2A>属性来获取当前处于活动状态的 MDI 子窗体。  
  
   
  
## Examples  
 下面的代码示例获取活动窗体，并禁用窗体上的所有控件。 该示例使用<xref:System.Windows.Forms.Control.Controls%2A>要循环访问每个窗体上的控件并禁用这些控件的窗体的集合。  
  
 [!code-cpp[Classic Form.ActiveForm Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveForm Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveForm Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveForm Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">用于请求窗体。 关联枚举：<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
      </Docs>
    </Member>
    <Member MemberName="ActiveMdiChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form ActiveMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form ActiveMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveMdiChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActiveMdiChild As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ ActiveMdiChild { System::Windows::Forms::Form ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前活动的多文档界面 (MDI) 子窗口。</summary>
        <value>返回表示当前活动的 MDI 子窗口的 <see cref="T:System.Windows.Forms.Form" />，或者如果当前没有子窗口，则返回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于确定是否有任何 MDI 子窗体在 MDI 应用程序中打开。 此方法还可用于执行操作的 MDI 子窗口上，从其 MDI 父窗体或显示在你的应用程序的另一种形式。  
  
 如果当前活动窗体不是 MDI 子窗体，则可以使用<xref:System.Windows.Forms.Form.ActiveForm%2A>属性来获取对它的引用。  
  
   
  
## Examples  
 下面的代码示例获取对活动的 MDI 子窗体，并循环访问所有的引用<xref:System.Windows.Forms.TextBox>控件在表单上的重置其<xref:System.Windows.Forms.TextBoxBase.Text%2A>属性。 此示例需要已创建了一个 MDI 父窗体和此方法调用，正在从 MDI 父窗体进行。  
  
 [!code-cpp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
      </Docs>
    </Member>
    <Member MemberName="AddOwnedForm">
      <MemberSignature Language="C#" Value="public void AddOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOwnedForm (ownedForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOwnedForm(System::Windows::Forms::Form ^ ownedForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm">此窗体将拥有的 <see cref="T:System.Windows.Forms.Form" />。</param>
        <summary>向此窗体添加附属窗体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 分配给所有者窗体的窗体将保持被拥有直到<xref:System.Windows.Forms.Form.RemoveOwnedForm%2A>调用方法。 你还可以通过设置拥有的另一个窗体<xref:System.Windows.Forms.Form.Owner%2A>与对其所有者窗体的引用的属性。  
  
 当窗体拥有的另一种形式时，它被关闭或隐藏与所有者窗体。 例如，考虑名为窗体`Form2`归名为窗体`Form1`。 如果`Form1`关闭或最小化，`Form2`也会关闭或隐藏。 附属窗体还永远不会显示在其所有者的窗体后面。 可以拥有的窗体以 windows 使用如查找和替换 windows，不应在选择所有者窗体时显示在所有者窗体。  
  
> [!NOTE]
>  如果窗体是多文档界面 (MDI) 父窗体，此属性返回当前任何 MDI 子窗体除了显示的所有窗体打开。 若要获取在 MDI 父窗体中打开的 MDI 子窗体，请使用<xref:System.Windows.Forms.Form.MdiChildren%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.AddOwnedForm%2A>窗体显示为另一个窗体的附属窗体的方法。 附属窗体显示后，你可以尽量减小其所有者窗体和附属窗体将与其最小化。 该示例需要示例中的代码从另一个事件或窗体的方法调用。  
  
 [!code-cpp[Form.AddOwnedForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AddOwnedForm/CPP/form1.cpp#1)]
 [!code-csharp[Form.AddOwnedForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AddOwnedForm/CS/form1.cs#1)]
 [!code-vb[Form.AddOwnedForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AddOwnedForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="AdjustFormScrollbars">
      <MemberSignature Language="C#" Value="protected override void AdjustFormScrollbars (bool displayScrollbars);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void AdjustFormScrollbars(bool displayScrollbars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AdjustFormScrollbars(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub AdjustFormScrollbars (displayScrollbars As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void AdjustFormScrollbars(bool displayScrollbars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="displayScrollbars" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="displayScrollbars">
          如果显示滚动条，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>根据当前控件位置和当前所选控件调整容器中的滚动条。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowTransparency">
      <MemberSignature Language="C#" Value="public bool AllowTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AllowTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowTransparency { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示能否调整窗体的不透明度。</summary>
        <value>
          如果可以更改窗体的不透明度，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性自动设置为`true`如果`Opacity`更改。 当使用设置窗体的不透明度`Opacity`属性，该窗体将窗体上的对象进行分层。 如果你设置<xref:System.Windows.Forms.Form.AllowTransparency%2A>属性`false`窗体不会在分层的模式下，这将提高窗体显示性能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAutoScaling">
      <MemberSignature Language="C#" Value="protected void ApplyAutoScaling ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ApplyAutoScaling() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ApplyAutoScaling" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ApplyAutoScaling ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ApplyAutoScaling();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the ApplyAutoScaling method instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>根据 <see cref="P:System.Windows.Forms.Form.AutoScaleBaseSize" /> 属性的当前值和当前字体的大小来调整窗体大小。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可确定使用的值的窗体大小<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>属性和<xref:System.Windows.Forms.Form.Size%2A>返回值<xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScale">
      <MemberSignature Language="C#" Value="public bool AutoScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScale" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScale" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScale As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoScale { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. Use the AutoScaleMode property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示窗体是否调整其大小以适合该窗体上使用的字体高度，以及是否缩放其控件。</summary>
        <value>
          如果窗体根据分配给它的当前字体自动缩放本身及其控件，则为 <see langword="true" />；否则，为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Form.AutoScale%2A>已过时，并已保留用于向后兼容。 未过时的替代项为 <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A?displayProperty=nameWithType>。 有关自动缩放的详细信息，请参阅[Windows 窗体中的自动缩放](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)。  
  
 可以使用此属性以允许你的窗体，并为自动调整其控件基于的字体中的更改。 这可在应用程序字体其中可能会增加或减少基于由 Windows 为使用指定的语言。  
  
 以获取要使用比例的窗体将自动的大小<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>属性。 如果你想要确定大小窗体将自动调整为根据特定的字体，使用<xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScaleBaseSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size AutoScaleBaseSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size AutoScaleBaseSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScaleBaseSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoScaleBaseSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size AutoScaleBaseSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于自动缩放窗体的基大小。</summary>
        <value>
          <see cref="T:System.Drawing.Size" />，表示此窗体用于自动缩放的基大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  此成员已保留用于向后兼容。 有关自动缩放的详细信息，请参阅[Windows 窗体中的自动缩放](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)。  
  
 值<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>属性用于在窗体显示时计算窗体的缩放因子。 自动缩放基大小用于由窗体作为基准比较到系统的字体大小来确定多少使用自动缩放时缩放窗体。 如果你想要确定大小窗体将自动调整为根据特定的字体，使用<xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>方法。  
  
> [!NOTE]
>  最初创建窗体时，使用此属性的值。 一旦设置该属性，它不能更改。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AutoScale" />
        <altmember cref="M:System.Windows.Forms.Form.GetAutoScaleSize(System.Drawing.Font)" />
      </Docs>
    </Member>
    <Member MemberName="AutoScroll">
      <MemberSignature Language="C#" Value="public override bool AutoScroll { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScroll" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScroll" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoScroll As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoScroll { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示窗体是否启用自动滚动。</summary>
        <value>
          若要在窗体上启用自动滚动，为 <see langword="true" />；否则，为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性设置为`true`，如果任何控件位于窗体的客户端区域外窗体上显示滚动条。 此外，当自动滚动时，窗体的工作区自动滚动，以使具有输入焦点的控件可见。  
  
 此属性可用于防止用户会失去其视频分辨率设置被设置为较低的分辨率时查看控件的能力。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.AutoScroll%2A>属性以支持超出窗体的工作区的控件的显示。 该示例创建一个新窗体并添加<xref:System.Windows.Forms.Button>到窗体控件。 <xref:System.Windows.Forms.Button>控件是超出新窗体的工作区。 <xref:System.Windows.Forms.Form.AutoScroll%2A>属性设置为 true，以在要使用户能够向下滚动到控件的窗体上显示滚动条。 此示例需要在此示例中定义方法从另一种形式的事件处理程序或其他方法中调用。  
  
 [!code-cpp[Form.AutoScroll#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AutoScroll/CPP/form1.cpp#1)]
 [!code-csharp[Form.AutoScroll#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoScroll/CS/form1.cs#1)]
 [!code-vb[Form.AutoScroll#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoScroll/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>根据 <see cref="P:System.Windows.Forms.Form.AutoSizeMode" /> 的设置调整窗体的大小。</summary>
        <value>
          如果窗体将自动调整大小，则为 <see langword="true" />；如果必须手动调整大小，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Windows.Forms.Form.AutoSize%2A>可以强制窗体，若要调整大小以适应其内容。  
  
 窗体不会自动调整大小，在 Visual Studio 窗体设计器中，而不考虑的值<xref:System.Windows.Forms.Form.AutoSize%2A>和<xref:System.Windows.Forms.Form.AutoSizeMode%2A>属性。 窗体正确调整自身大小在运行时根据这两个属性的值。 与之相反，自定义<xref:System.Windows.Forms.UserControl>自动调整自身大小在设计时和运行时。  
  
 使用时<xref:System.Windows.Forms.Form.AutoSize%2A>、<xref:System.Windows.Forms.Control.MinimumSize%2A>和<xref:System.Windows.Forms.Control.MaximumSize%2A>遵循属性，但的当前值<xref:System.Windows.Forms.Control.Size%2A>忽略属性。 使用<xref:System.Windows.Forms.Form.AutoSize%2A>和<xref:System.Windows.Forms.Form.AutoSizeMode%2A>还会呈现<xref:System.Windows.Forms.Form.AutoScroll%2A>多余的因为没有无法收缩要隐藏视图从其所含的控件的窗体的属性。  
  
 请参阅<xref:System.Windows.Forms.AutoSizeMode>有关窗体行为时的方式的信息的枚举<xref:System.Windows.Forms.Form.AutoSize%2A>是`true`。  
  
   
  
## Examples  
 下面的代码示例演示使用自动调整大小以适应其内容的代码创建的窗体。 当运行时，窗体显示<xref:System.Windows.Forms.Label>、<xref:System.Windows.Forms.TextBox>用于输入 URL，和一个<xref:System.Windows.Forms.Button>用于显示用户的默认 Web 浏览器内的该 URL。 此代码示例使用<xref:System.Windows.Forms.FlowLayoutPanel>进行布局所包含控制一个接一个。 它还将设置<xref:System.Windows.Forms.Control.AutoSize%2A>和<xref:System.Windows.Forms.AutoSizeMode>增加和缩小以适合其窗体的内容。  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.Form.AutoSize" /> 属性更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoSizeMode AutoSizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoSizeMode AutoSizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoSizeMode As AutoSizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AutoSizeMode AutoSizeMode { System::Windows::Forms::AutoSizeMode get(); void set(System::Windows::Forms::AutoSizeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体自动调整自身大小的模式。</summary>
        <value>
          <see cref="T:System.Windows.Forms.AutoSizeMode" /> 枚举值。 默认值为 <see cref="F:System.Windows.Forms.AutoSizeMode.GrowOnly" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Windows.Forms.Form.AutoSizeMode%2A>属性的新值会导致要再次布局的窗体。  
  
 窗体不会自动调整大小，在 Visual Studio 窗体设计器中，而不考虑的值<xref:System.Windows.Forms.Form.AutoSize%2A>和<xref:System.Windows.Forms.Form.AutoSizeMode%2A>属性。 窗体正确调整自身大小在运行时根据这两个属性的值。 与之相反，自定义<xref:System.Windows.Forms.UserControl>自动调整自身大小在设计时和运行时。  
  
   
  
## Examples  
 下面的代码示例演示使用自动调整大小以适应其内容的代码创建的窗体。 当运行时，窗体将显示<xref:System.Windows.Forms.Label>、<xref:System.Windows.Forms.TextBox>用于输入 URL，和一个<xref:System.Windows.Forms.Button>用于显示用户的默认 Web 浏览器内的该 URL。 此代码示例使用<xref:System.Windows.Forms.FlowLayoutPanel>进行布局所包含控制一个接一个。 它还将设置<xref:System.Windows.Forms.Control.AutoSize%2A>和<xref:System.Windows.Forms.AutoSizeMode>增加和缩小以适合其窗体的内容。  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">该值不是有效的 <see cref="T:System.Windows.Forms.AutoSizeMode" /> 值。</exception>
        <altmember cref="T:System.Windows.Forms.AutoSizeMode" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="M:System.Windows.Forms.Form.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidate">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.AutoValidate AutoValidate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoValidate AutoValidate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoValidate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoValidate As AutoValidate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AutoValidate AutoValidate { System::Windows::Forms::AutoValidate get(); void set(System::Windows::Forms::AutoValidate value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoValidate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示当焦点更改时是否自动验证此容器内的控件。</summary>
        <value>指示焦点更改时是否隐式验证所含控件的 <see cref="T:System.Windows.Forms.AutoValidate" /> 枚举值。 默认值为“继承”。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoValidateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoValidateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoValidateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoValidateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoValidateChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.Form.AutoValidate" /> 属性更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置控件的背景色。</summary>
        <value>表示控件背景色的 <see cref="T:System.Drawing.Color" />。 默认为 <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> 属性的值。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="CancelButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl CancelButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl CancelButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CancelButton" />
      <MemberSignature Language="VB.NET" Value="Public Property CancelButton As IButtonControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IButtonControl ^ CancelButton { System::Windows::Forms::IButtonControl ^ get(); void set(System::Windows::Forms::IButtonControl ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当用户按 Esc 键时单击的按钮控件。</summary>
        <value>
          <see cref="T:System.Windows.Forms.IButtonControl" />，表示窗体的“取消”按钮。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 窗体取消按钮是每当用户按下 ESC 键时单击该按钮控件。 必须是分配给此属性的按钮<xref:System.Windows.Forms.IButtonControl>当前窗体上或位于当前窗体上的容器。  
  
 此属性，可指定用户在你的应用程序中按 ESC 键时要发生的默认操作。 此属性可用于允许用户能够快速导航是允许他们只需按 ESC 键关闭窗口而不提交更改而不是手动单击取消按钮，用鼠标的一种简单形式。  
  
 <xref:System.Windows.Forms.Form.CancelButton%2A> 可能无法工作如果窗体上的另一个控件截获 ESC 键。 例如，如果你有<xref:System.Windows.Forms.ComboBox>打开窗体上，将关闭 ESC<xref:System.Windows.Forms.ComboBox>而不是关闭窗体。  
  
 <xref:System.Windows.Forms.IButtonControl>对象分配给<xref:System.Windows.Forms.Form.CancelButton%2A>必须在表单上可见，否则是按下 ESC 键将产生任何影响。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>和调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>属性来更改到对话框的外观和表单的功能。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>方法的窗体的<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AcceptButton" />
        <altmember cref="T:System.Windows.Forms.IButtonControl" />
      </Docs>
    </Member>
    <Member MemberName="CenterToParent">
      <MemberSignature Language="C#" Value="protected void CenterToParent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToParent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToParent" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CenterToParent ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CenterToParent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使窗体在父窗体边界内居中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不要调用<xref:System.Windows.Forms.Form.CenterToParent%2A>在代码中直接的方法。 与此相反，设置<xref:System.Windows.Forms.Form.StartPosition%2A>属性<xref:System.Windows.Forms.FormStartPosition.CenterParent>。  
  
 如果窗体或对话框为顶级，则<xref:System.Windows.Forms.Form.CenterToParent%2A>中心相对于屏幕或桌面上窗体。  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Forms.FormStartPosition.CenterParent" />
        <altmember cref="M:System.Windows.Forms.Form.CenterToScreen" />
      </Docs>
    </Member>
    <Member MemberName="CenterToScreen">
      <MemberSignature Language="C#" Value="protected void CenterToScreen ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToScreen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToScreen" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CenterToScreen ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CenterToScreen();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使窗体在当前屏幕上居中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请勿在代码中直接调用此。 与此相反，设置<xref:System.Windows.Forms.Form.StartPosition%2A>属性<xref:System.Windows.Forms.FormStartPosition.CenterScreen>。  
  
 <xref:System.Windows.Forms.Form.CenterToScreen%2A>方法使用下面的优先级列表以确定用于中心窗体的屏幕：  
  
1.  <xref:System.Windows.Forms.Form.Owner%2A>窗体的属性。  
  
2.  窗体 HWND 所有者。  
  
3.  屏幕当前具有鼠标光标。  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Forms.FormStartPosition.CenterScreen" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ClientSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size ClientSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体工作区的大小。</summary>
        <value>
          <see cref="T:System.Drawing.Size" />，表示窗体工作区的大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 窗体的工作区的大小是不包括边框和标题栏的窗体的大小。 窗体的工作区是可在其中放置控件在窗体区域。 可以使用此属性来获取正确的尺寸时执行图形操作或大小和位置表单上的控件时。 若要获取整个窗体的大小，请使用<xref:System.Windows.Forms.Form.Size%2A>属性或使用的各个属性<xref:System.Windows.Forms.Control.Height%2A>和<xref:System.Windows.Forms.Control.Width%2A>。  
  
> [!NOTE]
>  当前无法绑定到使用应用程序设置此属性。 应用程序设置的详细信息，请参阅[应用程序设置概述](~/docs/framework/winforms/advanced/application-settings-overview.md)。  
  
   
  
## Examples  
 下面的代码示例创建的事件处理程序<xref:System.Windows.Forms.Control.Resize>窗体的事件。 事件处理程序使用<xref:System.Windows.Forms.Form.ClientSize%2A>属性的窗体，以<xref:System.Windows.Forms.Button>控件名为`button1`填充整个客户端区域的窗体。  
  
 [!code-cpp[Classic Form.ClientSize Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ClientSize Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ClientSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ClientSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭窗体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 关闭窗体时，在该对象内创建的所有资源都关闭和释放该窗体。 你可以通过处理来防止在运行时关闭窗体<xref:System.Windows.Forms.Form.Closing>事件，并设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性<xref:System.ComponentModel.CancelEventArgs>作为参数传递给事件处理程序。 如果你在关闭窗体是你的应用程序启动窗体，你的应用程序结束。  
  
 以下两种情况时窗体不会被释放上`Close`当 （1） 它是一个多文档界面 (MDI) 应用程序的一部分和窗体不可见，则和 （2） 你具有显示窗体使用<xref:System.Windows.Forms.Form.ShowDialog%2A>。 在这些情况下，你将需要调用<xref:System.Windows.Forms.Form.Dispose%2A>手动来标记的所有垃圾回收的窗体的控件。  
  
> [!NOTE]
>  当<xref:System.Windows.Forms.Form.Close%2A>方法调用<xref:System.Windows.Forms.Form>显示为一个无模式窗口，则不能调用<xref:System.Windows.Forms.Control.Show%2A>方法，以使表单可见，因为已释放了窗体的资源。 若要隐藏窗体，然后将其可见，请使用<xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType>方法。  
  
> [!CAUTION]
>  之前[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]2.0，<xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType>和<xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType>事件不是时引发<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>调用方法以退出应用程序。 如果你有在上述任一事件，必须执行的验证代码，则应调用<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>单独之前调用每个打开的窗体的方法<xref:System.Windows.Forms.Application.Exit%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在创建句柄时关闭了窗体。</exception>
        <exception cref="T:System.ObjectDisposedException">当 <see cref="E:System.Windows.Forms.Form.Activated" /> 设置为 <see cref="P:System.Windows.Forms.Form.WindowState" /> 时，无法从 <see cref="F:System.Windows.Forms.FormWindowState.Maximized" /> 事件调用此方法。</exception>
        <altmember cref="P:System.ComponentModel.CancelEventArgs.Cancel" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>关闭窗体时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed>事件是.NET Framework 2.0 版中过时的; 使用<xref:System.Windows.Forms.Form.FormClosed>事件相反。  
  
 由用户或通过关闭窗体后，将发生此事件<xref:System.Windows.Forms.Form.Close%2A>形式的方法。 若要阻止关闭窗体，处理<xref:System.Windows.Forms.Form.Closing>事件并设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性<xref:System.ComponentModel.CancelEventArgs>传递给事件处理程序`true`。  
  
 若要执行任务，如释放资源由窗体和保存在窗体中输入信息或更新其父窗体，你可以使用此事件。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType>和<xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType>事件不是时引发<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>调用方法以退出应用程序。 如果你有在上述任一事件，必须执行的验证代码，则应调用<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>单独之前调用每个打开的窗体的方法<xref:System.Windows.Forms.Application.Exit%2A>方法。  
  
 如果窗体是 MDI 父窗体，<xref:System.Windows.Forms.Form.Closing>所有 MDI 子窗体的事件引发 MDI 父窗体的<xref:System.Windows.Forms.Form.Closing>引发事件。 此外，<xref:System.Windows.Forms.Form.Closed>之前，将引发事件的所有 MDI 子窗体<xref:System.Windows.Forms.Form.Closed>引发 MDI 父窗体的事件。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>， <xref:System.Windows.Forms.Form.Closed>， <xref:System.Windows.Forms.Form.Load>， <xref:System.Windows.Forms.Form.Activated>，和<xref:System.Windows.Forms.Form.Activate%2A>成员。 若要运行该示例，请将以下代码粘贴在窗体调用`Form1`包含<xref:System.Windows.Forms.Button>调用`Button1`和两个<xref:System.Windows.Forms.Label>控件称为`Label1`和`Label2`。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>关闭窗体时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closing>事件是.NET Framework 2.0 版中过时的; 使用<xref:System.Windows.Forms.Form.FormClosing>事件相反。  
  
 <xref:System.Windows.Forms.Form.Closing>事件发生，因为正在关闭窗体。 关闭窗体时，释放所有资源，在该对象内创建和释放该窗体。 如果您取消此事件，该窗体保持打开状态。 若要取消窗体的关闭，<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性<xref:System.ComponentModel.CancelEventArgs>传递给事件处理程序`true`。  
  
 当窗体显示为模式对话框中时，单击**关闭**按钮 （带有窗体的右上角的 X 按钮） 将导致要隐藏的窗体和<xref:System.Windows.Forms.Form.DialogResult%2A>属性设置为`DialogResult.Cancel`。 你可以重写的值分配给<xref:System.Windows.Forms.Form.DialogResult%2A>属性，当用户单击**关闭**通过设置按钮<xref:System.Windows.Forms.Form.DialogResult%2A>的事件处理程序中的属性<xref:System.Windows.Forms.Form.Closing>窗体的事件。  
  
> [!NOTE]
>  当<xref:System.Windows.Forms.Form.Close%2A>方法调用<xref:System.Windows.Forms.Form>显示为一个无模式窗口，则不能调用<xref:System.Windows.Forms.Control.Show%2A>方法，以使表单可见，因为已释放了窗体的资源。 若要隐藏窗体，然后将其可见，请使用<xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType>方法。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType>和<xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType>事件不是时引发<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>调用方法以退出应用程序。 如果你有在上述任一事件，必须执行的验证代码，则应调用<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>单独之前调用每个打开的窗体的方法<xref:System.Windows.Forms.Application.Exit%2A>方法。  
  
 如果窗体是 MDI 父窗体，<xref:System.Windows.Forms.Form.Closing>所有 MDI 子窗体的事件引发 MDI 父窗体的<xref:System.Windows.Forms.Form.Closing>引发事件。 此外，<xref:System.Windows.Forms.Form.Closed>之前，将引发事件的所有 MDI 子窗体<xref:System.Windows.Forms.Form.Closed>引发 MDI 父窗体的事件。 取消<xref:System.Windows.Forms.Form.Closing>的 MDI 子窗体的事件不会阻止<xref:System.Windows.Forms.Form.Closing>引发 MDI 父窗体的事件。 但是，取消该事件将设置为`true`<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性<xref:System.ComponentModel.CancelEventArgs>，作为参数传递到父窗体。 若要强制所有 MDI 父和子窗体关闭，设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性`false`在 MDI 父窗体。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.Forms.Form.Closing>以测试是否中的文本<xref:System.Windows.Forms.TextBox>已更改。 如果具有，则要求用户是否将所做的更改保存到文件。  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ControlBox">
      <MemberSignature Language="C#" Value="public bool ControlBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ControlBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ControlBox" />
      <MemberSignature Language="VB.NET" Value="Public Property ControlBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ControlBox { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示在该窗体的标题栏中是否显示控件框。</summary>
        <value>
          <see langword="true" /> 如果窗体的窗体，则右上角显示控件框否则为<see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Windows.Forms.Form.ControlBox%2A>属性设置为`true`中的标题栏的右上角显示控件框。 控件框可以包含最小化、 最大化，并帮助此外关闭按钮的按钮。 有关`ControlBox`属性产生任何影响，还必须设置窗体的<xref:System.Windows.Forms.Form.FormBorderStyle%2A>属性<xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>，或<xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>。  
  
 如果你设置<xref:System.Windows.Forms.Form.ControlBox%2A>到`false`并且还设置<xref:System.Windows.Forms.Form.Location%2A>属性，<xref:System.Windows.Forms.Form.Size%2A>窗体的属性未更新以反映该窗体的非工作区已被隐藏。 若要解决此问题，请将更改的代码放<xref:System.Windows.Forms.Form.Location%2A>中的属性<xref:System.Windows.Forms.Control.HandleCreated>事件处理程序。  
  
> [!NOTE]
>  当设置为`false`、<xref:System.Windows.Forms.Form.ControlBox%2A>属性不起作用创建时最大化显示多文档界面 (MDI) 子窗体上的。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.Forms.Form.ControlBox%2A>， <xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>属性创建不具有任何边框或标题中的窗体。 在此示例中创建的窗体无法用于创建应用程序的初始屏幕。 该示例需要示例的方法是在窗体类中定义并在初始化窗体时调用。  
  
 [!code-cpp[Classic Form.ControlBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ControlBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ControlBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ControlBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ShowIcon" />
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateControlsInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateControlsInstance () As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Forms::Control::ControlCollection ^ CreateControlsInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为控件创建控件集合的新实例。</summary>
        <returns>分配给控件的 <see cref="T:System.Windows.Forms.Control.ControlCollection" /> 的新实例。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControlsInstance" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected override void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CreateHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为窗体创建句柄。 如果派生类重写了该函数，它必须调用基实现。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Windows.Forms.Form" /> 的句柄已创建。</exception>
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取创建控件句柄时所需要的创建参数。</summary>
        <value>
          <see cref="T:System.Windows.Forms.CreateParams" />，包含创建控件的句柄时所需的创建参数。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="Deactivate">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Deactivate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivate As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivate;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当窗体失去焦点并不再是活动窗体时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可用于执行任务，例如已停用窗体中的数据更新应用程序中的另一个窗口。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.Deactivate>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.Deactivate>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#393](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#393)]
 [!code-vb[System.Windows.Forms.EventExamples#393](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#393)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
        <altmember cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode DefaultImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取控件支持的默认输入法编辑器 (IME) 模式。</summary>
        <value>
          <see cref="T:System.Windows.Forms.ImeMode" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 输入的法编辑器 (IME) 是一个程序，允许用户通过使用标准键盘输入复杂字符和符号，如日语汉字字符。  
  
 在中实现<xref:System.Windows.Forms.Form>类，此属性始终返回<xref:System.Windows.Forms.ImeMode.NoControl?displayProperty=nameWithType>值。 此属性的值分配给<xref:System.Windows.Forms.Control.ImeMode%2A?displayProperty=nameWithType>属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取控件的默认大小。</summary>
        <value>控件的默认 <see cref="T:System.Drawing.Size" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected override void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">要处理的 Windows <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>向默认窗口过程发送指定消息。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="DesktopBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle DesktopBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DesktopBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopBounds" />
      <MemberSignature Language="VB.NET" Value="Public Property DesktopBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle DesktopBounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 Windows 桌面上窗体的大小和位置。</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" />，它使用桌面坐标表示 Windows 桌面上窗体的边界。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 桌面坐标相对于屏幕，其中不包括任务栏的工作区域。 桌面坐标系统是基于像素的。 如果你的应用程序正在运行的多个监视器系统上，在窗体坐标是合并后的桌面的坐标。  
  
 此属性可用于调整大小和在 Windows 桌面上的位置相对于其他窗体或应用程序的窗体。  
  
   
  
## Examples  
 下面的代码示例设置的大小和窗体的位置，以便该窗体是定位 50 像素，距左边框的顶部的桌面的桌面版和 50 像素。 此示例需要在窗体类中定义方法。  
  
 [!code-cpp[Classic Form.DesktopBounds Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopBounds Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopBounds Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.DesktopLocation" />
      </Docs>
    </Member>
    <Member MemberName="DesktopLocation">
      <MemberSignature Language="C#" Value="public System.Drawing.Point DesktopLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point DesktopLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property DesktopLocation As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point DesktopLocation { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 Windows 桌面上窗体的位置。</summary>
        <value>
          <see cref="T:System.Drawing.Point" />，表示桌面上窗体的位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 桌面坐标相对于屏幕，其中不包括任务栏的工作区域。 桌面坐标系统是基于像素。 如果你的应用程序正在运行的多监视器系统上，在窗体的坐标为合并后的桌面的坐标。  
  
 此属性可用于在 Windows 桌面上的位置相对于其他窗体和应用程序窗体。  
  
 如果调用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>方法之前调用<xref:System.Windows.Forms.Form.Show%2A>方法，将在其默认位置，它由系统定位你的窗体。 有关窗口定位的详细信息，请参阅在 MSDN 库中的"窗口功能"文档"窗口大小和位置"部分http://msdn.microsoft.com/library。  
  
 如果调用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>之后调用<xref:System.Windows.Forms.Form.Show%2A>，你的窗体将位于你指定的位置。  
  
   
  
## Examples  
 下面的代码示例设置窗体的位置，以便窗体为定位的 100 个像素，距左边框的顶部的桌面的桌面和 100 个像素。 此示例需要已在窗体类中定义的方法。  
  
 [!code-cpp[Classic Form.DesktopLocation Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopLocation Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopLocation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DialogResult DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::DialogResult DialogResult { System::Windows::Forms::DialogResult get(); void set(System::Windows::Forms::DialogResult value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体的对话框结果。</summary>
        <value>
          <see cref="T:System.Windows.Forms.DialogResult" />，表示当窗体用作对话框时该窗体的结果。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 窗体的对话框结果是它显示为模式对话框时，从窗体返回的值。 如果该窗体显示为对话框中，设置此属性的值<xref:System.Windows.Forms.DialogResult>枚举设置窗体的对话框结果的值，隐藏模式对话框，并将控制权返回给调用窗体。 此属性通常由设置<xref:System.Windows.Forms.Button.DialogResult%2A>属性<xref:System.Windows.Forms.Button>窗体上的控件。 当用户单击<xref:System.Windows.Forms.Button>控制分配给值<xref:System.Windows.Forms.Button.DialogResult%2A>属性<xref:System.Windows.Forms.Button>分配给<xref:System.Windows.Forms.Form.DialogResult%2A>窗体的属性。  
  
 当窗体显示为模式对话框中时，单击**关闭**按钮 （带有中窗体的右上角的 X 按钮） 将导致要隐藏的窗体和<xref:System.Windows.Forms.Form.DialogResult%2A>属性设置为`DialogResult.Cancel`。 <xref:System.Windows.Forms.Form.Close%2A>方法时不会自动调用用户单击**关闭**按钮的对话框中设置的值或<xref:System.Windows.Forms.Form.DialogResult%2A>属性。 相反，窗体区域不可用，可以再次显示而无需创建对话框中的新实例。 由于此行为，必须调用<xref:System.Windows.Forms.Control.Dispose%2A>时窗体应用程序不再需要该窗体的方法。  
  
 此属性可用于确定如何将对话框中关闭以便正确处理在对话框中执行的操作。  
  
> [!NOTE]
>  你可以重写的值分配给<xref:System.Windows.Forms.Form.DialogResult%2A>属性，当用户单击**关闭**通过设置按钮<xref:System.Windows.Forms.Form.DialogResult%2A>的事件处理程序中的属性<xref:System.Windows.Forms.Form.Closing>窗体的事件。  
  
> [!NOTE]
>  如果<xref:System.Windows.Forms.Form>显示无模式窗口中，返回的值为<xref:System.Windows.Forms.Form.DialogResult%2A>属性可能不返回值分配给窗体，因为关闭窗体时自动释放窗体的资源。  
  
   
  
## Examples  
 下面的代码示例将窗体显示为对话框中，并显示消息框，该值指示是否通过引用被单击的窗体的确定或取消按钮<xref:System.Windows.Forms.Form.DialogResult%2A>窗体的属性。  
  
 [!code-cpp[Classic Form.DialogResult Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DialogResult Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DialogResult Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DialogResult Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定值不在有效值范围内。</exception>
        <altmember cref="T:System.Windows.Forms.DialogResult" />
        <altmember cref="P:System.Windows.Forms.Button.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>处置由 <see cref="T:System.Windows.Forms.Form" /> 占用的资源（内存除外）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法称为由公共`Dispose`方法和<xref:System.Object.Finalize%2A>方法。 `Dispose` 调用受保护`Dispose(Boolean)`方法替换`disposing`参数设置为`true`。 <xref:System.Object.Finalize%2A> 调用`Dispose`与`disposing`设置为`false`。  
  
 当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.Windows.Forms.Form> 引用的、由任何托管对象持有的全部资源。 此方法调用每个引用对象的 `Dispose` 方法。  
  
 <xref:System.Windows.Forms.Form.Dispose%2A> 如果使用显示窗体将自动调用<xref:System.Windows.Forms.Form.Show%2A>方法。 如果另一种方法，如<xref:System.Windows.Forms.Form.ShowDialog%2A>使用时，或根本永远不会显示窗体，则必须调用<xref:System.Windows.Forms.Form.Dispose%2A>中你的应用程序。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> 可以由其他对象多次调用。 重写 <see langword="Dispose(Boolean)" /> 时，请注意不要引用在以前调用 <see langword="Dispose" /> 时已释放的对象。 有关如何实现详细信息<see langword="Dispose(Boolean)" />，请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
 有关详细信息<see langword="Dispose" />和<see cref="M:System.Object.Finalize" />，请参阅[清洗向上非托管资源](~/docs/standard/garbage-collection/unmanaged.md)和[重写 Finalize 方法](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当前显示窗体的显示设备上的 DPI 设置更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FormBorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormBorderStyle FormBorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormBorderStyle FormBorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.FormBorderStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FormBorderStyle As FormBorderStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormBorderStyle FormBorderStyle { System::Windows::Forms::FormBorderStyle get(); void set(System::Windows::Forms::FormBorderStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-504)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormBorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体的边框样式。</summary>
        <value>
          <see cref="T:System.Windows.Forms.FormBorderStyle" />，表示要为窗体显示的边框样式。 默认值为 <see langword="FormBorderStyle.Sizable" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 窗体的边框样式确定的外边缘的窗体的显示方式。 除了更改窗体的边框显示，某些边框样式阻止窗体的大小。 例如，`FormBorderStyle.FixedDialog`边框样式更改为的对话框中的窗体的边框，并阻止窗体在正调整大小。 大小或窗体的标题栏区域的可用性，还会影响的边框样式。  
  
> [!NOTE]
>  与<xref:System.Windows.Forms.FormBorderStyle.Sizable>样式，就是无法调整大小窗口下面某些最小值，即使已设置<xref:System.Windows.Forms.Form.ControlBox%2A>到`false`并分配到一个零长度字符串<xref:System.Windows.Forms.Form.Text%2A>。 请解决这考虑通过使用<xref:System.Windows.Forms.FormBorderStyle.SizableToolWindow>改为样式。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>和调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>属性来更改到对话框的外观和表单的功能。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>方法的窗体的<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定值不在有效值范围内。</exception>
        <altmember cref="T:System.Windows.Forms.FormBorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="FormClosed">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosedEventHandler FormClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosedEventHandler FormClosed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FormClosed As FormClosedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::FormClosedEventHandler ^ FormClosed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>关闭窗体后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.FormClosed>事件发生在由用户或通过关闭窗体之后<xref:System.Windows.Forms.Form.Close%2A>方法或<xref:System.Windows.Forms.Application.Exit%2A>方法<xref:System.Windows.Forms.Application>类。 若要阻止关闭窗体，处理<xref:System.Windows.Forms.Form.FormClosing>事件并设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性<xref:System.ComponentModel.CancelEventArgs>传递给事件处理程序`true`。  
  
 若要执行任务，如释放资源由窗体和保存在窗体中输入信息或更新其父窗体，你可以使用此事件。  
  
 如果窗体是多文档界面 (MDI) 父窗体，<xref:System.Windows.Forms.Form.FormClosing>所有 MDI 子窗体的事件引发 MDI 父窗体的<xref:System.Windows.Forms.Form.FormClosing>引发事件。 同样，<xref:System.Windows.Forms.Form.FormClosed>之前，将引发事件的所有 MDI 子窗体<xref:System.Windows.Forms.Form.FormClosed>引发 MDI 父窗体的事件。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.FormClosed>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.FormClosed>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#395](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#395)]
 [!code-vb[System.Windows.Forms.EventExamples#395](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#395)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="FormClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosingEventHandler FormClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosingEventHandler FormClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FormClosing As FormClosingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::FormClosingEventHandler ^ FormClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>关闭窗体前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.FormClosing>事件发生，因为正在关闭窗体。 关闭窗体时，它将被释放，释放与表单关联的所有资源。 如果您取消此事件，该窗体保持打开状态。 若要取消窗体的关闭，<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性<xref:System.Windows.Forms.FormClosingEventArgs>传递给事件处理程序`true`。  
  
 当窗体显示为模式对话框中时，单击**关闭**按钮 （带有窗体的右上角的 X 按钮） 将导致要隐藏的窗体和<xref:System.Windows.Forms.Form.DialogResult%2A>属性设置为`DialogResult.Cancel`。 你可以重写的值分配给<xref:System.Windows.Forms.Form.DialogResult%2A>属性，当用户单击**关闭**通过设置按钮<xref:System.Windows.Forms.Form.DialogResult%2A>的事件处理程序中的属性<xref:System.Windows.Forms.Form.FormClosing>窗体的事件。  
  
> [!NOTE]
>  当<xref:System.Windows.Forms.Form.Close%2A>方法调用<xref:System.Windows.Forms.Form>显示为一个无模式窗口，则不能调用<xref:System.Windows.Forms.Control.Show%2A>方法，以使表单可见，因为已释放了窗体的资源。 若要隐藏窗体，然后将其可见，请使用<xref:System.Windows.Forms.Control.Hide%2A>方法。  
  
 如果窗体是多文档界面 (MDI) 父窗体，<xref:System.Windows.Forms.Form.FormClosing>所有 MDI 子窗体的事件引发 MDI 父窗体的<xref:System.Windows.Forms.Form.FormClosing>引发事件。 同样，<xref:System.Windows.Forms.Form.FormClosed>之前，将引发事件的所有 MDI 子窗体<xref:System.Windows.Forms.Form.FormClosed>引发 MDI 父窗体的事件。 取消<xref:System.Windows.Forms.Form.FormClosing>的 MDI 子窗体的事件不会阻止<xref:System.Windows.Forms.Form.FormClosing>引发 MDI 父窗体的事件。 但是，取消该事件将设置为`true`<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性<xref:System.Windows.Forms.FormClosingEventArgs>作为参数传递到父窗体的类。 若要强制所有 MDI 父和子窗体关闭，设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性`false`在 MDI 父窗体。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.FormClosing>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.FormClosing>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#394](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#394)]
 [!code-vb[System.Windows.Forms.EventExamples#394](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#394)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="GetAutoScaleSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.SizeF GetAutoScaleSize (System.Drawing.Font font);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.SizeF GetAutoScaleSize(class System.Drawing.Font font) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetAutoScaleSize(System.Drawing.Font)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::SizeF GetAutoScaleSize(System::Drawing::Font ^ font);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the AutoScaleDimensions property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="font" Type="System.Drawing.Font" />
      </Parameters>
      <Docs>
        <param name="font">
          <see cref="T:System.Drawing.Font" />，表示确定窗体的自动缩放基大小的字体。</param>
        <summary>获取根据指定的字体自动缩放窗体时的大小。</summary>
        <returns>
          <see cref="T:System.Drawing.SizeF" />，表示窗体的自动缩放大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A>方法是过时在.net Framework 2.0 版。 此成员已保留用于向后兼容。 有关自动缩放的详细信息，请参阅[Windows 窗体中的自动缩放](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md)。  
  
 此方法可用于确定窗体将字体应用于窗体之前将自动缩放到特定字体的大小。 如果你想要确定大小的形式是自动缩放到基于当前分配给窗体的字体，请使用<xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A>属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AutoScaleBaseSize" />
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="bounds">指定要在显示器边界中检索的区域的 <see cref="T:System.Drawing.Rectangle" />。</param>
        <param name="factor">控件边界的高度和宽度。</param>
        <param name="specified">
          <see cref="T:System.Windows.Forms.BoundsSpecified" /> 值之一，指定在定义控件大小和位置时要使用的控件边界。</param>
        <summary>检索缩放控件时的边界。</summary>
        <returns>一个表示控件缩放边界的 <see cref="T:System.Drawing.Rectangle" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="HelpButton">
      <MemberSignature Language="C#" Value="public bool HelpButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HelpButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.HelpButton" />
      <MemberSignature Language="VB.NET" Value="Public Property HelpButton As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HelpButton { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否应在窗体的标题框中显示“帮助”按钮。</summary>
        <value>
          如果为 <see langword="true" />，则在窗体的标题栏中显示“帮助”按钮；否则，为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当此属性设置为`true`，问号的小按钮将出现在左侧的标题栏中**关闭**按钮。 此按钮可用于显示有关你的应用程序的帮助。 你可以创建的事件处理程序<xref:System.Windows.Forms.Control.HelpRequested>事件来单击的窗体帮助按钮时，向用户显示帮助信息。  

若要显示帮助按钮，窗体的值<xref:System.Windows.Forms.Form.ControlBox>属性必须为`true`，其默认值。 <xref:System.Windows.Forms.Form.ControlBox>属性确定的标题栏的右上角是否包含如最大化按钮、 最小化按钮、 帮助按钮和关闭按钮的控件。 此外，还必须设置窗体的<xref:System.Windows.Forms.Form.FormBorderStyle%2A>属性<xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>，或<xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>。  


> [!IMPORTANT]
>  值<xref:System.Windows.Forms.Form.HelpButton%2A>如果忽略属性**最大化**或**最小化**显示按钮。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>和调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>属性来更改到对话框的外观和表单的功能。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>方法的窗体的<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
        <altmember cref="E:System.Windows.Forms.Form.HelpButtonClicked" />
      </Docs>
    </Member>
    <Member MemberName="HelpButtonClicked">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler HelpButtonClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler HelpButtonClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.HelpButtonClicked" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HelpButtonClicked As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ HelpButtonClicked;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>单击“帮助”按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.HelpButtonClicked>事件发生时**帮助**单击窗体的标题栏中的按钮。 **帮助**显示按钮时<xref:System.Windows.Forms.Form.HelpButton%2A>属性设置为`true`。 <xref:System.Windows.Forms.Form.HelpButtonClicked> 可以取消。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.HelpButtonClicked>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.HelpButtonClicked>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#388](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#388)]
 [!code-vb[System.Windows.Forms.EventExamples#388](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#388)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.HelpButton" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
        <altmember cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.HelpRequested" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Drawing.Icon Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Icon Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As Icon" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Icon ^ Icon { System::Drawing::Icon ^ get(); void set(System::Drawing::Icon ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Icon</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体的图标。</summary>
        <value>
          <see cref="T:System.Drawing.Icon" />，表示窗体的图标。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 窗体的图标指定表示任务栏，以及此图标显示为在窗体控件框中的窗体中的图片。  
  
 此属性将产生任何影响，如果<xref:System.Windows.Forms.Form.FormBorderStyle%2A>设置为<xref:System.Windows.Forms.FormBorderStyle.FixedDialog>。 在这种情况下，窗体将不会显示一个图标。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InputLanguageChanged As InputLanguageChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InputLanguageChangedEventHandler ^ InputLanguageChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>更改窗体的输入语言后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可用于对表单的外观和基于窗体的输入语言所做的更改的文本进行更改。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.InputLanguageChanged>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.InputLanguageChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#400](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#400)]
 [!code-vb[System.Windows.Forms.EventExamples#400](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#400)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanging" />
        <altmember cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanging">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InputLanguageChanging As InputLanguageChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InputLanguageChangingEventHandler ^ InputLanguageChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户尝试更改窗体的输入语言时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 窗体进行的输入语言更改之前，将发生此事件。 你可以通过设置取消语言更改<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性<xref:System.Windows.Forms.InputLanguageChangingEventArgs>传递给事件处理程序`false`。 如果取消了该事件，不会更改输入的语言。 你可以使用此事件以确定请求的输入的语言更改是否适合你的应用程序。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.InputLanguageChanging>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.InputLanguageChanging>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#401](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#401)]
 [!code-vb[System.Windows.Forms.EventExamples#401](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#401)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanged" />
        <altmember cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsMdiChild">
      <MemberSignature Language="C#" Value="public bool IsMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMdiChild As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMdiChild { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示窗体是否为多文档界面 (MDI) 子窗体。</summary>
        <value>
          如果该窗体是 MDI 子窗体，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在运行时，MDI 子窗体将显示在一个 MDI 父窗体工作区。 可以最大化、 最小化，和 MDI 父窗体中移动的 MDI 子窗体。 若要创建的 MDI 子窗体，将分配<xref:System.Windows.Forms.Form>将到 MDI 父窗体<xref:System.Windows.Forms.Form.MdiParent%2A>子窗体的属性。 你可以使用<xref:System.Windows.Forms.Form.IsMdiContainer%2A>属性来确定窗体是 MDI 父窗体。  
  
 你可以使用<xref:System.Windows.Forms.Form.IsMdiChild%2A>属性来确定由方法或属性返回的窗体是 MDI 子窗体或在你的应用程序，如对话框中的标准窗体。  
  
> [!NOTE]
>  所有 MDI 子窗体都具有可调整大小的边框、 一个控件菜单框中和最小化和**最大化**按钮，而不考虑的设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.ControlBox%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>，和<xref:System.Windows.Forms.Form.MaximizeBox%2A>属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
      </Docs>
    </Member>
    <Member MemberName="IsMdiContainer">
      <MemberSignature Language="C#" Value="public bool IsMdiContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiContainer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiContainer" />
      <MemberSignature Language="VB.NET" Value="Public Property IsMdiContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMdiContainer { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示窗体是否为多文档界面 (MDI) 子窗体的容器。</summary>
        <value>
          如果该窗体是 MDI 子窗体的容器，则为 <see langword="true" />；否则，为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性更改为一个 MDI 父窗体的显示和行为的窗体。 当此属性设置为`true`，窗体显示具有凸起边框的凹陷工作区。 分配给父窗体的所有 MDI 子窗体将都显示在其工作区内。  
  
 当关闭 MDI 父窗体时，<xref:System.Windows.Forms.Form.Closing>所有 MDI 子窗体的事件引发 MDI 父窗体的<xref:System.Windows.Forms.Form.Closing>引发事件。 此外，<xref:System.Windows.Forms.Form.Closed>之前，将引发事件的所有 MDI 子窗体<xref:System.Windows.Forms.Form.Closed>引发 MDI 父窗体的事件。  
  
> [!NOTE]
>  如果有两个<xref:System.Windows.Forms.MenuStrip>上设置的 MDI 子窗体的控件<xref:System.Windows.Forms.Form.IsMdiContainer%2A>到`true`父窗体将只有其中一个的内容合并<xref:System.Windows.Forms.MenuStrip>控件。 使用<xref:System.Windows.Forms.ToolStripManager.Merge%2A>其他子的内容合并<xref:System.Windows.Forms.MenuStrip>MDI 父窗体上的控件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.IsMdiContainer%2A>属性以及更改`BackColor`的 MDI 窗体的属性。 若要运行此示例，请在新的窗体中粘贴以下代码。  
  
 [!code-csharp[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
      </Docs>
    </Member>
    <Member MemberName="IsRestrictedWindow">
      <MemberSignature Language="C#" Value="public bool IsRestrictedWindow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRestrictedWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsRestrictedWindow" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRestrictedWindow As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRestrictedWindow { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示窗体是否可以不受限制地使用所有窗口和用户输入事件。</summary>
        <value>
          如果窗体有限制，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.IsRestrictedWindow%2A>属性确定是否<xref:System.Security.Permissions.UIPermissionWindow.AllWindows>授予权限。 此属性设置在窗体的构造函数中的运行时，窗体的生存期内缓存。 在部分信任环境中运行的 Windows 窗体应用程序不能避开此检查，因为公共语言运行时可确保，在部分信任情况下始终调用父构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPreview">
      <MemberSignature Language="C#" Value="public bool KeyPreview { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeyPreview" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.KeyPreview" />
      <MemberSignature Language="VB.NET" Value="Public Property KeyPreview As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeyPreview { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示在将键事件传递到具有焦点的控件前，窗体是否将接收此键事件。</summary>
        <value>
          如果窗体将接收所有键事件，则为 <see langword="true" />；如果窗体上当前选定控件接收键事件，则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当此属性设置为`true`，窗体将接收所有<xref:System.Windows.Forms.Control.KeyPress>， <xref:System.Windows.Forms.Control.KeyDown>，和<xref:System.Windows.Forms.Control.KeyUp>事件。 窗体的事件处理程序已完成处理击键后，键击然后指派给具有焦点的控件。 例如，如果<xref:System.Windows.Forms.Form.KeyPreview%2A>属性设置为`true`和当前选择的控件是<xref:System.Windows.Forms.TextBox>之后由窗体的事件处理程序处理击键,<xref:System.Windows.Forms.TextBox>控件将接收已按下的键。 若要仅在窗体级别处理键盘事件而不允许控件接收到键盘事件，<xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType>中窗体的属性<xref:System.Windows.Forms.Control.KeyPress>事件处理程序`true`。  
  
 此属性可用于处理大多数击键中你的应用程序并可以处理键击或调用来处理击键的相应控件。 例如，当应用程序使用功能键，你可能想要处理窗体级别，而不是为每个控件都可能会收到击键事件编写代码。  
  
> [!NOTE]
>  如果窗体不具有任何可见或启用的控件，它会自动获得所有键盘事件。  
  
> [!NOTE]
>  窗体上的控件可能进行编程，从而取消它接收任何击键。 由于控件永远不会将这些击键发送到窗体，该窗体将不会看到它们不管如何设置<xref:System.Windows.Forms.Form.KeyPreview%2A>。  
  
   
  
## Examples  
 下面的代码示例演示如何设置窗体的<xref:System.Windows.Forms.Form.KeyPreview%2A>为 true，处理窗体级别的关键事件的属性。 若要运行该示例，请在空白的窗体中粘贴以下代码。  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="LayoutMdi">
      <MemberSignature Language="C#" Value="public void LayoutMdi (System.Windows.Forms.MdiLayout value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LayoutMdi(valuetype System.Windows.Forms.MdiLayout value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LayoutMdi (value As MdiLayout)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LayoutMdi(System::Windows::Forms::MdiLayout value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.MdiLayout" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Windows.Forms.MdiLayout" /> 值之一，定义 MDI 子窗体的布局。</param>
        <summary>在 MDI 父窗体内排列多文档界面 (MDI) 子窗体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于在 MDI 父窗体，以便更轻松导航和操作的 MDI 子窗体中排列 MDI 子窗体。 MDI 子窗体可以平铺水平和垂直，级联，或者显示为在 MDI 父窗体内的图标。  
  
   
  
## Examples  
 下面的代码示例演示在 MDI 应用程序的父窗体的窗口菜单的菜单项的事件处理程序。 每个事件处理程序调用<xref:System.Windows.Forms.Form.LayoutMdi%2A>排列任何子窗体的方法是在应用程序中当前打开。  
  
 [!code-cpp[Classic Form.LayoutMdi Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.LayoutMdi Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CS/source.cs#1)]
 [!code-vb[Classic Form.LayoutMdi Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MdiLayout" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Load;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在第一次显示窗体前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可用于执行任务，例如分配由窗体的资源。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>， <xref:System.Windows.Forms.Form.Load>， <xref:System.Windows.Forms.Form.Activated>，和<xref:System.Windows.Forms.Form.Activate%2A>成员。 若要运行该示例，请将以下代码粘贴在窗体调用`Form1`包含<xref:System.Windows.Forms.Button>调用`Button1`和两个<xref:System.Windows.Forms.Label>控件称为`Label1`和`Label2`。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Location { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置以屏幕坐标表示的代表 <see cref="T:System.Windows.Forms.Form" /> 左上角的 <see cref="T:System.Drawing.Point" />。</summary>
        <value>以屏幕坐标表示的代表 <see cref="T:System.Windows.Forms.Form" /> 左上角的 <see cref="T:System.Drawing.Point" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Point> 是一种结构，这意味着它是值类型。 如果访问中的属性<xref:System.Drawing.Point>，返回的属性的副本。 因此，更改<xref:System.Drawing.Point.X%2A>或<xref:System.Drawing.Point.Y%2A>属性<xref:System.Drawing.Point>从返回<xref:System.Windows.Forms.Control.Location%2A>属性将不会影响<xref:System.Windows.Forms.Control.Left%2A>， <xref:System.Windows.Forms.Control.Right%2A>， <xref:System.Windows.Forms.Control.Top%2A>，或<xref:System.Windows.Forms.Control.Bottom%2A>属性值<xref:System.Windows.Forms.Form>. 若要调整这些属性，分别设置每个属性值，或设置<xref:System.Windows.Forms.Form.Location%2A>为一个新的属性<xref:System.Drawing.Point>。  
  
 <xref:System.Windows.Forms.Form.Location%2A>属性获取或设置<xref:System.Windows.Forms.Control.Location%2A>属性<xref:System.Windows.Forms.Control>基类，并设置<xref:System.ComponentModel.SettingsBindableAttribute.Bindable%2A>属性`true`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="MainMenuStrip">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuStrip MainMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MenuStrip MainMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MainMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Property MainMenuStrip As MenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuStrip ^ MainMenuStrip { System::Windows::Forms::MenuStrip ^ get(); void set(System::Windows::Forms::MenuStrip ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体的主菜单容器。</summary>
        <value>
          <see cref="T:System.Windows.Forms.MenuStrip" /> 表示窗体菜单结构的容器。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除了设置<xref:System.Windows.Forms.Form.MainMenuStrip%2A>属性，你必须<xref:System.Windows.Forms.Control.ControlCollection.Add%2A><xref:System.Windows.Forms.MenuStrip>控制转移到<xref:System.Windows.Forms.Control.Controls%2A>窗体的集合。  
  
 <xref:System.Windows.Forms.MenuStrip>类取代<xref:System.Windows.Forms.MainMenu>在以前版本的.NET Framework 的类。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MenuStrip" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Margin { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置控件之间的空间。</summary>
        <value>表示控件之间的空间的值。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MarginChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MarginChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MarginChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.Form.Margin" /> 属性更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximizeBox">
      <MemberSignature Language="C#" Value="public bool MaximizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaximizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizeBox" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximizeBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaximizeBox { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否在窗体的标题栏中显示“最大化”按钮。</summary>
        <value>
          <see langword="true" /> 若要显示**最大化**按钮窗体; 否则为<see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

 A**最大化**按钮使用户得以扩大到全屏幕大小的窗口。 若要显示**最大化**按钮的窗体的值<xref:System.Windows.Forms.Form.ControlBox>属性必须为`true`，其默认值。  <xref:System.Windows.Forms.Form.ControlBox>属性确定的标题栏的右上角是否包含如最大化按钮、 最小化按钮、 帮助按钮和关闭按钮的控件。 此外，还必须设置窗体的<xref:System.Windows.Forms.Form.FormBorderStyle%2A>属性<xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>，或<xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>。  
  
 A**最大化**按钮自动变成一个还原按钮最大化窗口时。 最小化或还原窗口将自动更改还原按钮返回到**最大化**按钮。  
  
> [!NOTE]
>  在运行时将窗体最大程度地生成<xref:System.Windows.Forms.Control.Resize>事件。 <xref:System.Windows.Forms.Form.WindowState%2A>属性反映窗口的当前状态。 如果你设置<xref:System.Windows.Forms.Form.WindowState%2A>属性`FormWindowState.Maximized`，窗体最大化独立于任何设置实际上适用于<xref:System.Windows.Forms.Form.MaximizeBox%2A>和<xref:System.Windows.Forms.Form.FormBorderStyle%2A>属性。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>和调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>属性来更改到对话框的外观和表单的功能。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>方法的窗体的<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="MaximizedBounds">
      <MemberSignature Language="C#" Value="protected System.Drawing.Rectangle MaximizedBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle MaximizedBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizedBounds" />
      <MemberSignature Language="VB.NET" Value="Protected Property MaximizedBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Drawing::Rectangle MaximizedBounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取和设置窗体最大化后的大小。</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" />，表示窗体最大化后的边界。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Drawing.Rectangle.Top" /> 属性的值大于窗体的高度。  
  
 或  
  
 <see cref="P:System.Drawing.Rectangle.Left" /> 属性的值大于窗体的宽度。</exception>
        <block subset="none" type="overrides">
          <para>继承自的类<see cref="T:System.Windows.Forms.Form" />可以重写此方法，以最大化时窗体提供新边界。 类将此属性设置内部时窗体的**最大化**单击按钮。</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximizedBoundsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximizedBoundsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MaximizedBoundsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MaximizedBoundsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="P:System.Windows.Forms.Form.MaximizedBounds" /> 属性的值更改后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.MaximizedBoundsChanged>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.MaximizedBoundsChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#389](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#389)]
 [!code-vb[System.Windows.Forms.EventExamples#389](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#389)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取窗体可调整到的最大大小。</summary>
        <value>
          <see cref="T:System.Drawing.Size" />，表示该窗体的最大大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可限制为指定的最大大小的窗体的大小。 你可以使用此功能，同时显示多个窗口时以确保单个窗口不会导致其他窗口来隐藏。 如果此属性设置为<xref:System.Drawing.Size>是 0 高度和宽度，窗体中的为 0 的对象将具有由 Windows 设置的限制之外没有最大大小。  
  
   
  
## Examples  
 下面的代码示例演示了如何设置<xref:System.Windows.Forms.Form.MaximumSize%2A>属性。  
  
 [!code-cpp[System.Windows.Forms.FormExample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.FormExample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.FormExample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="T:System.Drawing.Size" /> 对象内的高或宽的值小于零。</exception>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.SystemInformation.MaxWindowTrackSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximumSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MaximumSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MaximumSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="P:System.Windows.Forms.Form.MaximumSize" /> 属性的值更改后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.MaximumSizeChanged>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.MaximumSizeChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#390](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#390)]
 [!code-vb[System.Windows.Forms.EventExamples#390](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#390)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MdiChildActivate">
      <MemberSignature Language="C#" Value="public event EventHandler MdiChildActivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MdiChildActivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MdiChildActivate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MdiChildActivate As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MdiChildActivate;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在多文档界面 (MDI) 应用程序内激活或关闭 MDI 子窗体时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用此事件来执行任务，如更新 MDI 子窗体的内容和更改的菜单选项 MDI 父窗体中提供基于状态的已激活 MDI 子窗体。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.MdiChildActivate>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.MdiChildActivate>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#397](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#397)]
 [!code-vb[System.Windows.Forms.EventExamples#397](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#397)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MdiChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] MdiChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] MdiChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MdiChildren As Form()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Windows::Forms::Form ^&gt; ^ MdiChildren { cli::array &lt;System::Windows::Forms::Form ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取窗体的数组，这些窗体表示以此窗体作为父级的多文档界面 (MDI) 子窗体。</summary>
        <value>
          <see cref="T:System.Windows.Forms.Form" /> 对象的数组，每个对象都标识此窗体的一个 MDI 子窗体。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性，可获取对所有 MDI 子窗体在 MDI 父窗体中当前打开的引用。 若要创建的 MDI 子窗体，将分配<xref:System.Windows.Forms.Form>将到 MDI 父窗体<xref:System.Windows.Forms.Form.MdiParent%2A>子窗体的属性。  
  
 此属性可用于循环访问所有 MDI 子窗体来执行操作，例如将数据保存到数据库，MDI 父窗体关闭时或更新基于你的应用程序中执行的操作将子窗体上的字段。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.MdiChildren%2A>属性循环访问列表的 MDI 子窗体并添加<xref:System.Windows.Forms.Button>到每个控件。  
  
 [!code-cpp[Form.MDIChildren#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIChildren/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIChildren#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIChildren/CS/form1.cs#1)]
 [!code-vb[Form.MDIChildren#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIChildren/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
      </Docs>
    </Member>
    <Member MemberName="MdiParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form MdiParent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form MdiParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiParent" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiParent As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ MdiParent { System::Windows::Forms::Form ^ get(); void set(System::Windows::Forms::Form ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此窗体的当前多文档界面 (MDI) 父窗体。</summary>
        <value>
          <see cref="T:System.Windows.Forms.Form" />，表示 MDI 父窗体。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建的 MDI 子窗体，将分配<xref:System.Windows.Forms.Form>将到 MDI 父窗体<xref:System.Windows.Forms.Form.MdiParent%2A>子窗体的属性。 若要获取所有子窗体都需要的全局信息或调用执行所有子窗体的操作的方法，可以使用此属性从 MDI 子窗体。  
  
> [!NOTE]
>  如果有两个<xref:System.Windows.Forms.MenuStrip>上设置的 MDI 子窗体的控件<xref:System.Windows.Forms.Form.IsMdiContainer%2A>到`true`父窗体将只有其中一个的内容合并<xref:System.Windows.Forms.MenuStrip>控件。 使用<xref:System.Windows.Forms.ToolStripManager.Merge%2A>其他子的内容合并<xref:System.Windows.Forms.MenuStrip>MDI 父窗体上的控件。  
  
   
  
## Examples  
 下面的代码示例演示如何在 MDI 应用程序中创建子窗体。 此代码示例创建具有唯一的文本，以标识的子窗体的窗体。 该示例使用<xref:System.Windows.Forms.Form.MdiParent%2A>属性来指定窗体是子窗体。 此示例需要在示例中的代码称为从窗体具有其<xref:System.Windows.Forms.Form.IsMdiContainer%2A>属性设置为`true`和窗体具有一个名为的私有类级别的整型变量`childCount`。  
  
 [!code-cpp[Form.MDIParent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIParent/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIParent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIParent/CS/form1.cs#1)]
 [!code-vb[Form.MDIParent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIParent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">分配给此属性的 <see cref="T:System.Windows.Forms.Form" /> 没有被标记为 MDI 容器。  
  
 或  
  
 分配给此属性的 <see cref="T:System.Windows.Forms.Form" /> 同时作为子 MDI 窗体和 MDI 容器窗体。  
  
 或  
  
 分配给此属性的 <see cref="T:System.Windows.Forms.Form" /> 位于其他线程上。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">用于请求窗体。 关联枚举：<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
      </Docs>
    </Member>
    <Member MemberName="Menu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu Menu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu Menu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Menu" />
      <MemberSignature Language="VB.NET" Value="Public Property Menu As MainMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MainMenu ^ Menu { System::Windows::Forms::MainMenu ^ get(); void set(System::Windows::Forms::MainMenu ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在窗体中显示的 <see cref="T:System.Windows.Forms.MainMenu" />。</summary>
        <value>
          <see cref="T:System.Windows.Forms.MainMenu" />，表示要在窗体中显示的菜单。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用此属性在运行时的整个菜单集合间进行切换。 例如，你可以定义一个<xref:System.Windows.Forms.MainMenu>时多文档界面 (MDI) 窗体具有没有活动的 MDI 子窗体和另一个要显示<xref:System.Windows.Forms.MainMenu>显示子窗口时显示。 你还可以使用不同<xref:System.Windows.Forms.MainMenu>要求显示不同的菜单集的应用程序中存在特定条件时。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Windows.Forms.MainMenu>，将两个分配<xref:System.Windows.Forms.MenuItem>对象添加到<xref:System.Windows.Forms.MainMenu>并将其绑定到窗体。 此示例要求你拥有<xref:System.Windows.Forms.Form>创建命名为`Form1`。  
  
 [!code-cpp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MainMenu.MainMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MainMenu" />
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="MenuComplete">
      <MemberSignature Language="C#" Value="public event EventHandler MenuComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuComplete" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MenuComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MenuComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当窗体菜单失去焦点时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你单击菜单中的任何菜单项中正在执行的命令该结果和该菜单失去焦点时，引发此事件。 你可以使用此事件来执行任务，例如更新的文本<xref:System.Windows.Forms.StatusBar>控件或上启用和禁用按钮<xref:System.Windows.Forms.ToolBar>。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.MenuComplete>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.MenuComplete>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#398](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#398)]
 [!code-vb[System.Windows.Forms.EventExamples#398](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#398)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MenuStart">
      <MemberSignature Language="C#" Value="public event EventHandler MenuStart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuStart" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuStart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MenuStart As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MenuStart;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当窗体菜单接收焦点时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用户单击菜单中的任何菜单项时，引发此事件。 此事件可用于执行任务，例如启用和禁用菜单在访问时不应由用户访问窗体上的控件。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.MenuStart>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.MenuStart>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#399](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#399)]
 [!code-vb[System.Windows.Forms.EventExamples#399](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#399)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MergedMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu MergedMenu { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu MergedMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MergedMenu" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MergedMenu As MainMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MainMenu ^ MergedMenu { System::Windows::Forms::MainMenu ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取窗体的合并菜单。</summary>
        <value>
          <see cref="T:System.Windows.Forms.MainMenu" />，表示窗体的合并菜单。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在窗体合并了其父窗体的菜单的其菜单多文档界面 (MDI) 子窗体时，主要使用此属性。 此属性可用于获取 MDI 应用程序以进行更改或元素添加到菜单结构中的当前菜单结构。 若要获取的未合并<xref:System.Windows.Forms.MainMenu>分配给窗体，使用<xref:System.Windows.Forms.Form.Menu%2A>属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MainMenu" />
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="P:System.Windows.Forms.Form.Menu" />
      </Docs>
    </Member>
    <Member MemberName="MinimizeBox">
      <MemberSignature Language="C#" Value="public bool MinimizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MinimizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimizeBox" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimizeBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MinimizeBox { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否在窗体的标题栏中显示“最小化”按钮。</summary>
        <value>
          <see langword="true" /> 若要显示**最小化**按钮窗体; 否则为<see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A**最小化**按钮使用户得以最小化窗口图标。 若要显示**最小化**按钮的窗体的值<xref:System.Windows.Forms.Form.ControlBox>属性必须为`true`，其默认值。  <xref:System.Windows.Forms.Form.ControlBox>属性确定的标题栏的右上角是否包含如最大化按钮、 最小化按钮、 帮助按钮和关闭按钮的控件。 此外，还必须设置窗体的<xref:System.Windows.Forms.Form.FormBorderStyle%2A>属性<xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>， <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>，或<xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>。  
  
> [!NOTE]
>  最小化窗体，在运行时生成<xref:System.Windows.Forms.Control.Resize>事件。 <xref:System.Windows.Forms.Form.WindowState%2A>属性反映窗口的当前状态。 如果你设置<xref:System.Windows.Forms.Form.WindowState%2A>属性`FormWindowState.Minimized`，窗体将独立于任何设置实际上适用于最小化<xref:System.Windows.Forms.Form.MinimizeBox%2A>和<xref:System.Windows.Forms.Form.FormBorderStyle%2A>属性。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>和调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>， <xref:System.Windows.Forms.Form.MinimizeBox%2A>， <xref:System.Windows.Forms.Form.MaximizeBox%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>属性来更改到对话框的外观和表单的功能。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>方法的窗体的<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体可调整到的最小大小。</summary>
        <value>
          <see cref="T:System.Drawing.Size" />，表示该窗体的最小大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可限制为指定的最小大小的窗体的大小。 此功能可用于防止用户将窗口调整为不合需要的大小。 如果此属性设置为<xref:System.Drawing.Size>是 0 高度和宽度，窗体中的为 0 的对象将具有由 Windows 设置的限制之外没有最小大小。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="T:System.Drawing.Size" /> 对象内的高或宽的值小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="MinimumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MinimumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MinimumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MinimumSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MinimumSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MinimumSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="P:System.Windows.Forms.Form.MinimumSize" /> 属性的值更改后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.MinimumSizeChanged>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.MinimumSizeChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#391](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#391)]
 [!code-vb[System.Windows.Forms.EventExamples#391](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#391)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="Modal">
      <MemberSignature Language="C#" Value="public bool Modal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Modal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Modal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Modal { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否有模式地显示此窗体。</summary>
        <value>
          如果该窗体进行模式显示，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有模式地显示窗体时，不需要输入 （键盘或鼠标单击） 能对模式的窗体上的对象进行除外。 该程序必须隐藏或关闭模式中的窗体 （通常对某些用户执行任何操作的响应） 到另一种形式的输入之前进行。 有模式地显示的窗体通常用作应用程序中的对话框。  
  
 此属性可用于确定你获取从方法或属性的窗体是否已有模式地显示。  
  
 若要显示窗体以模式方式使用<xref:System.Windows.Forms.Form.ShowDialog%2A>方法。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.Forms.Form.Modal%2A>属性来确定是否窗体将显示为模式的窗体。 如果不是<xref:System.Windows.Forms.Form.FormBorderStyle%2A>和<xref:System.Windows.Forms.Form.TopLevel%2A>属性将更改以使工具窗口边框的非顶级窗体的窗体。  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.ShowDialog" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.Activated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnActivated%2A> 方法还允许派生类对事件进行处理而不必附加委托。 重写此方法是处理派生类中的事件的首选的技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackgroundImageChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包该数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnBackgroundImageChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackgroundImageLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackgroundImageLayoutChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.Closed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A>方法是.NET Framework 2.0 版中过时的; 使用<xref:System.Windows.Forms.Form.OnFormClosed%2A>方法相反。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnFormClosed%2A> 方法还允许派生类对事件进行处理而不必附加委托。 重写此方法是处理派生类中的事件的首选的技术。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A>和<xref:System.Windows.Forms.Form.OnClosing%2A>方法不调用时<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>调用方法以退出应用程序。 如果你有必须执行这些方法之一的验证代码，则应调用<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>单独之前调用每个打开的窗体的方法<xref:System.Windows.Forms.Application.Exit%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示如何重写<xref:System.Windows.Forms.Form.OnClosed%2A>从派生类中的方法<xref:System.Windows.Forms.Form>。  
  
 [!code-cpp[System.Drawing.PointsAndSizes#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.PointsAndSizes#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CS/form1.cs#6)]
 [!code-vb[System.Drawing.PointsAndSizes#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.ComponentModel.CancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.Closing" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosing%2A>方法是.NET Framework 2.0 版中过时的; 使用<xref:System.Windows.Forms.Form.OnFormClosing%2A>方法相反。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnClosing%2A> 方法还允许派生类对事件进行处理而不必附加委托。 重写此方法是处理派生类中的事件的首选的技术。  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A>和<xref:System.Windows.Forms.Form.OnClosing%2A>方法不调用时<xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType>调用方法以退出应用程序。 如果你有必须执行这些方法之一的验证代码，则应调用<xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType>单独之前调用每个打开的窗体的方法<xref:System.Windows.Forms.Application.Exit%2A>方法。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.Forms.Form.Closing>以测试是否中的文本<xref:System.Windows.Forms.TextBox>已更改。 如果具有，则要求用户是否将所做的更改保存到文件。  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
        <altmember cref="T:System.ComponentModel.CancelEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected override void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnCreateControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引发 <see langword="CreateControl" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Windows.Forms.Form.OnCreateControl" />在派生类中，一定要调用基类的<see cref="M:System.Windows.Forms.Form.OnCreateControl" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivate">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivate(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.Deactivate" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnDeactivate%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Deactivate" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.Forms.DpiChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(class System.Windows.Forms.DpiChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDpiChanged(System.Windows.Forms.DpiChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChanged (e As DpiChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChanged(System::Windows::Forms::DpiChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DpiChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.DpiChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected override void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEnabledChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.EnabledChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected override void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEnter(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.Enter" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnEnter%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.FontChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.OnFontChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFormClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosed (System.Windows.Forms.FormClosedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosed(class System.Windows.Forms.FormClosedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFormClosed (e As FormClosedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFormClosed(System::Windows::Forms::FormClosedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.FormClosedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.FormClosed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.OnFormClosing%2A>方法可以删除从当前窗体<xref:System.Windows.Forms.Application.OpenForms%2A>的关联集合<xref:System.Windows.Forms.Application>。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnFormClosed%2A> 方法还允许派生类对事件进行处理而不必附加委托。 重写此方法是处理派生类中的事件的首选的技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFormClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosing (System.Windows.Forms.FormClosingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosing(class System.Windows.Forms.FormClosingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFormClosing (e As FormClosingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFormClosing(System::Windows::Forms::FormClosingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.FormClosingEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.FormClosing" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnFormClosing%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnGetDpiScaledSize">
      <MemberSignature Language="C#" Value="protected virtual bool OnGetDpiScaledSize (int deviceDpiOld, int deviceDpiNew, ref System.Drawing.Size desiredSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnGetDpiScaledSize(int32 deviceDpiOld, int32 deviceDpiNew, valuetype System.Drawing.Size&amp; desiredSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnGetDpiScaledSize(System.Int32,System.Int32,System.Drawing.Size@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnGetDpiScaledSize (deviceDpiOld As Integer, deviceDpiNew As Integer, ByRef desiredSize As Size) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnGetDpiScaledSize(int deviceDpiOld, int deviceDpiNew, System::Drawing::Size % desiredSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" />
        <Parameter Name="desiredSize" Type="System.Drawing.Size&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">以前显示窗体的显示设备的 DPI 值。</param>
        <param name="deviceDpiNew">将显示窗体的显示设备的 DPI 值。</param>
        <param name="desiredSize">表示基于新 DPI 值的窗体的新大小的 <see cref="T:System.Drawing.Size" />。</param>
        <summary>引发 GetDpiScaledSize 事件。</summary>
        <returns>
          如果成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.HandleCreated" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHelpButtonClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpButtonClicked (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpButtonClicked(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHelpButtonClicked (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHelpButtonClicked(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.ComponentModel.CancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.HelpButtonClicked" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnHelpButtonClicked%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.HelpButtonClicked" />
        <altmember cref="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
        <altmember cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanged (System.Windows.Forms.InputLanguageChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanged(class System.Windows.Forms.InputLanguageChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInputLanguageChanged (e As InputLanguageChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInputLanguageChanged(System::Windows::Forms::InputLanguageChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.InputLanguageChangedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.InputLanguageChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnInputLanguageChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanged" />
        <altmember cref="T:System.Windows.Forms.InputLanguageChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanging (System.Windows.Forms.InputLanguageChangingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanging(class System.Windows.Forms.InputLanguageChangingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInputLanguageChanging (e As InputLanguageChangingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInputLanguageChanging(System::Windows::Forms::InputLanguageChangingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.InputLanguageChangingEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.InputLanguageChanging" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnInputLanguageChanging%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanging" />
        <altmember cref="T:System.Windows.Forms.InputLanguageChangingEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected override void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">事件数据。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.Layout" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.Load" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnLoad%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximizedBoundsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximizedBoundsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMaximizedBoundsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMaximizedBoundsChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.MaximizedBoundsChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMaximizedBoundsChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMaximumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMaximumSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMaximumSizeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.MaximumSizeChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMaximumSizeChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="E:System.Windows.Forms.Form.MaximumSizeChanged" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMdiChildActivate">
      <MemberSignature Language="C#" Value="protected virtual void OnMdiChildActivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMdiChildActivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMdiChildActivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMdiChildActivate(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.MdiChildActivate" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMdiChildActivate%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MdiChildActivate" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMenuComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMenuComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMenuComplete(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.MenuComplete" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMenuComplete%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MenuComplete" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMenuStart">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuStart (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuStart(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMenuStart (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMenuStart(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.MenuStart" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMenuStart%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MenuStart" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMinimumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMinimumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMinimumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMinimumSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMinimumSizeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.MinimumSizeChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnMinimumSizeChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MinimumSizeChanged" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected override void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.Paint" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected override void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnResize(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.Resize" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResizeBegin">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeBegin (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeBegin(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResizeBegin (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResizeBegin(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.ResizeBegin" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeBegin>将仅引发事件，如果窗体的<xref:System.Windows.Forms.Control.CanRaiseEvents%2A>属性设置为`true`。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnResizeBegin%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.ResizeBegin" />
        <altmember cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResizeEnd">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeEnd (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeEnd(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResizeEnd (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResizeEnd(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.ResizeEnd" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeEnd>将仅引发事件，如果窗体的<xref:System.Windows.Forms.Control.CanRaiseEvents%2A>属性设置为`true`。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnResizeEnd%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.ResizeEnd" />
        <altmember cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRightToLeftLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRightToLeftLayoutChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前窗体或其父级之一正在释放资源，<xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A>方法将返回而不执行任何操作。 如果<xref:System.Windows.Forms.Control.RightToLeft%2A>窗体的属性具有的值<xref:System.Windows.Forms.RightToLeft.Yes>，然后将通过对的调用中重新创建窗体及其子控件的句柄<xref:System.Windows.Forms.Control.RecreateHandle%2A>方法。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
        <altmember cref="P:System.Windows.Forms.Form.RightToLeftLayout" />
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="Overload:System.Windows.Forms.Form.Dispose" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
      </Docs>
    </Member>
    <Member MemberName="OnShown">
      <MemberSignature Language="C#" Value="protected virtual void OnShown (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShown(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShown (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShown(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Form.Shown" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Shown>事件发生时首次显示窗体。  
  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnShown%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected override void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnStyleChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.StyleChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected override void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.TextChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected override void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnVisibleChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.VisibleChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.Form.OnVisibleChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在派生类中重写 <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" /> 时，一定要调用基类的 <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" /> 方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Opacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Opacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Opacity { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.OpacityConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体的不透明度级别。</summary>
        <value>窗体的不透明度级别。 默认值为 1.00。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Opacity%2A>属性使您能够指定为窗体及其控件的透明度级别。 当此属性设置为小于 100%(1.00) 的值时，整个窗体中，包括边框、 进行更加透明。 此属性设置为值为 0%(0.00) 使窗体完全不可见。 你可以使用此属性，以提供不同级别的透明度或提供如窗体逐渐加入或退出视图的效果。 例如，你可以一个窗体逐渐到视图通过设置<xref:System.Windows.Forms.Form.Opacity%2A>属性 0%(0.00)，而且逐渐增加的值，直至其达到 100%(1.00) 的值。  
  
 <xref:System.Windows.Forms.Form.Opacity%2A> 不同于由提供的透明度<xref:System.Windows.Forms.Form.TransparencyKey%2A>、 这只是使窗体和其控件完全透明如果它们是中指定的值与相同的颜色<xref:System.Windows.Forms.Form.TransparencyKey%2A>属性。  
  
 此属性不是支持时<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>是`true`。  
  
 <xref:System.Windows.Forms.Form.Opacity%2A>属性依赖于分层的 Windows API 引入了在 Windows 2000 中使用。 有关详细信息，请参阅"分层 Windows:: 新方式对使用透明度和透明度效果在 Windows 应用程序"中的平台 SDK 文档[ http://msdn.microsoft.com ](http://msdn.microsoft.com/)。  
  
   
  
## Examples  
 下面的代码示例演示如何创建带有 75%的不透明度级别显示窗体。 此代码示例创建一个在与屏幕的中心中放置的新窗体<xref:System.Windows.Forms.Form.Opacity%2A>属性设置以更改窗体的不透明度级别。 代码示例还将设置<xref:System.Windows.Forms.Form.Size%2A>属性，以提供更大大小超过默认大小的窗体的窗体。 编写此代码示例时，在此示例中定义此方法叫做从事件处理程序或其他方法中的另一种形式的假设。  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.TransparencyKey" />
        <altmember cref="F:System.Windows.Forms.OSFeature.LayeredWindows" />
      </Docs>
    </Member>
    <Member MemberName="OwnedForms">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] OwnedForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] OwnedForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.OwnedForms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedForms As Form()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Windows::Forms::Form ^&gt; ^ OwnedForms { cli::array &lt;System::Windows::Forms::Form ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Forms.Form" /> 对象的数组，这些对象表示此窗体拥有的所有窗体。</summary>
        <value>
          <see cref="T:System.Windows.Forms.Form" /> 数组，它表示此窗体的附属窗体。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回一个数组，包含此窗体拥有的所有窗体。 若要使窗体拥有的另一种形式，调用<xref:System.Windows.Forms.Form.AddOwnedForm%2A>方法。 分配给所有者窗体的窗体将保持拥有直到<xref:System.Windows.Forms.Form.RemoveOwnedForm%2A>调用方法。 你还可以通过设置拥有的另一个窗体<xref:System.Windows.Forms.Form.Owner%2A>与对其所有者窗体的引用的属性。  
  
 当窗体拥有的另一种形式时，它被关闭或隐藏与所有者窗体。 例如，考虑名为窗体`Form2`归名为窗体`Form1`。 如果`Form1`关闭或最小化，`Form2`也会关闭或隐藏。 附属窗体还永远不会显示在其所有者的窗体后面。 可以拥有的窗体以 windows 使用如查找和替换 windows，不应在选择所有者窗体时显示在所有者窗体。  
  
> [!NOTE]
>  如果窗体是多文档界面 (MDI) 父窗体，该属性将返回当前任何 MDI 子窗体除了显示的所有窗体打开。 若要获取在 MDI 父窗体中打开的 MDI 子窗体，请使用<xref:System.Windows.Forms.Form.MdiChildren%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.OwnedForms%2A>属性修改所有者窗体拥有的所有窗体。 在示例中第一种方法将窗体添加到与附属窗体的附属窗体的数组。 第二种方法遍历所有附属窗体，并更改标题。 此示例需要这两种方法调用的事件或表单的其他方法。  
  
 [!code-cpp[Form.OwnedForms#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.OwnedForms/CPP/form1.cpp#1)]
 [!code-csharp[Form.OwnedForms#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.OwnedForms/CS/form1.cs#1)]
 [!code-vb[Form.OwnedForms#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.OwnedForms/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ Owner { System::Windows::Forms::Form ^ get(); void set(System::Windows::Forms::Form ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置拥有此窗体的窗体。</summary>
        <value>
          <see cref="T:System.Windows.Forms.Form" />，表示作为此窗体的所有者的窗体。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要将另一个窗体拥有的窗体，将分配其<xref:System.Windows.Forms.Form.Owner%2A>的引用将成为所有者的窗体的属性。  
  
 当窗体拥有的另一种形式时，它被关闭或隐藏与所有者窗体。 例如，考虑名为窗体`Form2`归名为窗体`Form1`。 如果`Form1`关闭或最小化，`Form2`也会关闭或隐藏。附属窗体还永远不会显示在其所有者的窗体后面。 你可以拥有的窗体以 windows 使用如查找和替换 windows，选中所有者窗体时应不会消失。 若要确定属于父窗体的窗体，请使用<xref:System.Windows.Forms.Form.OwnedForms%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">顶级窗口不能具有所有者。</exception>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">通过引用传递的 <see cref="T:System.Windows.Forms.Message" />，它表示要处理的 Win32 消息。</param>
        <param name="keyData">
          <see cref="T:System.Windows.Forms.Keys" /> 值之一，表示要处理的键。</param>
        <summary>处理命令键。</summary>
        <returns>
          如果控件处理并使用击键，则为 <see langword="true" />；否则为 <see langword="false" />，以允许进一步处理。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ProcessCmdKey%2A>方法重写基  
  
 <xref:System.Windows.Forms.ContainerControl.ProcessCmdKey%2A?displayProperty=nameWithType> 实现以提供的主菜单命令键和 MDI 快捷键的其他处理。  
  
 有关捕获击键的信息，请参阅"如何使用 Visual C# 陷阱控件中的键击"和"如何捕获.NET 中的键击控件通过使用 Visual Basic.NET"Microsoft 知识库中在http://support.microsoft.com。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="T:System.Windows.Forms.Message" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessDialogKey(System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogChar(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">要处理的字符。</param>
        <summary>处理对话框字符。</summary>
        <returns>
          如果字符已由控件处理，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">
          <see cref="T:System.Windows.Forms.Keys" /> 值之一，表示要处理的键。</param>
        <summary>处理对话框键。</summary>
        <returns>
          如果控件处理并使用击键，则为 <see langword="true" />；否则为 <see langword="false" />，以允许进一步处理。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ProcessDialogKey%2A>方法重写基<xref:System.Windows.Forms.ContainerControl.ProcessDialogKey%2A?displayProperty=nameWithType>实现以提供的对话框中的返回和转义键的其他处理。 该方法对包括的 ALT 或控件的修饰符的击键执行不会进行处理。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessDialogKey(System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessDialogChar(System.Char)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected override bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessKeyPreview (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessKeyPreview(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">通过引用传递的 <see cref="T:System.Windows.Forms.Message" />，表示要处理的窗口消息。</param>
        <summary>预览键盘消息。</summary>
        <returns>
          如果消息已由控件处理，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal override bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function ProcessMnemonic (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool ProcessMnemonic(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">要处理的字符。</param>
        <summary>处理助记键字符。</summary>
        <returns>
          如果字符由控件作为助记键处理，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessTabKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessTabKey (bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessTabKey(bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessTabKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessTabKey (forward As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessTabKey(bool forward);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forward">
          如果在 ContainerControl 内的控件中向前循环，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>选择下一个可用控件并使其成为活动控件。</summary>
        <returns>
          如果选择了一个控件，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessTabKey(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveOwnedForm">
      <MemberSignature Language="C#" Value="public void RemoveOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveOwnedForm (ownedForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveOwnedForm(System::Windows::Forms::Form ^ ownedForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm">
          <see cref="T:System.Windows.Forms.Form" />，表示要从此窗体的附属窗体列表中移除的窗体。</param>
        <summary>从此窗体移除附属窗体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 分配给所有者窗体的窗体将保持被拥有直到<xref:System.Windows.Forms.Form.RemoveOwnedForm%2A>调用方法。 除了附属窗体移除附属窗体的列表，此方法还将所有者窗体设置为`null`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
      </Docs>
    </Member>
    <Member MemberName="ResizeBegin">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeBegin;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeBegin" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeBegin" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResizeBegin As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ResizeBegin;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>窗体进入大小调整模式时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeBegin>在用户开始调整窗体中，大小通常，通过单击和拖动其中一个边框或位于在窗体右下角的大小调整手柄时引发事件。 此操作将窗体进入大小调整模式循环，直到大小调整操作完成。 通常情况下，调整大小操作期间发生以下一组事件：  
  
1.  单个<xref:System.Windows.Forms.Form.ResizeBegin>事件发生窗体进入大小调整模式。  
  
2.  零个或多个对<xref:System.Windows.Forms.Control.Resize>和<xref:System.Windows.Forms.Control.SizeChanged>事件发生为窗体的<xref:System.Windows.Forms.Form.Size%2A>被修改。  
  
3.  单个<xref:System.Windows.Forms.Form.ResizeEnd>事件发生窗体退出大小调整模式。  
  
> [!NOTE]
>  只通过单击而无需拖动边框或大小调整手柄将生成<xref:System.Windows.Forms.Form.ResizeBegin>和<xref:System.Windows.Forms.Form.ResizeEnd>事件而无需任何中间<xref:System.Windows.Forms.Control.Resize>和<xref:System.Windows.Forms.Control.SizeChanged>事件对。  
  
 <xref:System.Windows.Forms.Form.ResizeBegin>和<xref:System.Windows.Forms.Form.ResizeEnd>当用户将窗体中，通常通过单击和拖动在标题栏上，也会引发的事件对。 这些事件不由生成的窗体中，编程操作例如通过更改<xref:System.Windows.Forms.Form.Size%2A>或<xref:System.Windows.Forms.Control.Location%2A>属性。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.ResizeBegin>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.ResizeBegin>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#404](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#404)]
 [!code-vb[System.Windows.Forms.EventExamples#404](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#404)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.Control.PreferredSize" />
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Form.SizeGripStyle" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
        <altmember cref="E:System.Windows.Forms.Form.ResizeEnd" />
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="ResizeEnd">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeEnd" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResizeEnd As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ResizeEnd;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>窗体退出大小调整模式时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeEnd>用户完成调整大小操作窗体中，通常通过拖动其中一个边框或大小调整手柄的右下角的窗体中，然后将其释放时，将引发事件。 有关大小调整操作的详细信息，请参阅<xref:System.Windows.Forms.Form.ResizeBegin>事件。  
  
 <xref:System.Windows.Forms.Form.ResizeEnd>之后用户移动窗体中，通常通过单击和拖动在标题栏上，也会生成事件。 此事件不由生成的窗体中，编程操作例如通过更改<xref:System.Windows.Forms.Form.Size%2A>或<xref:System.Windows.Forms.Control.Location%2A>属性。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.ResizeEnd>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.ResizeEnd>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#405](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#405)]
 [!code-vb[System.Windows.Forms.EventExamples#405](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#405)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.Control.PreferredSize" />
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Form.SizeGripStyle" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
        <altmember cref="E:System.Windows.Forms.Form.ResizeBegin" />
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle RestoreBounds { System::Drawing::Rectangle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取窗体在其正常窗口状态下的位置和大小。</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" />，包含窗体在正常窗口状态下的位置和大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，使用<xref:System.Windows.Forms.Form.RestoreBounds%2A>属性跟踪用户的窗口大小，并在其正常窗口状态放置窗体的首选项。 应跟踪这两个值的<xref:System.Windows.Forms.Form.WindowState%2A>和<xref:System.Windows.Forms.Form.RestoreBounds%2A>属性跟踪用户的窗口首选项时。  
  
> [!NOTE]
>  值<xref:System.Windows.Forms.Form.RestoreBounds%2A>属性是仅当<xref:System.Windows.Forms.Form.WindowState%2A>属性<xref:System.Windows.Forms.Form>类是否不等于<xref:System.Windows.Forms.FormWindowState.Normal>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayout">
      <MemberSignature Language="C#" Value="public virtual bool RightToLeftLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeftLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RightToLeftLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RightToLeftLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool RightToLeftLayout { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否打开从右向左的镜像放置。</summary>
        <value>
          如果打开了从右到左的镜像放置，则为 <see langword="true" />；否则对于标准子控件放置，为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A>属性是主要用于为全球受众开发全球通用的窗体。 许多窗体经过专门设计，因此，以从左到右的方式在窗体上的控件进行布局。 这些窗体将遵循此编写指导的语言与兼容。 但是，当向右到左语言的用户显示相同的窗体时，通常最好是反向窗体上控件的顺序。 如果这两个<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>和<xref:System.Windows.Forms.Control.RightToLeft%2A>属性`true`，镜像将打开窗体，并且控件放置和文本流将为从右到左。  
  
 与不同<xref:System.Windows.Forms.Control.RightToLeft%2A>，<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>不会继承。 如果您希望其生效子控件，你必须将它设置每个要镜像的子控件。  
  
 不是所有者描述支持时<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>设置为`Yes`。 仍将发生所有者 draw 事件，但未定义这些事件中编写任何代码的行为。 此外， <xref:System.Windows.Forms.Control.BackgroundImage%2A>， <xref:System.Windows.Forms.Form.Opacity%2A>， <xref:System.Windows.Forms.Form.TransparencyKey%2A>，并且不支持绘制事件。  
  
 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A>和<xref:System.Windows.Forms.Control.RightToLeft%2A>属性会导致以下 Win32 API 窗口样式设置：  
  
-   当<xref:System.Windows.Forms.Control.RightToLeft%2A>设置为`Yes`和<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>设置为`true`，Windows 窗体设置`WS_EX_LAYOUTRTL`窗口样式，并移除`WS_EX_RIGHT`和`WS_EX_RTLREADING`样式。  
  
-   当<xref:System.Windows.Forms.Control.RightToLeft%2A>设置为`Yes`但<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>设置为`No`，Windows 窗体设置`WS_EX_RIGHT`和`WS_EX_RTLREADING`窗口样式。  
  
 更改此属性的值引发<xref:System.Windows.Forms.Form.RightToLeftLayoutChanged>事件。  
  
 有关的全球化问题的详细信息，请参阅[开发全球通用应用程序的最佳实践](~/docs/standard/globalization-localization/best-practices-for-developing-world-ready-apps.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="Overload:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RightToLeftLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RightToLeftLayoutChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>更改 <see cref="P:System.Windows.Forms.Form.RightToLeftLayout" /> 属性值之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RightToLeft%2A>和<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>属性通常用在开发全球通用应用程序。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.RightToLeftLayoutChanged>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.RightToLeftLayoutChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#402](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#402)]
 [!code-vb[System.Windows.Forms.EventExamples#402](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#402)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.RightToLeftLayout" />
        <altmember cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected override void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="factor">控件高度和宽度的缩放因子。</param>
        <param name="specified">一个 <see cref="T:System.Windows.Forms.BoundsSpecified" /> 值，指定在定义控件的大小和位置时要使用的控件边界。</param>
        <summary>缩放控件的位置、大小、空白和边距。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected override void ScaleCore (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleCore(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleCore(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ScaleCore (x As Single, y As Single)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ScaleCore(float x, float y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">水平缩放窗体的百分比</param>
        <param name="y">垂直缩放窗体的百分比</param>
        <summary>执行窗体缩放操作。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected override void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Select(bool directed, bool forward);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">如果设置为 true，则更改活动控件</param>
        <param name="forward">如果 directed 为 true，则它控制焦点移动的方向。 如果此项为 <see langword="true" />，则下一个控件被选定；否则，上一个控件被选定。</param>
        <summary>选择此窗体，并且可以选择下一个或上一个控件。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">用于更改焦点。 关联枚举：<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected override void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">控件的新 <see cref="P:System.Windows.Forms.Control.Left" /> 属性值。</param>
        <param name="y">控件的新 <see cref="P:System.Windows.Forms.Control.Top" /> 属性值。</param>
        <param name="width">控件的新 <see cref="P:System.Windows.Forms.Control.Width" /> 属性值。</param>
        <param name="height">控件的新 <see cref="P:System.Windows.Forms.Control.Height" /> 属性值。</param>
        <param name="specified">
          <see cref="T:System.Windows.Forms.BoundsSpecified" /> 值的按位组合。</param>
        <summary>执行设置该控件的指定边界的工作。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected override void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetClientSizeCore (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetClientSizeCore(int x, int y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">请求的工作区宽度。</param>
        <param name="y">请求的工作区高度。</param>
        <summary>设置窗体的工作区大小。 这将调整窗体的界限，以将工作区大小设置为请求的大小。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
      </Docs>
    </Member>
    <Member MemberName="SetDesktopBounds">
      <MemberSignature Language="C#" Value="public void SetDesktopBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDesktopBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDesktopBounds(int x, int y, int width, int height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">窗体位置的 x 坐标。</param>
        <param name="y">窗体位置的 y 坐标。</param>
        <param name="width">窗体的宽度。</param>
        <param name="height">窗体的高度。</param>
        <summary>以桌面坐标设置窗体的边界。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 桌面坐标相对于屏幕，其中不包括任务栏的工作区域。 你可以使用此方法在桌面上设置的位置和大小的窗体。 因为桌面坐标基于窗体的工作区域，可以使用此方法以确保你的窗体是完全在桌面上可见。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.SetDesktopBounds%2A>方法。 若要运行此示例中，粘贴以下代码中包含名为的按钮的窗体`Button2`。 确保所有事件都都其事件处理程序关联。  
  
 [!code-cpp[System.Windows.Forms.FormExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.FormExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.FormExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.SetDesktopLocation(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetDesktopLocation">
      <MemberSignature Language="C#" Value="public void SetDesktopLocation (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopLocation(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopLocation(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDesktopLocation (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDesktopLocation(int x, int y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">窗体位置的 x 坐标。</param>
        <param name="y">窗体位置的 y 坐标。</param>
        <summary>以桌面坐标设置窗体的位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 桌面坐标相对于屏幕，其中不包括任务栏的工作区域。 此方法可用于在桌面上定位你的窗体。 因为桌面坐标基于窗体的工作区域，可以使用此方法以确保你的窗体是完全在桌面上可见。 此方法应主要用于顶级窗体;使用<xref:System.Windows.Forms.Form.LayoutMdi%2A>方法定位多文档界面 (MDI) 子窗体。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.SetDesktopLocation%2A>，<xref:System.Windows.Forms.Form.Load>和<xref:System.Windows.Forms.Form.Activate%2A>成员。 若要运行该示例，请将以下代码粘贴在窗体调用`Form1`包含一个按钮调用`Button1`和两个`Label`控件称为`Label1`和`Label2`。  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.SetDesktopBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected override void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetVisibleCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetVisibleCore (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetVisibleCore(bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          <see langword="true" /> 表示使控件可见；<see langword="false" /> 表示使控件不可见。</param>
        <summary>将控件设置为指定的可见状态。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Show(System.Windows.Forms.IWin32Window)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show (owner As IWin32Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show(System::Windows::Forms::IWin32Window ^ owner);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" />
      </Parameters>
      <Docs>
        <param name="owner">任何实现 <see cref="T:System.Windows.Forms.IWin32Window" /> 并表示将拥有此窗体的顶级窗口的对象。</param>
        <summary>向用户显示具有指定所有者的窗体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于显示的非模式窗体。 当你使用此方法，<xref:System.Windows.Forms.Form.Owner%2A>窗体的属性设置为`owner`。 非模式窗体可以使用<xref:System.Windows.Forms.Form.Owner%2A>属性以获取有关所属的窗体的信息。  调用此方法等同于设置<xref:System.Windows.Forms.Form.Owner%2A>非模式的属性，然后再调用<xref:System.Windows.Forms.Control.Show>方法。  
  
 显示窗体等效于设置<xref:System.Windows.Forms.Control.Visible%2A>属性`true`。 后<xref:System.Windows.Forms.Form.Show%2A>调用方法时，<xref:System.Windows.Forms.Control.Visible%2A>属性返回的值`true`直到<xref:System.Windows.Forms.Control.Hide%2A>调用方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">要显示的窗体已经可见。  
  
 或  
  
 <paramref name="owner" /> 参数中指定的窗体就是显示的窗体。  
  
 或  
  
 所显示窗体被禁用。  
  
 或  
  
 显示的窗体不是顶级窗口。  
  
 或  
  
 显示为对话框的窗体已经是模式窗体。  
  
 或  
  
 当前进程不是以用户交互模式运行的（有关更多信息，请参见 <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />）。</exception>
        <altmember cref="Overload:System.Windows.Forms.Form.ShowDialog" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
        <altmember cref="P:System.Windows.Forms.Form.ShowInTaskbar" />
        <altmember cref="P:System.Windows.Forms.Form.ShowIcon" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ShowDialog">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将窗体显示为模式对话框。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DialogResult ShowDialog();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将窗体显示为模式对话框。</summary>
        <returns>
          <see cref="T:System.Windows.Forms.DialogResult" /> 值之一。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于在你的应用程序中显示模式对话框。 当调用此方法时，后面的代码后关闭该对话框不执行之前。 对话框中可以分配的值之一<xref:System.Windows.Forms.DialogResult>枚举通过将其分配给<xref:System.Windows.Forms.Button.DialogResult%2A>属性<xref:System.Windows.Forms.Button>窗体上或通过设置<xref:System.Windows.Forms.Form.DialogResult%2A>的窗体代码中的属性。 此方法然后返回此值。 此返回值可用于确定如何处理发生在对话框中的操作。 例如，如果对话框已关闭并返回`DialogResult.Cancel`值通过这种方法，你可以阻止之后对调用代码<xref:System.Windows.Forms.Form.ShowDialog%2A>执行。  
  
 当窗体显示为模式对话框中时，单击**关闭**按钮 （带有窗体的右上角的 X 按钮） 将导致要隐藏的窗体和<xref:System.Windows.Forms.Form.DialogResult%2A>属性设置为`DialogResult.Cancel`。 与非模式窗体，不同<xref:System.Windows.Forms.Form.Close%2A>方法不在用户单击对话框中的关闭窗体按钮或设置的值时由.NET Framework 调用<xref:System.Windows.Forms.Form.DialogResult%2A>属性。 改为窗体将隐藏，并且可以再次显示而无需创建对话框中的新实例。 因为窗体显示为对话框中隐藏而不是关闭，你必须调用<xref:System.Windows.Forms.Control.Dispose%2A>时窗体应用程序不再需要该窗体的方法。  
  
 此版本的<xref:System.Windows.Forms.Form.ShowDialog%2A>方法没有指定窗体或控件作为其所有者。 当调用此版本时，当前处于活动状态窗口进行对话框框的所有者。 如果你想要指定特定的所有者，则使用此方法的其他版本。  
  
   
  
## Examples  
 下面的代码示例将窗体显示为模式对话框，并才能决定是否要读取的值计算对话框中的返回值<xref:System.Windows.Forms.TextBox>对话框框中窗体上的控件。 此示例需要<xref:System.Windows.Forms.Form>名为`testDialog`创建及其所含的<xref:System.Windows.Forms.TextBox>控件名为`TextBox1`。 此外，该示例需要在此示例中的代码是包含和从其他调用<xref:System.Windows.Forms.Form>为了显示`testDialog`为模式对话框。 此示例使用的版本<xref:System.Windows.Forms.Form.ShowDialog%2A>，它指定所有者为对话框。  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">要显示的窗体已经可见。  
  
 或  
  
 所显示窗体被禁用。  
  
 或  
  
 显示的窗体不是顶级窗口。  
  
 或  
  
 显示为对话框的窗体已经是模式窗体。  
  
 或  
  
 当前进程不是以用户交互模式运行的（有关更多信息，请参见 <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />）。</exception>
        <altmember cref="P:System.Windows.Forms.Form.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog(System.Windows.Forms.IWin32Window)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog (owner As IWin32Window) As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DialogResult ShowDialog(System::Windows::Forms::IWin32Window ^ owner);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" />
      </Parameters>
      <Docs>
        <param name="owner">任何实现 <see cref="T:System.Windows.Forms.IWin32Window" />（表示将拥有模式对话框的顶级窗口）的对象。</param>
        <summary>将窗体显示为具有指定所有者的模式对话框。</summary>
        <returns>
          <see cref="T:System.Windows.Forms.DialogResult" /> 值之一。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于在你的应用程序中显示模式对话框。 当调用此方法时，后面的代码后关闭该对话框不执行之前。 对话框中可以分配的值之一<xref:System.Windows.Forms.DialogResult>通过将其分配给<xref:System.Windows.Forms.Button.DialogResult%2A>属性<xref:System.Windows.Forms.Button>窗体上或通过设置<xref:System.Windows.Forms.Form.DialogResult%2A>的窗体代码中的属性。 此方法然后返回此值。 此返回值可用于确定如何处理发生在对话框中的操作。 例如，如果对话框已关闭并返回`DialogResult.Cancel`值通过这种方法，你可以阻止之后对调用代码<xref:System.Windows.Forms.Form.ShowDialog%2A>执行。  
  
 当窗体显示为模式对话框中时，单击**关闭**按钮 （带有窗体的右上角的 X 按钮） 将导致要隐藏的窗体和<xref:System.Windows.Forms.Form.DialogResult%2A>属性设置为`DialogResult.Cancel`。 与无模式的窗体，不同<xref:System.Windows.Forms.Form.Close%2A>方法不在用户单击对话框中的关闭窗体按钮或设置的值时由.NET Framework 调用<xref:System.Windows.Forms.Form.DialogResult%2A>属性。 改为窗体将隐藏，并且可以再次显示而无需创建对话框中的新实例。 因为窗体显示为对话框中隐藏而不是关闭，你必须调用<xref:System.Windows.Forms.Control.Dispose%2A>时窗体应用程序不再需要该窗体的方法。  
  
 此版本的<xref:System.Windows.Forms.Form.ShowDialog%2A>方法允许你指定将拥有显示的对话框中的特定形式。  
  
   
  
## Examples  
 下面的代码示例将窗体显示为模式对话框，并才能决定是否要读取的值计算对话框中的返回值<xref:System.Windows.Forms.TextBox>对话框框中窗体上的控件。 此示例需要<xref:System.Windows.Forms.Form>名为`Form2`创建及其所含的<xref:System.Windows.Forms.TextBox>控件名为`TextBox1`。 此示例使用的版本<xref:System.Windows.Forms.Form.ShowDialog%2A>，它指定所有者为对话框。  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="owner" /> 参数中指定的窗体就是显示的窗体。</exception>
        <exception cref="T:System.InvalidOperationException">要显示的窗体已经可见。  
  
 或  
  
 所显示窗体被禁用。  
  
 或  
  
 显示的窗体不是顶级窗口。  
  
 或  
  
 显示为对话框的窗体已经是模式窗体。  
  
 或  
  
 当前进程不是以用户交互模式运行的（有关更多信息，请参见 <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />）。</exception>
        <altmember cref="P:System.Windows.Forms.Form.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="ShowIcon">
      <MemberSignature Language="C#" Value="public bool ShowIcon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowIcon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowIcon" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowIcon As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowIcon { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否在窗体的标题栏中显示图标。</summary>
        <value>
          如果窗体在标题栏中显示图标，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ShowIcon%2A>属性包含<xref:System.Boolean>值，该值指示是否在窗体的<xref:System.Windows.Forms.Form.Icon%2A>窗体的标题栏中显示。 如果<xref:System.Windows.Forms.Form.ControlBox%2A>属性是`false`，将抑制图标和控件框。  
  
 如果<xref:System.Windows.Forms.Form.ShowIcon%2A>是`false`的通用图标时显示主窗体，将显示在应用程序的任务栏按钮。  
  
 此属性如果不起作用<xref:System.Windows.Forms.Form.FormBorderStyle%2A>设置为<xref:System.Windows.Forms.FormBorderStyle.FixedDialog>。 在这种情况下，窗体不显示一个图标。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.Icon" />
        <altmember cref="P:System.Windows.Forms.Form.ShowInTaskbar" />
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否在 Windows 任务栏中显示窗体。</summary>
        <value>
          如果为 <see langword="true" />，则运行时在 Windows 任务栏中显示窗体；否则，为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果窗体有父级在另一个窗体，该父窗体不会显示 Windows 任务栏中。  
  
 此属性可用于防止用户选择通过 Windows 任务栏窗体。 例如，如果你的应用程序中显示的查找和替换工具窗口，你可能想要防止该窗口被选中通过 Windows 任务栏中，因为你将需要应用程序的主窗口和查找和替换工具窗口显示，以便适当地处理搜索。  
  
 你将通常想要使用此属性时创建的窗体具有<xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow>样式。 设置<xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow>样式不单独保证不将在任务栏中出现一个窗口。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Form.ShowInTaskbar%2A>属性以使对话框框中，不会显示在 Windows 任务栏。  
  
 [!code-cpp[Form.ShowInTaskbar#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.ShowInTaskbar/CPP/form1.cpp#1)]
 [!code-csharp[Form.ShowInTaskbar#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.ShowInTaskbar/CS/form1.cs#1)]
 [!code-vb[Form.ShowInTaskbar#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.ShowInTaskbar/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shown">
      <MemberSignature Language="C#" Value="public event EventHandler Shown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Shown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Shown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Shown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Shown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>只要窗体是首次显示就发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Shown>第一次显示窗体时才引发事件; 随后最小化、 最大化、 还原、 隐藏、 显示，或使失效并重新绘制不会引发此事件。 窗体的事件的顺序的详细信息，请参阅[Windows 窗体中的事件顺序的](~/docs/framework/winforms/order-of-events-in-windows-forms.md)。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Form.Shown>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.Form>名为`Form1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.Form.Shown>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#403](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#403)]
 [!code-vb[System.Windows.Forms.EventExamples#403](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#403)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="ShowWithoutActivation">
      <MemberSignature Language="C#" Value="protected virtual bool ShowWithoutActivation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowWithoutActivation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowWithoutActivation" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ShowWithoutActivation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ShowWithoutActivation { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示显示窗口时是否激活它。</summary>
        <value>
          如果显示窗口时不将其激活，则为 <see langword="True" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你想要显示在顶级窗口，但不希望采用输入的焦点离开当前窗口中断用户的工作，请使用此属性。 这可以是信息性的弹出窗口或浮动窗口，如绘制应用程序中的工具调色板。  
  
 由于此属性是只读的你可以仅将其值更改通过重写<xref:System.Windows.Forms.Form.ShowWithoutActivation%2A>中自己窗体，并对其返回进行编程`true`。  
  
 如果您非激活的窗口需要使用 UI 控件，则应考虑使用<xref:System.Windows.Forms.ToolStrip>控件，如<xref:System.Windows.Forms.ToolStripDropDown>。 这些控件无窗口，并且不会导致窗口在激活时选择它们。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置窗体的大小。</summary>
        <value>
          <see cref="T:System.Drawing.Size" />，它表示窗体的大小。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可以在同一时间而不是设置中设置高度和宽度 （以像素为单位） 的窗体<xref:System.Windows.Forms.Control.Height%2A>和<xref:System.Windows.Forms.Control.Width%2A>属性单独。 如果你想要设置的大小和窗体的位置，则可以使用<xref:System.Windows.Forms.Form.DesktopBounds%2A>属性来调整大小和找到的表单基于桌面坐标或使用<xref:System.Windows.Forms.Control.Bounds%2A>属性<xref:System.Windows.Forms.Control>类来设置的大小和窗体位置基于屏幕坐标inates。  
  
> [!NOTE]
>  此属性的最大值受到窗体在其运行的屏幕的分辨率。 值不能通过每个屏幕维度 （水平 + 12 和垂直 + 12） 大于 12 的像素为单位。  
  
> [!NOTE]
>  在 Pocket PC 设备中，你可以创建可调整大小窗口通过设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>到`None`和删除任何<xref:System.Windows.Forms.MainMenu>控件。 您可以在永远不会被调整 SmartPhone 设备上<xref:System.Windows.Forms.Form>-它始终将填充整个屏幕。  
  
   
  
## Examples  
 下面的代码示例演示如何创建带有 75%的不透明度级别显示窗体。 该示例代码创建一个在与屏幕的中心中放置的新窗体<xref:System.Windows.Forms.Form.Opacity%2A>属性设置以更改窗体的不透明度级别。 此示例代码还设置<xref:System.Windows.Forms.Form.Size%2A>属性，以提供更大大小超过默认大小的窗体的窗体。 此示例需要在此示例中定义方法从另一种形式的事件处理程序或其他方法中调用。  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Width" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="SizeGripStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.SizeGripStyle SizeGripStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.SizeGripStyle SizeGripStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.SizeGripStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeGripStyle As SizeGripStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::SizeGripStyle SizeGripStyle { System::Windows::Forms::SizeGripStyle get(); void set(System::Windows::Forms::SizeGripStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.SizeGripStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在窗体右下角显示的大小调整手柄的样式。</summary>
        <value>
          <see cref="T:System.Windows.Forms.SizeGripStyle" />，表示要显示的大小手柄的样式。 默认值为 <see cref="F:System.Windows.Forms.SizeGripStyle.Auto" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性使您能够确定当窗体上显示大小调整手柄。 你可以设置此属性，以显示大小调整手柄或者使它自动显示于的设置基于<xref:System.Windows.Forms.Form.FormBorderStyle%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何隐藏有关的大小调整手柄<xref:System.Windows.Forms.Form>时<xref:System.Windows.Forms.Form>不可调整大小。  
  
 [!code-cpp[Form.SizeGripStyle#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.SizeGripStyle/CPP/form1.cpp#1)]
 [!code-csharp[Form.SizeGripStyle#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.SizeGripStyle/CS/form1.cs#1)]
 [!code-vb[Form.SizeGripStyle#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.SizeGripStyle/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定值不在有效值范围内。</exception>
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="T:System.Windows.Forms.SizeGripStyle" />
      </Docs>
    </Member>
    <Member MemberName="StartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormStartPosition StartPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormStartPosition StartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.StartPosition" />
      <MemberSignature Language="VB.NET" Value="Public Property StartPosition As FormStartPosition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormStartPosition StartPosition { System::Windows::Forms::FormStartPosition get(); void set(System::Windows::Forms::FormStartPosition value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormStartPosition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置运行时窗体的起始位置。</summary>
        <value>
          <see cref="T:System.Windows.Forms.FormStartPosition" />，表示窗体的起始位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性使您可以在运行时显示时设置窗体的起始位置。 可以通过将设置手动指定窗体的位置<xref:System.Windows.Forms.Form.Location%2A>属性或使用 Windows 所指定的默认位置。 您可以定位要在屏幕的中心或如多文档界面 (MDI) 子窗体的窗体其父窗体的中心中显示的窗体。  
  
 显示窗体之前，应设置此属性。  你可以设置此属性，然后才能调用<xref:System.Windows.Forms.Form.Show%2A>或<xref:System.Windows.Forms.Form.ShowDialog%2A>方法或在窗体的构造函数中。  
  
   
  
## Examples  
 下面的代码示例创建的新实例<xref:System.Windows.Forms.Form>和调用<xref:System.Windows.Forms.Form.ShowDialog%2A>窗体显示为对话框中的方法。 该示例设置<xref:System.Windows.Forms.Form.FormBorderStyle%2A>， <xref:System.Windows.Forms.Form.AcceptButton%2A>， <xref:System.Windows.Forms.Form.CancelButton%2A>，和<xref:System.Windows.Forms.Form.StartPosition%2A>属性来更改到对话框的外观和表单的功能。 此示例还使用<xref:System.Windows.Forms.Form.ControlCollection.Add%2A>方法的窗体的<xref:System.Windows.Forms.Control.Controls%2A>集合来添加两个<xref:System.Windows.Forms.Button>控件。 该示例使用<xref:System.Windows.Forms.Form.HelpButton%2A>属性对话框中的标题栏中显示帮助按钮。  
  
 [!code-cpp[Classic Form.StartPosition Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.StartPosition Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CS/source.cs#1)]
 [!code-vb[Classic Form.StartPosition Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.StartPosition Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定值不在有效值范围内。</exception>
        <altmember cref="T:System.Windows.Forms.FormStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置控件在其容器内的 Tab 键顺序。</summary>
        <value>
          <see cref="T:System.Int32" />，它包含其容器内按 Tab 键顺序包括的控件集内的控件索引。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 窗体不包括的 tab 键顺序。 设置<xref:System.Windows.Forms.Form.TabIndex%2A>属性不执行任何操作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabIndexChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.Form.TabIndex" /> 属性的值更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property TabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TabStop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示用户能否使用 Tab 键将焦点放到该控件上。</summary>
        <value>
          如果用户可以用 Tab 键将焦点放到此控件上，则为 <see langword="true" />；反之，则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabStopChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabStopChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabStopChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.Form.TabStop" /> 属性更改时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与此控件关联的文本。</summary>
        <value>与该控件关联的文本。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="TopLevel">
      <MemberSignature Language="C#" Value="public bool TopLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopLevel" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TopLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TopLevel { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否将窗体显示为顶层窗口。</summary>
        <value>
          如果为 <see langword="true" />，则将窗体显示为顶级窗口；否则，为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 顶级窗体是一个窗口，其没有父窗体中，或其父窗体是在桌面窗口。 顶级窗口通常作为主窗体应用程序中使用。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.Forms.Form.Modal%2A>属性来确定是否窗体将显示为模式的窗体。 如果不是<xref:System.Windows.Forms.Form.FormBorderStyle%2A>和<xref:System.Windows.Forms.Form.TopLevel%2A>属性发生更改以使具有工具窗口边框的窗体非顶级窗体。  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">多文档界面 (MDI) 父窗体必须是顶级窗口。</exception>
        <altmember cref="P:System.Windows.Forms.Form.TopMost" />
      </Docs>
    </Member>
    <Member MemberName="TopMost">
      <MemberSignature Language="C#" Value="public bool TopMost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopMost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopMost" />
      <MemberSignature Language="VB.NET" Value="Public Property TopMost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TopMost { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，指示该窗体是否应显示为最顶层窗体。</summary>
        <value>
          如果将窗体显示为最顶层窗体，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最顶层窗体是重叠所有其他 （非顶层） 形式，即使它并不是活动或前台形式。 最顶层窗体始终显示在桌面上的 windows 的 z 顺序最高数据点。 此属性可用于创建始终应用程序，如查找和替换工具窗口中显示的窗体。  
  
   
  
## Examples  
 下面的代码示例演示如何创建最顶层窗体。 该示例创建两个窗体，一个是在最大化，一个将显示为最顶层窗体。 第一个窗体中，名为`bottomForm`，将显示最大化时，使用<xref:System.Windows.Forms.Form.WindowState%2A>属性，以更好地演示的最顶层窗体的能力。 第二个窗体中，名为`topMostForm`，设置<xref:System.Windows.Forms.Form.TopMost%2A>属性`true`窗体显示为最顶层窗体。 当运行此代码时，单击最大化窗体上不会导致最顶层窗体最大化窗体下显示。 该示例需要在示例中定义此方法叫做从另一种形式。  
  
 [!code-cpp[Form.TopMost#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.TopMost/CPP/form1.cpp#1)]
 [!code-csharp[Form.TopMost#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.TopMost/CS/form1.cs#1)]
 [!code-vb[Form.TopMost#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.TopMost/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.TopLevel" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取表示当前窗体实例的字符串。</summary>
        <returns>由窗体对象类的完全限定名组成的字符串，窗体的 <see cref="P:System.Windows.Forms.Form.Text" /> 属性追加到字符串的末尾。 例如，如果该窗体派生自 <c>MyNamespace</c> 命名空间中的类 <c>MyForm</c>，并且 <see cref="P:System.Windows.Forms.Form.Text" /> 属性设置为 <c>Hello, World</c>，则此方法会返回 <c>MyNamespace.MyForm, Text: Hello, World</c>。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransparencyKey">
      <MemberSignature Language="C#" Value="public System.Drawing.Color TransparencyKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color TransparencyKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TransparencyKey" />
      <MemberSignature Language="VB.NET" Value="Public Property TransparencyKey As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color TransparencyKey { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置将表示窗体透明区域的颜色。</summary>
        <value>
          <see cref="T:System.Drawing.Color" />，表示要在窗体上透明显示的颜色。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Windows.Forms.Form.TransparencyKey%2A>属性分配<xref:System.Drawing.Color>，具有相同的窗体区域<xref:System.Windows.Forms.Control.BackColor%2A>将以透明方式显示。 鼠标的任何操作，例如单击鼠标，在窗体透明区域执行将传输到下的透明区域的窗口。 例如，如果窗体的客户端区域进行透明，则该区域上单击鼠标将发送到低于其任何窗口的单击事件通知。 如果颜色分配给<xref:System.Windows.Forms.Form.TransparencyKey%2A>属性等同于窗体上任何控件，则它们还将显示以透明方式。 例如，如果你有<xref:System.Windows.Forms.Button>具有窗体上的控件其<xref:System.Windows.Forms.Form.TransparencyKey%2A>属性设置为`SystemColors.Control`，控件将以透明方式显示，除非<xref:System.Windows.Forms.Control.BackColor%2A>属性<xref:System.Windows.Forms.Button>控件更改为另一种颜色。  
  
 此属性不是支持时<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>是`true`。  
  
   
  
## Examples  
 下面的代码示例创建该窗口具有透明的客户端区域而不考虑的窗体的背景色。 此示例需要示例方法在窗体类中定义。  
  
 [!code-cpp[Classic Form.TransparencyKey Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.TransparencyKey Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CS/source.cs#1)]
 [!code-vb[Classic Form.TransparencyKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultButton">
      <MemberSignature Language="C#" Value="protected override void UpdateDefaultButton ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void UpdateDefaultButton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.UpdateDefaultButton" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub UpdateDefaultButton ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void UpdateDefaultButton();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>更新哪个按钮为默认按钮。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.UpdateDefaultButton%2A>方法确定窗体上的按钮引发其 Click 事件，当用户按 ENTER，根据以下优先级：  
  
1.  如果<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>属性实现<xref:System.Windows.Forms.IButtonControl>接口，控制为默认按钮。  
  
2.  <xref:System.Windows.Forms.Form.AcceptButton%2A>属性为默认按钮。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
        <altmember cref="P:System.Windows.Forms.Form.AcceptButton" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateChildren">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>验证窗体中所有可选择的子控件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ValidateChildren () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ValidateChildren();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使控件内支持验证的所有子控件都对其数据进行验证。</summary>
        <returns>
          如果成功验证所有子级，则为 <see langword="true" />；否则为 <see langword="false" />。 如果是从 <see cref="E:System.Windows.Forms.Control.Validating" /> 或 <see cref="E:System.Windows.Forms.Control.Validated" /> 事件处理程序调用的，则该方法将始终返回 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren" />
      </Docs>
    </Member>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren (System.Windows.Forms.ValidationConstraints validationConstraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren(valuetype System.Windows.Forms.ValidationConstraints validationConstraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ValidateChildren(System::Windows::Forms::ValidationConstraints validationConstraints);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationConstraints" Type="System.Windows.Forms.ValidationConstraints" />
      </Parameters>
      <Docs>
        <param name="validationConstraints">添加对哪些控件可以引发其 <see cref="E:System.Windows.Forms.Control.Validating" /> 事件的限制。</param>
        <summary>使控件内支持验证的所有子控件都对其数据进行验证。</summary>
        <returns>
          如果成功验证所有子级，则为 <see langword="true" />；否则为 <see langword="false" />。 如果是从 <see cref="E:System.Windows.Forms.Control.Validating" /> 或 <see cref="E:System.Windows.Forms.Control.Validated" /> 事件处理程序调用的，则该方法将始终返回 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormWindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormWindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As FormWindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormWindowState WindowState { System::Windows::Forms::FormWindowState get(); void set(System::Windows::Forms::FormWindowState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormWindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示窗体是最小化、最大化还是正常。</summary>
        <value>
          <see cref="T:System.Windows.Forms.FormWindowState" />，它表示窗体是最小化、 最大化，还是正常。 默认值为 <see langword="FormWindowState.Normal" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表单显示之前，<xref:System.Windows.Forms.Form.WindowState%2A>属性始终设置为`FormWindowState.Normal`，不管其初始设置。 这反映在<xref:System.Windows.Forms.Control.Height%2A>， <xref:System.Windows.Forms.Control.Left%2A>， <xref:System.Windows.Forms.Control.Top%2A>，和<xref:System.Windows.Forms.Control.Width%2A>属性设置。 如果窗体隐藏后已被证实，这些属性反映以前的状态，直到再次，而不考虑对所做任何更改显示窗体<xref:System.Windows.Forms.Form.WindowState%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何设置<xref:System.Windows.Forms.Form.WindowState%2A>为最大化。 从调用代码<xref:System.Windows.Forms.Form.Shown>创建窗体后，事件处理程序。  
  
```csharp  
private void Form1_Shown(object sender, EventArgs e)  
        {  
            this.WindowState = System.Windows.Forms.FormWindowState.Maximized;  
        }  
```  
  
```vb  
Private  Sub Form1_Shown(ByVal sender As Object, ByVal e As EventArgs)  
            Me.WindowState = System.Windows.Forms.FormWindowState.Maximized  
End Sub  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定值不在有效值范围内。</exception>
        <altmember cref="T:System.Windows.Forms.FormWindowState" />
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">要处理的 Windows <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>处理 Windows 消息。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>