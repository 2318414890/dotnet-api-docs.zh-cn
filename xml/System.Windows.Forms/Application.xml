<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="24faab7220b703ca01fba4fff8dce9e4e7d58f2a" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32037948" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供 <see langword="static" /> 方法和属性以管理应用程序，例如启动和停止应用程序、处理 Windows 消息的方法和获取应用程序信息的属性。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application>类具有方法用于启动和停止应用程序和线程，并处理 Windows 消息，如下所示：  
  
-   <xref:System.Windows.Forms.Application.Run%2A> 在当前线程上启动应用程序消息循环和 （可选） 使窗体可见。  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> 或<xref:System.Windows.Forms.Application.ExitThread%2A>停止消息循环。  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> 你的程序时在循环中处理消息。  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> 将消息筛选器添加到应用程序消息泵来监视 Windows 消息。  
  
-   <xref:System.Windows.Forms.IMessageFilter> 允许您停止来自引发的事件或在调用事件处理程序之前执行特殊操作。  
  
 此类具有<xref:System.Windows.Forms.Application.CurrentCulture%2A>和<xref:System.Windows.Forms.Application.CurrentInputLanguage%2A>属性要获取或设置区域性当前线程的信息。  
  
 无法创建此类的实例。  
  
   
  
## Examples  
 下面的代码示例列出窗体上一个列表框中的数字。 每次你单击`button1`，应用程序列表中添加另一个数。  
  
 `Main`方法调用<xref:System.Windows.Forms.Application.Run%2A>启动该应用程序，这将创建窗体，`listBox1`和`button1`。 当用户单击`button1`、`button1_Click`方法显示<xref:System.Windows.Forms.MessageBox>。 如果用户单击`No`上<xref:System.Windows.Forms.MessageBox>、`button1_Click`方法向列表添加一个数字。 如果用户单击`Yes`，应用程序调用<xref:System.Windows.Forms.Application.Exit%2A>来处理队列中的所有剩余消息，然后退出。  
  
> [!NOTE]
>  调用<xref:System.Windows.Forms.Application.Exit%2A>在部分信任环境中将失败。  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">要安装的 <see cref="T:System.Windows.Forms.IMessageFilter" /> 接口的实现。</param>
        <summary>添加消息筛选器以便在向目标传送 Windows 消息时监视这些消息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止引发特定事件或执行特殊操作事件传递到事件处理程序前，请使用消息筛选器。 消息筛选器是唯一的特定线程。  
  
 若要防止消息被调度，`value`将传递给此方法的参数实例必须重写<xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A>方法替换为代码来处理该消息。 该方法必须返回 `false`。  
  
> [!CAUTION]
>  将消息筛选器添加到应用程序的消息泵会降低性能。  
  
   
  
## Examples  
 下面的代码示例创建消息筛选器调用`TestMessageFilter`。 此筛选器会阻止与鼠标左键相关的所有消息。 你可以使用消息筛选器之前，必须提供的实现<xref:System.Windows.Forms.IMessageFilter>接口。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直接调用方调用非托管的代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示调用方能否退出该应用程序的值。</summary>
        <value>
          如果调用方能够退出该应用程序，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回`false`如果从调用<xref:System.Windows.Forms.Control>在 Web 浏览器内承载。 因此，<xref:System.Windows.Forms.Control>无法退出<xref:System.Windows.Forms.Application>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在应用程序即将关闭时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须将附加到的事件处理程序<xref:System.Windows.Forms.Application.Exit%2A>事件以执行未经处理，所需任务的应用程序停止运行前。 你可以关闭打开的此应用程序或释放的垃圾回收未回收的对象文件。  
  
 由于这是一个静态事件，则必须分离附加到此事件中任何事件处理程序<xref:System.Windows.Forms.Application.ApplicationExit>本身的事件处理程序。 如果未分离这些处理程序，它们将保留附加在该事件，继续占用的内存。  
  
   
  
## Examples  
 下面的代码示例显示两个窗体，并退出应用程序，这两个窗体关闭时。 当应用程序启动和退出时，将记住每个窗体的位置。 此示例演示如何使用<xref:System.Windows.Forms.Application.ApplicationExit>事件，以了解在窗体位置应保存到文件，以及时`FileStream`应关闭。  
  
 类`MyApplicationContext`继承自<xref:System.Windows.Forms.ApplicationContext>和跟踪时每个窗体已关闭，并在它们都时退出当前线程。 关闭时，该类会记住每个窗体的位置。 当<xref:System.Windows.Forms.Application.ApplicationExit>事件发生时，类将写入文件的每个用户的位置。 窗体位置数据存储在文件标题为`appdata.txt`，它在由位置创建<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法调用`Application.Run(context)`启动应用程序提供<xref:System.Windows.Forms.ApplicationContext>。  
  
 此代码摘自中所示的示例<xref:System.Windows.Forms.ApplicationContext>类概述。 请参阅<xref:System.Windows.Forms.ApplicationContext>为完整的代码清单。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取所有用户共享的应用程序数据的路径。</summary>
        <value>所有用户共享的应用程序数据的路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果路径不存在，将创建一个采用以下格式：  
  
 *基路径*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> 第一个如下所示，以查看是否有包含主可执行文件的程序集`AssemblyInformationalVersion`在其上的属性。 如果存在此属性，它同时用于<xref:System.Windows.Forms.Application.ProductVersion%2A>和<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>。 如果此属性不存在，这两个属性使用的可执行文件的版本。  
  
 则路径将会不同，具体取决于是否使用部署 Windows 窗体应用程序[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 应用程序存储在每个用户应用程序缓存中 C:\Documents and Settings\\*用户名*目录。 有关详细信息，请参阅[访问本地数据和 ClickOnce 应用程序中的远程数据](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取所有用户共享的应用程序数据的注册表项。</summary>
        <value>一个 <see cref="T:Microsoft.Win32.RegistryKey" />，它表示所有用户共享的应用程序数据的注册表项。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不存在该键，则将它创建采用以下格式：  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与该应用程序关联的公司名称。</summary>
        <value>公司名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例获取此属性，并在文本框中显示其值。 该示例需要`textBox1`已放在窗体上。  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前线程的区域性信息。</summary>
        <value>一个 <see cref="T:System.Globalization.CultureInfo" />，它代表当前线程的区域性信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例获取此属性，并在文本框中显示其值。 该示例需要`textBox1`已放在窗体上。  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要将此属性设置的所有窗口。 关联的枚举： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前线程的当前输入语言。</summary>
        <value>一个 <see cref="T:System.Windows.Forms.InputLanguage" />，它代表当前线程的当前输入语言。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例获取此属性，并在文本框中显示其值。 该示例需要`textBox1`已放在窗体上。  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直接调用方调用非托管的代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>处理当前在消息队列中的所有 Windows 消息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 运行 Windows 窗体时，它会创建新的表单，然后等待事件处理。 在每次窗体处理事件，它将处理所有与该事件关联的代码。 在队列中等待所有其他事件。 而你的代码来处理该事件，你的应用程序未响应。 例如，如果另一个窗口拖到顶部，也无法重新绘制窗口。  
  
 如果调用<xref:System.Windows.Forms.Application.DoEvents%2A>在代码中，你的应用程序可以处理其他事件。 例如，如果你拥有将数据添加到窗体<xref:System.Windows.Forms.ListBox>并添加<xref:System.Windows.Forms.Application.DoEvents%2A>到代码中，你的窗体可重新绘制在另一个窗口拖到它。 如果你删除<xref:System.Windows.Forms.Application.DoEvents%2A>从代码中，你的窗体不会重新绘制按钮的 click 事件处理程序完成之前执行。 有关消息传送的详细信息，请参阅[Windows 窗体中的用户输入](~/docs/framework/winforms/user-input-in-windows-forms.md)。  
  
 与 Visual Basic 6.0 中，不同<xref:System.Windows.Forms.Application.DoEvents%2A>未调用<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法。  
  
 通常情况下，在处理消息循环中使用此方法。  
  
> [!CAUTION]
>  调用此方法会导致在处理所有等待窗口消息时要挂起当前线程。 如果消息导致要触发的事件，可能执行应用程序代码的其他方面。 这会导致你的应用程序来展示难以调试的意外的行为。 通常，如果你执行的操作或需要较长时间的计算，则更可取的方法执行新线程上的那些操作。 有关异步编程的详细信息，请参阅[异步编程模型 (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Application.DoEvents%2A>方法。 该示例运行时，用户可选择从图形文件<xref:System.Windows.Forms.OpenFileDialog>。 所选的文件将显示在窗体中。 <xref:System.Windows.Forms.Application.DoEvents%2A>方法会强行重绘的每个图形文件在打开的窗体。 若要运行此示例中，粘贴以下代码中一个窗体包含<xref:System.Windows.Forms.PictureBox>名为`PictureBox1`、<xref:System.Windows.Forms.OpenFileDialog>名为`OpenFileDialog1`，和一个名为的按钮`fileButton`。 调用`InitializePictureBox`和`InitializeOpenFileDialog`从窗体的构造函数的方法或`Load`方法。  
  
> [!NOTE]
>  在 Visual Studio 中，如果你添加<xref:System.Windows.Forms.OpenFileDialog>到窗体中通过拖动操作，则将需要修改以下`InitializeOpenFileDialog`通过删除创建的新实例的行的方法<xref:System.Windows.Forms.OpenFileDialog>。  
  
 该示例还要求<xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType>事件<xref:System.Windows.Forms.Button>控件和<xref:System.Windows.Forms.FileDialog.FileOk>事件<xref:System.Windows.Forms.OpenFileDialog>连接到示例中定义的事件处理程序。 当运行示例时，显示对话框中单击的按钮。  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>启用应用程序的可视样式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使应用程序的可视样式。 了可视样式的颜色、 字体和窗体操作系统主题其他可视元素。 如果控件和操作系统支持，将以视觉样式绘制控件。 产生任何影响，<xref:System.Windows.Forms.Application.EnableVisualStyles>必须在创建应用程序; 中的任何控件之前调用通常情况下，<xref:System.Windows.Forms.Application.EnableVisualStyles>是中的第一个行`Main`函数。 启用视觉样式，在调用时不需要单独清单<xref:System.Windows.Forms.Application.EnableVisualStyles>。  
  
> [!NOTE]
>  在.NET Framework 2.0 中之前,`FlatStyle`的某些控件，例如派生的控件的属性<xref:System.Windows.Forms.ButtonBase>，必须设置为<xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType>顺序以视觉样式绘制的控件。 在使用.NET Framework 2.0 编写的应用程序，这是不再有必要。  
  
> [!NOTE]
>  此方法不起作用的 Internet Explorer 中承载的控件。  
  
   
  
## Examples  
 下面的代码示例演示如何调用<xref:System.Windows.Forms.Application.EnableVisualStyles%2A>中`Main`函数，以使应用程序的可视样式。  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序即将进入模式状态时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Application.EnterThreadModal>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 要运行此代码示例，将其粘贴到 Windows 窗体，并确保与事件处理程序<xref:System.Windows.Forms.Application.EnterThreadModal>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">需要<see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" />侦听事件的权限。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取启动了应用程序的可执行文件的路径，包括可执行文件的名称。</summary>
        <value>启动了应用程序的可执行文件的路径和可执行文件的名称。  
  
 取决于是否使用 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 部署 Windows 窗体应用程序，此路径将会不同。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 应用程序存储在每个用户应用程序缓存中 C:\Documents and Settings\\*用户名*目录。 有关详细信息，请参阅[访问本地数据和 ClickOnce 应用程序中的远程数据](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于获取路径。 关联的枚举： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>通知所有消息泵必须终止，并且在处理了消息以后关闭所有应用程序窗口。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通知所有消息泵必须终止，并且在处理了消息以后关闭所有应用程序窗口。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.Exit%2A>方法所有线程上停止所有正在运行消息循环，并关闭应用程序的所有窗口。 此方法不一定强制退出该应用程序。 <xref:System.Windows.Forms.Application.Exit%2A>方法通常从调用中使用消息循环，并强制<xref:System.Windows.Forms.Application.Run%2A>返回。 若要退出当前线程的消息循环，请调用<xref:System.Windows.Forms.Application.ExitThread%2A>。  
  
 <xref:System.Windows.Forms.Application.Exit%2A> 可引发以下事件并执行关联的条件操作：  
  
-   A<xref:System.Windows.Forms.Form.FormClosing>为表示由每个窗体中引发事件<xref:System.Windows.Forms.Application.OpenForms%2A>属性。 此事件可取消通过设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>属性其<xref:System.Windows.Forms.FormClosingEventArgs>参数`true`。  
  
-   如果一个或多个处理程序将取消该事件，然后<xref:System.Windows.Forms.Application.Exit%2A>返回而无需进一步操作。 否则为<xref:System.Windows.Forms.Form.FormClosed>对于每个打开的窗体，将引发事件，然后关闭所有正在运行的消息循环和窗体。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Application.Exit%2A>方法不会引发<xref:System.Windows.Forms.Form.Closed>和<xref:System.Windows.Forms.Form.Closing>起已过时的事件[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]。  
  
   
  
## Examples  
 下面的代码示例列出窗体上一个列表框中的数字。 每次你单击`button1`，应用程序列表中添加另一个数。  
  
 `Main`方法调用<xref:System.Windows.Forms.Application.Run%2A>启动该应用程序，这将创建窗体， `listBox1`，和`button1`。 当用户单击`button1`、`button1_Click`方法添加到列表框中，一到三个数字并显示<xref:System.Windows.Forms.MessageBox>。 如果用户单击**否**上<xref:System.Windows.Forms.MessageBox>、`button1_Click`方法向列表添加另一个数。 如果用户单击**是**，应用程序调用<xref:System.Windows.Forms.Application.Exit%2A>，来处理队列中的所有剩余消息，然后退出。  
  
 该示例需要`listBox1`和`button1`已实例化并已放置在窗体上。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直接调用方调用非托管的代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">返回应用程序中的任何 <see cref="T:System.Windows.Forms.Form" /> 是否已取消退出。</param>
        <summary>通知所有消息泵必须终止，并且在处理了消息以后关闭所有应用程序窗口。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">提供许可以终止正在运行的应用程序线程。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>退出当前线程上的消息循环，并关闭该线程上的所有窗口。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法退出当前线程的消息循环。 此方法会导致调用<xref:System.Windows.Forms.Application.Run%2A>当前线程在可以返回。 若要退出整个应用程序，请调用<xref:System.Windows.Forms.Application.Exit%2A>。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直接调用方调用非托管的代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="message">要筛选的 Windows 事件消息。</param>
        <summary>对窗口消息运行任何筛选器，并返回修改后的消息的副本。</summary>
        <returns>
          如果已处理筛选，则为 <see langword="True" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序完成处理并即将进入空闲状态时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你有必须执行的任务的线程进入空闲状态之前，将它们附加到此事件。  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Application.Idle>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，将其粘贴到 Windows 窗体，并确保该事件处理程序与关联<xref:System.Windows.Forms.Application.Idle>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序即将退出模式状态时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Application.LeaveThreadModal>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 要运行此代码示例，将其粘贴到 Windows 窗体，并确保与事件处理程序<xref:System.Windows.Forms.Application.LeaveThreadModal>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取本地、非漫游用户的应用程序数据的路径。</summary>
        <value>本地、非漫游用户的应用程序数据的路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本地用户是指其用户配置文件存储在用户登录的系统上。 如果路径不存在，将创建一个采用以下格式：  
  
 *基路径*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 典型的基路径是 C:\Documents and Settings\\*用户名*settings\application Data。 此路径将会不同，但是，如果通过使用部署 Windows 窗体应用程序[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 创建其自己独立于所有其他应用程序的应用程序数据目录。 有关详细信息，请参阅[访问本地数据和 ClickOnce 应用程序中的远程数据](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
   
  
## Examples  
 下面的代码示例显示两个窗体，并退出应用程序，这两个窗体关闭时。 当应用程序启动和退出时，将记住每个窗体的位置。 虽然此示例演示如何使用<xref:System.Windows.Forms.Application.UserAppDataPath%2A>属性来存储应用程序数据的用户，<xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A>可以改为使用。  
  
 `MyApplicationContext`类继承自<xref:System.Windows.Forms.ApplicationContext>每个窗体已关闭，并在它们都时退出当前线程时保持跟踪。 该类存储了用户的每个窗体的位置。 窗体位置数据存储在文件标题为`Appdata.txt`，它在由位置创建<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法调用`Application.Run(context)`启动应用程序提供<xref:System.Windows.Forms.ApplicationContext>。  
  
 此代码摘自中所示的示例<xref:System.Windows.Forms.ApplicationContext>类概述。 为了简洁起见，不显示某些代码。 请参阅<xref:System.Windows.Forms.ApplicationContext>为完整的代码清单。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示该线程上是否存在消息循环的值。</summary>
        <value>
          如果存在消息循环，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性在其他环境，如非托管应用程序中承载 Windows 窗体时将始终返回`false`。 使用<xref:System.Windows.Forms.Application.RegisterMessageLoop%2A>以指示 Windows 窗体的宿主环境如果仍有活动的消息循环。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>初始化当前线程上的 OLE。</summary>
        <returns>
          <see cref="T:System.Threading.ApartmentState" /> 值之一。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用任何之前调用此方法`Microsoft.Win32`需要 OLE 的方法。 <xref:System.Windows.Forms.Application.OleRequired%2A> 首先检查是否已在当前线程上初始化 OLE。 如果没有，则初始化线程的 OLE。  
  
> [!NOTE]
>  除非线程直接调用 OLE 方法，你不需要调用此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">一个 <see cref="T:System.Exception" />，它代表所引发的异常。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Application.ThreadException" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用<xref:System.Windows.Forms.Application.OnThreadException%2A>以引发异常，处理的应用程序，则将暂停。  
  
 <xref:System.Windows.Forms.Application>类具有<xref:System.Windows.Forms.Application.ThreadException>事件。 可以将事件处理程序附加到此事件来执行的未处理异常所需的任何自定义处理。 如果你不会附加一个事件处理程序即<xref:System.Windows.Forms.Application.OnThreadException%2A>将执行默认行为，其中包括显示一个对话框，通知用户已被错误。  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> 仅在线程拥有的 Windows 窗体上实现默认的发生的未经处理异常的异常行为。 由其他线程上未经处理的异常处理<xref:System.AppDomain.UnhandledException>事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为应用程序所有的已打开窗体的集合。</summary>
        <value>包含属于此应用程序的所有当前打开窗体的 <see cref="T:System.Windows.Forms.FormCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.OpenForms%2A>属性表示拥有的应用程序的窗体的只读集合。 可以搜索此集合，按索引位置或通过<xref:System.Windows.Forms.Control.Name%2A>的<xref:System.Windows.Forms.Form>。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">按照定义，调用方必须有权访问所有窗口，<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />值<see cref="T:System.Security.Permissions.UIPermissionWindow" />枚举。</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与该应用程序关联的产品名称。</summary>
        <value>产品名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` 将取自于包含当前应用程序的主窗体的程序集的元数据。 你可以将其设置通过设置<xref:System.Reflection.AssemblyProductAttribute>内程序集清单。 有关详细信息，请参阅[程序集清单](~/docs/framework/app-domains/assembly-manifest.md)。  
  
   
  
## Examples  
 下面的代码示例获取此属性，并在文本框中显示其值。 该示例需要`textBox1`已放在窗体上。  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与该应用程序关联的产品版本。</summary>
        <value>产品版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，版本号将显示为*主要数*。*版本号*。*内部版本号*。*专用部件号*。 通过设置你的程序集清单中的程序集版本可以显式将其设置。 有关详细信息，请参阅[程序集清单](~/docs/framework/app-domains/assembly-manifest.md)。  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> 第一个如下所示，以查看是否有包含主可执行文件的程序集`AssemblyInformationalVersion`在其上的属性。 如果存在此属性，它同时用于<xref:System.Windows.Forms.Application.ProductVersion%2A>和<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>。 如果此属性不存在，这两个属性使用的可执行文件的版本。  
  
   
  
## Examples  
 下面的代码示例获取此属性，并在文本框中显示其值。 该示例需要`textBox1`已放在窗体上。  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要传递给 <see cref="T:System.EventArgs" /> 事件的 <see cref="E:System.Windows.Forms.Application.Idle" /> 对象。</param>
        <summary>在宿主方案中引发 <see cref="E:System.Windows.Forms.Application.Idle" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在另一个环境，如非托管应用程序中承载 Windows 窗体时使用此方法。 应调用<xref:System.Windows.Forms.Application.RaiseIdle%2A>在宿主应用程序进入空闲状态。 这样，某些 Windows 窗体控件和组件进行重要后台工作时用户未与应用程序交互。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" />
      </Parameters>
      <Docs>
        <param name="callback">当 Windows 窗体需要检查宿主环境是否仍在发送消息时，所要调用的方法。</param>
        <summary>注册一个回调以检查消息循环是否正在宿主环境中运行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在另一个环境，如非托管应用程序中承载 Windows 窗体时使用此方法。 在托管环境中，<xref:System.Windows.Forms.Application.MessageLoop%2A>属性将始终返回 false，如果 Windows 窗体不处理消息。 使用此回调来告诉 Windows 窗体的宿主环境仍在处理消息。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">要从应用程序移除的 <see cref="T:System.Windows.Forms.IMessageFilter" /> 的实现。</param>
        <summary>从应用程序的消息泵移除一个消息筛选器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你不再想要捕获 Windows 消息之前被发送时，你可以删除消息筛选器。  
  
   
  
## Examples  
 你可以使用消息筛选器之前，必须提供的实现<xref:System.Windows.Forms.IMessageFilter>接口。 下面的类创建消息筛选器调用`TestMessageFilter`。 此筛选器会阻止与鼠标左键相关的所有消息。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指定当前应用程序是否使用可视样式绘制控件的值。</summary>
        <value>
          如果在应用程序窗口的工作区为控件启用了可视样式，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您正在绘制的自定义控件，则使用此属性来确定是否要绘制控件带或不带可视样式，以使其外观与应用程序中其他控件一致。  
  
 下表显示的四个条件必须存在的<xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A>返回`true`。  
  
|条件|描述|  
|---------------|-----------------|  
|操作系统支持视觉样式|若要单独验证这种情况，请使用 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> 类的 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 属性。|  
|用户已启用在操作系统中的视觉样式|若要单独验证这种情况，请使用 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> 类的 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 属性。|  
|应用程序中启用了可视样式|可以通过调用 <xref:System.Windows.Forms.Application.EnableVisualStyles> 方法或使用指定用 ComCtl32.dll 版本 6 或更高版本绘制控件的应用程序清单来启用应用程序中的视觉样式。|  
|正在使用可视样式绘制应用程序窗口的工作区|若要单独验证这种情况，请使用 <xref:System.Windows.Forms.Application> 类的 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 属性，验证它是否具有 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> 或 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType> 值。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭应用程序并立即启动一个新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用的最常见原因`Restart`是启动新版本的应用程序已通过下载[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]使用`Update`或`UpdateAsync`方法。  
  
 应用程序将重新启动它们首次运行所在的上下文中。 如果你的应用程序已开始使用直接指向应用程序的主可执行文件的 URL，它将重新启动使用相同的 URL。 如果你的应用程序[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序中，它将重新启动使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。  
  
 如果你的应用程序时它第一次执行了最初提供的命令行选项<xref:System.Windows.Forms.Application.Restart%2A>将启动应用程序再次使用相同的选项。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">您的代码不是 Windows 窗体应用程序。 不能在此上下文中调用此方法。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">需要<see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" />权限。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在当前线程上开始运行标准应用程序消息循环。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在没有窗体的情况下，在当前线程上开始运行标准应用程序消息循环。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在基于 Win32 的或 Windows 窗体应用程序消息循环是处理用户事件，如点击鼠标和键盘键击代码中的例程。 每个正在运行的基于 Windows 的应用程序需要调用主消息循环活动的消息循环。 当关闭主消息循环时，应用程序退出。 在 Windows 窗体，将关闭此循环时<xref:System.Windows.Forms.Application.Exit%2A>调用方法时，或当<xref:System.Windows.Forms.Application.ExitThread%2A>运行主消息循环的线程上调用方法。  
  
 大多数 Windows 窗体开发人员将不需要使用此版本的方法。 应使用<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29>重载，以使用主窗体中，启动应用程序，以便在应用程序终止时关闭主窗体。 对于所有其他情况下，使用<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29>重载，该产品支持提供<xref:System.Windows.Forms.ApplicationContext>更好地控制应用程序的生存期的对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">主消息循环已在此线程上运行。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">一个 <see cref="T:System.Windows.Forms.ApplicationContext" />，应用程序将在其中运行。</param>
        <summary>在特定的 <see cref="T:System.Windows.Forms.ApplicationContext" /> 中，在当前线程上开始运行标准应用程序消息循环。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息循环运行，直到<xref:System.Windows.Forms.Application.Exit%2A>或<xref:System.Windows.Forms.Application.ExitThread%2A>称为或<xref:System.Windows.Forms.Application.ThreadExit>上下文对象上引发事件。  
  
   
  
## Examples  
 此示例显示两个窗体，并退出应用程序，这两个窗体关闭时。 当应用程序启动和退出时，将记住每个窗体的位置。 此示例演示如何使用<xref:System.Windows.Forms.ApplicationContext>，连同`Application.Run(context)`方法，以显示多个窗体应用程序启动时。  
  
 类`MyApplicationContext`继承自<xref:System.Windows.Forms.ApplicationContext>每个窗体已关闭，并在它们都时退出当前线程时保持跟踪。 该类存储了用户的每个窗体的位置。 窗体位置数据存储在文件标题为`Appdata.txt`，它在由位置创建<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法调用`Application.Run(context)`启动应用程序提供<xref:System.Windows.Forms.ApplicationContext>。  
  
 代码`AppForm1`和`AppForm2`起见不显示窗体。 请参阅<xref:System.Windows.Forms.ApplicationContext>类概述为完整的代码清单。  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">主消息循环已在此线程上运行。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">一个 <see cref="T:System.Windows.Forms.Form" />，它代表要使之可见的窗体。</param>
        <summary>在当前线程上开始运行标准应用程序消息循环，并使指定窗体可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，应用程序的主函数调用此方法，并将应用程序的主窗口传递给它。  
  
 此方法将添加到事件处理程序`mainForm`参数<xref:System.Windows.Forms.Form.Closed>事件。 事件处理程序调用<xref:System.Windows.Forms.Application.ExitThread%2A>清理应用程序。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Dispose%2A>方法<xref:System.Windows.Forms.Form>类将在此方法返回之前调用。  
  
   
  
## Examples  
 下面的代码示例列出窗体上一个列表框中的数字。 每次你单击`button1`，应用程序列表中添加另一个数。  
  
 `Main`方法调用<xref:System.Windows.Forms.Application.Run%2A>启动该应用程序，这将创建窗体， `listBox1`，和`button1`。 当用户单击`button1`、`button1_Click`方法添加到列表框中，一到三个数字并显示<xref:System.Windows.Forms.MessageBox>。 如果用户单击**否**上<xref:System.Windows.Forms.MessageBox>、`button1_Click`方法向列表添加另一个数。 如果用户单击**是**，应用程序调用<xref:System.Windows.Forms.Application.Exit%2A>来处理队列中的所有剩余消息，然后退出。  
  
 该示例需要`listBox1`和`button1`已创建并已放置在窗体上。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">主消息循环已在当前线程上运行。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当顶级窗口标题与版权警告标志一起显示时，要应用于顶级窗口标题的格式字符串。</summary>
        <value>要应用于顶级窗口标题的格式字符串。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要将此属性设置的所有窗口。 关联的枚举： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">用于新控件的默认值。 如果为 <see langword="true" />，则支持 <c>UseCompatibleTextRendering</c> 的新控件使用基于 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] 的 <see cref="T:System.Drawing.Graphics" /> 类进行文本呈现；如果为 <see langword="false" />，则新控件使用基于 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 的 <see cref="T:System.Windows.Forms.TextRenderer" /> 类。</param>
        <summary>将某些控件上定义的 <c>UseCompatibleTextRendering</c> 属性设置为应用程序范围内的默认值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些 Windows 窗体控件可以呈现使用其文本<xref:System.Windows.Forms.TextRenderer>类，基于[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]图形库或<xref:System.Drawing.Graphics>类，基于[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]图形库。 此更改为了[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]因性能和本地化问题[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]。 使用<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>设置的默认值`UseCompatibleTextRendering`支持它的控件的属性。  
  
 `UseCompatibleTextRendering`属性旨在提供 visual Windows 窗体控件之间的兼容性，呈现文本使用<xref:System.Windows.Forms.TextRenderer>类和[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]和[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]应用程序执行自定义文本呈现使用<xref:System.Drawing.Graphics>类。 在大多数情况下，如果你的应用程序不正在升级从[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]或[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]，因此，建议你停`UseCompatibleTextRendering`设置的默认值为`false`。  
  
 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]基于<xref:System.Windows.Forms.TextRenderer>类中引入了[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]为了提高性能，使文本效果更好，并提高的国际字体支持。 在早期版本的[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]、[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]基于<xref:System.Drawing.Graphics>类用于执行所有文本呈现。 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 计算字符间距和自动换行从的不同[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]。 在 Windows 窗体应用程序中使用<xref:System.Drawing.Graphics>类呈现文本中，这可能会导致使用的控件的文本<xref:System.Windows.Forms.TextRenderer>显示不同于应用程序中的其他文本。 若要解决此不兼容性，你可以设置`UseCompatibleTextRendering`属性`true`。 若要设置`UseCompatibleTextRendering`到`true`应用程序中的所有受支持控件，调用<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>方法的参数替换`true`。  
  
 如果在另一个应用程序，如 Internet Explorer 中承载 Windows 窗体代码，应永远不会调用此方法。 只能在独立的 Windows 窗体应用程序中调用此方法。  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  若要设置的默认值为`UseCompatibleTextRendering`中[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]或更高版本，请参阅<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>。  
  
 在[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]或更高版本，对的调用<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>在 Program.cs 文件中自动生成。 若要更改文本呈现默认值，请修改生成的代码。  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">您只能在 Windows 窗体应用程序创建第一个窗口之前调用此方法。</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" />
        <Parameter Name="force" Type="System.Boolean" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="state">指示要转换到的目标电源活动模式的 <see cref="T:System.Windows.Forms.PowerState" />。</param>
        <param name="force">
          若要立即强制挂起模式，则为 <see langword="true" />；若要使 Windows 向每个应用程序发送挂起请求，则为 <see langword="false" />。</param>
        <param name="disableWakeEvent">
          值为 <see langword="true" /> 时可在发生唤醒事件时禁止将系统的电源状态恢复为活动状态；值为 <see langword="false" /> 时可在发生唤醒事件时允许将系统的电源状态恢复为活动状态。</param>
        <summary>挂起系统或使系统休眠，或者请求系统挂起或休眠。</summary>
        <returns>
          如果正在挂起该系统，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果应用程序不响应的挂起请求在 20 秒内，Windows 将确定它处于非响应状态，并且，应用程序可以被置于休眠模式或终止。 一旦应用程序响应的挂起请求，但是，它可能需要它需要清理资源，并关闭活动进程的任意时间。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示应用程序如何响应未经处理的异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设置 Windows 窗体线程和其他线程发生的异常的异常发生的事件处理程序。 它将设置<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>以便所有异常都处理应用程序，而不考虑应用程序的用户配置文件中的设置。 它使用<xref:System.Windows.Forms.Application.ThreadException>事件来处理 UI 线程异常和<xref:System.AppDomain.UnhandledException>事件来处理非 UI 线程异常。 由于<xref:System.AppDomain.UnhandledException>无法防止应用程序终止，则只需将错误记录中在终止之前应用程序事件日志。  
  
 此示例假定你已经定义了两个<xref:System.Windows.Forms.Button>控件，`button1`和`button2`，在你<xref:System.Windows.Forms.Form>类。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
      </Parameters>
      <Docs>
        <param name="mode">一个 <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 值，描述在引发未捕获的异常时应用程序的行为方式。</param>
        <summary>指示应用程序如何响应未经处理的异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它通常不是可行捕捉所有由 Windows 窗体引发的异常。 使用此方法，你可以指示是否应捕获所有未经处理由 Windows 窗体组件引发的异常并继续运行，或它是否应将它们公开给用户并暂停执行你的应用程序。  
  
 调用<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>实例化你的应用程序使用的主窗体之前<xref:System.Windows.Forms.Application.Run%2A>方法。  
  
 若要捕获不创建的线程中出现的异常和由 Windows 窗体，拥有使用<xref:System.AppDomain.UnhandledException>事件处理程序。  
  
   
  
## Examples  
 下面的代码示例设置 Windows 窗体线程和其他线程发生的异常的异常发生的事件处理程序。 它将设置<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>以便所有异常都处理应用程序，而不考虑应用程序的用户配置文件中的设置。 它使用<xref:System.Windows.Forms.Application.ThreadException>事件来处理 UI 线程异常和<xref:System.AppDomain.UnhandledException>事件来处理非 UI 线程异常。 由于<xref:System.AppDomain.UnhandledException>无法防止应用程序终止，则只需将错误记录中在终止之前应用程序事件日志。  
  
 此示例假定你已经定义了两个<xref:System.Windows.Forms.Button>控件，`button1`和`button2`，在你<xref:System.Windows.Forms.Form>类。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在应用程序创建其第一个窗口后，您将无法设置异常模式。</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
        <Parameter Name="threadScope" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mode">一个 <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 值，描述在引发未捕获的异常时应用程序的行为方式。</param>
        <param name="threadScope">
          如果设置线程异常模式，为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>指示应用程序如何响应未经处理的异常，同时可选择应用特定于线程的行为。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它通常不是可行捕捉所有由 Windows 窗体引发的异常。 使用此方法，你可以指示是否应捕获所有未经处理由 Windows 窗体组件引发的异常并继续运行，或它是否应将它们公开给用户并暂停执行你的应用程序。  
  
 调用<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>实例化你的应用程序使用的主窗体之前<xref:System.Windows.Forms.Application.Run%2A>方法。  
  
 当`threadScope`是`true`，设置线程异常模式。 如果此线程异常模式重写应用程序异常模式`mode`未设置为<xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>。  
  
 当`threadScope`是`false`，应用程序异常模式设置。 应用程序异常模式适用于具有的所有线程<xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>模式。 设置应用程序异常模式不会影响当前线程的设置。  
  
 若要捕获不创建的线程中出现的异常和由 Windows 窗体，拥有使用<xref:System.AppDomain.UnhandledException>事件处理程序。  
  
   
  
## Examples  
 下面的代码示例设置 Windows 窗体线程和其他线程发生的异常的异常发生的事件处理程序。 它将设置<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>以便所有异常都处理应用程序，而不考虑应用程序的用户配置文件中的设置。 它使用<xref:System.Windows.Forms.Application.ThreadException>事件来处理 UI 线程异常和<xref:System.AppDomain.UnhandledException>事件来处理非 UI 线程异常。 由于<xref:System.AppDomain.UnhandledException>无法防止应用程序终止，则只需将错误记录中在终止之前应用程序事件日志。  
  
 此示例假定你已经定义了两个<xref:System.Windows.Forms.Button>控件，`button1`和`button2`，在你<xref:System.Windows.Forms.Form>类。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在应用程序创建其第一个窗口后，您将无法设置异常模式。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取启动了应用程序的可执行文件的路径，不包括可执行文件的名称。</summary>
        <value>启动了应用程序的可执行文件的路径。  
  
 取决于是否使用 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 部署 Windows 窗体应用程序，此路径将会不同。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 应用程序存储在每个用户应用程序缓存中 C:\Documents and Settings\\*用户名*目录。 有关详细信息，请参阅[访问本地数据和 ClickOnce 应用程序中的远程数据](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例获取此属性，并在文本框中显示其值。 该示例需要`textBox1`已放在窗体上。  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于获取路径。 关联的枚举： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在发生未捕获线程异常时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件允许 Windows 窗体应用程序与 Windows 窗体线程中发生的句柄否则为未经处理的异常。 附加到事件处理程序<xref:System.Windows.Forms.Application.ThreadException>事件来处理这些例外情况，这将使你的应用程序处于未知状态。 如果可能，应由结构化异常处理块处理异常。  
  
 你可以更改是否通过设置情况下，使用 Windows 窗体线程的未处理异常的此回调<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>。 若要捕获不创建的线程中出现的异常和由 Windows 窗体，拥有使用<xref:System.AppDomain.UnhandledException>事件处理程序。  
  
> [!NOTE]
>  若要确保此事件没有激活会丢失，必须附加处理程序，然后才能调用<xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>。  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
   
  
## Examples  
 下面的代码示例设置 Windows 窗体线程和其他线程发生的异常的异常发生的事件处理程序。 它将设置<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>以便所有异常都处理应用程序，而不考虑应用程序的用户配置文件中的设置。 它使用<xref:System.Windows.Forms.Application.ThreadException>事件来处理 UI 线程异常和<xref:System.AppDomain.UnhandledException>事件来处理非 UI 线程异常。 由于<xref:System.AppDomain.UnhandledException>无法防止应用程序终止，则只需将错误记录中在终止之前应用程序事件日志。  
  
 此示例假定你已经定义了两个<xref:System.Windows.Forms.Button>控件，`button1`和`button2`，在你<xref:System.Windows.Forms.Form>类。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直接调用方调用非托管的代码时此事件添加处理程序。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在某线程即将关闭时发生。 当应用程序的主线程即将关闭时，首先引发该事件，随后是 <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须将附加到的事件处理程序<xref:System.Windows.Forms.Application.ThreadExit>事件以执行任何未处理的、 所需任务的线程停止运行前。 关闭打开的此线程或释放的垃圾回收器未回收的对象文件。  
  
> [!CAUTION]
>  由于这是一个静态事件，则必须在你的应用程序将被释放，或会导致内存泄漏时分离事件处理程序。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Application.ThreadExit>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 要运行此代码示例，将其粘贴到 Windows 窗体，并确保与事件处理程序<xref:System.Windows.Forms.Application.ThreadExit>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>注销使用 <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" /> 发出的消息循环回调。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用户的应用程序数据的路径。</summary>
        <value>用户的应用程序数据的路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果路径不存在，将创建一个采用以下格式：  
  
 *基路径*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 此路径中存储的数据是启用的漫游用户配置文件的一部分。 漫游用户在网络中的多个计算机上工作。 漫游用户的用户配置文件保留在网络上的服务器上，并在用户登录时加载到系统。 用户配置文件才会考虑让漫游时，操作系统必须支持漫游配置文件，并且必须启用。  
  
 典型的基路径是 C:\Documents and Settings\\*用户名*\Application 数据。 此路径将会不同，但是，如果通过使用部署 Windows 窗体应用程序[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 创建其自己独立于所有其他应用程序的应用程序数据目录。 有关详细信息，请参阅[访问本地数据和 ClickOnce 应用程序中的远程数据](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
   
  
## Examples  
 下面的代码示例显示两个窗体，并退出应用程序，这两个窗体关闭时。 当应用程序启动和退出时，将记住每个窗体的位置。 此示例演示如何使用<xref:System.Windows.Forms.Application.UserAppDataPath%2A>属性来存储用户的应用程序数据。  
  
 类`MyApplicationContext`继承自<xref:System.Windows.Forms.ApplicationContext>每个窗体已关闭，并在它们都时退出当前线程时保持跟踪。 该类存储了用户的每个窗体的位置。 窗体位置数据存储在文件标题为`Appdata.txt`，它在由位置创建<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法调用`Application.Run(context)`启动应用程序提供<xref:System.Windows.Forms.ApplicationContext>。  
  
 此代码摘自中所示的示例<xref:System.Windows.Forms.ApplicationContext>类概述。 为了简洁起见，不显示某些代码。 请参阅<xref:System.Windows.Forms.ApplicationContext>为完整的代码清单。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用户的应用程序数据的注册表项。</summary>
        <value>一个 <see cref="T:Microsoft.Win32.RegistryKey" />，它表示特定于用户的应用程序数据的注册表项。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不存在该键，则将它创建采用以下格式：  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 数据存储在此项是启用的漫游用户配置文件的一部分。 漫游用户在网络中的多个计算机上工作。 漫游用户的用户配置文件保留在网络上的服务器上，并在用户登录时加载到系统。 用户配置文件才会考虑让漫游时，操作系统必须支持漫游配置文件，并且必须启用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置是否对应用程序的所有打开窗体使用等待光标。</summary>
        <value>
          如果等待光标用于所有打开的窗体，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当此属性设置为`true`、<xref:System.Windows.Forms.Control.UseWaitCursor%2A>的应用程序中的所有打开窗体的属性将设置为`true`。 此属性将设置在所有窗体上之前，不会返回此调用。 当你有一个长时间运行的操作，并想要在所有应用程序窗体中指示该操作仍在处理时，请使用此属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指定可视样式如何应用于应用程序窗口的值。</summary>
        <value>
          <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> 值的按位组合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这<xref:System.Windows.Forms.Application.VisualStyleState%2A>属性确定在客户端区域或应用程序窗口非工作区中是否启用了可视样式。 通常情况下，应在主窗体的构造函数中设置此属性或<xref:System.Windows.Forms.Form.Load>事件处理程序。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Windows.Forms.Application.VisualStyleState%2A>属性之一<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>值内<xref:System.Windows.Forms.Control.Click>事件处理程序<xref:System.Windows.Forms.Button>控件。 此代码示例摘自更大的示例为提供<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>枚举。  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>