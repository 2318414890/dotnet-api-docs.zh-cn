<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e752222af6c6569cb55bfb9498e89168045d4932" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51870451" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供 <see langword="static" /> 方法和属性以管理应用程序，例如启动和停止应用程序、处理 Windows 消息的方法和获取应用程序信息的属性。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application>类具有方法来启动和停止应用程序和线程，并处理 Windows 消息，如下所示：  
  
-   <xref:System.Windows.Forms.Application.Run%2A> 当前线程上启动应用程序消息循环，并 （可选） 将使窗体可见。  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> 或<xref:System.Windows.Forms.Application.ExitThread%2A>停止消息循环。  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> 虽然您的程序是在循环中处理的消息。  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> 将消息筛选器添加到应用程序消息泵来监视 Windows 消息。  
  
-   <xref:System.Windows.Forms.IMessageFilter> 可停止来自正在引发的事件或调用事件处理程序之前执行特殊操作。  
  
 此类具有<xref:System.Windows.Forms.Application.CurrentCulture%2A>和<xref:System.Windows.Forms.Application.CurrentInputLanguage%2A>属性获取或设置区域性的当前线程的信息。  
  
 无法创建此类的实例。  
  
   
  
## Examples  
 下面的代码示例列出了在窗体上的列表框中的数字。 每次单击`button1`，应用程序向列表添加另一个数。  
  
 `Main`方法调用<xref:System.Windows.Forms.Application.Run%2A>以启动应用程序，创建表单时，`listBox1`和`button1`。 当用户单击`button1`，则`button1_Click`方法将显示<xref:System.Windows.Forms.MessageBox>。 如果用户单击`No`上<xref:System.Windows.Forms.MessageBox>，则`button1_Click`方法向列表添加一个数字。 如果用户单击`Yes`，应用程序调用<xref:System.Windows.Forms.Application.Exit%2A>来处理队列中的所有剩余消息，然后退出。  
  
> [!NOTE]
>  对调用<xref:System.Windows.Forms.Application.Exit%2A>在部分信任中将失败。  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">要安装的 <see cref="T:System.Windows.Forms.IMessageFilter" /> 接口的实现。</param>
        <summary>添加消息筛选器以便在向目标传送 Windows 消息时监视这些消息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止引发特定事件或执行特殊操作事件传递到事件处理程序之前，请使用消息筛选器。 消息筛选器是唯一的特定线程。  
  
 若要防止消息被调度`value`传递给此方法的参数实例必须重写<xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A>代码，以处理消息的方法。 该方法必须返回 `false`。  
  
> [!CAUTION]
>  将消息筛选器添加到应用程序的消息泵可能会降低性能。  
  
   
  
## Examples  
 下面的代码示例创建名为消息筛选器`TestMessageFilter`。 此筛选器会阻止与鼠标按钮相关的所有消息。 可以使用消息筛选器之前，必须提供一个实现<xref:System.Windows.Forms.IMessageFilter>接口。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直接调用方调用非托管的代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示调用方能否退出该应用程序的值。</summary>
        <value>如果调用方能够退出该应用程序，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回`false`如果从调用<xref:System.Windows.Forms.Control>所承载的 Web 浏览器。 因此，<xref:System.Windows.Forms.Control>无法退出<xref:System.Windows.Forms.Application>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在应用程序即将关闭时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须将附加到的事件处理程序<xref:System.Windows.Forms.Application.Exit%2A>事件来执行未处理状态，该应用程序停止运行前必需任务。 你可以关闭打开的此应用程序或释放的垃圾回收未回收的对象文件。  
  
 由于这是一个静态事件，必须分离附加到此事件中的任何事件处理程序<xref:System.Windows.Forms.Application.ApplicationExit>事件处理程序本身。 如果未分离这些处理程序，它们将保持附加在该事件并继续占用的内存。  
  
   
  
## Examples  
 下面的代码示例显示两个窗体，并退出应用程序，这两个窗体关闭时。 当应用程序启动并退出时，会记住每个窗体的位置。 此示例演示如何使用<xref:System.Windows.Forms.Application.ApplicationExit>事件，以了解窗体位置应永久保存到文件，以及时`FileStream`应将其关闭。  
  
 该类`MyApplicationContext`继承<xref:System.Windows.Forms.ApplicationContext>和跟踪的每个窗体处于关闭状态，并在它们都时退出当前线程时间。 在关闭时，类会记住每个窗体的位置。 当<xref:System.Windows.Forms.Application.ApplicationExit>发生事件时，类将每个用户的位置写入到文件。 窗体位置数据存储在名为的文件`appdata.txt`由在位置创建<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法调用`Application.Run(context)`以启动应用程序提供<xref:System.Windows.Forms.ApplicationContext>。  
  
 此代码是一段摘录所示示例<xref:System.Windows.Forms.ApplicationContext>类概述。 请参阅<xref:System.Windows.Forms.ApplicationContext>有关整个代码列表。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取所有用户共享的应用程序数据的路径。</summary>
        <value>所有用户共享的应用程序数据的路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果路径不存在，被创建一个采用以下格式：  
  
 *基路径*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> 第一个看起来是否包含主可执行文件的程序集具有`AssemblyInformationalVersion`上它的属性。 如果存在此属性，它使用两个<xref:System.Windows.Forms.Application.ProductVersion%2A>和<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>。 如果此属性不存在，这两个属性使用的可执行文件的版本。  
  
 路径将会不同，具体取决于是否使用部署 Windows 窗体应用程序[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 应用程序存储在每个用户应用程序缓存中 C:\Documents and Settings\\*用户名*目录。 有关详细信息，请参阅[访问本地数据和 ClickOnce 应用程序中的远程数据](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取所有用户共享的应用程序数据的注册表项。</summary>
        <value>一个 <see cref="T:Microsoft.Win32.RegistryKey" />，它表示所有用户共享的应用程序数据的注册表项。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果键不存在，它被创建采用以下格式：  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与该应用程序关联的公司名称。</summary>
        <value>公司名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例获取此属性，并在文本框中显示其值。 该示例需要`textBox1`已放在窗体上。  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前线程的区域性信息。</summary>
        <value>一个 <see cref="T:System.Globalization.CultureInfo" />，它代表当前线程的区域性信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例获取此属性，并在文本框中显示其值。 该示例需要`textBox1`已放在窗体上。  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要将此属性设置的所有窗口。 关联的枚举： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前线程的当前输入语言。</summary>
        <value>一个 <see cref="T:System.Windows.Forms.InputLanguage" />，它代表当前线程的当前输入语言。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例获取此属性，并在文本框中显示其值。 该示例需要`textBox1`已放在窗体上。  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直接调用方调用非托管的代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>处理当前在消息队列中的所有 Windows 消息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 运行 Windows 窗体，它会创建新窗体，然后等待要处理的事件。 在窗体处理的事件，每次处理所有与该事件关联的代码。 在队列中等待所有其他事件。 虽然你的代码处理事件时，你的应用程序不响应。 例如，如果另一个窗口拖到顶部，也无法重新绘制窗口。  
  
 如果调用<xref:System.Windows.Forms.Application.DoEvents%2A>在代码中，你的应用程序可以处理其他事件。 例如，如果您将添加到数据的窗体<xref:System.Windows.Forms.ListBox>并添加<xref:System.Windows.Forms.Application.DoEvents%2A>到代码中，你的窗体可时重新绘制另一个窗口拖到它。 如果你删除<xref:System.Windows.Forms.Application.DoEvents%2A>在代码中，你的窗体不会重新绘制按钮的单击事件处理程序完成之前执行。 消息传送的详细信息，请参阅[在 Windows 窗体中的用户输入](~/docs/framework/winforms/user-input-in-windows-forms.md)。  
  
 与不同的是 Visual Basic 6.0<xref:System.Windows.Forms.Application.DoEvents%2A>方法不会调用<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法。  
  
 通常情况下，在处理消息循环中使用此方法。  
  
> [!CAUTION]
>  调用此方法会导致当前线程暂停，但所有等待窗口消息进行都处理。 如果一条消息将导致触发的事件，可能执行的应用程序代码其他区域。 这会导致出现意外的行为难以调试的应用程序。 如果执行的操作或需要较长时间的计算，通常最好是新线程上执行的运算。 有关异步编程的详细信息，请参阅[异步编程模型 (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md)。  
  
   
  
## Examples  
 下面的代码示例演示了如何使用<xref:System.Windows.Forms.Application.DoEvents%2A>方法。 如果该示例运行时，用户可以选择从图形文件<xref:System.Windows.Forms.OpenFileDialog>。 在窗体中显示所选的文件。 <xref:System.Windows.Forms.Application.DoEvents%2A>方法强制重新绘制的每个打开的图形文件的窗体。 若要运行此示例中，粘贴以下代码在一个窗体，其中包含<xref:System.Windows.Forms.PictureBox>名为`PictureBox1`，则<xref:System.Windows.Forms.OpenFileDialog>名为`OpenFileDialog1`，和一个名为按钮`fileButton`。 调用`InitializePictureBox`并`InitializeOpenFileDialog`窗体的构造函数中的方法或`Load`方法。  
  
> [!NOTE]
>  在 Visual Studio 中，如果您将添加<xref:System.Windows.Forms.OpenFileDialog>向窗体通过使用拖放操作，您必须修改以下`InitializeOpenFileDialog`方法删除创建的新实例的代码行<xref:System.Windows.Forms.OpenFileDialog>。  
  
 该示例还需要<xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType>的事件<xref:System.Windows.Forms.Button>控件并<xref:System.Windows.Forms.FileDialog.FileOk>事件的<xref:System.Windows.Forms.OpenFileDialog>连接到在示例中定义的事件处理程序。 当运行示例时，通过单击按钮显示的对话框。  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>启用应用程序的可视样式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使应用程序的可视样式。 视觉样式已颜色、 字体和其他可视元素构成操作系统主题。 如果该控件和操作系统支持它，将以视觉样式绘制控件。 若要具有某个效果，请<xref:System.Windows.Forms.Application.EnableVisualStyles>必须在该应用程序; 中创建的任何控件之前调用通常情况下，<xref:System.Windows.Forms.Application.EnableVisualStyles>是中的第一行`Main`函数。 启用视觉样式，调用时不需要单独清单<xref:System.Windows.Forms.Application.EnableVisualStyles>。  
  
> [!NOTE]
>  在.NET Framework 2.0 中前,`FlatStyle`的一些控件，如派生的控件的属性<xref:System.Windows.Forms.ButtonBase>，必须设置为<xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType>用于以视觉样式绘制的控件顺序。 在使用.NET Framework 2.0 编写的应用程序，这是不再必要。  
  
> [!NOTE]
>  此方法不会影响 Internet Explorer 中承载的控件。  
  
   
  
## Examples  
 下面的代码示例演示如何调用<xref:System.Windows.Forms.Application.EnableVisualStyles%2A>在`Main`函数，以使应用程序的可视样式。  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序即将进入模式状态时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  由于这是一个静态事件，必须释放你的应用程序，或会导致内存泄漏时分离事件处理程序。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Application.EnterThreadModal>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，将其粘贴到 Windows 窗体，并确保事件处理程序相关联<xref:System.Windows.Forms.Application.EnterThreadModal>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">需要<see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" />侦听的事件的权限。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取启动了应用程序的可执行文件的路径，包括可执行文件的名称。</summary>
        <value>启动了应用程序的可执行文件的路径和可执行文件的名称。  
  
取决于是否使用 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 部署 Windows 窗体应用程序，此路径将会不同。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 应用程序存储在每个用户应用程序缓存中 C:\Documents and Settings\\*用户名*目录。 有关详细信息，请参阅[访问本地数据和 ClickOnce 应用程序中的远程数据](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于获取路径。 关联的枚举： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>通知所有消息泵必须终止，并且在处理了消息以后关闭所有应用程序窗口。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通知所有消息泵必须终止，并且在处理了消息以后关闭所有应用程序窗口。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.Exit%2A>方法对所有线程停止所有正在运行消息循环，并关闭所有窗口的应用程序。 此方法并不强制退出该应用程序。 <xref:System.Windows.Forms.Application.Exit%2A>通常从调用中使用消息循环，并强制<xref:System.Windows.Forms.Application.Run%2A>返回。 若要退出当前线程的消息循环，请调用<xref:System.Windows.Forms.Application.ExitThread%2A>。  
  
 <xref:System.Windows.Forms.Application.Exit%2A> 引发以下事件，并执行相关联的条件操作：  
  
-   一个<xref:System.Windows.Forms.Form.FormClosing>为每个窗体，由表示引发事件<xref:System.Windows.Forms.Application.OpenForms%2A>属性。 此事件可通过设置取消<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>的属性及其<xref:System.Windows.Forms.FormClosingEventArgs>参数`true`。  
  
-   如果一个或多个处理程序将取消该事件，然后<xref:System.Windows.Forms.Application.Exit%2A>返回，而不执行进一步的操作。 否则为<xref:System.Windows.Forms.Form.FormClosed>事件引发的每个打开的窗体，然后关闭所有正在运行的消息循环和窗体。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Application.Exit%2A>方法不会引发<xref:System.Windows.Forms.Form.Closed>并<xref:System.Windows.Forms.Form.Closing>事件，已过时的[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]。  
  
   
  
## Examples  
 下面的代码示例列出了在窗体上的列表框中的数字。 每次单击`button1`，应用程序向列表添加另一个数。  
  
 `Main`方法调用<xref:System.Windows.Forms.Application.Run%2A>以启动应用程序，创建表单时， `listBox1`，和`button1`。 当用户单击`button1`，则`button1_Click`方法将添加到列表框中，一到三个数字并显示<xref:System.Windows.Forms.MessageBox>。 如果用户单击**否**上<xref:System.Windows.Forms.MessageBox>，则`button1_Click`方法向列表添加另一个数。 如果用户单击**是**，应用程序调用<xref:System.Windows.Forms.Application.Exit%2A>，来处理队列中的所有剩余消息，然后退出。  
  
 该示例需要`listBox1`和`button1`已实例化并已放置在窗体上。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直接调用方调用非托管的代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">返回应用程序中的任何 <see cref="T:System.Windows.Forms.Form" /> 是否已取消退出。</param>
        <summary>通知所有消息泵必须终止，并且在处理了消息以后关闭所有应用程序窗口。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">终止正在运行的权限的应用程序线程。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>退出当前线程上的消息循环，并关闭该线程上的所有窗口。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法退出当前线程的消息循环。 此方法将导致调用<xref:System.Windows.Forms.Application.Run%2A>当前线程返回。 若要退出整个应用程序，请调用<xref:System.Windows.Forms.Application.Exit%2A>。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直接调用方调用非托管的代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="message">要筛选的 Windows 事件消息。</param>
        <summary>对窗口消息运行任何筛选器，并返回修改后的消息的副本。</summary>
        <returns>如果已处理筛选，则为 <see langword="True" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序完成处理并即将进入空闲状态时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您有必须执行的任务在线程进入空闲状态之前，请将它们附加到此事件。  
  
> [!CAUTION]
>  由于这是一个静态事件，必须释放你的应用程序，或会导致内存泄漏时分离事件处理程序。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Application.Idle>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，将其粘贴到 Windows 窗体，并确保事件处理程序与<xref:System.Windows.Forms.Application.Idle>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序即将退出模式状态时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  由于这是一个静态事件，必须释放你的应用程序，或会导致内存泄漏时分离事件处理程序。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Application.LeaveThreadModal>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，将其粘贴到 Windows 窗体，并确保事件处理程序相关联<xref:System.Windows.Forms.Application.LeaveThreadModal>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取本地、非漫游用户的应用程序数据的路径。</summary>
        <value>本地、非漫游用户的应用程序数据的路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本地用户是指其用户配置文件存储在其的用户登录的系统。 如果路径不存在，被创建一个采用以下格式：  
  
 *基路径*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 典型的基路径是 C:\Documents and Settings\\*用户名*settings\application Data。 此路径将会不同，但是，如果通过使用部署 Windows 窗体应用程序[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 创建其自己的应用程序数据目录的独立于所有其他应用程序。 有关详细信息，请参阅[访问本地数据和 ClickOnce 应用程序中的远程数据](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
   
  
## Examples  
 下面的代码示例显示两个窗体，并退出应用程序，这两个窗体关闭时。 当应用程序启动并退出时，会记住每个窗体的位置。 虽然此示例演示如何使用<xref:System.Windows.Forms.Application.UserAppDataPath%2A>属性来存储用户的应用程序数据<xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A>可改为使用。  
  
 `MyApplicationContext`类继承自<xref:System.Windows.Forms.ApplicationContext>时每个窗体处于关闭状态，并在它们都时退出当前线程保持跟踪。 类用于存储用户的每个窗体的位置。 窗体位置数据存储在名为的文件`Appdata.txt`由在位置创建<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法调用`Application.Run(context)`以启动应用程序提供<xref:System.Windows.Forms.ApplicationContext>。  
  
 此代码是一段摘录所示示例<xref:System.Windows.Forms.ApplicationContext>类概述。 为了简洁起见，不显示一些代码。 请参阅<xref:System.Windows.Forms.ApplicationContext>有关整个代码列表。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示该线程上是否存在消息循环的值。</summary>
        <value>如果存在消息循环，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在其他环境，如非托管应用程序中承载 Windows 窗体时此属性将始终返回`false`。 使用<xref:System.Windows.Forms.Application.RegisterMessageLoop%2A>以指示 Windows 窗体如果宿主环境仍然有活动的消息循环。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>初始化当前线程上的 OLE。</summary>
        <returns>
          <see cref="T:System.Threading.ApartmentState" /> 值之一。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在调用之前调用任何`Microsoft.Win32`需要 OLE 的方法。 <xref:System.Windows.Forms.Application.OleRequired%2A> 首先检查以查看是否已在当前线程上初始化 OLE。 如果没有，它针对 OLE 初始化线程。  
  
> [!NOTE]
>  除非某个线程直接调用 OLE 方法，您不需要调用此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">一个 <see cref="T:System.Exception" />，它代表所引发的异常。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Application.ThreadException" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用<xref:System.Windows.Forms.Application.OnThreadException%2A>引发异常，将停止处理的应用程序。  
  
 <xref:System.Windows.Forms.Application>类具有<xref:System.Windows.Forms.Application.ThreadException>事件。 可以将事件处理程序附加到此事件，以便执行所需的未经处理的异常的任何自定义处理。 如果事件处理程序，不附加<xref:System.Windows.Forms.Application.OnThreadException%2A>将执行默认行为，其中包括显示一个对话框，通知用户已被错误。  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> 仅在线程拥有的 Windows 窗体上实现默认未经处理的异常的异常行为。 其他线程的未处理的异常将由<xref:System.AppDomain.UnhandledException>事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为应用程序所有的已打开窗体的集合。</summary>
        <value>包含属于此应用程序的所有当前打开窗体的 <see cref="T:System.Windows.Forms.FormCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.OpenForms%2A>属性表示拥有的应用程序的窗体的只读集合。 此集合可按索引位置或通过搜索<xref:System.Windows.Forms.Control.Name%2A>的<xref:System.Windows.Forms.Form>。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">调用方必须有权访问所有窗口，通过定义<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />的值<see cref="T:System.Security.Permissions.UIPermissionWindow" />枚举。</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与该应用程序关联的产品名称。</summary>
        <value>产品名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` 取自包含当前应用程序的主窗体的程序集的元数据。 通过设置可设置它<xref:System.Reflection.AssemblyProductAttribute>内程序集清单。 有关详细信息，请参阅[程序集清单](~/docs/framework/app-domains/assembly-manifest.md)。  
  
   
  
## Examples  
 下面的代码示例获取此属性，并在文本框中显示其值。 该示例需要`textBox1`已放在窗体上。  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与该应用程序关联的产品版本。</summary>
        <value>产品版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，显示为一个版本号*主要数*。*版本号*。*内部版本号*。*专用部件号*。 通过设置程序集清单中的程序集版本可以显式将其设置。 有关详细信息，请参阅[程序集清单](~/docs/framework/app-domains/assembly-manifest.md)。  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> 第一个看起来是否包含主可执行文件的程序集具有`AssemblyInformationalVersion`上它的属性。 如果存在此属性，它使用两个<xref:System.Windows.Forms.Application.ProductVersion%2A>和<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>。 如果此属性不存在，这两个属性使用的可执行文件的版本。  
  
   
  
## Examples  
 下面的代码示例获取此属性，并在文本框中显示其值。 该示例需要`textBox1`已放在窗体上。  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">要传递给 <see cref="T:System.EventArgs" /> 事件的 <see cref="E:System.Windows.Forms.Application.Idle" /> 对象。</param>
        <summary>在宿主方案中引发 <see cref="E:System.Windows.Forms.Application.Idle" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在另一个环境，如非托管应用程序中承载 Windows 窗体时使用此方法。 应调用<xref:System.Windows.Forms.Application.RaiseIdle%2A>宿主应用程序进入空闲状态时。 这样，某些 Windows 窗体控件和组件进行重要的后台工作，而用户不与应用程序进行交互。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" />
      </Parameters>
      <Docs>
        <param name="callback">当 Windows 窗体需要检查宿主环境是否仍在发送消息时，所要调用的方法。</param>
        <summary>注册一个回调以检查消息循环是否正在宿主环境中运行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在另一个环境，如非托管应用程序中承载 Windows 窗体时使用此方法。 在托管环境中，<xref:System.Windows.Forms.Application.MessageLoop%2A>属性将始终返回 false，如果 Windows 窗体未处理的消息。 使用此回调来告诉 Windows 窗体的宿主环境仍在处理消息。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">要从应用程序移除的 <see cref="T:System.Windows.Forms.IMessageFilter" /> 的实现。</param>
        <summary>从应用程序的消息泵移除一个消息筛选器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你不再想要捕获 Windows 消息之前对它们时，可以删除消息筛选器。  
  
   
  
## Examples  
 可以使用消息筛选器之前，必须提供一个实现<xref:System.Windows.Forms.IMessageFilter>接口。 下面的类创建消息筛选器名为`TestMessageFilter`。 此筛选器会阻止与鼠标按钮相关的所有消息。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指定当前应用程序是否使用可视样式绘制控件的值。</summary>
        <value>如果在应用程序窗口的工作区为控件启用了可视样式，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您正在绘制的自定义控件，使用此属性来确定是否要绘制控件使用或不具有可视样式，使其外观与应用程序中其他控件保持一致。  
  
 下表显示了四个条件必须存在<xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A>以返回`true`。  
  
|条件|描述|  
|---------------|-----------------|  
|操作系统支持视觉样式|若要单独验证这种情况，请使用 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> 类的 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 属性。|  
|用户已启用操作系统中的视觉样式|若要单独验证这种情况，请使用 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> 类的 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 属性。|  
|在应用程序中启用了可视样式|可以通过调用 <xref:System.Windows.Forms.Application.EnableVisualStyles> 方法或使用指定用 ComCtl32.dll 版本 6 或更高版本绘制控件的应用程序清单来启用应用程序中的视觉样式。|  
|正在使用视觉样式绘制的应用程序窗口工作区|若要单独验证这种情况，请使用 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 类的 <xref:System.Windows.Forms.Application> 属性，验证它是否具有 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> 或 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>值。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭应用程序并立即启动一个新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用的最常见原因`Restart`是启动新版本的应用程序的已通过下载[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]使用`Update`或`UpdateAsync`方法。  
  
 他们首次运行所在的上下文中重新启动应用程序。 如果你的应用程序已启动使用 URL 直接指向应用程序的主可执行文件，它将使用相同的 URL 重启。 如果你的应用程序[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序，它将在重新启动使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。  
  
 如果你的应用程序在它首次执行时已提供了命令行选项<xref:System.Windows.Forms.Application.Restart%2A>将启动应用程序使用相同的选项。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">您的代码不是 Windows 窗体应用程序。 不能在此上下文中调用此方法。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">需要<see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" />权限。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在当前线程上开始运行标准应用程序消息循环。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在没有窗体的情况下，在当前线程上开始运行标准应用程序消息循环。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在基于 Win32 的或 Windows 窗体应用程序消息循环是处理用户事件，如鼠标单击和键盘键击的代码中的例程。 每个正在运行的基于 Windows 的应用程序需要活动的消息循环，调用主消息循环。 关闭后主消息循环，该应用程序将退出。 在 Windows 窗体中此循环时，将关闭<xref:System.Windows.Forms.Application.Exit%2A>调用方法时，或当<xref:System.Windows.Forms.Application.ExitThread%2A>正在运行的主消息循环的线程上调用方法。  
  
 大多数 Windows 窗体开发人员将不需要使用此版本的方法。 应使用<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29>重载来启动应用程序主窗体，以便在应用程序终止时关闭主窗体。 对于所有其他情况下，使用<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29>重载，该产品支持提供<xref:System.Windows.Forms.ApplicationContext>更好地控制应用程序的生存期的对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">主消息循环已在此线程上运行。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">一个 <see cref="T:System.Windows.Forms.ApplicationContext" />，应用程序将在其中运行。</param>
        <summary>在特定的 <see cref="T:System.Windows.Forms.ApplicationContext" /> 中，在当前线程上开始运行标准应用程序消息循环。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息循环运行，直到<xref:System.Windows.Forms.Application.Exit%2A>或<xref:System.Windows.Forms.Application.ExitThread%2A>称为或<xref:System.Windows.Forms.Application.ThreadExit>上下文对象上引发事件。  
  
   
  
## Examples  
 此示例显示两个窗体，并退出应用程序，这两个窗体关闭时。 当应用程序启动并退出时，会记住每个窗体的位置。 此示例演示如何使用<xref:System.Windows.Forms.ApplicationContext>，连同`Application.Run(context)`方法，在应用程序启动时显示多个窗体。  
  
 该类`MyApplicationContext`继承<xref:System.Windows.Forms.ApplicationContext>时每个窗体处于关闭状态，并在它们都时退出当前线程保持跟踪。 类用于存储用户的每个窗体的位置。 窗体位置数据存储在名为的文件`Appdata.txt`由在位置创建<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法调用`Application.Run(context)`以启动应用程序提供<xref:System.Windows.Forms.ApplicationContext>。  
  
 代码`AppForm1`和`AppForm2`起见不显示窗体。 请参阅<xref:System.Windows.Forms.ApplicationContext>类概述有关整个代码列表。  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">主消息循环已在此线程上运行。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">一个 <see cref="T:System.Windows.Forms.Form" />，它代表要使之可见的窗体。</param>
        <summary>在当前线程上开始运行标准应用程序消息循环，并使指定窗体可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，应用程序的 main 函数调用此方法，并将传递给它的应用程序的主窗口。  
  
 此方法将添加到事件处理程序`mainForm`参数<xref:System.Windows.Forms.Form.Closed>事件。 事件处理程序调用<xref:System.Windows.Forms.Application.ExitThread%2A>清理应用程序。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Dispose%2A>方法的<xref:System.Windows.Forms.Form>类将在此方法返回之前调用。  
  
   
  
## Examples  
 下面的代码示例列出了在窗体上的列表框中的数字。 每次单击`button1`，应用程序向列表添加另一个数。  
  
 `Main`方法调用<xref:System.Windows.Forms.Application.Run%2A>以启动应用程序，创建表单时， `listBox1`，和`button1`。 当用户单击`button1`，则`button1_Click`方法将添加到列表框中，一到三个数字并显示<xref:System.Windows.Forms.MessageBox>。 如果用户单击**否**上<xref:System.Windows.Forms.MessageBox>，则`button1_Click`方法向列表添加另一个数。 如果用户单击**是**，应用程序调用<xref:System.Windows.Forms.Application.Exit%2A>来处理队列中的所有剩余消息，然后退出。  
  
 该示例需要`listBox1`和`button1`已创建并已放置在窗体上。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">主消息循环已在当前线程上运行。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当顶级窗口标题与版权警告标志一起显示时，要应用于顶级窗口标题的格式字符串。</summary>
        <value>要应用于顶级窗口标题的格式字符串。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要将此属性设置的所有窗口。 关联的枚举： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">用于新控件的默认值。 如果为 <see langword="true" />，则支持 <c>UseCompatibleTextRendering</c> 的新控件使用基于 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] 的 <see cref="T:System.Drawing.Graphics" /> 类进行文本呈现；如果为 <see langword="false" />，则新控件使用基于 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 的 <see cref="T:System.Windows.Forms.TextRenderer" /> 类。</param>
        <summary>将某些控件上定义的 <c>UseCompatibleTextRendering</c> 属性设置为应用程序范围内的默认值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些 Windows 窗体控件可以呈现使用其文本<xref:System.Windows.Forms.TextRenderer>类，该类基于[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]图形库，或<xref:System.Drawing.Graphics>类，该类基于[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]图形库。 此更改为了[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]由于性能和本地化问题而[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]。 使用<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>若要设置的默认值`UseCompatibleTextRendering`支持它的控件的属性。  
  
 `UseCompatibleTextRendering`属性用于提供 visual 兼容性 Windows 窗体控件之间呈现文本使用<xref:System.Windows.Forms.TextRenderer>类和[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]和[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]的应用程序执行自定义文本呈现使用<xref:System.Drawing.Graphics>类。 在大多数情况下，如果不从升级您的应用程序[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]或[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]，则建议您保留`UseCompatibleTextRendering`设置的默认值为`false`。  
  
 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]基于<xref:System.Windows.Forms.TextRenderer>类中引入了[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]为了提高性能，使文本看起来不错，并提高对国际字体支持。 在早期版本的[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]，则[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]基于<xref:System.Drawing.Graphics>类用于执行所有文本呈现。 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 计算字符间距和自动换行中的不同[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]。 使用 Windows 窗体应用程序中<xref:System.Drawing.Graphics>类来呈现文本，这可能会导致使用的控件的文本<xref:System.Windows.Forms.TextRenderer>才会显示不同的应用程序中的其他文本。 若要解决此不兼容性，可以设置`UseCompatibleTextRendering`属性设置为`true`。 若要设置`UseCompatibleTextRendering`到`true`应用程序中的所有受支持控件，调用<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>方法的参数替换`true`。  
  
 如果在另一个应用程序，如 Internet Explorer 中承载 Windows 窗体代码，应永远不会调用此方法。 仅在独立的 Windows 窗体应用程序中调用此方法。  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  若要设置的默认值为`UseCompatibleTextRendering`中[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]或更高版本，请参阅<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>。  
  
 在中[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]或更高版本，调用<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>在 Program.cs 文件中自动生成。 若要更改文本呈现默认值，修改生成的代码。  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">您只能在 Windows 窗体应用程序创建第一个窗口之前调用此方法。</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" />
        <Parameter Name="force" Type="System.Boolean" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="state">指示要转换到的目标电源活动模式的 <see cref="T:System.Windows.Forms.PowerState" />。</param>
        <param name="force">若要立即强制挂起模式，则为 <see langword="true" />；若要使 Windows 向每个应用程序发送挂起请求，则为 <see langword="false" />。</param>
        <param name="disableWakeEvent">值为 <see langword="true" /> 时可在发生唤醒事件时禁止将系统的电源状态恢复为活动状态；值为 <see langword="false" /> 时可在发生唤醒事件时允许将系统的电源状态恢复为活动状态。</param>
        <summary>挂起系统或使系统休眠，或者请求系统挂起或休眠。</summary>
        <returns>如果正在挂起该系统，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果应用程序不会在 20 秒内未响应的挂起请求，Windows 将确定它处于无响应状态，并且，应用程序可以置于休眠状态或终止。 一旦应用程序响应的挂起请求，但是，可能需要的任意时间它需要清理资源，并关闭活动进程。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示应用程序如何响应未经处理的异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设置 Windows 窗体线程和其他线程上发生的异常发生的异常的事件处理程序。 它会设置<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，以便所有异常都处理应用程序，而不考虑应用程序的用户配置文件中的设置。 它使用<xref:System.Windows.Forms.Application.ThreadException>事件来处理 UI 线程异常和<xref:System.AppDomain.UnhandledException>事件来处理非 UI 线程异常。 由于<xref:System.AppDomain.UnhandledException>不能阻止的应用程序终止，该示例只记录错误终止之前在应用程序事件日志中。  
  
 此示例假定您已经定义了两个<xref:System.Windows.Forms.Button>控件，`button1`并`button2`，然后在你<xref:System.Windows.Forms.Form>类。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
      </Parameters>
      <Docs>
        <param name="mode">一个 <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 值，描述在引发未捕获的异常时应用程序的行为方式。</param>
        <summary>指示应用程序如何响应未经处理的异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它通常不是可行捕捉所有由 Windows 窗体引发的异常。 使用此方法，可以指示你的应用程序是否应捕获引发的 Windows 窗体组件的所有未处理的异常并继续操作，或它是否应将它们公开给用户并暂停执行。  
  
 调用<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>实例化应用程序使用的主窗体之前<xref:System.Windows.Forms.Application.Run%2A>方法。  
  
 捕获在不创建的线程中发生的异常并拥有的 Windows 窗体使用<xref:System.AppDomain.UnhandledException>事件处理程序。  
  
   
  
## Examples  
 下面的代码示例设置 Windows 窗体线程和其他线程上发生的异常发生的异常的事件处理程序。 它会设置<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，以便所有异常都处理应用程序，而不考虑应用程序的用户配置文件中的设置。 它使用<xref:System.Windows.Forms.Application.ThreadException>事件来处理 UI 线程异常和<xref:System.AppDomain.UnhandledException>事件来处理非 UI 线程异常。 由于<xref:System.AppDomain.UnhandledException>不能阻止的应用程序终止，该示例只记录错误终止之前在应用程序事件日志中。  
  
 此示例假定您已经定义了两个<xref:System.Windows.Forms.Button>控件，`button1`并`button2`，然后在你<xref:System.Windows.Forms.Form>类。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在应用程序创建其第一个窗口后，您将无法设置异常模式。</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
        <Parameter Name="threadScope" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mode">一个 <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 值，描述在引发未捕获的异常时应用程序的行为方式。</param>
        <param name="threadScope">如果设置线程异常模式，为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>指示应用程序如何响应未经处理的异常，同时可选择应用特定于线程的行为。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 它通常不是可行捕捉所有由 Windows 窗体引发的异常。 使用此方法，可以指示你的应用程序是否应捕获引发的 Windows 窗体组件的所有未处理的异常并继续操作，或它是否应将它们公开给用户并暂停执行。  
  
 调用<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>实例化应用程序使用的主窗体之前<xref:System.Windows.Forms.Application.Run%2A>方法。  
  
 当`threadScope`是`true`，设置线程异常模式。 如果线程异常模式的应用程序异常模式重写`mode`未设置为<xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>。  
  
 当`threadScope`是`false`，设置应用程序异常模式。 应用程序异常模式用于具有的所有线程<xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>模式。 设置应用程序异常模式不会影响当前线程的设置。  
  
 捕获在不创建的线程中发生的异常并拥有的 Windows 窗体使用<xref:System.AppDomain.UnhandledException>事件处理程序。  
  
   
  
## Examples  
 下面的代码示例设置 Windows 窗体线程和其他线程上发生的异常发生的异常的事件处理程序。 它会设置<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，以便所有异常都处理应用程序，而不考虑应用程序的用户配置文件中的设置。 它使用<xref:System.Windows.Forms.Application.ThreadException>事件来处理 UI 线程异常和<xref:System.AppDomain.UnhandledException>事件来处理非 UI 线程异常。 由于<xref:System.AppDomain.UnhandledException>不能阻止的应用程序终止，该示例只记录错误终止之前在应用程序事件日志中。  
  
 此示例假定您已经定义了两个<xref:System.Windows.Forms.Button>控件，`button1`并`button2`，然后在你<xref:System.Windows.Forms.Form>类。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在应用程序创建其第一个窗口后，您将无法设置异常模式。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取启动了应用程序的可执行文件的路径，不包括可执行文件的名称。</summary>
        <value>启动了应用程序的可执行文件的路径。  
  
取决于是否使用 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 部署 Windows 窗体应用程序，此路径将会不同。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 应用程序存储在每个用户应用程序缓存中 C:\Documents and Settings\\*用户名*目录。 有关详细信息，请参阅[访问本地数据和 ClickOnce 应用程序中的远程数据](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例获取此属性，并在文本框中显示其值。 该示例需要`textBox1`已放在窗体上。  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于获取路径。 关联的枚举： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在发生未捕获线程异常时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件，在 Windows 窗体应用程序与 Windows 窗体线程中发生的句柄否则为未经处理的异常。 附加到事件处理程序<xref:System.Windows.Forms.Application.ThreadException>事件来处理这些异常，这会将你的应用程序处于未知状态。 如有可能，应通过结构化异常处理块处理异常。  
  
 您可以更改是否通过设置情况下，使用 Windows 窗体线程的未处理异常的此回叫<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>。 捕获在不创建的线程中发生的异常并拥有的 Windows 窗体使用<xref:System.AppDomain.UnhandledException>事件处理程序。  
  
> [!NOTE]
>  若要确保此事件没有激活会丢失，必须附加一个处理程序，然后再调用<xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>。  
  
> [!CAUTION]
>  由于这是一个静态事件，必须释放你的应用程序，或会导致内存泄漏时分离事件处理程序。  
  
   
  
## Examples  
 下面的代码示例设置 Windows 窗体线程和其他线程上发生的异常发生的异常的事件处理程序。 它会设置<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>，以便所有异常都处理应用程序，而不考虑应用程序的用户配置文件中的设置。 它使用<xref:System.Windows.Forms.Application.ThreadException>事件来处理 UI 线程异常和<xref:System.AppDomain.UnhandledException>事件来处理非 UI 线程异常。 由于<xref:System.AppDomain.UnhandledException>不能阻止的应用程序终止，该示例只记录错误终止之前在应用程序事件日志中。  
  
 此示例假定您已经定义了两个<xref:System.Windows.Forms.Button>控件，`button1`并`button2`，然后在你<xref:System.Windows.Forms.Form>类。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">有关将一个处理程序添加到此事件时调用非托管的代码直接调用方。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在某线程即将关闭时发生。 当应用程序的主线程即将关闭时，首先引发该事件，随后是 <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须将附加到的事件处理程序<xref:System.Windows.Forms.Application.ThreadExit>事件执行任何未经处理的、 所需任务的线程停止运行前。 关闭打开的此线程或释放的垃圾回收器未回收的对象文件。  
  
> [!CAUTION]
>  由于这是一个静态事件，必须释放你的应用程序，或会导致内存泄漏时分离事件处理程序。  
  
   
  
## Examples  
 下面的代码示例演示如何将此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.Application.ThreadExit>事件。 此报告可帮助您了解事件发生的并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑更换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或将消息附加到多行<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，将其粘贴到 Windows 窗体，并确保事件处理程序相关联<xref:System.Windows.Forms.Application.ThreadExit>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>注销使用 <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" /> 发出的消息循环回调。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用户的应用程序数据的路径。</summary>
        <value>用户的应用程序数据的路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果路径不存在，被创建一个采用以下格式：  
  
 *基路径*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 此路径中存储的数据是启用漫游用户配置文件的一部分。 漫游用户在网络中的多台计算机上工作。 漫游用户的用户配置文件在网络上的服务器上，并在用户登录时加载到系统上。 为用户配置文件以作为漫游，操作系统必须支持漫游配置文件并且必须启用它。  
  
 典型的基路径是 C:\Documents and Settings\\*用户名*\Application Data。 此路径将会不同，但是，如果通过使用部署 Windows 窗体应用程序[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 创建其自己的应用程序数据目录的独立于所有其他应用程序。 有关详细信息，请参阅[访问本地数据和 ClickOnce 应用程序中的远程数据](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
   
  
## Examples  
 下面的代码示例显示两个窗体，并退出应用程序，这两个窗体关闭时。 当应用程序启动并退出时，会记住每个窗体的位置。 此示例演示如何使用<xref:System.Windows.Forms.Application.UserAppDataPath%2A>属性来存储用户的应用程序数据。  
  
 该类`MyApplicationContext`继承<xref:System.Windows.Forms.ApplicationContext>时每个窗体处于关闭状态，并在它们都时退出当前线程保持跟踪。 类用于存储用户的每个窗体的位置。 窗体位置数据存储在名为的文件`Appdata.txt`由在位置创建<xref:System.Windows.Forms.Application.UserAppDataPath%2A>。 `Main`方法调用`Application.Run(context)`以启动应用程序提供<xref:System.Windows.Forms.ApplicationContext>。  
  
 此代码是一段摘录所示示例<xref:System.Windows.Forms.ApplicationContext>类概述。 为了简洁起见，不显示一些代码。 请参阅<xref:System.Windows.Forms.ApplicationContext>有关整个代码列表。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用户的应用程序数据的注册表项。</summary>
        <value>一个 <see cref="T:Microsoft.Win32.RegistryKey" />，它表示特定于用户的应用程序数据的注册表项。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果键不存在，它被创建采用以下格式：  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 数据存储在此项是启用漫游用户配置文件的一部分。 漫游用户在网络中的多台计算机上工作。 漫游用户的用户配置文件在网络上的服务器上，并在用户登录时加载到系统上。 为用户配置文件以作为漫游，操作系统必须支持漫游配置文件并且必须启用它。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置是否对应用程序的所有打开窗体使用等待光标。</summary>
        <value>如果等待光标用于所有打开的窗体，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当此属性设置为`true`，则<xref:System.Windows.Forms.Control.UseWaitCursor%2A>应用程序中的所有打开窗体的属性将设置为`true`。 在所有窗体上设置此属性之前，不会返回此调用。 有一个长时间运行的操作，并且想要在所有应用程序窗体中指示该操作仍在处理时，请使用此属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指定可视样式如何应用于应用程序窗口的值。</summary>
        <value>
          <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> 值的按位组合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这<xref:System.Windows.Forms.Application.VisualStyleState%2A>属性确定是否在客户端区域或应用程序窗口非工作区中启用了可视样式。 通常情况下，应在主窗体的构造函数内设置此属性或<xref:System.Windows.Forms.Form.Load>事件处理程序。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Windows.Forms.Application.VisualStyleState%2A>属性设置为之一<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>值内<xref:System.Windows.Forms.Control.Click>事件处理程序<xref:System.Windows.Forms.Button>控件。 此代码示例是为提供一个更大示例的一部分<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>枚举。  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>