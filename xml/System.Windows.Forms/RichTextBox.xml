<Type Name="RichTextBox" FullName="System.Windows.Forms.RichTextBox">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f6bc4582e825296fa306e1a8f5b9ad0a64930707" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36516152" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RichTextBox : System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RichTextBox extends System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.RichTextBox" />
  <TypeSignature Language="VB.NET" Value="Public Class RichTextBox&#xA;Inherits TextBoxBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class RichTextBox : System::Windows::Forms::TextBoxBase" />
  <TypeSignature Language="F#" Value="type RichTextBox = class&#xA;    inherit TextBoxBase" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.RichTextBoxDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Forms.Docking(System.Windows.Forms.DockingBehavior.Ask)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示 Windows 多格式文本框控件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与<xref:System.Windows.Forms.RichTextBox>控件，用户可以输入和编辑文本。 该控件还提供更高级的格式设置功能比标准<xref:System.Windows.Forms.TextBox>控件。 文本可以直接分配给该控件，也可以加载从丰富文本格式 (RTF) 或纯文本文件。 字符和段落格式设置，可以分配控件中的文本。  
  
 <xref:System.Windows.Forms.RichTextBox>控件提供大量可以使用控件中的文本的任何部分应用格式设置的属性。 若要更改的文本格式，它必须首先选择。 字符和段落格式设置，可以分配仅选定的文本。 一旦对文本的选定部分进行了设置，选择输入所选内容也格式化具有相同设置，直到设置更改后的所有文本或控件的文档的其他部分。 <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>属性使您能够将粗体或斜体的文本。 你还可以使用此属性更改的大小和文本的字样。 <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A>属性使您能够更改的文本颜色。 若要创建项目符号列表，可以使用<xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A>属性。 你还可以调整段落格式设置通过设置<xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A>， <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A>，和<xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A>属性。  
  
 <xref:System.Windows.Forms.RichTextBox>控件提供提供打开和保存文件的功能的方法。 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法使你能够加载到控件中的现有 RTF 或 ASCII 文本文件。 你也可以从已打开的数据流中加载数据。 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A>使您能够将文件保存到 RTF 或 ASCII 文本。 类似于<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法，你还可以使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法将保存到打开的数据流。 <xref:System.Windows.Forms.RichTextBox>控件还提供了功能，用于查找的文本字符串。 <xref:System.Windows.Forms.RichTextBox.Find%2A>方法是重载若要查找的文本这两个字符串以及为特定字符文本中的控件。  
  
 也可以初始化<xref:System.Windows.Forms.RichTextBox>存储在内存中数据的控件。 例如，你可以初始化<xref:System.Windows.Forms.RichTextBox.Rtf%2A>属性包含的文本显示，包括确定应如何格式化文本的格式为 RTF 代码的字符串。  
  
 如果控件中的文本包含链接，例如链接到网站，你可以使用<xref:System.Windows.Forms.RichTextBox.DetectUrls%2A>适当地显示链接控件的文本中的属性。 然后可处理<xref:System.Windows.Forms.RichTextBox.LinkClicked>事件以执行与链接相关联的任务。 <xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A>属性使您能够从用户的操作保护控件中的文本。 与受保护的文本控件中，你可以处理<xref:System.Windows.Forms.RichTextBox.Protected>事件，以确定当用户已尝试修改受保护的文本，并提醒用户的文本受保护或用户提供一种标准的方式来操作受保护的文本。  
  
 已使用的应用程序<xref:System.Windows.Forms.TextBox>控件可以轻松地进行适配以便利用<xref:System.Windows.Forms.RichTextBox>控件。 但是，<xref:System.Windows.Forms.RichTextBox>控件不具有相同的 64k 字符容量限制的<xref:System.Windows.Forms.TextBox>控件。 <xref:System.Windows.Forms.RichTextBox>通常用于文本操作，并显示类似于 Microsoft Word 等文字处理应用程序的功能。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.TextBoxBase.Undo%2A?displayProperty=nameWithType>方法并不适用于<xref:System.Windows.Forms.Control.KeyPress>或<xref:System.Windows.Forms.Control.TextChanged>事件。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Windows.Forms.RichTextBox>将 RTF 文件加载到控件和"Text。 该单词的第一个实例的搜索控件 然后，代码更改字体样式、 字体大小和所选文本的字体颜色，并将所做的更改保存回原始文件。 示例代码可以通过添加到控件来完成其<xref:System.Windows.Forms.Form>。 此示例需要创建的代码示例中的方法添加到<xref:System.Windows.Forms.Form>类，并从窗体的构造函数。 该示例还需要创建一个 RTF 文件，包含单词"文本。"的 C 驱动器的根目录中  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.TextBoxBase" />
    <altmember cref="T:System.Windows.Forms.TextBox" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Forms.RichTextBox" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，<xref:System.Windows.Forms.TextBoxBase.Multiline%2A>的控件属性设置为`true`。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Windows.Forms.RichTextBox>将 RTF 文件加载到控件和"Text。 该单词的第一个实例的搜索控件 然后，代码更改字体样式、 字体大小和所选文本的字体颜色，并将所做的更改保存回原始文件。 示例代码可以通过添加到控件来完成其<xref:System.Windows.Forms.Form>。 此示例需要创建的代码示例中的方法添加到<xref:System.Windows.Forms.Form>类，并从窗体的构造函数。 该示例还需要创建一个 RTF 文件，包含单词"文本。"的 C 驱动器的根目录中  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public override bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示控件是否允许拖放操作。</summary>
        <value>如果控件中允许拖放操作，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何执行拖放操作使用<xref:System.Windows.Forms.ListBox>包含用于放到项的控件<xref:System.Windows.Forms.RichTextBox>控件。 表单集的构造函数<xref:System.Windows.Forms.RichTextBox.AllowDrop%2A>属性`true`启用拖放操作中发生<xref:System.Windows.Forms.RichTextBox>。 该示例使用<xref:System.Windows.Forms.Control.MouseDown>事件<xref:System.Windows.Forms.ListBox>启动拖动操作，通过调用<xref:System.Windows.Forms.Control.DoDragDrop%2A>方法。 该示例使用<xref:System.Windows.Forms.Control.DragEnter>事件来确定是否项拖放到<xref:System.Windows.Forms.RichTextBox>是有效的数据类型。 <xref:System.Windows.Forms.Control.DragDrop>事件执行拖动的项到实际删除<xref:System.Windows.Forms.RichTextBox>内当前光标位置处的控件<xref:System.Windows.Forms.RichTextBox>。 此示例需要<xref:System.Windows.Forms.Control.DragDrop>和<xref:System.Windows.Forms.Control.DragEnter>事件已连接到示例中定义的事件处理程序。  
  
 [!code-cpp[RichTextBox.AllowDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.AllowDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CS/form1.cs#1)]
 [!code-vb[RichTextBox.AllowDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.AllowDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此属性与此类无关。</summary>
        <value>如果已启用，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   此属性与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoWordSelection">
      <MemberSignature Language="C#" Value="public bool AutoWordSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoWordSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoWordSelection" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoWordSelection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoWordSelection { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoWordSelection : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AutoWordSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示是否启用自动选择字词。</summary>
        <value>如果启用自动选择字词，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性设置为`true`，控件中选择任何一部分文本选择整个单词。  
  
   
  
## Examples  
 下面的代码示例演示如何创建<xref:System.Windows.Forms.RichTextBox>，文本将放大，自动选择控件的文本中单词的单词正在双击，并且控件的客户端区域右侧边距时。 如果<xref:System.Windows.Forms.RichTextBox>控件具有较小的宽度，使用此代码将创建<xref:System.Windows.Forms.RichTextBox>其中每个字符的文本将显示在其对应行。 在此垂直显示位置上，单击某个词的任何部分将选择而不考虑垂直显示的文本的单词的所有字符。 此示例要求你拥有一个包含窗体<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`。  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.RichTextBox.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此属性与此类无关。</summary>
        <value>在控件中显示的背景图像。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.RichTextBox.BackgroundImage" /> 属性的值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.RichTextBox.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此属性与此类无关。</summary>
        <value>在控件中显示的背景图像的布局。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" /> 属性的值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BulletIndent">
      <MemberSignature Language="C#" Value="public int BulletIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BulletIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property BulletIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BulletIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BulletIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.BulletIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置对文本应用项目符号样式时，<see cref="T:System.Windows.Forms.RichTextBox" /> 控件中使用的缩进。</summary>
        <value>作为缩进在项目符号后插入的像素数。 默认值为零。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要将项目符号样式应用于一段文本，将设置<xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A>属性`true`然后设置<xref:System.Windows.Forms.RichTextBox.BulletIndent%2A>属性应缩进文本的像素数。 段落将具有应用于它与指定的符号后面的缩进量的项目符号样式。 此属性仅影响控件的文本和当前所选项目符号列表中的项目符号中的当前段落。 若要将不同的缩进级别应用于整个项目符号列表项的列表中，所有项目符号列表项的文本之前，必须选择设置<xref:System.Windows.Forms.RichTextBox.BulletIndent%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A>具有属性<xref:System.Windows.Forms.RichTextBox.BulletIndent%2A>， <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>， <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>，和<xref:System.Windows.Forms.RichTextBox.SelectionColor%2A>属性以创建中的项目符号列表<xref:System.Windows.Forms.RichTextBox>控件。 此示例需要<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`在窗体上创建。  
  
 [!code-cpp[RichTextBox.BulletIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.BulletIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.BulletIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.BulletIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定的缩进小于零。</exception>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      </Docs>
    </Member>
    <Member MemberName="CanPaste">
      <MemberSignature Language="C#" Value="public bool CanPaste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanPaste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanPaste (clipFormat As DataFormats.Format) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanPaste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberSignature Language="F#" Value="member this.CanPaste : System.Windows.Forms.DataFormats.Format -&gt; bool" Usage="richTextBox.CanPaste clipFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat">
          <see cref="T:System.Windows.Forms.DataFormats.Format" /> 值之一。</param>
        <summary>确定是否可以粘贴指定数据格式的剪贴板信息。</summary>
        <returns>如果可以粘贴指定数据格式的剪贴板数据，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用此方法确定是否剪贴板的当前内容中指定的剪贴板数据格式在启用使用者粘贴到的信息之前<xref:System.Windows.Forms.RichTextBox>控件。 例如，可以创建的事件处理程序<xref:System.Windows.Forms.MenuItem.Popup>粘贴命令事件<xref:System.Windows.Forms.MenuItem>并使用此方法来确定是否粘贴<xref:System.Windows.Forms.MenuItem>基于剪贴板中的数据类型，应启用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.RichTextBox.Paste%2A>方法以粘贴到位图<xref:System.Windows.Forms.RichTextBox>控件。 在从文件中打开一个位图之后, 该示例使用<xref:System.Windows.Forms.Clipboard.SetDataObject%2A>方法以将位图复制到 Windows 剪贴板。 最后，该示例将检索的格式<xref:System.Drawing.Bitmap>对象，使用<xref:System.Windows.Forms.RichTextBox.CanPaste%2A>方法以验证格式可以粘贴到<xref:System.Windows.Forms.RichTextBox>控件，然后使用<xref:System.Windows.Forms.RichTextBox.Paste%2A>粘贴数据的方法。  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="CanRedo">
      <MemberSignature Language="C#" Value="public bool CanRedo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRedo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CanRedo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRedo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRedo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRedo : bool" Usage="System.Windows.Forms.RichTextBox.CanRedo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示在 <see cref="T:System.Windows.Forms.RichTextBox" /> 内发生的操作中是否有可以重新应用的操作。</summary>
        <value>如果有已撤消的操作可以重新应用到控件内容，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用此属性以确定是否在中撤消的上一个操作<xref:System.Windows.Forms.RichTextBox>可以使用重新应用<xref:System.Windows.Forms.RichTextBox.Redo%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.RichTextBox.CanRedo%2A>和<xref:System.Windows.Forms.RichTextBox.RedoActionName%2A>属性，与<xref:System.Windows.Forms.RichTextBox.Redo%2A>方法，以限制对除删除文本的任何操作的重做操作。 此示例要求你拥有一个包含窗体<xref:System.Windows.Forms.RichTextBox>控制的和中的某个操作<xref:System.Windows.Forms.RichTextBox>已经执行并通过撤消在此示例中的代码调用之前。  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="ContentsResized">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ContentsResizedEventHandler ContentsResized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ContentsResizedEventHandler ContentsResized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentsResized As ContentsResizedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ContentsResizedEventHandler ^ ContentsResized;" />
      <MemberSignature Language="F#" Value="member this.ContentsResized : System.Windows.Forms.ContentsResizedEventHandler " Usage="member this.ContentsResized : System.Windows.Forms.ContentsResizedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContentsResizedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当调整控件内容的大小时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.RichTextBox.ContentsResized>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.RichTextBox>名为`RichTextBox1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.RichTextBox.ContentsResized>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#537](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#537)]
 [!code-vb[System.Windows.Forms.EventExamples#537](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#537)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContentsResizedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.RichTextBox.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取创建控件句柄时所需要的创建参数。</summary>
        <value>
          <see cref="T:System.Windows.Forms.CreateParams" />，包含创建控件的句柄时所需的创建参数。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRichEditOleCallback">
      <MemberSignature Language="C#" Value="protected virtual object CreateRichEditOleCallback ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object CreateRichEditOleCallback() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CreateRichEditOleCallback" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateRichEditOleCallback () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ CreateRichEditOleCallback();" />
      <MemberSignature Language="F#" Value="abstract member CreateRichEditOleCallback : unit -&gt; obj&#xA;override this.CreateRichEditOleCallback : unit -&gt; obj" Usage="richTextBox.CreateRichEditOleCallback " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建用于处理 Rich Edit 回调操作的 <see langword="IRichEditOleCallback" /> 兼容对象。</summary>
        <returns>一个实现 <see langword="IRichEditOleCallback" /> 接口的对象。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直接调用方调用非托管的代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>你可以在允许访问基础 rich 编辑功能在派生类中重写此方法。如果你重写此方法，将不会引发所有拖放事件。因此，你将需要提供您自己的支持拖放操作。有关详细信息<see langword="IRichEditOleCallback" />接口，请参阅平台 SDK 文档： http://msdn.microsoft.com。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.RichTextBox.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取控件的默认大小。</summary>
        <value>一个 <see cref="T:System.Drawing.Size" /> 值。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DetectUrls">
      <MemberSignature Language="C#" Value="public bool DetectUrls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DetectUrls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      <MemberSignature Language="VB.NET" Value="Public Property DetectUrls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DetectUrls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DetectUrls : bool with get, set" Usage="System.Windows.Forms.RichTextBox.DetectUrls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示当在控件中键入某个统一资源定位器 (URL) 时，<see cref="T:System.Windows.Forms.RichTextBox" /> 是否自动设置 URL 的格式。</summary>
        <value>如果 <see cref="T:System.Windows.Forms.RichTextBox" /> 将键入到控件中的 URL 自动设置为链接格式，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性设置为`true`，文本框由控件中输入任何文本<xref:System.Windows.Forms.RichTextBox>要 URL 自动设置为链接的格式。 你可以创建的事件处理程序<xref:System.Windows.Forms.RichTextBox.LinkClicked>事件来处理所有链接在单击控件中。 <xref:System.Windows.Forms.LinkClickedEventArgs>到事件处理程序提供<xref:System.Windows.Forms.RichTextBox.LinkClicked>事件提供数据，可用于确定要处理的链接控件中被单击的链接。  
  
   
  
## Examples  
 下面的代码示例包含的事件处理程序<xref:System.Windows.Forms.RichTextBox.LinkClicked>事件。 事件处理程序处理的文档中的链接单击<xref:System.Windows.Forms.RichTextBox>控制，并启动默认浏览器的实例 (使用<xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType>方法)，显示被单击的链接的页。 此示例需要事件处理程序已连接到<xref:System.Windows.Forms.RichTextBox.LinkClicked>事件<xref:System.Windows.Forms.RichTextBox>。  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
        <altmember cref="T:System.Windows.Forms.LinkClickedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberSignature Language="F#" Value="member this.DragDrop : System.Windows.Forms.DragEventHandler " Usage="member this.DragDrop : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在用户完成拖放时发生</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.Forms.DragEventHandler " Usage="member this.DragEnter : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在将对象拖入控件的边界时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.RichTextBox.DragEnter>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.RichTextBox>名为`RichTextBox1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.RichTextBox.DragEnter>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#539](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#539)]
 [!code-vb[System.Windows.Forms.EventExamples#539](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#539)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : EventHandler " Usage="member this.DragLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将对象拖出控件的边界时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件与此类无关。 有关处理事件的详细信息，请参阅[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.DragEventHandler " Usage="member this.DragOver : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在将对象拖到控件的边界上发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件与此类无关。 有关处理事件的详细信息，请参阅[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberSignature Language="F#" Value="override this.DrawToBitmap : System.Drawing.Bitmap * System.Drawing.Rectangle -&gt; unit" Usage="richTextBox.DrawToBitmap (bitmap, targetBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="bitmap">
          <see cref="T:System.Drawing.Bitmap" />。</param>
        <param name="targetBounds">
          <see cref="T:System.Drawing.Rectangle" />。</param>
        <summary>此方法与此类无关。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableAutoDragDrop">
      <MemberSignature Language="C#" Value="public bool EnableAutoDragDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableAutoDragDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.EnableAutoDragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableAutoDragDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableAutoDragDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableAutoDragDrop : bool with get, set" Usage="System.Windows.Forms.RichTextBox.EnableAutoDragDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值在文本、图片和其他数据上启用拖放操作。</summary>
        <value>如果启用拖放操作，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Find">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 <see cref="T:System.Windows.Forms.RichTextBox" /> 的内容内搜索文本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] -&gt; int" Usage="richTextBox.Find characterSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="characterSet">要搜索的字符数组。</param>
        <summary>在 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件的文本中搜索字符列表中某个字符的第一个实例。</summary>
        <returns>在控件中找到搜索字符的位置；如果未找到搜索字符或者在 <paramref name="char" /> 参数中指定了空搜索字符集，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法搜索中指定的字符的列表中的一个字符的第一个实例`characterSet`参数并返回字符的位置。 例如，你将传递字符，其中包含的字符 Q 的数组。 如果控件包含文本"快速 Brown Fox"，<xref:System.Windows.Forms.RichTextBox.Find%2A>方法将返回四个值。 大写字符和小写字符被视为在搜索中的不同值。  
  
 如果属性返回一个负值，该控件的内容中未找到要搜索的字符。 此方法可用于搜索的一组控件内的字符。 此版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法要求在控件中包含的整个文档会搜索的字符。 如果从提供的方法中的字符列表的字符`characterSet`找到的参数，此方法返回的值是在控件中的字符的位置的从零开始索引。 空间时应考虑字符由方法确定一个字符的位置。  
  
   
  
## Examples  
 下面的代码示例的内容中搜索<xref:System.Windows.Forms.RichTextBox>传递给方法中的字符有关`text`参数。 如果内容`text`数组位于<xref:System.Windows.Forms.RichTextBox>，该方法返回找到; 否则为值的索引，则返回-1。 该示例需要此方法所在的类中<xref:System.Windows.Forms.Form>包含<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`和<xref:System.Windows.Forms.Button>控件，名为`button1`，即连接到`Click`中定义的事件处理程序该示例。  
  
 [!code-cpp[RichTextBox.FindChar1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar1/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar1/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar1/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str);" />
      <MemberSignature Language="F#" Value="member this.Find : string -&gt; int" Usage="richTextBox.Find str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">要在控件中定位的文本。</param>
        <summary>在 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件的文本中搜索字符串。</summary>
        <returns>在控件中找到搜索文本的位置；如果未找到搜索字符串或者在 <paramref name="str" /> 参数中指定了空搜索字符串，则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A>方法搜索中指定的文本`str`参数并返回在控件内的第一个字符的位置。 如果该属性返回一个负值，该控件的内容中未找到要搜索的文本字符串。 此方法可用于创建可以提供给控件的用户的搜索功能。 此方法还可用于搜索文本，以替换为特定的格式。 例如，如果用户文本框控件中输入日期，则无法使用<xref:System.Windows.Forms.RichTextBox.Find%2A>方法来搜索文档中的所有日期和在使用之前将它们替换为适当的格式<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>的控件的方法。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A>方法，其接受`string`如参数找不到多个行中的文本包含的文本<xref:System.Windows.Forms.RichTextBox>。 执行此类的搜索将返回值为负一 (-1)。  
  
   
  
## Examples  
 下面的代码示例的整个内容中搜索<xref:System.Windows.Forms.RichTextBox>搜索字符串的第一个实例传递给方法的文本参数。 如果在中找到的搜索字符串<xref:System.Windows.Forms.RichTextBox>，该方法返回的值`true`并突出显示搜索文本，否则它将返回`false`。 该示例需要此方法所在的类中<xref:System.Windows.Forms.Form>包含<xref:System.Windows.Forms.RichTextBox>名为`richTextBox1`。  
  
 [!code-cpp[Classic RichTextBox.Find Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] * int -&gt; int" Usage="richTextBox.Find (characterSet, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">要搜索的字符数组。</param>
        <param name="start">控件文本中开始搜索的位置。</param>
        <summary>从特定的起始点开始，在 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件的文本中搜索字符列表中某个字符的第一个实例。</summary>
        <returns>控件内找到搜索字符的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法搜索中指定的字符的列表中的一个字符的第一个实例`characterSet`参数和返回的字符的位置。 例如，你将传递字符，其中包含的字符 Q 的数组。 如果控件包含文本"快速 Brown Fox"，<xref:System.Windows.Forms.RichTextBox.Find%2A>方法将返回四个值。 大写字符和小写字符被视为在搜索中的不同值。  
  
 如果属性返回一个负值，该控件的内容中未找到要搜索的字符。 此方法可用于搜索的一组控件内的字符。 如果从提供的方法中的字符列表的字符`characterSet`找到的参数，此方法返回的值是在控件中的字符的位置的从零开始索引。 空间时应考虑字符由方法确定一个字符的位置。  
  
 此版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法，您可以通过指定的值设置从控件文本内指定的开始位置的字符搜索`start`参数。 零值指示应从控件的文档的开头搜索。 你可以使用此版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法以缩小搜索范围以避免你已经知道的文本不包含您要搜索或并不重要在搜索中的指定的字符。  
  
   
  
## Examples  
 下面的代码示例的内容中搜索<xref:System.Windows.Forms.RichTextBox>传递给方法中的字符有关`text`参数。 从内的位置开始执行搜索<xref:System.Windows.Forms.RichTextBox>指定的`start`参数`FindMyText`方法。 如果文本数组的内容位于<xref:System.Windows.Forms.RichTextBox>，该方法返回找到; 否则为值的索引，则返回-1。 该示例需要此方法所在的类中<xref:System.Windows.Forms.Form>包含<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`和<xref:System.Windows.Forms.Button>控件名为`button1`的已连接到<xref:System.Windows.Forms.Control.Click>中定义的事件处理程序示例。  
  
 [!code-cpp[RichTextBox.FindChar2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar2/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar2/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar2/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">要在控件中定位的文本。</param>
        <param name="options">
          <see cref="T:System.Windows.Forms.RichTextBoxFinds" /> 值的按位组合。</param>
        <summary>在对搜索应用特定选项的情况下，在 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件的文本中搜索字符串。</summary>
        <returns>控件内找到搜索文本的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A>方法搜索中指定的文本`str`参数并返回在控件内的第一个字符的位置。 如果该属性返回一个负值，该控件的内容中未找到要搜索的文本字符串。 此方法可用于创建可以提供给控件的用户的搜索功能。 此方法还可用于搜索文本，以替换为特定的格式。 例如，如果用户文本框控件中输入日期，则可以使用<xref:System.Windows.Forms.RichTextBox.Find%2A>方法来搜索文档中的所有日期和在使用之前将它们替换为适当的格式<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>的控件的方法。  
  
 与此版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法，你可以指定选项，使你可以展开或缩小搜索范围。 你可以指定允许你以匹配的大小写的搜索词或完整的字词，而不是部分单词搜索选项。 通过指定`RichTextBoxFinds.Reverse`中的枚举`options`参数，你可以搜索文本从文档底部到顶部，而不是默认顶部到底部搜索方法。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A>方法，其接受`string`如参数找不到多个行中的文本包含的文本<xref:System.Windows.Forms.RichTextBox>。 执行此类的搜索将返回值为负一 (-1)。  
  
   
  
## Examples  
 下面的代码示例的整个内容中搜索<xref:System.Windows.Forms.RichTextBox>搜索字符串的第一个实例传递给方法的文本参数。 如果在中找到的搜索字符串<xref:System.Windows.Forms.RichTextBox>，该方法返回的值`true`并突出显示文本; 否则，它将返回`false`。 该示例还指定在搜索匹配指定的搜索字符串的大小写的选项。 该示例需要此方法所在的类中<xref:System.Windows.Forms.Form>包含<xref:System.Windows.Forms.RichTextBox>名为`richTextBox1`。  
  
 [!code-cpp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start, int end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start, int32 end) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer, end As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start, int end);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] * int * int -&gt; int" Usage="richTextBox.Find (characterSet, start, end)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">要搜索的字符数组。</param>
        <param name="start">控件文本中开始搜索的位置。</param>
        <param name="end">控件文本中结束搜索的位置。</param>
        <summary>在 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件的某个文本范围中搜索字符列表的某个字符的第一个实例。</summary>
        <returns>控件内找到搜索字符的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法搜索中指定的字符的列表中的一个字符的第一个实例`characterSet`参数并返回字符的位置。 例如，你将传递字符，其中包含的字符 Q 的数组。 如果控件包含文本"快速 Brown Fox"，<xref:System.Windows.Forms.RichTextBox.Find%2A>方法将返回四个值。 大写字符和小写字符被视为在搜索中的不同值。  
  
 如果属性返回一个负值，该控件的内容中未找到要搜索的字符。 此方法可用于搜索的一组控件内的字符。 如果从提供的方法中的字符列表的字符`characterSet`参数找不到，此方法返回的值是从零开始的控件中的字符的位置的索引。 空间时应考虑字符由方法确定一个字符的位置。  
  
 此版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法，您可以通过指定的值设置从一个控件中的文本范围的字符搜索`start`和`end`参数。 值为零`start`参数指示搜索应从控件的文档的开头开始。 为-1 值`end`参数指示搜索应在控件中的文本的末尾结束。 你可以使用此版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法为特定范围的控件以避免搜索并不重要的应用程序的需求的文档区域中的文本将搜索范围缩小。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="characterSet" /> 为 null。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="start" /> 小于 0 或者大于控件中文本的长度。</exception>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * int * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, start, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">要在控件中定位的文本。</param>
        <param name="start">控件文本中开始搜索的位置。</param>
        <param name="options">
          <see cref="T:System.Windows.Forms.RichTextBoxFinds" /> 值的按位组合。</param>
        <summary>在对搜索应用特定选项的情况下，在 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件的文本中搜索位于控件内特定位置的字符串。</summary>
        <returns>控件内找到搜索文本的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A>方法搜索中指定的文本`str`参数并返回在控件内的字符串的搜索的第一个字符的位置。 如果该属性返回一个负值，该控件的内容中未找到要搜索的文本字符串。 此方法可用于创建可以提供给控件的用户的搜索功能。 此方法还可用于搜索文本，以替换为特定的格式。 例如，如果用户文本框控件中输入日期，则无法使用<xref:System.Windows.Forms.RichTextBox.Find%2A>方法来搜索文档中的所有日期和在使用之前将它们替换为适当的格式<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>的控件的方法。  
  
 与此版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法，你可以指定选项，使你可以展开或缩小搜索范围。 你可以指定允许你以匹配的大小写的搜索词或完整的字词，而不是部分单词搜索选项。 通过指定`RichTextBoxFinds.Reverse`中的枚举`options`参数，你可以搜索文本从文档底部到顶部，而不是默认顶部到底部搜索方法。 此版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法还使您缩小搜索的文本范围的选择控件的文本内的特定起始位置。 此功能可以启用你可以避免的文本，可能已搜索完或您要搜索的特定文本知道不存在。 当`RichTextBoxFinds.Reverse`中指定值`options`参数、 的值`start`参数指示由于时使用此版本的搜索将从文档底部开始反向搜索将结束位置的位置<xref:System.Windows.Forms.RichTextBox.Find%2A>方法。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A>方法，其接受`string`如参数找不到多个行中的文本包含的文本<xref:System.Windows.Forms.RichTextBox>。 执行此类的搜索将返回值为负一 (-1)。  
  
   
  
## Examples  
 下面的代码示例的整个内容中搜索<xref:System.Windows.Forms.RichTextBox>搜索字符串的第一个实例传递给方法的文本参数。 搜索起始位置由该方法的 start 参数指定。 如果在中找到的搜索字符串<xref:System.Windows.Forms.RichTextBox>，该方法返回找到的文本的第一个字符的索引位置，并突出显示找到的文本; 否则，它将返回值-1。 该示例还指定在搜索匹配指定的搜索字符串的大小写的选项。 该示例需要此方法所在的类中<xref:System.Windows.Forms.Form>包含<xref:System.Windows.Forms.RichTextBox>名为`richTextBox1`。 你可以使用此示例执行"查找下一个"类型的操作。 一旦已找到搜索文本的实例，你可以通过更改的值中查找文本的其他实例`start`参数来搜索超出当前匹配项的位置的位置。  
  
 [!code-cpp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, int end, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, int32 end, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, end As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, int end, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * int * int * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, start, end, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">要在控件中定位的文本。</param>
        <param name="start">控件文本中开始搜索的位置。</param>
        <param name="end">控件文本中结束搜索的位置。 此值必须等于 -1 或者大于或等于 <c>start</c> 参数。</param>
        <param name="options">
          <see cref="T:System.Windows.Forms.RichTextBoxFinds" /> 值的按位组合。</param>
        <summary>在对搜索应用特定选项的情况下，在 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件文本中搜索控件内某个文本范围内的字符串。</summary>
        <returns>控件内找到搜索文本的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A>方法搜索中指定的文本`str`参数并返回在控件内的字符串的搜索的第一个字符的位置。 如果该属性返回一个负值，该控件的内容中未找到要搜索的文本字符串。 此方法可用于创建可以提供给控件的用户的搜索功能。 此方法还可用于搜索文本，以替换为特定的格式。 例如，如果用户文本框控件中输入日期，则可以使用<xref:System.Windows.Forms.RichTextBox.Find%2A>方法来搜索文档中的所有日期和在使用之前将它们替换为适当的格式<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>的控件的方法。  
  
 与此版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法，你可以指定选项，使你可以展开或缩小搜索范围。 你可以指定允许你以匹配的大小写的搜索词或完整的字词，而不是部分单词搜索选项。 通过指定`RichTextBoxFinds.Reverse`中的枚举`options`参数，你可以搜索文本从文档底部到顶部，而不是默认顶部到底部搜索方法。 此版本的<xref:System.Windows.Forms.RichTextBox.Find%2A>方法还可以通过选择控件的文本内的特定开始和结束位置来缩小搜索的文本。 此功能可以启用你限制到特定的控件的文本段的搜索范围。 如果值为负一 (-1) 分配给`end`参数，该方法将搜索中的文本的结束之前一直<xref:System.Windows.Forms.RichTextBox>正常搜索。 对于反向搜索，值为负一 (-1) 分配给`end`参数指示将定义的位置到从文本 （底端） 末尾搜索文本`start`参数。 当`start`和`end`的参数提供相同的值整个控件搜索正常搜索。 对于反向搜索时，搜索整个控件，但搜索文档底部开始，一直搜索到文档顶部。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A>方法，其接受`string`如参数找不到多个行中的文本包含的文本<xref:System.Windows.Forms.RichTextBox>。 执行此类的搜索将返回值为负一 (-1)。  
  
   
  
## Examples  
 下面的代码示例中的文本段中搜索<xref:System.Windows.Forms.RichTextBox>的搜索字符串的第一个实例传递给`searchText`的方法参数。 要搜索为指定控件中的文本范围`searchStart`和`searchEnd`方法参数。 如果在中找到的搜索字符串<xref:System.Windows.Forms.RichTextBox>，该方法返回找到的文本的第一个字符的索引位置，并突出显示找到的文本; 否则，它将返回值-1。 此示例还使用`options`参数<xref:System.Windows.Forms.RichTextBox.Find%2A>方法，以指定找到的文本应匹配的搜索字符串的大小写。 该示例需要此方法所在的类中<xref:System.Windows.Forms.Form>包含<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`。 在第一个之后的搜索字符串的实例已找到，您可以使用此示例在文本中找到其他实例。  
  
 [!code-cpp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindStringStartEnd#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> 参数是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="end" /> 参数小于 <paramref name="start" /> 参数。</exception>
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public override System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Font : System.Drawing.Font with get, set" Usage="System.Windows.Forms.RichTextBox.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置控件显示的文字的字体。</summary>
        <value>要应用于由控件显示的文本的 <see cref="T:System.Drawing.Font" />。 默认为 <see cref="P:System.Windows.Forms.Control.DefaultFont" /> 属性的值。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置控件的前景色。</summary>
        <value>表示控件前景色的 <see cref="T:System.Drawing.Color" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ForeColor" />
      </Docs>
    </Member>
    <Member MemberName="GetCharIndexFromPosition">
      <MemberSignature Language="C#" Value="public override int GetCharIndexFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharIndexFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharIndexFromPosition (pt As Point) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharIndexFromPosition(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="override this.GetCharIndexFromPosition : System.Drawing.Point -&gt; int" Usage="richTextBox.GetCharIndexFromPosition pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">要搜索的位置。</param>
        <summary>检索距离指定位置最近的字符索引。</summary>
        <returns>位于指定位置的从零开始的字符索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回与指定的位置最接近的字符索引`pt`参数。 字符索引是文本的在控件中，包括空格中的从零开始索引。 此方法可用于确定在文本中用户在其上将鼠标放将鼠标坐标传递给此方法。 这很有用，如果你想要在用户将鼠标指针停留在该控件的文本中的单词时执行任务。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition%2A>方法替换<xref:System.Windows.Forms.RichTextBox.Find%2A>方法搜索特定字符串在<xref:System.Windows.Forms.RichTextBox>控件，并显示找到的字符串所在的位置中的字符索引<xref:System.Windows.Forms.RichTextBox>控件。 示例搜索单词"brown"控件的内容中，并返回找到的搜索字符串的字符索引位置。 此示例要求你拥有一个包含窗体<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`包含文本。 它还要求该示例中的代码已连接到<xref:System.Windows.Forms.Control.MouseDown>事件<xref:System.Windows.Forms.RichTextBox>。  
  
 [!code-cpp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CS/form1.cs#1)]
 [!code-vb[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineFromCharIndex">
      <MemberSignature Language="C#" Value="public override int GetLineFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetLineFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetLineFromCharIndex (index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetLineFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="override this.GetLineFromCharIndex : int -&gt; int" Usage="richTextBox.GetLineFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要搜索的字符索引位置。</param>
        <summary>从 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件文本内的指定字符位置检索行号。</summary>
        <returns>字符索引所在的从零开始的行号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于确定基于中指定的字符索引的行号`index`的方法参数。 控件中的文本的第一行返回值零。 <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>方法返回的物理行号的索引的字符所在的位置在控件内。 例如，如果第一个逻辑行中的文本的一部分控件换行到下一行，<xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>方法返回 1，如果指定的字符索引处的字符已经换行到第二个物理行。 如果<xref:System.Windows.Forms.TextBoxBase.WordWrap%2A>设置为`false`、 行的任何部分被换到下一行，并且该方法返回对指定的字符索引为 0。 此方法可用于确定哪一行是位于特定的字符索引。 例如，在调用<xref:System.Windows.Forms.RichTextBox.Find%2A>方法来搜索的文本，你可以获取到找到搜索结果的字符索引。 你可以调用此方法返回的字符索引与<xref:System.Windows.Forms.RichTextBox.Find%2A>找不到方法，以确定其行单词。  
  
 在某些情况下，<xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>不会引发异常时`index`参数是无效值。 例如:  
  
-   如果`index`参数是<xref:System.Int32.MinValue>或-1，<xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>返回 0。  
  
-   如果`index`参数是文本长度或<xref:System.Int32.MaxValue>，<xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>返回的最后一行文本，并不一定相同数作为`Lines.Length-1`，具体的值取决于<xref:System.Windows.Forms.TextBoxBase.WordWrap%2A>属性。  
  
 在这些情况下，验证之前调用的输入<xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>。  
  
> [!NOTE]
>  如果在中指定的字符索引`index`参数为超出可用的控件内包含的行数，则返回最后一个行号。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>方法。 若要运行该示例，请将以下代码粘贴在窗体包含<xref:System.Windows.Forms.RichTextBox>控件名为`RichTextBox1`，名为的按钮`Button1`和名为的两个文本框`TextBox1`和`TextBox2`。 当运行示例时，输入中的搜索字符串`TextBox2`单击该按钮以获取搜索结果。  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromCharIndex">
      <MemberSignature Language="C#" Value="public override System.Drawing.Point GetPositionFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Drawing.Point GetPositionFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPositionFromCharIndex (index As Integer) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Drawing::Point GetPositionFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="override this.GetPositionFromCharIndex : int -&gt; System.Drawing.Point" Usage="richTextBox.GetPositionFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要检索其位置的字符索引。</param>
        <summary>检索控件内指定字符索引处的位置。</summary>
        <returns>指定字符的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可确定在控件中特定的字符索引所在的位置。 此方法可用于任务，如在控件中显示快捷菜单项或帮助信息的单词。 例如，如果你想要向用户显示的菜单选项，当用户右键单击控件中的单词上，你可以使用此方法来确定单词以正确显示的位置<xref:System.Windows.Forms.ContextMenu>控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在执行拖动操作期间发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HScroll">
      <MemberSignature Language="C#" Value="public event EventHandler HScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.HScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HScroll;" />
      <MemberSignature Language="F#" Value="member this.HScroll : EventHandler " Usage="member this.HScroll : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户单击控件的水平滚动条时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.RichTextBox.HScroll>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.RichTextBox>名为`RichTextBox1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.RichTextBox.HScroll>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#540](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#540)]
 [!code-vb[System.Windows.Forms.EventExamples#540](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#540)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeChange">
      <MemberSignature Language="C#" Value="public event EventHandler ImeChange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeChange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ImeChange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeChange As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeChange;" />
      <MemberSignature Language="F#" Value="member this.ImeChange : EventHandler " Usage="member this.ImeChange : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户在中文版的 Windows 操作系统上切换输入方法时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.RichTextBox.ImeChange>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.RichTextBox>名为`RichTextBox1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.RichTextBox.ImeChange>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#542](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#542)]
 [!code-vb[System.Windows.Forms.EventExamples#542](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#542)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageOption">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.LanguageOption" />
      <MemberSignature Language="VB.NET" Value="Public Property LanguageOption As RichTextBoxLanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxLanguageOptions LanguageOption { System::Windows::Forms::RichTextBoxLanguageOptions get(); void set(System::Windows::Forms::RichTextBoxLanguageOptions value); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOption : System.Windows.Forms.RichTextBoxLanguageOptions with get, set" Usage="System.Windows.Forms.RichTextBox.LanguageOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxLanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示输入法编辑器 (IME) 和亚洲语言支持的 <see cref="T:System.Windows.Forms.RichTextBox" /> 设置。</summary>
        <value>
          <see cref="T:System.Windows.Forms.RichTextBoxLanguageOptions" /> 值之一。 默认值为 <see cref="F:System.Windows.Forms.RichTextBoxLanguageOptions.AutoFontSizeAdjust" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkClicked">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LinkClickedEventHandler LinkClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LinkClickedEventHandler LinkClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LinkClicked As LinkClickedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LinkClickedEventHandler ^ LinkClicked;" />
      <MemberSignature Language="F#" Value="member this.LinkClicked : System.Windows.Forms.LinkClickedEventHandler " Usage="member this.LinkClicked : System.Windows.Forms.LinkClickedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LinkClickedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户在控件文本内的链接上单击时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以创建的事件处理程序处理已单击控件内的链接此事件。 使用提供给事件处理程序的信息，你可以确定文档中被单击的链接。  
  
> [!IMPORTANT]
>  默认情况下，显示为文本与不是可单击的链接。 要使它们可单击组<xref:System.Windows.Forms.RichTextBox.DetectUrls%2A>属性`true`。  
  
 有关处理事件的详细信息，请参阅[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下面的代码示例包含的事件处理程序<xref:System.Windows.Forms.RichTextBox.LinkClicked>事件。 事件处理程序处理的文档中的链接单击<xref:System.Windows.Forms.RichTextBox>控制，并启动默认浏览器的实例 (使用<xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType>方法)，显示被单击的链接的页。 此示例需要事件处理程序已连接到<xref:System.Windows.Forms.RichTextBox.LinkClicked>事件<xref:System.Windows.Forms.RichTextBox>。  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将文件的内容加载到 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : string -&gt; unit" Usage="richTextBox.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要加载到控件中的文件的名称和位置。</param>
        <summary>将 RTF 格式文件或标准 ASCII 文本文件加载到 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 加载的文件时<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法，所加载的文件的内容替换的全部内容<xref:System.Windows.Forms.RichTextBox>控件。 这将导致的值<xref:System.Windows.Forms.TextBoxBase.Text%2A>和<xref:System.Windows.Forms.RichTextBox.Rtf%2A>属性来更改。 此方法可用于将以前创建的文本或 RTF 文档加载到操作的控件。 如果你想要保存该文件，则可以使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法。  
  
> [!NOTE]
>  与此版本的<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法，如果正在加载该文件不是一个 RTF 文档中，将发生异常。 若要加载不同类型的文件，如 ASCII 文本文件，请使用此方法接受从值的其他版本<xref:System.Windows.Forms.RichTextBoxStreamType>枚举作为参数。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法将不会打开一个文件，直到为创建句柄<xref:System.Windows.Forms.RichTextBox>。 确保控件的句柄创建，然后再调<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法。  
  
   
  
## Examples  
 下面的代码示例将打开到 RTF 文件<xref:System.Windows.Forms.RichTextBox>控件。 该示例使用<xref:System.Windows.Forms.OpenFileDialog>类以显示对话框以请求用户文件。 代码接着加载此文件假定它是 RTF 文档文件。 如果文件不是，该示例代码将引发异常。 此示例需要将代码置于中<xref:System.Windows.Forms.Form>具有类<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`。  
  
 [!code-cpp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">将文件加载到控件中时出现错误。</exception>
        <exception cref="T:System.ArgumentException">所加载的文件不是 RTF 文档。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于打开文件。 关联的枚举：<see langword="Read" />值<see cref="T:System.Security.Permissions.FileIOPermissionAccess" />。</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : System.IO.Stream * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.LoadFile (data, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data">要加载到 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件中的数据流。</param>
        <param name="fileType">
          <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 值之一。</param>
        <summary>将现有数据流的内容加载到 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用此版本的<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法以加载<xref:System.Windows.Forms.RichTextBox>数据的现有流中的数据。 加载到控件的数据的整个内容替换<xref:System.Windows.Forms.RichTextBox>控件。 这将导致的值<xref:System.Windows.Forms.TextBoxBase.Text%2A>和<xref:System.Windows.Forms.RichTextBox.Rtf%2A>属性来更改。 此方法可用于已打开的文件加载到数据流到操作的控件。 如果你想要将控件内容保存到流中，你可以使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法接受<xref:System.IO.Stream>对象作为参数。  
  
 此版本的<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法还使您可以指定要加载到控件的数据的类型。 此功能，可使用到控件包含丰富文本格式 (RTF) 的文档以外的数据的数据流。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法将不会打开一个文件，直到为创建句柄<xref:System.Windows.Forms.RichTextBox>。 确保控件的句柄创建，然后再调<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>和<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>与流的方法。 它还演示如何使用<xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>， <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>， <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType>，和<xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType>成员。  
  
 这是已准备好运行时将其复制到你的项目的完整示例。  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">将文件加载到控件中时出现错误。</exception>
        <exception cref="T:System.ArgumentException">所加载的文件不是 RTF 文档。</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : string * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.LoadFile (path, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">要加载到控件中的文件的名称和位置。</param>
        <param name="fileType">
          <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 值之一。</param>
        <summary>将特定类型的文件加载到 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 加载的文件时<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法，所加载的文件的内容替换的全部内容<xref:System.Windows.Forms.RichTextBox>控件。 这将导致的值<xref:System.Windows.Forms.TextBoxBase.Text%2A>和<xref:System.Windows.Forms.RichTextBox.Rtf%2A>属性来更改。 此方法可用于将以前创建的文本或丰富文本格式 (RTF) 文档加载到操作的控件。 如果你想要保存该文件，则可以使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法。  
  
 你可以使用此版本的<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法，以指定所加载的文件的文件类型。 此功能，可加载到控件中的 RTF 文档以外的文件。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法将不会打开一个文件，直到为创建句柄<xref:System.Windows.Forms.RichTextBox>。 确保控件的句柄创建，然后再调<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法。  
  
   
  
## Examples  
 下面的代码示例打开到一个文本文件<xref:System.Windows.Forms.RichTextBox>控件。 该示例使用<xref:System.Windows.Forms.OpenFileDialog>类以显示对话框以请求用户文件。 然后则代码将加载到该文件<xref:System.Windows.Forms.RichTextBox>控件。 该示例使用此版本的<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法，以指定为 ASCII 文本文件而不是标准的丰富文本格式打开文件。 此示例需要将代码置于中<xref:System.Windows.Forms.Form>具有类<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`。  
  
 [!code-cpp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">将文件加载到控件中时出现错误。</exception>
        <exception cref="T:System.ArgumentException">所加载的文件不是 RTF 文档。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于打开文件。 关联的枚举：<see langword="Read" />值<see cref="T:System.Security.Permissions.FileIOPermissionAccess" />。</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="MaxLength">
      <MemberSignature Language="C#" Value="public override int MaxLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.MaxLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaxLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaxLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxLength : int with get, set" Usage="System.Windows.Forms.RichTextBox.MaxLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用户可在多格式文本框控件中键入或粘贴的最大字符数。</summary>
        <value>可以在文本框控件中输入的字符数。 默认值为 <see cref="F:System.Int32.MaxValue" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当此属性设置为 0 时，则可以在控件中输入的最大长度是文本的 64 KB 的字符。 此属性通常是时使用<xref:System.Windows.Forms.RichTextBox>用于显示单个丰富文本格式 (RTF) 文本行。 可以使用此属性，以限制为如邮政编码和电话号码的值输入控件中的文本的长度或将输入数据时要输入在数据库中的文本的长度限制。 你可以限制到数据库中的对应字段的最大长度文本框控件中输入的文本。  
  
> [!NOTE]
>  在代码中，你可以设置的值<xref:System.Windows.Forms.TextBoxBase.Text%2A>属性的长度大于指定的值的值<xref:System.Windows.Forms.TextBoxBase.MaxLength%2A>属性。 此属性仅影响在运行时文本框控件中输入的文本。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.RichTextBox.MaxLength%2A>属性来确定如果文本分配给<xref:System.Windows.Forms.RichTextBox>控件大于分配给值<xref:System.Windows.Forms.RichTextBox.MaxLength%2A>属性。 如果文本不是更大的该示例使用<xref:System.Windows.Forms.RichTextBox.SelectedText%2A>要分配给控件的文本属性。 此示例需要<xref:System.Windows.Forms.RichTextBox>控件，名为`richTextBox1`，已添加到窗体和示例中的方法调用与提供给粘贴到该控件的参数的文本。 该示例还要求<xref:System.Windows.Forms.TextBoxBase.MaxLength%2A>属性已设置为值为限制到文本输入<xref:System.Windows.Forms.RichTextBox>。  
  
 [!code-cpp[RichTextBox.MaxLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.MaxLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.MaxLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.MaxLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.MaxLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.MaxLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">分配给属性的值小于零。</exception>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.MaxLength" />
      </Docs>
    </Member>
    <Member MemberName="Multiline">
      <MemberSignature Language="C#" Value="public override bool Multiline { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Multiline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Multiline" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Multiline As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Multiline { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Multiline : bool with get, set" Usage="System.Windows.Forms.RichTextBox.Multiline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示此控件是否为多行 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件。</summary>
        <value>如果该控件是多行 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnBackColorChanged : EventArgs -&gt; unit" Usage="richTextBox.OnBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.BackColorChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentsResized">
      <MemberSignature Language="C#" Value="protected virtual void OnContentsResized (System.Windows.Forms.ContentsResizedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentsResized(class System.Windows.Forms.ContentsResizedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentsResized (e As ContentsResizedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentsResized(System::Windows::Forms::ContentsResizedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentsResized : System.Windows.Forms.ContentsResizedEventArgs -&gt; unit&#xA;override this.OnContentsResized : System.Windows.Forms.ContentsResizedEventArgs -&gt; unit" Usage="richTextBox.OnContentsResized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ContentsResizedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.ContentsResizedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.RichTextBox.ContentsResized" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.RichTextBox.OnContentsResized%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" />方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuChanged : EventArgs -&gt; unit" Usage="richTextBox.OnContextMenuChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.ContextMenuChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="richTextBox.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.HandleCreated" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="richTextBox.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnHScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHScroll(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHScroll : EventArgs -&gt; unit&#xA;override this.OnHScroll : EventArgs -&gt; unit" Usage="richTextBox.OnHScroll e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.RichTextBox.HScroll" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.RichTextBox.OnHScroll%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" />方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.HScroll" />
      </Docs>
    </Member>
    <Member MemberName="OnImeChange">
      <MemberSignature Language="C#" Value="protected virtual void OnImeChange (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeChange(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeChange (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeChange(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnImeChange : EventArgs -&gt; unit&#xA;override this.OnImeChange : EventArgs -&gt; unit" Usage="richTextBox.OnImeChange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.RichTextBox.ImeChange" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.RichTextBox.OnImeChange%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" />方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ImeChange" />
      </Docs>
    </Member>
    <Member MemberName="OnLinkClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnLinkClicked (System.Windows.Forms.LinkClickedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLinkClicked(class System.Windows.Forms.LinkClickedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLinkClicked (e As LinkClickedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLinkClicked(System::Windows::Forms::LinkClickedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLinkClicked : System.Windows.Forms.LinkClickedEventArgs -&gt; unit&#xA;override this.OnLinkClicked : System.Windows.Forms.LinkClickedEventArgs -&gt; unit" Usage="richTextBox.OnLinkClicked e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.LinkClickedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Forms.LinkClickedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.RichTextBox.LinkClicked" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.RichTextBox.OnLinkClicked%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" />方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      </Docs>
    </Member>
    <Member MemberName="OnProtected">
      <MemberSignature Language="C#" Value="protected virtual void OnProtected (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProtected(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnProtected (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnProtected(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnProtected : EventArgs -&gt; unit&#xA;override this.OnProtected : EventArgs -&gt; unit" Usage="richTextBox.OnProtected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.RichTextBox.Protected" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.RichTextBox.OnProtected%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" />方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected override void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnRightToLeftChanged : EventArgs -&gt; unit" Usage="richTextBox.OnRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionChanged : EventArgs -&gt; unit&#xA;override this.OnSelectionChanged : EventArgs -&gt; unit" Usage="richTextBox.OnSelectionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.RichTextBox.OnSelectionChanged%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" />方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnVScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnVScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVScroll(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnVScroll : EventArgs -&gt; unit&#xA;override this.OnVScroll : EventArgs -&gt; unit" Usage="richTextBox.OnVScroll e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.RichTextBox.VScroll" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Windows.Forms.RichTextBox.OnVScroll%2A> 方法还允许派生类对事件进行处理而不必附加委托。 这是在派生类中处理事件的首选技术。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" />方法，以便已注册的委托对事件进行接收。</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.VScroll" />
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Paste (clipFormat As DataFormats.Format)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberSignature Language="F#" Value="override this.Paste : System.Windows.Forms.DataFormats.Format -&gt; unit" Usage="richTextBox.Paste clipFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat">数据应从剪贴板获得的剪贴板格式。</param>
        <summary>粘贴指定剪贴板格式的剪贴板内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于将数据从剪贴板粘贴到控件。 此版本的<xref:System.Windows.Forms.RichTextBox.Paste%2A>方法是不同于<xref:System.Windows.Forms.TextBoxBase.Paste%2A?displayProperty=nameWithType>作为它的方法使你能够将只会将文本粘贴指定的剪贴板格式。 你可以使用<xref:System.Windows.Forms.RichTextBox.CanPaste%2A>方法来确定在剪贴板中的数据是否为指定的剪贴板格式。 然后，你可以调用此版本的<xref:System.Windows.Forms.RichTextBox.Paste%2A>方法，以确保进行与相应的数据格式，必须粘贴操作。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.RichTextBox.Paste%2A>方法以粘贴到位图<xref:System.Windows.Forms.RichTextBox>控件。 在从文件中打开一个位图之后, 该示例使用<xref:System.Windows.Forms.Clipboard.SetDataObject%2A>方法以将位图复制到 Windows 剪贴板。 最后，该示例将检索的格式<xref:System.Drawing.Bitmap>对象，请验证格式可以粘贴到<xref:System.Windows.Forms.RichTextBox>控件，并使用<xref:System.Windows.Forms.RichTextBox.Paste%2A>粘贴数据的方法。  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">用于从剪贴板读取。 关联的枚举：<see langword="AllClipboard" />值<see cref="T:System.Security.Permissions.UIPermissionClipboard" />。</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message m, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; m, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef m As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % m, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="richTextBox.ProcessCmdKey (m, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="m">通过引用传递的 <see cref="T:System.Windows.Forms.Message" />，表示要处理的窗口消息。</param>
        <param name="keyData">
          <see cref="T:System.Windows.Forms.Keys" /> 值之一，表示要处理的键。</param>
        <summary>处理命令键。</summary>
        <returns>如果字符已由控件处理，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="Protected">
      <MemberSignature Language="C#" Value="public event EventHandler Protected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Protected" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.Protected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Protected As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Protected;" />
      <MemberSignature Language="F#" Value="member this.Protected : EventHandler " Usage="member this.Protected : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户尝试修改控件中受保护的文本时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在应用程序来确定当用户已尝试修改已标记为控件中受保护的文本时，可以创建的事件处理程序此事件。 可以使用事件处理程序，以通知受保护的文本用户正尝试修改的用户，或以显示一个对话框，使用户能够对文本进行相应更改。 例如，如果受保护的区域是日期，则可以显示一个对话框，使用户能够选择然后可以应用于控件的文本的日期。  
  
 有关处理事件的详细信息，请参阅[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.RichTextBox.Protected>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.RichTextBox>名为`RichTextBox1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.RichTextBox.Protected>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#543](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#543)]
 [!code-vb[System.Windows.Forms.EventExamples#543](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#543)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此事件与此类无关。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Redo">
      <MemberSignature Language="C#" Value="public void Redo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Redo" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redo();" />
      <MemberSignature Language="F#" Value="member this.Redo : unit -&gt; unit" Usage="richTextBox.Redo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新应用控件中上次撤消的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 然后，可以使用<xref:System.Windows.Forms.RichTextBox.Redo%2A>方法以重新应用到控件的上一个撤消操作。 <xref:System.Windows.Forms.RichTextBox.CanRedo%2A>方法使您能够确定是否可以重新撤消了用户的上一个操作应用于控件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.RichTextBox.CanRedo%2A>和<xref:System.Windows.Forms.RichTextBox.RedoActionName%2A>属性，与<xref:System.Windows.Forms.RichTextBox.Redo%2A>方法，以限制对除删除文本的任何操作的重做操作。 此示例要求你拥有一个包含窗体<xref:System.Windows.Forms.RichTextBox>控制的和中的某个操作<xref:System.Windows.Forms.RichTextBox>已经执行并通过撤消在此示例中的代码调用之前。  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
      </Docs>
    </Member>
    <Member MemberName="RedoActionName">
      <MemberSignature Language="C#" Value="public string RedoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RedoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RedoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedoActionName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RedoActionName : string" Usage="System.Windows.Forms.RichTextBox.RedoActionName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当调用 <see cref="M:System.Windows.Forms.RichTextBox.Redo" /> 方法后，可以重新应用到控件的操作名称。</summary>
        <value>一个字符串，表示发出对 <see cref="M:System.Windows.Forms.RichTextBox.Redo" /> 方法的调用后执行的操作名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性返回一个空字符串 ("")，没有操作可重新应用于控件。 你可以使用此方法以确定上一操作撤消的<xref:System.Windows.Forms.RichTextBox>然后控制何时调用重新应用的控件<xref:System.Windows.Forms.RichTextBox.Redo%2A>方法由。 你可以确定是否有任何操作将重新应用到该控件使用<xref:System.Windows.Forms.RichTextBox.CanRedo%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.RichTextBox.CanRedo%2A>和<xref:System.Windows.Forms.RichTextBox.RedoActionName%2A>属性，与<xref:System.Windows.Forms.RichTextBox.Redo%2A>方法，以限制对除删除文本的任何操作的重做操作。 此示例要求你拥有一个包含窗体<xref:System.Windows.Forms.RichTextBox>控制的和中的某个操作<xref:System.Windows.Forms.RichTextBox>已经执行并通过撤消在此示例中的代码调用之前。  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="RichTextShortcutsEnabled">
      <MemberSignature Language="C#" Value="public bool RichTextShortcutsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RichTextShortcutsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RichTextShortcutsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property RichTextShortcutsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RichTextShortcutsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RichTextShortcutsEnabled : bool with get, set" Usage="System.Windows.Forms.RichTextBox.RichTextShortcutsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此属性与此类无关。</summary>
        <value>如果启用快捷键，则为 <see langword="true" />，否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性与此类无关。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightMargin">
      <MemberSignature Language="C#" Value="public int RightMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RightMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RightMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property RightMargin As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RightMargin { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.RightMargin : int with get, set" Usage="System.Windows.Forms.RichTextBox.RightMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件内单个文本行的大小。</summary>
        <value>控件中单个文本行的大小（以像素为单位）。 默认值为零。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当文本框控件中输入一个大于零的值时，则不可见的边距置于控件在指定的控件左侧的像素数。 输入超出此边距的任何文本将放置在控件中的文本的下一行。 此属性会影响当前输入到控件，以及设置该属性后文本框控件中输入任何其他文本的所有文本。 你可以使用此属性指定的所有文本输入到最大线条宽度<xref:System.Windows.Forms.RichTextBox>控件。  
  
   
  
## Examples  
 下面的代码示例演示如何创建<xref:System.Windows.Forms.RichTextBox>，文本将放大，自动选择控件的文本中单词的单词正在双击，并且控件的客户端区域右侧边距时。 如果<xref:System.Windows.Forms.RichTextBox>控件具有较小的宽度，使用此代码将创建<xref:System.Windows.Forms.RichTextBox>其中每个字符的文本将显示在其对应行。 在此垂直显示位置上，单击某个词的任何部分将选择而不考虑垂直显示的文本的单词的所有字符。 此示例要求你拥有一个包含窗体<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`。  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定的值小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Rtf">
      <MemberSignature Language="C#" Value="public string Rtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Rtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Rtf" />
      <MemberSignature Language="VB.NET" Value="Public Property Rtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Rtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Rtf : string with get, set" Usage="System.Windows.Forms.RichTextBox.Rtf" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件的文本，包括所有 RTF 格式代码。</summary>
        <value>RTF 格式的控件文本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用此属性设置为将 RTF 格式化文本到控件，以进行显示或带指定 RTF 格式定义控件的文本中提取该控件的文本。 将另一个 RTF 源，如 Microsoft Word 或 Windows 写字板的 RTF 文本分配给该控件时，通常使用此属性。  
  
 如果你更改<xref:System.Windows.Forms.Control.RightToLeft%2A>保留在运行时，仅原始文本不带格式的属性。  
  
 RTF 代码，请参阅"丰富文本格式 (RTF) 规范，版本 1.6"MSDN 库中http://msdn.microsoft.com/library。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Windows.Forms.RichTextBox" /> 的内容保存到文件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : string -&gt; unit" Usage="richTextBox.SaveFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要保存的文件的名称和位置。</param>
        <summary>将 <see cref="T:System.Windows.Forms.RichTextBox" /> 的内容保存到 RTF 格式文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法使你能够将控件的整个内容保存到可由其他程序，如 Microsoft Word 和 Windows 写字板 RTF 文件。 如果文件名传递给`path`上指定的目录已存在参数，则文件将覆盖恕不另行通知。 你可以使用<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法以加载到文件的内容<xref:System.Windows.Forms.RichTextBox>。  
  
> [!NOTE]
>  若要将控件的内容保存到不同类型的文件格式，如 ASCII 文本中，使用此方法接受从值的其他版本<xref:System.Windows.Forms.RichTextBoxStreamType>枚举作为参数。  
  
   
  
## Examples  
 下面的代码示例将保存的内容<xref:System.Windows.Forms.RichTextBox>RTF 文件的控件。 该示例使用<xref:System.Windows.Forms.SaveFileDialog>类来显示一个对话框以请求来自用户、 路径和文件的文件名保存。 然后，此代码将保存假定内容为丰富文本格式的文件。 如果该文件已存在，则以无自动覆盖。 此示例需要将代码置于中<xref:System.Windows.Forms.Form>具有类<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`。  
  
 [!code-cpp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">将控件内容保存到文件时出错。</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : System.IO.Stream * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.SaveFile (data, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data">包含要保存到的文件的数据流。</param>
        <param name="fileType">
          <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 值之一。</param>
        <summary>将 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件的内容保存到开放式数据流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此版本的<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法使你能够将控件的整个内容保存到已打开的数据流。 数据流然后可以将信息保存到文件。 你可以使用<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法以加载到文件的内容<xref:System.Windows.Forms.RichTextBox>。  
  
 此版本的<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法还使您可以指定将发送到的信息的数据格式<xref:System.IO.Stream>对象。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>和<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>与流的方法。 它还演示如何使用<xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>， <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>， <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType>，和<xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType>成员。  
  
 这是已准备好运行时将其复制到你的项目的完整示例。  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fileType" /> 参数中指定了无效的文件类型。</exception>
        <exception cref="T:System.IO.IOException">将控件内容保存到文件时出错。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于创建或修改文件。 关联的枚举：<see langword="Write" />值<see cref="T:System.Security.Permissions.FileIOPermissionAccess" />。</permission>
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : string * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.SaveFile (path, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">要保存的文件的名称和位置。</param>
        <param name="fileType">
          <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 值之一。</param>
        <summary>将 <see cref="T:System.Windows.Forms.RichTextBox" /> 的内容保存到特定类型的文件中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法使你能够将控件的整个内容保存到可由其他程序，如 Microsoft Word 和 Windows 写字板 RTF 文件。 如果文件名传递给`path`上指定的目录已存在参数，则文件将覆盖恕不另行通知。 你可以使用<xref:System.Windows.Forms.RichTextBox.LoadFile%2A>方法以加载到文件的内容<xref:System.Windows.Forms.RichTextBox>。  
  
 此版本的<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法，可指定要保存到控件的内容的文件类型。 此功能可用于确保该文件保存在基于控件的内容的正确格式。 例如，如果你的文档在字体样式或着色上的没有差别，可以保存该文件为 ASCII 文本文件通过设置`fileType`参数`RichTextBoxStreamType.PlainText`。  
  
   
  
## Examples  
 下面的代码示例将保存的内容<xref:System.Windows.Forms.RichTextBox>成一个 ASCII 文本文件。 该示例使用<xref:System.Windows.Forms.SaveFileDialog>类以显示对话框以请求用户的路径和文件名称。 然后，代码将控件的内容保存到该文件。 该示例使用此版本的<xref:System.Windows.Forms.RichTextBox.SaveFile%2A>方法，以指定将文件保存为而不是标准的丰富文本格式的 ASCII 文本文件。 此示例需要将代码置于中<xref:System.Windows.Forms.Form>具有类<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`。  
  
 [!code-cpp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fileType" /> 参数中指定了无效的文件类型。</exception>
        <exception cref="T:System.IO.IOException">将控件内容保存到文件时出错。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于创建或修改文件。 关联的枚举：<see langword="Write" />值<see cref="T:System.Security.Permissions.FileIOPermissionAccess" />。</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="ScrollBars">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxScrollBars ScrollBars { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxScrollBars ScrollBars" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ScrollBars" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollBars As RichTextBoxScrollBars" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxScrollBars ScrollBars { System::Windows::Forms::RichTextBoxScrollBars get(); void set(System::Windows::Forms::RichTextBoxScrollBars value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollBars : System.Windows.Forms.RichTextBoxScrollBars with get, set" Usage="System.Windows.Forms.RichTextBox.ScrollBars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxScrollBars</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件中显示的滚动条类型。</summary>
        <value>
          <see cref="T:System.Windows.Forms.RichTextBoxScrollBars" /> 值之一。 默认值为 <see langword="RichTextBoxScrollBars.Both" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性使您能够提供给的用户，水平和垂直滚动条<xref:System.Windows.Forms.RichTextBox>控件，使控件的物理维度之外的控件中的滚动文本。 此属性还可用于移除要限制滚动控件内容的控件的滚动条。  
  
> [!NOTE]
>  不会显示水平滚动条如果<xref:System.Windows.Forms.TextBoxBase.WordWrap%2A>是`true`，而不考虑的值的<xref:System.Windows.Forms.RichTextBox.ScrollBars%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">没有在 <see cref="T:System.Windows.Forms.RichTextBoxScrollBars" /> 枚举中定义指定值。</exception>
        <altmember cref="T:System.Windows.Forms.RichTextBoxScrollBars" />
      </Docs>
    </Member>
    <Member MemberName="SelectedRtf">
      <MemberSignature Language="C#" Value="public string SelectedRtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedRtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectedRtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SelectedRtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedRtf : string with get, set" Usage="System.Windows.Forms.RichTextBox.SelectedRtf" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置控件中当前选择的 RTF 格式的格式化文本。</summary>
        <value>控件中选定的 RTF 文本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性可获取该控件，包括 RTF 格式设置代码中选定的文本。 你可以使用此属性将文本复制从控件，完成，但包含格式设置，和粘贴其他的应用程序接受 RTF 文本格式的文本，例如 Microsoft Word 和 Windows 写字板。 若要获取所选的文本，而无需 RTF 格式设置代码，请使用<xref:System.Windows.Forms.TextBoxBase.SelectedText%2A>属性。  
  
 如果当前未不选定任何文本，此属性中指定的文本将插入的插入点处。 如果已选定文本，分配给此属性的任何文本将替换所选的文本。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.Rtf" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="SelectedText">
      <MemberSignature Language="C#" Value="public override string SelectedText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedText" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectedText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SelectedText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedText : string with get, set" Usage="System.Windows.Forms.RichTextBox.SelectedText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Forms.RichTextBox" /> 内的选定文本。</summary>
        <value>表示控件中选定文本的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A>具有属性<xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>， <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>，和<xref:System.Windows.Forms.RichTextBox.SelectionColor%2A>属性以创建中的项目符号列表<xref:System.Windows.Forms.RichTextBox>控件。 此示例需要<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`在窗体上创建。  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HorizontalAlignment SelectionAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.HorizontalAlignment SelectionAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HorizontalAlignment SelectionAlignment { System::Windows::Forms::HorizontalAlignment get(); void set(System::Windows::Forms::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionAlignment : System.Windows.Forms.HorizontalAlignment with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用到当前选定内容或插入点的对齐方式。</summary>
        <value>
          <see cref="T:System.Windows.Forms.HorizontalAlignment" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果控件中不选择任何段落，则设置此属性适用于插入点出现以及有关段落对齐方式属性设置的段落之后创建的段落对齐方式设置。 例如，如果有两个段落中的<xref:System.Windows.Forms.RichTextBox>控制和插入点位于第二个段落中。 如果你设置<xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A>属性`HorizontalAlignment.Center`，将在控件内居中的插入点处的段落。 如果第三个段落创建后的第二个段落中，它也是的中心对齐的控件。  
  
 如果属性设置时，将在控件内做出选择，则所有选定段落对齐根据此属性设置。 你可以使用此属性来对齐在中创建的文档中的段落<xref:System.Windows.Forms.RichTextBox>。 例如，如果你想要居中的文档中的所有段落，你可以选择控件中所有段落和集<xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A>属性`HorizontalAlignment.Center`。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> 返回`SelectionAlignment.Left`文本选择时包含采用混合对齐方式的多个段落。  
  
   
  
## Examples  
 下面的代码示例演示如何将中的文本对齐<xref:System.Windows.Forms.RichTextBox>。 此示例需要<xref:System.Windows.Forms.RichTextBox>控件，名为`richTextBox1`，已添加到窗体。  
  
 [!code-cpp[RichTextBox.SelectionAlignment#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionAlignment#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionAlignment#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定的值不是 <see cref="T:System.Windows.Forms.HorizontalAlignment" /> 类中定义的值之一。</exception>
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
      </Docs>
    </Member>
    <Member MemberName="SelectionBackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionBackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionBackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件中选中文本时文本的颜色。</summary>
        <value>
          <see cref="T:System.Drawing.Color" />，表示文本在选中时的颜色。 默认为 <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> 属性的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A>要获取或设置中选定的文本的颜色<xref:System.Windows.Forms.RichTextBox>。 如果当前未不选定任何文本，<xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A>属性应用于当前插入符号的位置。 从该位置输入字符的具有指定<xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBullet">
      <MemberSignature Language="C#" Value="public bool SelectionBullet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionBullet" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBullet As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionBullet { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBullet : bool with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionBullet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示项目符号样式是否应用到当前选定内容或插入点。</summary>
        <value>如果当前选定内容或插入点应用了项目符号样式，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不选择任何文本，则项目符号样式应用到当前插入点，并对所有用户输入后插入点的段落。 项目符号样式应用于控件的文本插入点移动为止，或当用户按 Enter 键下的空项目符号项上。  
  
 如果此属性设置时，将控件中选定文本，将选定文本中的所有段落都转换为项目符号列表中的项目符号列表项。 你可以使用此属性来创建在中创建的文档中的项目符号列表<xref:System.Windows.Forms.RichTextBox>控件。  
  
 <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A>属性使您能够指定要应用的项目符号和项目符号列表项的文本之间的缩进量。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A>具有属性<xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>， <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>，和<xref:System.Windows.Forms.RichTextBox.SelectionColor%2A>属性以创建中的项目符号列表<xref:System.Windows.Forms.RichTextBox>控件。 此示例需要<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`在窗体上创建。  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectionChanged : EventHandler " Usage="member this.SelectionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>控件内的选定文本更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以创建的事件处理程序来确定当用户已更改控件中的文本选择时此事件。 此事件的事件处理程序可以用于保持用户已完成应用程序中的任务之前选择的文本。  
  
 有关处理事件的详细信息，请参阅[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.RichTextBox.SelectionChanged>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.RichTextBox>名为`RichTextBox1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.RichTextBox.SelectionChanged>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#544](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#544)]
 [!code-vb[System.Windows.Forms.EventExamples#544](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#544)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionCharOffset">
      <MemberSignature Language="C#" Value="public int SelectionCharOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionCharOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionCharOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionCharOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionCharOffset { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionCharOffset : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionCharOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置控件中的文本是显示在基线上、作为上标还是作为基线下方的下标。</summary>
        <value>指定字符偏移量的数字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的值必须介于-2000年到 2000年之间。  
  
 如果此属性设置为零，则将显示文本位于基线上。 如果它是正数值中的数字指定用来引发文本选择基线上的像素数。 如果它为负数，此数字指定依据具有到下标文本选择的像素数。 可以使用此属性指定为上标或下标的文本。  
  
 如果未选择文本，偏移量被应用到当前插入点，并为用户键入插入点之后的所有文本。 属性更改为不同的值，或直到将插入点移动到在控件内的其他部分之前，将应用的字符偏移量。  
  
 如果控件中选定文本，文本选择将具有对其应用此属性的值后，输入所选的文本和任何文本。 此属性可用于创建此类应用程序作为数学表达式上标和下标的文本。  
  
   
  
## Examples  
 下面的代码示例演示如何指定上标和下标的文本中<xref:System.Windows.Forms.RichTextBox>使用<xref:System.Windows.Forms.RichTextBox.SelectionCharOffset%2A>属性。 此示例需要<xref:System.Windows.Forms.RichTextBox>控件，名为`richTextBox1`，已添加到窗体。  
  
 [!code-cpp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionCharOffset#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定的值小于 -2000 或大于 2000。</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前选定文本或插入点的文本颜色。</summary>
        <value>表示应用到当前选定文本或在插入点后输入的文本的颜色的 <see cref="T:System.Drawing.Color" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前选定的文本将具有多个指定的颜色，此属性返回`Color.Empty`。 如果当前未不选定任何文本，则会将此属性中指定的文本颜色应用到当前插入点和插入点之后键入到控件的所有文本。 属性更改为不同的颜色，或直到将插入点移动到在控件内的其他部分之前，将应用的文本颜色设置。  
  
 如果控件中选定文本，文本选择将具有对其应用此属性的值后，输入所选的文本和任何文本。 你可以使用此属性来更改中文本的颜色<xref:System.Windows.Forms.RichTextBox>。  
  
 若要使文本加粗控件中，使用<xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>要分配的新字体有指定的粗体的字体样式属性。  
  
   
  
## Examples  
 下面的代码示例显示<xref:System.Windows.Forms.ColorDialog>用户指定的当前文本选择或输入在当前插入后的文本的颜色点中<xref:System.Windows.Forms.RichTextBox>控件。 此示例需要在示例中定义的方法添加到<xref:System.Windows.Forms.Form>类，该类包含<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`。  
  
 [!code-cpp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionFont" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionFont">
      <MemberSignature Language="C#" Value="public System.Drawing.Font SelectionFont { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font SelectionFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionFont" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Font ^ SelectionFont { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionFont : System.Drawing.Font with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前选定文本或插入点的字体。</summary>
        <value>表示应用到当前选定文本或在插入点后输入的文本的字体的 <see cref="T:System.Drawing.Font" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前选定的文本具有多个指定的字体，此属性是`null`。 如果当前未不选定任何文本，则会将此属性中指定的字体应用到当前插入点和插入点之后键入到控件的所有文本。 属性更改为不同的字体或直到将插入点移动到在控件内的其他部分之前，将应用字体设置。  
  
 如果控件中选定文本，文本选择将具有对其应用此属性的值后，输入所选的文本和任何文本。 你可以使用此属性来更改中的文本的字体样式<xref:System.Windows.Forms.RichTextBox>。 你可以将文本控件中的粗体、 斜体和带下划线。 你还可以更改的文本以及应用于文本的字体的大小。  
  
 若要更改控件中的文本的颜色，请使用<xref:System.Windows.Forms.RichTextBox.SelectionColor%2A>属性。  
  
   
  
## Examples  
 下面的代码示例更改当前设置的文本选择或输入中的插入点之后的文本的字体以粗体显示样式<xref:System.Windows.Forms.RichTextBox>控件。 此示例需要在方法中包含的代码<xref:System.Windows.Forms.Form>。 该示例还要求<xref:System.Windows.Forms.RichTextBox>命名`richTextBox1`，已添加到<xref:System.Windows.Forms.Form>。  
  
 [!code-cpp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionColor" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionHangingIndent">
      <MemberSignature Language="C#" Value="public int SelectionHangingIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionHangingIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionHangingIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionHangingIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionHangingIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置选定段落中第一行文本的左边缘和同一段落中后面各行的左边缘之间的距离。</summary>
        <value>应用到当前选定文本或插入点的悬挂缩进的距离（以像素为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前未不选定任何文本，悬挂缩进将应用到在其中插入点出现的段落和插入点之后键入到控件的所有文本。 悬挂缩进设置适用，直到属性更改为不同的值或插入点移动到在控件内的其他段落为止。  
  
 如果控件中选定文本，文本选择将具有对其应用此属性的值后，输入所选的文本和任何文本。 此属性可用于将悬挂缩进应用于你段落。  
  
 若要设置的段落选择内容的第一行的缩进，使用<xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何指定悬挂缩进内的<xref:System.Windows.Forms.RichTextBox>使用<xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A>属性。 此示例需要<xref:System.Windows.Forms.RichTextBox>控件，名为`richTextBox1`，已添加到窗体。  
  
 [!code-cpp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionIndent">
      <MemberSignature Language="C#" Value="public int SelectionIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置所选内容开始行的缩进距离（以像素为单位）。</summary>
        <value>应用到当前选定文本或插入点的左边的当前缩进距离（以像素为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前未不选定任何文本，缩进设置将应用到在其中插入点出现的段落和插入点之后键入到控件的所有文本。 缩进设置一直属性更改为不同的值或插入点移动到在控件内的其他段落为止应用。  
  
 如果控件中选定文本，文本选择将具有对其应用此属性的值后，输入所选的文本和任何文本。 你可以使用此属性的文档中包含的段落的缩进<xref:System.Windows.Forms.RichTextBox>。 你可以结合使用此属性<xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A>创建显示段落中的段落。  
  
 若要创建控件中的段落悬挂缩进，使用<xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何指定中的缩进的文本<xref:System.Windows.Forms.RichTextBox>使用<xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A>属性。 此示例需要<xref:System.Windows.Forms.RichTextBox>控件，名为`richTextBox1`，已添加到窗体。  
  
 [!code-cpp[RichTextBox.SelectionIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionLength">
      <MemberSignature Language="C#" Value="public override int SelectionLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectionLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int SelectionLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionLength : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置控件中选定的字符数。</summary>
        <value>文本框中选定的字符数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用此属性以确定是否任何字符当前在所选文本执行操作前选择文本框控件中。 你还可以使用此属性以确定执行单个字符中的任务时选择了的字符 （包括空格） 的总数`for`循环。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.RichTextBox.SelectionLength%2A>属性来确定内已选定文本<xref:System.Windows.Forms.RichTextBox>。 此示例需要<xref:System.Windows.Forms.RichTextBox>控件，名为`richTextBox1`，已添加到窗体。 该示例还要求`richTextBox1`包含在控件中选定的文本。  
  
 [!code-cpp[RichTextBox.SelectionLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      </Docs>
    </Member>
    <Member MemberName="SelectionProtected">
      <MemberSignature Language="C#" Value="public bool SelectionProtected { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionProtected" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionProtected" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionProtected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionProtected { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionProtected : bool with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionProtected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示是否保护当前选定文本。</summary>
        <value>如果禁止更改当前选择的任何内容，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前未不选定任何文本，到在其中插入点出现的段落和插入点之后键入到控件的所有文本应用的保护设置。 属性更改为不同的值或插入点移动到在控件内的其他段落为止之前，将应用的保护设置。  
  
 如果控件中选定文本，文本选择将具有对其应用此属性的值后，输入所选的文本和任何文本。 此属性可用于防止用户修改的控件中的文本部分。  
  
 如果此属性设置为`true`、<xref:System.Windows.Forms.RichTextBox.Protected>当用户尝试更改当前文本选择时引发事件。  
  
> [!NOTE]
>  此属性将返回`true`仅当控件中的整个选择包含受保护的内容。  
  
   
  
## Examples  
 下面的代码示例演示如何指定在受保护的文本<xref:System.Windows.Forms.RichTextBox>使用<xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A>属性。 此示例需要<xref:System.Windows.Forms.RichTextBox>控件，名为`richTextBox1`，已添加到窗体和，<xref:System.Windows.Forms.RichTextBox>控件具有文本添加到其中包含单词"RichTextBox。"  
  
 [!code-cpp[RichTextBox.SelectionProtected#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionProtected#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionProtected#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionProtected/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="SelectionRightIndent">
      <MemberSignature Language="C#" Value="public int SelectionRightIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionRightIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionRightIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionRightIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionRightIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionRightIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.RichTextBox" /> 控件右边缘与选中文本或在当前插入点添加的文本的右边缘之间的距离（以像素为单位）。</summary>
        <value>当前选定内容或插入点右侧的缩进空间（以像素为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前未不选定任何文本，缩进设置将应用到在其中插入点出现的段落和插入点之后键入到控件的所有文本。 缩进设置一直属性更改为不同的值或插入点移动到在控件内的其他段落为止应用。  
  
 如果控件中选定文本，文本选择将具有对其应用此属性的值后，输入所选的文本和任何文本。 你可以使用此属性的文档中包含的段落的缩进<xref:System.Windows.Forms.RichTextBox>。 你可以结合使用此属性<xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A>创建显示段落中的段落。  
  
 若要创建控件中的段落悬挂缩进，使用<xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何创建在右边距<xref:System.Windows.Forms.RichTextBox>使用<xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A>属性。 该示例要求你拥有的窗体包含<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`，和从事件在窗体的类中调用的代码示例。  
  
 [!code-cpp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionRightIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionTabs">
      <MemberSignature Language="C#" Value="public int[] SelectionTabs { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32[] SelectionTabs" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionTabs" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionTabs As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;int&gt; ^ SelectionTabs { cli::array &lt;int&gt; ^ get(); void set(cli::array &lt;int&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionTabs : int[] with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionTabs" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Forms.RichTextBox" /> 控件中的绝对制表位位置。</summary>
        <value>包含每个成员以像素为单位指定的制表位偏移量的数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性使您能够获取一个数组，包含在当前选定文本中的每个选项卡的间距<xref:System.Windows.Forms.RichTextBox>控件。 然后可以使用此属性可调整大小的文本选择的范围内的每个选项卡。 例如，如果你想要调整的文档中的选项卡空间，你可以选择整个文档并获得的选项卡上使用的空间列表<xref:System.Windows.Forms.RichTextBox.SelectionTabs%2A>属性。 然后，可以调整为新值，并将它们重新分配到此属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">数组的元素个数大于所允许的最大值 32。</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxSelectionTypes SelectionType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxSelectionTypes SelectionType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectionType As RichTextBoxSelectionTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxSelectionTypes SelectionType { System::Windows::Forms::RichTextBoxSelectionTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectionType : System.Windows.Forms.RichTextBoxSelectionTypes" Usage="System.Windows.Forms.RichTextBox.SelectionType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxSelectionTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取控件内的选定内容类型。</summary>
        <value>
          <see cref="T:System.Windows.Forms.RichTextBoxSelectionTypes" /> 值的按位组合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用此属性来确定为了正确地处理所选内容，当执行对当前选定内容控件中的任务时当前选择控件中的数据的类型。 属性可以表示的值的任何组合<xref:System.Windows.Forms.RichTextBoxSelectionTypes>表示中当前选择的对象的许多类型的枚举。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      </Docs>
    </Member>
    <Member MemberName="ShowSelectionMargin">
      <MemberSignature Language="C#" Value="public bool ShowSelectionMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowSelectionMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ShowSelectionMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowSelectionMargin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowSelectionMargin { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowSelectionMargin : bool with get, set" Usage="System.Windows.Forms.RichTextBox.ShowSelectionMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，通过该值指示 <see cref="T:System.Windows.Forms.RichTextBox" /> 中是否显示选定内容的边距。</summary>
        <value>如果控件中启用了选定内容的边距，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用此属性，使用户能够轻松地选择中的文本行<xref:System.Windows.Forms.RichTextBox>。 选定内容的边距添加到左侧<xref:System.Windows.Forms.RichTextBox>。 此边距便于用户选择控件左侧开始的文本。 用户可以在选定内容的边距选择单个文本行中单击或双击以选择被双击的行包含在整个段落。  
  
> [!NOTE]
>  如果<xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A>属性设置为`true`，则设置<xref:System.Windows.Forms.RichTextBox.ScrollBars%2A>属性`RichTextBoxScrollBars.Horizontal`， `RichTextBoxScrollBars.Vertical`，或`RichTextBoxScrollBars.Both`不会导致要显示的滚动条。 为了显示时的滚动条<xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A>属性设置为`true`，将其设置<xref:System.Windows.Forms.RichTextBox.ScrollBars%2A>属性`RichTextBoxScrollBars.ForcedHorizontal`， `RichTextBoxScrollBars.ForcedVertical`，或`RichTextBoxScrollBars.ForcedBoth`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.RichTextBox.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置多格式文本框中的当前文本。</summary>
        <value>在控件中显示的文本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要显示多个行中的文本<xref:System.Windows.Forms.RichTextBox>，将其设置<xref:System.Windows.Forms.TextBoxBase.Multiline%2A>属性`true`。 若要读取或设置多行文本框的文本，请使用<xref:System.Windows.Forms.TextBoxBase.Lines%2A>属性。 <xref:System.Windows.Forms.RichTextBox.Text%2A>属性不返回有关应用到的内容的格式设置的任何信息<xref:System.Windows.Forms.RichTextBox>。 若要获取丰富的文本格式 (RTF) 代码，请使用<xref:System.Windows.Forms.RichTextBox.Rtf%2A>属性。 可输入的文本量<xref:System.Windows.Forms.RichTextBox>控件仅受可用系统内存。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Lines" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="TextLength">
      <MemberSignature Language="C#" Value="public override int TextLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.TextLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TextLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int TextLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TextLength : int" Usage="System.Windows.Forms.RichTextBox.TextLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取控件中文本的长度。</summary>
        <value>控件文本中所含的字符数。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="UndoActionName">
      <MemberSignature Language="C#" Value="public string UndoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UndoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.UndoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UndoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UndoActionName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UndoActionName : string" Usage="System.Windows.Forms.RichTextBox.UndoActionName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取调用 <see cref="M:System.Windows.Forms.TextBoxBase.Undo" /> 方法后在控件中可撤消的操作名称。</summary>
        <value>可撤消的操作的文本名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性使您能够确定上一操作可用于撤消控件内执行。 此属性可用于限制可用于控制用户撤消的操作。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
      </Docs>
    </Member>
    <Member MemberName="VScroll">
      <MemberSignature Language="C#" Value="public event EventHandler VScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.VScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VScroll;" />
      <MemberSignature Language="F#" Value="member this.VScroll : EventHandler " Usage="member this.VScroll : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户单击控件的垂直滚动条时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关处理事件的详细信息，请参阅[NIB： 使用事件](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在示例中，事件处理程序报告的匹配项<xref:System.Windows.Forms.RichTextBox.VScroll>事件。 此报告可帮助您了解当发生事件，并可以帮助您进行调试。 若要报告或频繁发生的事件上多个事件，请考虑替换<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>与<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>或追加到一个多行消息<xref:System.Windows.Forms.TextBox>。  
  
 若要运行此代码示例，请将其粘贴到包含类型的实例的项目<xref:System.Windows.Forms.RichTextBox>名为`RichTextBox1`。 然后，确保与事件处理程序<xref:System.Windows.Forms.RichTextBox.VScroll>事件。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#545](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#545)]
 [!code-vb[System.Windows.Forms.EventExamples#545](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#545)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="richTextBox.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">一个 Windows 消息对象。</param>
        <summary>处理 Windows 消息。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ZoomFactor">
      <MemberSignature Language="C#" Value="public float ZoomFactor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 ZoomFactor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ZoomFactor" />
      <MemberSignature Language="VB.NET" Value="Public Property ZoomFactor As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float ZoomFactor { float get(); void set(float value); };" />
      <MemberSignature Language="F#" Value="member this.ZoomFactor : single with get, set" Usage="System.Windows.Forms.RichTextBox.ZoomFactor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Forms.RichTextBox" /> 的当前缩放级别。</summary>
        <value>控件内容的缩放因子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的值可介于 1/64 (0.015625) 和 64.0，不含之间。 值为 1.0 指示无缩放应用于控件。 当该文档包含 TrueType 字体时，缩放功能以最佳方式执行。 不是 TrueType 字体使用的控件，文档中时<xref:System.Windows.Forms.RichTextBox.ZoomFactor%2A>属性将使用最接近的整数值。 你可以使用此属性启用的用户<xref:System.Windows.Forms.RichTextBox>控件缩放到太小，若要查看或紧缩视图以启用多个要在屏幕上查看的文档部分中的说明。  
  
   
  
## Examples  
 下面的代码示例演示如何创建<xref:System.Windows.Forms.RichTextBox>，文本将放大，自动选择控件的文本中单词的单词正在双击，并且控件的客户端区域右侧边距时。 如果<xref:System.Windows.Forms.RichTextBox>控件具有较小的宽度，使用此代码将创建<xref:System.Windows.Forms.RichTextBox>其中每个字符的文本将显示在其对应行。 在此垂直显示位置上，单击某个词的任何部分将选择而不考虑垂直显示的文本的单词的所有字符。 此示例要求你拥有一个包含窗体<xref:System.Windows.Forms.RichTextBox>控件名为`richTextBox1`。  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定的缩放因子不在允许的范围内。</exception>
      </Docs>
    </Member>
  </Members>
</Type>