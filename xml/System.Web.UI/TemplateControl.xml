<Type Name="TemplateControl" FullName="System.Web.UI.TemplateControl">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="568f4b0d1255d188a655c0094c14d13a356cf5f0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30610651" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TemplateControl : System.Web.UI.Control, System.Web.UI.IFilterResolutionService, System.Web.UI.INamingContainer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract TemplateControl extends System.Web.UI.Control implements class System.Web.UI.IFilterResolutionService, class System.Web.UI.INamingContainer" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.TemplateControl" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TemplateControl&#xA;Inherits Control&#xA;Implements IFilterResolutionService, INamingContainer" />
  <TypeSignature Language="C++ CLI" Value="public ref class TemplateControl abstract : System::Web::UI::Control, System::Web::UI::IFilterResolutionService, System::Web::UI::INamingContainer" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.IFilterResolutionService</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>为 <see cref="T:System.Web.UI.Page" /> 类和 <see cref="T:System.Web.UI.UserControl" /> 类提供了一组基本功能。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl>类是一个抽象类，提供通用的属性和方法<xref:System.Web.UI.Page>类和<xref:System.Web.UI.UserControl>类。 新实例<xref:System.Web.UI.TemplateControl>不直接创建。  
  
 <xref:System.Web.UI.TemplateControl>类定义支持声明性数据绑定表达式的方法：  
  
-   使用<xref:System.Web.UI.TemplateControl.Eval%2A>涉及数据源，如简单的属性或表达式的数据绑定表达式的方法。  
  
-   使用<xref:System.Web.UI.TemplateControl.XPath%2A>进行分析和 XPath 数据绑定表达式进行求值的方法。  
  
-   使用<xref:System.Web.UI.TemplateControl.XPathSelect%2A>方法用于对包含 XPath 表达式的数据绑定 select 语句。 结果是实现一个节点集合<xref:System.Collections.IEnumerable>接口。  
  
 有关数据绑定表达式的详细信息，请参阅[数据绑定表达式语法](http://msdn.microsoft.com/library/676beb1d-ddfa-4153-bba8-3c86dcb7ceca)和[绑定到数据库](http://msdn.microsoft.com/library/ab7b2846-975b-4057-a948-45527497c742)。  
  
   
  
## Examples  
 下面的代码示例演示如何派生一个名为控件`MyControl`从<xref:System.Web.UI.TemplateControl>类并重写<xref:System.Web.UI.TemplateControl.Construct%2A>方法。  当`MyControl`初始化时，重写<xref:System.Web.UI.TemplateControl.Construct%2A>调用方法。  
  
 [!code-csharp[TemplateControl_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplateControl_Sample1/CS/tempcontrol_samples1.ascx.cs#1)]
 [!code-vb[TemplateControl_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplateControl_Sample1/VB/tempcontrol_samples1.ascx.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="T:System.Web.UI.UserControl" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TemplateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TemplateControl();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.TemplateControl" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.%23ctor%2A>不直接调用构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AbortTransaction">
      <MemberSignature Language="C#" Value="public event EventHandler AbortTransaction;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AbortTransaction" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.TemplateControl.AbortTransaction" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AbortTransaction As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AbortTransaction;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户结束交易时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何注册的自定义事件处理程序<xref:System.Web.UI.TemplateControl.AbortTransaction>事件。 因为<xref:System.Web.UI.TemplateControl>是一个抽象类，此代码示例使用<xref:System.Web.UI.Page>类，该类派生自<xref:System.Web.UI.TemplateControl>类。 `Account` 是支持的类`Debit`操作，这是事务性的必须作为一个单元执行。 如果在此操作期间引发任何异常，则事务将中止。  
  
 [!code-csharp[TemplateControl_OnCommitTransaction#1](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplateControl_OnCommitTransaction/CS/templatecontrol_oncommittransaction.cs.aspx#1)]
 [!code-vb[TemplateControl_OnCommitTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplateControl_OnCommitTransaction/VB/templatecontrol_oncommittransaction.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.TemplateControl.CommitTransaction" />
        <altmember cref="E:System.Web.UI.TemplateControl.Error" />
        <altmember cref="M:System.Web.UI.TemplateControl.OnAbortTransaction(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="AppRelativeVirtualPath">
      <MemberSignature Language="C#" Value="public string AppRelativeVirtualPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeVirtualPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.TemplateControl.AppRelativeVirtualPath" />
      <MemberSignature Language="VB.NET" Value="Public Property AppRelativeVirtualPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeVirtualPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置从中解析和编译控件的文件的相对于应用程序的虚拟目录路径。</summary>
        <value>一个表示该路径的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 时，它定义的文件<xref:System.Web.UI.TemplateControl>控件驻留在一个目录以外的页处理请求，请使用<xref:System.Web.UI.TemplateControl.AppRelativeVirtualPath%2A>属性以返回到的相对于应用程序、 虚拟路径<xref:System.Web.UI.TemplateControl>。  
  
 <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A>属性上设置中的虚拟路径上设置基于<xref:System.Web.UI.TemplateControl.AppRelativeVirtualPath%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">设置的路径为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">设置的路径不是基于根路径的路径。</exception>
        <altmember cref="M:System.Web.VirtualPathUtility.MakeRelative(System.String,System.String)" />
        <altmember cref="P:System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
        <altmember cref="M:System.Web.UI.Control.ResolveUrl(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AutoHandlers">
      <MemberSignature Language="C#" Value="protected virtual int AutoHandlers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AutoHandlers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.TemplateControl.AutoHandlers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property AutoHandlers As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int AutoHandlers { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use of this property is not recommended because it is no longer useful. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET 2.0 中已弃用 <see cref="P:System.Web.UI.TemplateControl.AutoHandlers" /> 属性。 它是由生成的类使用的，不应在代码中使用。</summary>
        <value>始终为 0。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommitTransaction">
      <MemberSignature Language="C#" Value="public event EventHandler CommitTransaction;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CommitTransaction" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.TemplateControl.CommitTransaction" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CommitTransaction As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CommitTransaction;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当事务完成时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何注册的自定义事件处理程序<xref:System.Web.UI.TemplateControl.CommitTransaction>事件。 因为<xref:System.Web.UI.TemplateControl>是一个抽象类，此代码示例使用<xref:System.Web.UI.Page>类，该类派生自<xref:System.Web.UI.TemplateControl>类。 `Account` 是支持的类`Debit`操作，这是事务性的必须作为一个单元执行。 如果在此操作期间引发任何异常，则事务将中止。  
  
 [!code-csharp[TemplateControl_OnCommitTransaction#2](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplateControl_OnCommitTransaction/CS/templatecontrol_oncommittransaction.cs.aspx#2)]
 [!code-vb[TemplateControl_OnCommitTransaction#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplateControl_OnCommitTransaction/VB/templatecontrol_oncommittransaction.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.TemplateControl.AbortTransaction" />
        <altmember cref="E:System.Web.UI.TemplateControl.Error" />
        <altmember cref="M:System.Web.UI.TemplateControl.OnCommitTransaction(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Construct">
      <MemberSignature Language="C#" Value="protected virtual void Construct ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Construct() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.Construct" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Construct ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Construct();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>执行设计时逻辑。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.Construct%2A>方法允许设计时代码执行的<xref:System.Web.UI.Page>和<xref:System.Web.UI.UserControl>控件。  
  
   
  
## Examples  
 下面的代码示例演示如何重写<xref:System.Web.UI.TemplateControl.Construct%2A>方法的自定义控件派生自<xref:System.Web.UI.TemplateControl>类。  
  
 完整定义`MyControl`类，请参阅<xref:System.Web.UI.TemplateControl>。  
  
 [!code-csharp[TemplateControl_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplateControl_Sample1/CS/tempcontrol_samples1.ascx.cs#2)]
 [!code-vb[TemplateControl_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplateControl_Sample1/VB/tempcontrol_samples1.ascx.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="CreateResourceBasedLiteralControl">
      <MemberSignature Language="C#" Value="protected System.Web.UI.LiteralControl CreateResourceBasedLiteralControl (int offset, int size, bool fAsciiOnly);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Web.UI.LiteralControl CreateResourceBasedLiteralControl(int32 offset, int32 size, bool fAsciiOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.CreateResourceBasedLiteralControl(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateResourceBasedLiteralControl (offset As Integer, size As Integer, fAsciiOnly As Boolean) As LiteralControl" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Web::UI::LiteralControl ^ CreateResourceBasedLiteralControl(int offset, int size, bool fAsciiOnly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.LiteralControl</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="fAsciiOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="offset">资源中该字符串的开头的偏移量。</param>
        <param name="size">字符串的大小（以字节为单位）。</param>
        <param name="fAsciiOnly">一个布尔值，指示资源中的字符串是否只包含 7 位 ASCII 字符。</param>
        <summary>访问存储在资源中的字符串。 <see cref="M:System.Web.UI.TemplateControl.CreateResourceBasedLiteralControl(System.Int32,System.Int32,System.Boolean)" /> 方法并不应从代码中使用。</summary>
        <returns>表示资源中字符串的 <see cref="T:System.Web.UI.LiteralControl" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.CreateResourceBasedLiteralControl%2A>方法用于访问存储资源中的文本字符串，不应从你的代码中使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.LiteralControl" />
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.TemplateControl.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个布尔值，该值指示主题是否应用于派生自 <see cref="T:System.Web.UI.TemplateControl" /> 类的控件。</summary>
        <value>
          如果使用主题，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.EnableTheming%2A>属性指示是否为派生自的控件启用主题<xref:System.Web.UI.TemplateControl>类。 当<xref:System.Web.UI.TemplateControl.EnableTheming%2A>属性是`true`，应用程序的主题目录搜索要应用的控件外观。 如果用于特定的控件中的主题目录存在，则不会应用外观。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.PageTheme" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event EventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.TemplateControl.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Error;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当引发未经处理的异常时发生。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Web.UI.TemplateControl.AbortTransaction" />
        <altmember cref="E:System.Web.UI.TemplateControl.CommitTransaction" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Eval">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为在运行时根据对象分析和计算数据绑定表达式提供支持。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Eval">
      <MemberSignature Language="C#" Value="protected internal object Eval (string expression);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance object Eval(string expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.Eval(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function Eval (expression As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Object ^ Eval(System::String ^ expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">从容器到要放置在绑定控件属性中的公共属性值的导航路径。</param>
        <summary>计算数据绑定表达式。</summary>
        <returns>由计算数据绑定表达式所得出的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值`expression`计算结果必须为公共属性。  
  
 <xref:System.Web.UI.TemplateControl.Eval%2A>方法调用<xref:System.Web.UI.DataBinder.Eval%2A?displayProperty=nameWithType>方法使用<xref:System.Web.UI.Page.GetDataItem%2A>方法解决针对计算该表达式的对象引用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">数据绑定方法只能用于 <see cref="T:System.Web.UI.Page" /> 中包含的控件。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> 为 <see langword="null" />。  
  
 \- 或 -  
  
 <paramref name="expression" /> 为空字符串 ("")。</exception>
        <altmember cref="T:System.Web.UI.DataBinder" />
      </Docs>
    </Member>
    <Member MemberName="Eval">
      <MemberSignature Language="C#" Value="protected internal string Eval (string expression, string format);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance string Eval(string expression, string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.Eval(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function Eval (expression As String, format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::String ^ Eval(System::String ^ expression, System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">从容器到要放置在绑定控件属性中的公共属性值的导航路径。</param>
        <param name="format">要对结果应用的 .NET Framework 格式字符串。</param>
        <summary>使用用于显示结果的指定格式字符串计算数据绑定表达式。</summary>
        <returns>通过计算数据绑定表达式并将结果转换为字符串类型所得出的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值`expression`计算结果必须为公共属性。  
  
 <xref:System.Web.UI.TemplateControl.Eval%2A>方法调用<xref:System.Web.UI.DataBinder.Eval%2A>方法使用<xref:System.Web.UI.Page.GetDataItem%2A>方法解决针对计算该表达式的对象引用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该数据绑定方法只能用于 <see cref="T:System.Web.UI.Page" /> 上包含的控件。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> 为 <see langword="null" />。  
  
 \- 或 -  
  
 <paramref name="expression" /> 为空字符串 ("")。</exception>
        <altmember cref="T:System.Web.UI.DataBinder" />
      </Docs>
    </Member>
    <Member MemberName="FrameworkInitialize">
      <MemberSignature Language="C#" Value="protected virtual void FrameworkInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FrameworkInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.FrameworkInitialize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub FrameworkInitialize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void FrameworkInitialize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>初始化派生自 <see cref="T:System.Web.UI.TemplateControl" /> 类的控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不会重写<xref:System.Web.UI.TemplateControl.FrameworkInitialize%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取应用程序级别的资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="protected object GetGlobalResourceObject (string className, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetGlobalResourceObject(string className, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetGlobalResourceObject (className As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ GetGlobalResourceObject(System::String ^ className, System::String ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">表示 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 的字符串。</param>
        <param name="resourceKey">表示 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 的字符串。</param>
        <summary>根据指定的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 和 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性，获取应用程序级别资源对象。</summary>
        <returns>表示所请求资源对象的对象；如果不存在这样的对象，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序级别资源存储在 App_GlobalResources 文件夹。 有关详细信息，请参阅[ASP.NET 应用程序中的资源](http://msdn.microsoft.com/library/5a29f26b-d94d-48d9-864e-5ee8890dc265)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.TemplateControl.GetGlobalResourceObject%2A>方法来访问名为一个字符串`GlobalResourceString1`从一个名为的全局资源`MyResource.resx`App_GlobalResources 文件夹中。 `className`参数是`MyResource`不带.resx 扩展名。  
  
 [!code-aspx-csharp[System.Web.UI.TemplateControl_GetResources#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.TemplateControl_GetResources/cs/sourcecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.TemplateControl_GetResources#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.TemplateControl_GetResources/vb/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="protected object GetGlobalResourceObject (string className, string resourceKey, Type objType, string propName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetGlobalResourceObject(string className, string resourceKey, class System.Type objType, string propName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.GetGlobalResourceObject(System.String,System.String,System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetGlobalResourceObject (className As String, resourceKey As String, objType As Type, propName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ GetGlobalResourceObject(System::String ^ className, System::String ^ resourceKey, Type ^ objType, System::String ^ propName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="objType" Type="System.Type" />
        <Parameter Name="propName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">表示 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 的字符串。</param>
        <param name="resourceKey">表示 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 的字符串。</param>
        <param name="objType">资源中要获取的对象的类型。</param>
        <param name="propName">要获取的对象的属性名称。</param>
        <summary>根据资源的指定 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 和 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性、对象类型和属性名称获取应用程序级别的资源对象。</summary>
        <returns>表示所请求资源对象的对象；如果不存在这样的对象，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序级别资源存储在 App_GlobalResources 文件夹。 有关详细信息，请参阅[ASP.NET 应用程序中的资源](http://msdn.microsoft.com/library/5a29f26b-d94d-48d9-864e-5ee8890dc265)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取页级别的资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="protected object GetLocalResourceObject (string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetLocalResourceObject(string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.GetLocalResourceObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetLocalResourceObject (resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ GetLocalResourceObject(System::String ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceKey">表示 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 的字符串。</param>
        <summary>根据指定的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性获取页级别的资源对象。</summary>
        <returns>表示所请求资源对象的对象；如果不存在这样的对象，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本地资源文件存储在 App_LocalResources 目录中。 有关详细信息，请参阅[ASP.NET 应用程序中的资源](http://msdn.microsoft.com/library/5a29f26b-d94d-48d9-864e-5ee8890dc265)  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.TemplateControl.GetLocalResourceObject%2A>方法来访问名为一个字符串`LocalResourceString1`从位于 App_LocalResources 文件夹中的本地页资源。  
  
 [!code-aspx-csharp[System.Web.UI.TemplateControl_GetResources#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.TemplateControl_GetResources/cs/sourcecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.TemplateControl_GetResources#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.TemplateControl_GetResources/vb/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="protected object GetLocalResourceObject (string resourceKey, Type objType, string propName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetLocalResourceObject(string resourceKey, class System.Type objType, string propName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.GetLocalResourceObject(System.String,System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetLocalResourceObject (resourceKey As String, objType As Type, propName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ GetLocalResourceObject(System::String ^ resourceKey, Type ^ objType, System::String ^ propName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="objType" Type="System.Type" />
        <Parameter Name="propName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceKey">表示 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 的字符串。</param>
        <param name="objType">要获取的资源对象类型。</param>
        <param name="propName">要获取的资源对象的属性名称。</param>
        <summary>根据指定的 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 属性、对象类型和属性名称获取页级别的资源对象。</summary>
        <returns>表示所请求资源对象的对象；如果不存在这样的对象，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本地资源文件存储在 App_LocalResources 目录中。 有关详细信息，请参阅[ASP.NET 应用程序中的资源](http://msdn.microsoft.com/library/5a29f26b-d94d-48d9-864e-5ee8890dc265)  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加载 <see cref="T:System.Web.UI.Control" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当容器控件中载入控件时，容器将引发所有添加的控件事件，直到它已经赶上到当前的事件。 但是，添加的控件不赶上回发数据处理。 对于添加的控件，以参与回发数据处理，包括验证，必须在添加控件<xref:System.Web.UI.Control.Init>事件而不是在<xref:System.Web.UI.Control.Load>事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control LoadControl (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.Control LoadControl(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.LoadControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadControl (virtualPath As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::Control ^ LoadControl(System::String ^ virtualPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">控件文件的虚拟路径。</param>
        <summary>根据指定的虚拟路径从文件加载 <see cref="T:System.Web.UI.Control" /> 对象。</summary>
        <returns>返回指定的 <see cref="T:System.Web.UI.Control" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该控件支持缓存，从返回的对象<xref:System.Web.UI.TemplateControl.LoadControl%2A>方法不是实际<xref:System.Web.UI.Control>对象; 而是<xref:System.Web.UI.PartialCachingControl>对象。 如果`virtualPath`参数是相对，加载的控件的路径是相对于的路径<xref:System.Web.UI.TemplateControl>。  
  
 当容器控件中载入控件时，容器将引发所有添加的控件事件，直到它已经赶上到当前的事件。 但是，添加的控件不赶上回发数据处理。 对于添加的控件，以参与回发数据处理，包括验证，必须在添加控件<xref:System.Web.UI.Control.Init>事件而不是在<xref:System.Web.UI.Control.Load>事件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.TemplateControl.LoadControl%2A>方法将用户控件添加到 ASP.NET 页。  
  
 在`OnInit`事件方法中，此页使用<xref:System.Web.UI.TemplateControl.LoadControl%2A>方法以编程方式创建页上的用户控件。 该方法将添加到控件<xref:System.Web.UI.Control.Controls%2A>属性<xref:System.Web.UI.WebControls.PlaceHolder>Web 服务器控件名为`Placeholder1`。  
  
 定义`MyControl`类，该类用于在此代码示例，请参阅<xref:System.Web.UI.TemplateControl>。  
  
 [!code-csharp[TemplateControl_Sample1#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplateControl_Sample1/CS/TempControl_Samples1.aspx#3)]
 [!code-vb[TemplateControl_Sample1#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplateControl_Sample1/VB/tempcontrol_samples1.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">虚拟路径为 <see langword="null" /> 或空。</exception>
        <altmember cref="T:System.Web.UI.UserControl" />
        <altmember cref="M:System.Web.UI.TemplateControl.LoadControl(System.Type,System.Object[])" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="LoadControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control LoadControl (Type t, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.Control LoadControl(class System.Type t, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.LoadControl(System.Type,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadControl (t As Type, parameters As Object()) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::Control ^ LoadControl(Type ^ t, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="t">控件的类型。</param>
        <param name="parameters">与要调用构造函数的参数数量、顺序和类型匹配的参数数组。 如果参数<c></c>是空数组或 <see langword="null" />，则调用不使用参数的构造函数（默认构造函数）。</param>
        <summary>根据指定类型和构造函数参数加载 <see cref="T:System.Web.UI.Control" /> 对象。</summary>
        <returns>返回指定的 <see cref="T:System.Web.UI.UserControl" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果用户控件支持缓存，从返回的对象<xref:System.Web.UI.TemplateControl.LoadControl%2A>方法不是实际<xref:System.Web.UI.UserControl>对象; 而是<xref:System.Web.UI.PartialCachingControl>对象。  
  
 当容器控件中载入控件时，容器将引发所有添加的控件事件，直到它已经赶上到当前的事件。 但是，添加的控件不赶上回发数据处理。 对于添加的控件，以参与回发数据处理，包括验证，必须在添加控件<xref:System.Web.UI.Control.Init>事件而不是在<xref:System.Web.UI.Control.Load>事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.UserControl" />
        <altmember cref="M:System.Web.UI.TemplateControl.LoadControl(System.String)" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="LoadTemplate">
      <MemberSignature Language="C#" Value="public System.Web.UI.ITemplate LoadTemplate (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.ITemplate LoadTemplate(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.LoadTemplate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadTemplate (virtualPath As String) As ITemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::ITemplate ^ LoadTemplate(System::String ^ virtualPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ITemplate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">用户控件文件的虚拟路径。</param>
        <summary>从外部文件获取 <see cref="T:System.Web.UI.ITemplate" /> 接口的实例。</summary>
        <returns>指定模板的实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.TemplateControl.LoadTemplate%2A>方法将用户控件添加作为交替项<xref:System.Web.UI.WebControls.DataList>Web 服务器控件名为`DataList1`。 用户控件实现<xref:System.Web.UI.ITemplate>接口以及是否包含在名为 Newtemplate.ascx 的文件。  
  
 [!code-csharp[System.Web.UI.TemplateControl_LoadTemplate#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.TemplateControl_LoadTemplate/CS/loadtemplatecs.aspx#1)]
 [!code-vb[System.Web.UI.TemplateControl_LoadTemplate#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.TemplateControl_LoadTemplate/VB/loadtemplatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ITemplate" />
      </Docs>
    </Member>
    <Member MemberName="OnAbortTransaction">
      <MemberSignature Language="C#" Value="protected virtual void OnAbortTransaction (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAbortTransaction(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.OnAbortTransaction(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAbortTransaction (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAbortTransaction(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.TemplateControl.AbortTransaction" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.TemplateControl.OnAbortTransaction%2A>和<xref:System.Web.UI.TemplateControl.OnCommitTransaction%2A>方法。 因为<xref:System.Web.UI.TemplateControl>是一个抽象类，此代码示例使用<xref:System.Web.UI.Page>类，该类派生自<xref:System.Web.UI.TemplateControl>类。 `Account` 是支持的类`Debit`操作，这是事务性的必须作为一个单元执行。 如果在此操作期间引发任何异常，则事务将中止。  
  
 [!code-csharp[TemplateControl_OnCommitTransaction#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplateControl_OnCommitTransaction/CS/templatecontrol_oncommittransaction.cs.aspx#3)]
 [!code-vb[TemplateControl_OnCommitTransaction#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplateControl_OnCommitTransaction/VB/templatecontrol_oncommittransaction.vb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCommitTransaction">
      <MemberSignature Language="C#" Value="protected virtual void OnCommitTransaction (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCommitTransaction(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.OnCommitTransaction(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCommitTransaction (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCommitTransaction(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.TemplateControl.CommitTransaction" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用<xref:System.Web.UI.TemplateControl.OnCommitTransaction%2A>任何处理的逻辑页或用户控件所参与的事务的方法。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.TemplateControl.OnAbortTransaction%2A>和<xref:System.Web.UI.TemplateControl.OnCommitTransaction%2A>方法。 因为<xref:System.Web.UI.TemplateControl>是一个抽象类，此代码示例使用<xref:System.Web.UI.Page>类，该类派生自<xref:System.Web.UI.TemplateControl>类。 `Account` 是支持的类`Debit`操作，这是事务性的必须作为一个单元执行。 如果在此操作期间引发任何异常，则事务将中止。  
  
 [!code-csharp[TemplateControl_OnCommitTransaction#2](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplateControl_OnCommitTransaction/CS/templatecontrol_oncommittransaction.cs.aspx#2)]
 [!code-vb[TemplateControl_OnCommitTransaction#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplateControl_OnCommitTransaction/VB/templatecontrol_oncommittransaction.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected virtual void OnError (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnError(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.OnError(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnError (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnError(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.TemplateControl.Error" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示一种使用的可能方法<xref:System.Web.UI.TemplateControl.OnError%2A>方法。 它将创建一个字符串与某些无效的参数，这会导致的异常。 因为<xref:System.Web.UI.TemplateControl>类一个抽象类，此代码示例使用编写<xref:System.Web.UI.Page>类，该类派生自<xref:System.Web.UI.TemplateControl>类。  
  
```vb  
<%@ Page language="VB" %>  
 <html>  
  <head>  
  <script language="VB" runat="server">  
  Sub Page_Load(sender as object, e as System.EventArgs)  
  AddHandler Page.Error, AddressOf Error_Handler  
  try  
  Dim myString as string = "Hello"  
  'An exception is raised because the length of 'myString' is less than '6'.  
  Dim mySubString as string= myString.Substring(0,6)  
  catch e1 As Exception  
  OnError (EventArgs.Empty)  
  End try  
  End Sub  
  Sub Error_Handler(sender as object,e as System.EventArgs)  
  Response.Write("<br><b>An Error was raised</b>")  
  End Sub  
  </script>  
  </head>  
 </html>  
```  
  
```csharp  
<%@ Page language="c#" %>  
 <html>  
  <head>  
  <script language="C#" runat="server">  
  void Page_Load(object sender, System.EventArgs e)  
  {  
  Page.Error += new System.EventHandler(Error_Handler);  
  try  
  {  
  string myString = "Hello";  
  // An exception is raised because the length of 'myString' is less than '6'.  
  string mySubString = myString.Substring(0,6);  
  }  
  catch(Exception)  
  {  
  OnError(EventArgs.Empty);  
  }  
  }  
  void Error_Handler(object sender,System.EventArgs e)  
  {  
  Response.Write("<br><b>An Error was raised</b>");  
  }  
  </script>  
  </head>  
 </html>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ParseControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将输入字符串分析为 ASP.NET 网页或用户控件上的 <see cref="T:System.Web.UI.Control" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.ParseControl%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ParseControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control ParseControl (string content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.Control ParseControl(string content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.ParseControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ParseControl (content As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::Control ^ ParseControl(System::String ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="content">包含用户控件的字符串。</param>
        <summary>将输入字符串分析为 Web 窗体页或用户控件上的 <see cref="T:System.Web.UI.Control" /> 对象。</summary>
        <returns>已分析的 <see cref="T:System.Web.UI.Control" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `content`参数包含一个用户控件，例如你将在一个.ascx 文件中找到。 此字符串不能包含任何代码，因为<xref:System.Web.UI.TemplateControl.ParseControl%2A>方法永远不会导致编译。  
  
   
  
## Examples  
 下面的代码示例演示如何创建<xref:System.Web.UI.WebControls.Button>Web 服务器控件使用<xref:System.Web.UI.TemplateControl.ParseControl%2A>方法，并将结果发送到<xref:System.Web.UI.ControlCollection>集合<xref:System.Web.UI.WebControls.PlaceHolder>Web 服务器控件名为`myPlaceholder`。  
  
 [!code-aspx-csharp[System.Web.UI.TemplateControl.ParseControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.TemplateControl.ParseControl/CS/templatecontrol_parsecontrolcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.TemplateControl.ParseControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.TemplateControl.ParseControl/VB/templatecontrol_parsecontrolvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.TemplateControl.LoadControl" />
      </Docs>
    </Member>
    <Member MemberName="ParseControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control ParseControl (string content, bool ignoreParserFilter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.Control ParseControl(string content, bool ignoreParserFilter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.ParseControl(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ParseControl (content As String, ignoreParserFilter As Boolean) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::Control ^ ParseControl(System::String ^ content, bool ignoreParserFilter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.String" />
        <Parameter Name="ignoreParserFilter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="content">包含用户控件的字符串。</param>
        <param name="ignoreParserFilter">一个指定是否忽略分析程序筛选器的值。</param>
        <summary>将输入字符串分析为 ASP.NET 网页或用户控件上的 <see cref="T:System.Web.UI.Control" /> 对象。</summary>
        <returns>已分析的控件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `content`参数包含用户控件 （.ascx 文件的内容）。 此字符串不能包含任何代码，因为<xref:System.Web.UI.TemplateControl.ParseControl%2A>方法永远不会导致编译。  
  
 `ignoreParserFilter`参数允许<xref:System.Web.UI.PageParserFilter>类被忽略。 <xref:System.Web.UI.PageParserFilter> ASP.NET 分析器使用类以确定是否在分析时允许在页中的项。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadStringResource">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>读取字符串资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadStringResource">
      <MemberSignature Language="C#" Value="public object ReadStringResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadStringResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.ReadStringResource" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadStringResource () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadStringResource();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取字符串资源。 <see cref="M:System.Web.UI.TemplateControl.ReadStringResource" /> 方法并不应从代码中使用。</summary>
        <returns>表示资源的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.ReadStringResource%2A> 方法并不应从代码中使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="M:System.Web.UI.TemplateControl.ReadStringResource" /> 不再受支持。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadStringResource">
      <MemberSignature Language="C#" Value="public static object ReadStringResource (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ReadStringResource(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.ReadStringResource(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadStringResource (t As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ReadStringResource(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">要读取的资源的 <see cref="T:System.Type" />。</param>
        <summary>读取字符串资源。 <see cref="M:System.Web.UI.TemplateControl.ReadStringResource(System.Type)" /> 方法并不应从代码中使用。</summary>
        <returns>表示资源的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.ReadStringResource%2A> 方法并不应从代码中使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetStringResourcePointer">
      <MemberSignature Language="C#" Value="protected void SetStringResourcePointer (object stringResourcePointer, int maxResourceOffset);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetStringResourcePointer(object stringResourcePointer, int32 maxResourceOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.SetStringResourcePointer(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetStringResourcePointer (stringResourcePointer As Object, maxResourceOffset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetStringResourcePointer(System::Object ^ stringResourcePointer, int maxResourceOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringResourcePointer" Type="System.Object" />
        <Parameter Name="maxResourceOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stringResourcePointer">表示指向该字符串资源的指针的对象。</param>
        <param name="maxResourceOffset">资源大小。</param>
        <summary>设置指向字符串资源的指针。 <see cref="M:System.Web.UI.TemplateControl.SetStringResourcePointer(System.Object,System.Int32)" /> 方法是由生成的类使用的，并且不应从代码中使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportAutoEvents">
      <MemberSignature Language="C#" Value="protected virtual bool SupportAutoEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportAutoEvents" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.TemplateControl.SupportAutoEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property SupportAutoEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool SupportAutoEvents { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Web.UI.TemplateControl" /> 控件是否支持自动事件。</summary>
        <value>总是为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.SupportAutoEvents%2A>属性指示是否支持自动的事件。 <xref:System.Web.UI.TemplateControl.SupportAutoEvents%2A>属性是只读的`true`所有用例。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IFilterResolutionService.CompareFilters">
      <MemberSignature Language="C#" Value="int IFilterResolutionService.CompareFilters (string filter1, string filter2);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Web.UI.IFilterResolutionService.CompareFilters(string filter1, string filter2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.System#Web#UI#IFilterResolutionService#CompareFilters(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Function CompareFilters (filter1 As String, filter2 As String) As Integer Implements IFilterResolutionService.CompareFilters" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Web.UI.IFilterResolutionService.CompareFilters(System::String ^ filter1, System::String ^ filter2) = System::Web::UI::IFilterResolutionService::CompareFilters;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IFilterResolutionService.CompareFilters(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter1" Type="System.String" />
        <Parameter Name="filter2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filter1">设备筛选器名称。</param>
        <param name="filter2">设备筛选器名称。</param>
        <summary>返回一个值，该值指示在两个指定设备筛选器之间是否存在父/子关系。</summary>
        <returns>如果 <paramref name="filter1" /> 是 <paramref name="filter2" /> 的父级，则为 1；如果 <paramref name="filter2" /> 是 <paramref name="filter1" /> 的父级，则为 -1；如果 <paramref name="filter1" /> 和 <paramref name="filter2" /> 之间没有父/子关系，则为 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.System%23Web%23UI%23IFilterResolutionService%23CompareFilters%2A>方法是的一部分<xref:System.Web.UI.IFilterResolutionService>接口，这是特定于控件在设计器的环境中使用设备筛选器的方式。 当分析或上下文外部浏览器请求，设计器的环境中保留控件<xref:System.Web.UI.IFilterResolutionService>提供一种方法，以确定是否通过指定筛选器并指定筛选器是否为特定的一部分影响当前控件设备筛选器层次结构。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.TemplateControl.System#Web#UI#IFilterResolutionService#EvaluateFilter(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IFilterResolutionService.EvaluateFilter">
      <MemberSignature Language="C#" Value="bool IFilterResolutionService.EvaluateFilter (string filterName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Web.UI.IFilterResolutionService.EvaluateFilter(string filterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.System#Web#UI#IFilterResolutionService#EvaluateFilter(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function EvaluateFilter (filterName As String) As Boolean Implements IFilterResolutionService.EvaluateFilter" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Web.UI.IFilterResolutionService.EvaluateFilter(System::String ^ filterName) = System::Web::UI::IFilterResolutionService::EvaluateFilter;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IFilterResolutionService.EvaluateFilter(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterName">设备筛选器的名称。</param>
        <summary>返回一个值，该值指示指定的筛选器是否为当前筛选器对象的其中一个类型。</summary>
        <returns>
          如果指定筛选器是适用于当前筛选器对象的类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.System%23Web%23UI%23IFilterResolutionService%23EvaluateFilter%2A>方法是的一部分<xref:System.Web.UI.IFilterResolutionService>接口，这是特定于控件在设计器的环境中使用设备筛选器的方式。 当分析或上下文外部浏览器请求，设计器的环境中保留控件<xref:System.Web.UI.IFilterResolutionService>提供一种方法，以确定是否通过指定筛选器并指定筛选器是否为特定的一部分影响当前控件设备筛选器层次结构。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.TemplateControl.System#Web#UI#IFilterResolutionService#CompareFilters(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TestDeviceFilter">
      <MemberSignature Language="C#" Value="public virtual bool TestDeviceFilter (string filterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TestDeviceFilter(string filterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.TestDeviceFilter(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TestDeviceFilter (filterName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TestDeviceFilter(System::String ^ filterName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterName">要测试的浏览器名称。</param>
        <summary>返回一个布尔值，该值指示是否对该 HTTP 请求应用设备筛选器。</summary>
        <returns>
          如果在 <paramref name="filterName" /> 中指定的客户端浏览器与指定浏览器相同，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.TestDeviceFilter%2A>方法调用<xref:System.Web.Configuration.HttpCapabilitiesBase.IsBrowser%2A>方法。 有关设备筛选的详细信息，请参阅[设备筛选概述](http://msdn.microsoft.com/library/bdfeaa58-dedd-4c0d-8610-988aac0eff19)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="M:System.Web.Configuration.HttpCapabilitiesBase.IsBrowser(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="WriteUTF8ResourceString">
      <MemberSignature Language="C#" Value="protected void WriteUTF8ResourceString (System.Web.UI.HtmlTextWriter output, int offset, int size, bool fAsciiOnly);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WriteUTF8ResourceString(class System.Web.UI.HtmlTextWriter output, int32 offset, int32 size, bool fAsciiOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.WriteUTF8ResourceString(System.Web.UI.HtmlTextWriter,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WriteUTF8ResourceString (output As HtmlTextWriter, offset As Integer, size As Integer, fAsciiOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WriteUTF8ResourceString(System::Web::UI::HtmlTextWriter ^ output, int offset, int size, bool fAsciiOnly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.Web.UI.HtmlTextWriter" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="fAsciiOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="output">要写入的控件。</param>
        <param name="offset">
          <c>value</c> 内的起始位置。</param>
        <param name="size">要使用的 <c>value</c> 内的字符数。</param>
        <param name="fAsciiOnly">
          <see langword="true" /> 表示跳过重编码；否则为 <see langword="false" />。</param>
        <summary>向 <see cref="T:System.Web.UI.HtmlTextWriter" /> 控件写入资源字符串。 <see cref="M:System.Web.UI.TemplateControl.WriteUTF8ResourceString(System.Web.UI.HtmlTextWriter,System.Int32,System.Int32,System.Boolean)" /> 方法是由生成的类使用的，并且不应从代码中使用。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">正在访问无效的数据；<paramref name="offset" /> 或 <paramref name="size" /> 小于零。  
  
 \- 或 -  
  
 <paramref name="offset" /> 与 <paramref name="size" /> 的和大于资源大小。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="XPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为在运行时根据对象分析和计算 XPath 数据绑定表达式提供支持。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="XPath">
      <MemberSignature Language="C#" Value="protected internal object XPath (string xPathExpression);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance object XPath(string xPathExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.XPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function XPath (xPathExpression As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Object ^ XPath(System::String ^ xPathExpression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xPathExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xPathExpression">要计算的 XPath 表达式。 有关详情，请参阅<see cref="T:System.Web.UI.XPathBinder" />。</param>
        <summary>计算 XPath 数据绑定表达式。</summary>
        <returns>由计算数据绑定表达式所得出的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.XPath%2A>方法调用<xref:System.Web.UI.XPathBinder.Eval%2A?displayProperty=nameWithType>方法使用<xref:System.Web.UI.Page.GetDataItem%2A>方法解决<xref:System.Xml.XPath.IXPathNavigable>针对计算该表达式的对象引用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.TemplateControl.XPath%2A>中的方法<xref:System.Web.UI.WebControls.Repeater>控件。  
  
 [!code-aspx-csharp[System.Web.UI.TemplateControl_XPath1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.TemplateControl_XPath1/cs/templatecontrolxpathcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.TemplateControl_XPath1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.TemplateControl_XPath1/vb/templatecontrolxpathvb.aspx#1)]  
  
 在前面的代码示例中，可以使用以下测试 XML 数据。  
  
```  
<contacts>  
   <contact id="1">  
     <name>contact name 1</name>  
     <note>contact note 1</note>  
   </contact>  
   <contact id="2">  
     <name>contact name 2</name>  
     <note>contact note 2</note>  
   </contact>  
</contacts>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">数据绑定方法只能用于 <see cref="T:System.Web.UI.Page" /> 中包含的控件。</exception>
        <altmember cref="T:System.Web.UI.XPathBinder" />
      </Docs>
    </Member>
    <Member MemberName="XPath">
      <MemberSignature Language="C#" Value="protected internal string XPath (string xPathExpression, string format);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance string XPath(string xPathExpression, string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.XPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function XPath (xPathExpression As String, format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::String ^ XPath(System::String ^ xPathExpression, System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xPathExpression" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xPathExpression">要计算的 XPath 表达式。 有关详情，请参阅<see cref="T:System.Web.UI.XPathBinder" />。</param>
        <param name="format">要对结果应用的 .NET Framework 格式字符串。</param>
        <summary>计算 XPath 数据绑定表达式，使用指定的格式字符串来显示结果。</summary>
        <returns>通过计算数据绑定表达式并将结果转换为字符串类型所得出的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.XPath%2A>方法调用<xref:System.Web.UI.XPathBinder.Eval%2A?displayProperty=nameWithType>方法使用<xref:System.Web.UI.Page.GetDataItem%2A>方法解决<xref:System.Xml.XPath.IXPathNavigable>针对计算该表达式的对象引用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">数据绑定方法只能用于 <see cref="T:System.Web.UI.Page" /> 中包含的控件。</exception>
        <altmember cref="T:System.Web.UI.XPathBinder" />
      </Docs>
    </Member>
    <Member MemberName="XPath">
      <MemberSignature Language="C#" Value="protected internal object XPath (string xPathExpression, System.Xml.IXmlNamespaceResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance object XPath(string xPathExpression, class System.Xml.IXmlNamespaceResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.XPath(System.String,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function XPath (xPathExpression As String, resolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Object ^ XPath(System::String ^ xPathExpression, System::Xml::IXmlNamespaceResolver ^ resolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xPathExpression" Type="System.String" />
        <Parameter Name="resolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="xPathExpression">要计算的 XPath 表达式。 有关详情，请参阅<see cref="T:System.Web.UI.XPathBinder" />。</param>
        <param name="resolver">一组用于命名空间解析的前缀和命名空间映射。</param>
        <summary>使用指定的前缀和命名空间映射来计算 XPath 数据绑定表达式，以进行命名空间解析。</summary>
        <returns>由计算数据绑定表达式所得出的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.XPath%2A>方法调用<xref:System.Web.UI.XPathBinder.Eval%2A?displayProperty=nameWithType>方法使用<xref:System.Web.UI.Page.GetDataItem%2A>方法解决<xref:System.Xml.XPath.IXPathNavigable>针对计算该表达式的对象引用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">数据绑定方法只能用于 <see cref="T:System.Web.UI.Page" /> 中包含的控件。</exception>
        <altmember cref="T:System.Web.UI.XPathBinder" />
      </Docs>
    </Member>
    <Member MemberName="XPath">
      <MemberSignature Language="C#" Value="protected internal string XPath (string xPathExpression, string format, System.Xml.IXmlNamespaceResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance string XPath(string xPathExpression, string format, class System.Xml.IXmlNamespaceResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.XPath(System.String,System.String,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function XPath (xPathExpression As String, format As String, resolver As IXmlNamespaceResolver) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::String ^ XPath(System::String ^ xPathExpression, System::String ^ format, System::Xml::IXmlNamespaceResolver ^ resolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xPathExpression" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="resolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="xPathExpression">要计算的 XPath 表达式。 有关详情，请参阅<see cref="T:System.Web.UI.XPathBinder" />。</param>
        <param name="format">要对结果应用的 .NET Framework 格式字符串。</param>
        <param name="resolver">一组用于命名空间解析的前缀和命名空间映射。</param>
        <summary>使用用于命名空间解析的指定前缀和命名空间映射以及用于显示结果的指定格式字符串来计算 XPath 数据绑定表达式。</summary>
        <returns>通过计算数据绑定表达式并将结果转换为字符串类型所得出的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.XPath%2A>方法调用<xref:System.Web.UI.XPathBinder.Eval%2A?displayProperty=nameWithType>方法使用<xref:System.Web.UI.Page.GetDataItem%2A>方法解决<xref:System.Xml.XPath.IXPathNavigable>针对计算该表达式的对象引用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">数据绑定方法只能用于 <see cref="T:System.Web.UI.Page" /> 中包含的控件。</exception>
        <altmember cref="T:System.Web.UI.XPathBinder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="XPathSelect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>针对基于 XML 的数据提供运行时数据绑定并返回实现 <see cref="T:System.Collections.IEnumerable" /> 接口的节点集合。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="XPathSelect">
      <MemberSignature Language="C#" Value="protected internal System.Collections.IEnumerable XPathSelect (string xPathExpression);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Collections.IEnumerable XPathSelect(string xPathExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.XPathSelect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function XPathSelect (xPathExpression As String) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Collections::IEnumerable ^ XPathSelect(System::String ^ xPathExpression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xPathExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xPathExpression">要计算的 XPath 表达式。 有关详情，请参阅<see cref="T:System.Web.UI.XPathBinder" />。</param>
        <summary>计算 XPath 数据绑定表达式，并返回实现 <see cref="T:System.Collections.IEnumerable" /> 接口的节点集合。</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerable" /> 节点列表。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.XPathSelect%2A>方法调用<xref:System.Web.UI.XPathBinder.Select%2A?displayProperty=nameWithType>方法使用<xref:System.Web.UI.Page.GetDataItem%2A>方法解决<xref:System.Xml.XPath.IXPathNavigable>针对计算该表达式的对象引用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.TemplateControl.XPathSelect%2A>中的方法<xref:System.Web.UI.WebControls.Repeater>控件。  
  
 [!code-aspx-csharp[System.Web.UI.TemplateControl_XPath1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.TemplateControl_XPath1/cs/templatecontrolxpathcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.TemplateControl_XPath1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.TemplateControl_XPath1/vb/templatecontrolxpathvb.aspx#1)]  
  
 在前面的代码示例中，可以使用以下测试 XML 数据。  
  
```  
<contacts>  
   <contact id="1">  
     <name>contact name 1</name>  
     <note>contact note 1</note>  
   </contact>  
   <contact id="2">  
     <name>contact name 2</name>  
     <note>contact note 2</note>  
   </contact>  
</contacts>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.XPathBinder" />
      </Docs>
    </Member>
    <Member MemberName="XPathSelect">
      <MemberSignature Language="C#" Value="protected internal System.Collections.IEnumerable XPathSelect (string xPathExpression, System.Xml.IXmlNamespaceResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Collections.IEnumerable XPathSelect(string xPathExpression, class System.Xml.IXmlNamespaceResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.TemplateControl.XPathSelect(System.String,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function XPathSelect (xPathExpression As String, resolver As IXmlNamespaceResolver) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Collections::IEnumerable ^ XPathSelect(System::String ^ xPathExpression, System::Xml::IXmlNamespaceResolver ^ resolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xPathExpression" Type="System.String" />
        <Parameter Name="resolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="xPathExpression">要计算的 XPath 表达式。 有关详情，请参阅<see cref="T:System.Web.UI.XPathBinder" />。</param>
        <param name="resolver">一组用于命名空间解析的前缀和命名空间映射。</param>
        <summary>使用用于命名空间解析的指定前缀和命名空间映射计算 XPath 数据绑定表达式，并返回实现 <see cref="T:System.Collections.IEnumerable" /> 接口的节点集合。</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerable" /> 节点列表。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.TemplateControl.XPathSelect%2A>方法调用<xref:System.Web.UI.XPathBinder.Select%2A?displayProperty=nameWithType>方法使用<xref:System.Web.UI.Page.GetDataItem%2A>方法解决<xref:System.Xml.XPath.IXPathNavigable>针对计算该表达式的对象引用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.XPathBinder" />
      </Docs>
    </Member>
  </Members>
</Type>